import {
  require_react
} from "./chunk-M4SNM3GZ.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-EQCVQC35.js";

// ../node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "../node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex2) {
                  error$1 = ex2;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self2) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config, maybeKey, source, self2) {
          {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self2);
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        var didWarnAboutKeySpread = {};
        function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props, key, source, self2);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray(children)) {
                    for (var i = 0; i < children.length; i++) {
                      validateChildKeys(children[i], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type);
                }
              }
            }
            {
              if (hasOwnProperty.call(props, "key")) {
                var componentName = getComponentNameFromType(type);
                var keys = Object.keys(props).filter(function(k) {
                  return k !== "key";
                });
                var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
                if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                  var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                  error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
                  didWarnAboutKeySpread[componentName + beforeExample] = true;
                }
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, true);
          }
        }
        function jsxWithValidationDynamic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, false);
          }
        }
        var jsx2 = jsxWithValidationDynamic;
        var jsxs2 = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx2;
        exports.jsxs = jsxs2;
      })();
    }
  }
});

// ../node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "../node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// ../node_modules/agora-rtc-react/dist/agora-rtc-react.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function yN(t11, e) {
  return e.forEach(function(n) {
    n && typeof n != "string" && !Array.isArray(n) && Object.keys(n).forEach(function(i) {
      if (i !== "default" && !(i in t11)) {
        var r = Object.getOwnPropertyDescriptor(n, i);
        Object.defineProperty(t11, i, r.get ? r : { enumerable: true, get: function() {
          return n[i];
        } });
      }
    });
  }), Object.freeze(t11);
}
var Vs = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ae(t11) {
  return t11 && t11.__esModule && Object.prototype.hasOwnProperty.call(t11, "default") ? t11.default : t11;
}
var Se = function(t11) {
  try {
    return !!t11();
  } catch {
    return true;
  }
};
var vu = !Se(function() {
  var t11 = (function() {
  }).bind();
  return typeof t11 != "function" || t11.hasOwnProperty("prototype");
});
var IA = vu;
var vA = Function.prototype;
var G_ = vA.call;
var AN = IA && vA.bind.bind(G_, G_);
var me = IA ? AN : function(t11) {
  return function() {
    return G_.apply(t11, arguments);
  };
};
var hn = me({}.isPrototypeOf);
var cd = function(t11) {
  return t11 && t11.Math == Math && t11;
};
var We = cd(typeof globalThis == "object" && globalThis) || cd(typeof window == "object" && window) || cd(typeof self == "object" && self) || cd(typeof Vs == "object" && Vs) || /* @__PURE__ */ function() {
  return this;
}() || Vs || Function("return this")();
var bN = vu;
var yA = Function.prototype;
var Xf = yA.apply;
var Qf = yA.call;
var vm = typeof Reflect == "object" && Reflect.apply || (bN ? Qf.bind(Xf) : function() {
  return Qf.apply(Xf, arguments);
});
var AA = me;
var wN = AA({}.toString);
var ON = AA("".slice);
var pr = function(t11) {
  return ON(wN(t11), 8, -1);
};
var NN = pr;
var DN = me;
var gc = function(t11) {
  if (NN(t11) === "Function") return DN(t11);
};
var uh = typeof document == "object" && document.all;
var yu = { all: uh, IS_HTMLDDA: uh === void 0 && uh !== void 0 };
var PN = yu.all;
var He = yu.IS_HTMLDDA ? function(t11) {
  return typeof t11 == "function" || t11 === PN;
} : function(t11) {
  return typeof t11 == "function";
};
var Yc = {};
var ri = !Se(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var kN = vu;
var dd = Function.prototype.call;
var Ke = kN ? dd.bind(dd) : function() {
  return dd.apply(dd, arguments);
};
var Au = {};
var bA = {}.propertyIsEnumerable;
var wA = Object.getOwnPropertyDescriptor;
var LN = wA && !bA.call({ 1: 2 }, 1);
Au.f = LN ? function(t11) {
  var e = wA(this, t11);
  return !!e && e.enumerable;
} : bA;
var xr;
var rl;
var _o = function(t11, e) {
  return { enumerable: !(1 & t11), configurable: !(2 & t11), writable: !(4 & t11), value: e };
};
var MN = Se;
var UN = pr;
var hh = Object;
var xN = me("".split);
var bu = MN(function() {
  return !hh("z").propertyIsEnumerable(0);
}) ? function(t11) {
  return UN(t11) == "String" ? xN(t11, "") : hh(t11);
} : hh;
var da = function(t11) {
  return t11 == null;
};
var VN = da;
var FN = TypeError;
var la = function(t11) {
  if (VN(t11)) throw FN("Can't call method on " + t11);
  return t11;
};
var BN = bu;
var jN = la;
var Eo = function(t11) {
  return BN(jN(t11));
};
var Zf = He;
var GN = yu.all;
var Hn = yu.IS_HTMLDDA ? function(t11) {
  return typeof t11 == "object" ? t11 !== null : Zf(t11) || t11 === GN;
} : function(t11) {
  return typeof t11 == "object" ? t11 !== null : Zf(t11);
};
var Gi = {};
var ph = Gi;
var _h = We;
var WN = He;
var $f = function(t11) {
  return WN(t11) ? t11 : void 0;
};
var Dn = function(t11, e) {
  return arguments.length < 2 ? $f(ph[t11]) || $f(_h[t11]) : ph[t11] && ph[t11][e] || _h[t11] && _h[t11][e];
};
var $o = typeof navigator < "u" && String(navigator.userAgent) || "";
var OA = We;
var Eh = $o;
var tg = OA.process;
var eg = OA.Deno;
var ng = tg && tg.versions || eg && eg.version;
var ig = ng && ng.v8;
ig && (rl = (xr = ig.split("."))[0] > 0 && xr[0] < 4 ? 1 : +(xr[0] + xr[1])), !rl && Eh && (!(xr = Eh.match(/Edge\/(\d+)/)) || xr[1] >= 74) && (xr = Eh.match(/Chrome\/(\d+)/)) && (rl = +xr[1]);
var zo = rl;
var rg = zo;
var HN = Se;
var KN = We.String;
var ua = !!Object.getOwnPropertySymbols && !HN(function() {
  var t11 = Symbol();
  return !KN(t11) || !(Object(t11) instanceof Symbol) || !Symbol.sham && rg && rg < 41;
});
var NA = ua && !Symbol.sham && typeof Symbol.iterator == "symbol";
var YN = Dn;
var qN = He;
var zN = hn;
var JN = Object;
var qc = NA ? function(t11) {
  return typeof t11 == "symbol";
} : function(t11) {
  var e = YN("Symbol");
  return qN(e) && zN(e.prototype, JN(t11));
};
var XN = String;
var ha = function(t11) {
  try {
    return XN(t11);
  } catch {
    return "Object";
  }
};
var QN = He;
var ZN = ha;
var $N = TypeError;
var yi = function(t11) {
  if (QN(t11)) return t11;
  throw $N(ZN(t11) + " is not a function");
};
var tD = yi;
var eD = da;
var wu = function(t11, e) {
  var n = t11[e];
  return eD(n) ? void 0 : tD(n);
};
var mh = Ke;
var fh = He;
var gh = Hn;
var nD = TypeError;
var DA = { exports: {} };
var og = We;
var iD = Object.defineProperty;
var rD = function(t11, e) {
  try {
    iD(og, t11, { value: e, configurable: true, writable: true });
  } catch {
    og[t11] = e;
  }
  return e;
};
var sg = "__core-js_shared__";
var ym = We[sg] || rD(sg, {});
var ag = ym;
(DA.exports = function(t11, e) {
  return ag[t11] || (ag[t11] = e !== void 0 ? e : {});
})("versions", []).push({ version: "3.31.1", mode: "pure", copyright: "Â© 2014-2023 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE", source: "https://github.com/zloirock/core-js" });
var pa = DA.exports;
var oD = la;
var sD = Object;
var _r = function(t11) {
  return sD(oD(t11));
};
var aD = _r;
var cD = me({}.hasOwnProperty);
var Je = Object.hasOwn || function(t11, e) {
  return cD(aD(t11), e);
};
var dD = me;
var lD = 0;
var uD = Math.random();
var hD = dD(1 .toString);
var Am = function(t11) {
  return "Symbol(" + (t11 === void 0 ? "" : t11) + ")_" + hD(++lD + uD, 36);
};
var pD = pa;
var cg = Je;
var _D = Am;
var ED = ua;
var mD = NA;
var ws = We.Symbol;
var Th = pD("wks");
var fD = mD ? ws.for || ws : ws && ws.withoutSetter || _D;
var pe = function(t11) {
  return cg(Th, t11) || (Th[t11] = ED && cg(ws, t11) ? ws[t11] : fD("Symbol." + t11)), Th[t11];
};
var gD = Ke;
var dg = Hn;
var lg = qc;
var TD = wu;
var SD = function(t11, e) {
  var n, i;
  if (fh(n = t11.toString) && !gh(i = mh(n, t11)) || fh(n = t11.valueOf) && !gh(i = mh(n, t11)) || e !== "string") return i;
  throw nD("Can't convert object to primitive value");
};
var RD = TypeError;
var CD = pe("toPrimitive");
var ID = function(t11, e) {
  if (!dg(t11) || lg(t11)) return t11;
  var n, i = TD(t11, CD);
  if (i) {
    if (n = gD(i, t11, e), !dg(n) || lg(n)) return n;
    throw RD("Can't convert object to primitive value");
  }
  return SD(t11, e);
};
var vD = qc;
var Ou = function(t11) {
  var e = ID(t11, "string");
  return vD(e) ? e : e + "";
};
var ug = Hn;
var W_ = We.document;
var yD = ug(W_) && ug(W_.createElement);
var bm = function(t11) {
  return yD ? W_.createElement(t11) : {};
};
var AD = bm;
var PA = !ri && !Se(function() {
  return Object.defineProperty(AD("div"), "a", { get: function() {
    return 7;
  } }).a != 7;
});
var bD = ri;
var wD = Ke;
var OD = Au;
var ND = _o;
var DD = Eo;
var PD = Ou;
var kD = Je;
var LD = PA;
var hg = Object.getOwnPropertyDescriptor;
Yc.f = bD ? hg : function(t11, e) {
  if (t11 = DD(t11), e = PD(e), LD) try {
    return hg(t11, e);
  } catch {
  }
  if (kD(t11, e)) return ND(!wD(OD.f, t11, e), t11[e]);
};
var MD = Se;
var UD = He;
var xD = /#|\.prototype\./;
var zc = function(t11, e) {
  var n = FD[VD(t11)];
  return n == jD || n != BD && (UD(e) ? MD(e) : !!e);
};
var VD = zc.normalize = function(t11) {
  return String(t11).replace(xD, ".").toLowerCase();
};
var FD = zc.data = {};
var BD = zc.NATIVE = "N";
var jD = zc.POLYFILL = "P";
var kA = zc;
var GD = yi;
var WD = vu;
var HD = gc(gc.bind);
var mo = function(t11, e) {
  return GD(t11), e === void 0 ? t11 : WD ? HD(t11, e) : function() {
    return t11.apply(e, arguments);
  };
};
var Ai = {};
var LA = ri && Se(function() {
  return Object.defineProperty(function() {
  }, "prototype", { value: 42, writable: false }).prototype != 42;
});
var KD = Hn;
var YD = String;
var qD = TypeError;
var Cn = function(t11) {
  if (KD(t11)) return t11;
  throw qD(YD(t11) + " is not an object");
};
var zD = ri;
var JD = PA;
var XD = LA;
var ld = Cn;
var pg = Ou;
var QD = TypeError;
var Sh = Object.defineProperty;
var ZD = Object.getOwnPropertyDescriptor;
var Rh = "enumerable";
var Ch = "configurable";
var Ih = "writable";
Ai.f = zD ? XD ? function(t11, e, n) {
  if (ld(t11), e = pg(e), ld(n), typeof t11 == "function" && e === "prototype" && "value" in n && Ih in n && !n[Ih]) {
    var i = ZD(t11, e);
    i && i[Ih] && (t11[e] = n.value, n = { configurable: Ch in n ? n[Ch] : i[Ch], enumerable: Rh in n ? n[Rh] : i[Rh], writable: false });
  }
  return Sh(t11, e, n);
} : Sh : function(t11, e, n) {
  if (ld(t11), e = pg(e), ld(n), JD) try {
    return Sh(t11, e, n);
  } catch {
  }
  if ("get" in n || "set" in n) throw QD("Accessors not supported");
  return "value" in n && (t11[e] = n.value), t11;
};
var $D = Ai;
var tP = _o;
var fo = ri ? function(t11, e, n) {
  return $D.f(t11, e, tP(1, n));
} : function(t11, e, n) {
  return t11[e] = n, t11;
};
var ud = We;
var eP = vm;
var nP = gc;
var iP = He;
var rP = Yc.f;
var oP = kA;
var os = Gi;
var sP = mo;
var ss = fo;
var _g = Je;
var aP = function(t11) {
  var e = function(n, i, r) {
    if (this instanceof e) {
      switch (arguments.length) {
        case 0:
          return new t11();
        case 1:
          return new t11(n);
        case 2:
          return new t11(n, i);
      }
      return new t11(n, i, r);
    }
    return eP(t11, this, arguments);
  };
  return e.prototype = t11.prototype, e;
};
var xt = function(t11, e) {
  var n, i, r, o, s, a, c, d, l, u = t11.target, h = t11.global, p = t11.stat, g = t11.proto, E = h ? ud : p ? ud[u] : (ud[u] || {}).prototype, f = h ? os : os[u] || ss(os, u, {})[u], S = f.prototype;
  for (o in e) i = !(n = oP(h ? o : u + (p ? "." : "#") + o, t11.forced)) && E && _g(E, o), a = f[o], i && (c = t11.dontCallGetSet ? (l = rP(E, o)) && l.value : E[o]), s = i && c ? c : e[o], i && typeof a == typeof s || (d = t11.bind && i ? sP(s, ud) : t11.wrap && i ? aP(s) : g && iP(s) ? nP(s) : s, (t11.sham || s && s.sham || a && a.sham) && ss(d, "sham", true), ss(f, o, d), g && (_g(os, r = u + "Prototype") || ss(os, r, {}), ss(os[r], o, s), t11.real && S && (n || !S[o]) && ss(S, o, s)));
};
var cP = Math.ceil;
var dP = Math.floor;
var lP = Math.trunc || function(t11) {
  var e = +t11;
  return (e > 0 ? dP : cP)(e);
};
var uP = lP;
var wm = function(t11) {
  var e = +t11;
  return e != e || e === 0 ? 0 : uP(e);
};
var hP = wm;
var pP = Math.max;
var _P = Math.min;
var Om = function(t11, e) {
  var n = hP(t11);
  return n < 0 ? pP(n + e, 0) : _P(n, e);
};
var EP = wm;
var mP = Math.min;
var MA = function(t11) {
  return t11 > 0 ? mP(EP(t11), 9007199254740991) : 0;
};
var fP = MA;
var Lr = function(t11) {
  return fP(t11.length);
};
var gP = Eo;
var TP = Om;
var SP = Lr;
var Eg = function(t11) {
  return function(e, n, i) {
    var r, o = gP(e), s = SP(o), a = TP(i, s);
    if (t11 && n != n) {
      for (; s > a; ) if ((r = o[a++]) != r) return true;
    } else for (; s > a; a++) if ((t11 || a in o) && o[a] === n) return t11 || a || 0;
    return !t11 && -1;
  };
};
var Nm = { includes: Eg(true), indexOf: Eg(false) };
var RP = Nm.includes;
xt({ target: "Array", proto: true, forced: Se(function() {
  return !Array(1).includes();
}) }, { includes: function(t11) {
  return RP(this, t11, arguments.length > 1 ? arguments[1] : void 0);
} });
var CP = Gi;
var bi = function(t11) {
  return CP[t11 + "Prototype"];
};
var IP = bi("Array").includes;
var vP = Hn;
var yP = pr;
var AP = pe("match");
var UA = function(t11) {
  var e;
  return vP(t11) && ((e = t11[AP]) !== void 0 ? !!e : yP(t11) == "RegExp");
};
var bP = UA;
var wP = TypeError;
var xA = {};
xA[pe("toStringTag")] = "z";
var Dm = String(xA) === "[object z]";
var OP = Dm;
var NP = He;
var ol = pr;
var DP = pe("toStringTag");
var PP = Object;
var kP = ol(/* @__PURE__ */ function() {
  return arguments;
}()) == "Arguments";
var Er = OP ? ol : function(t11) {
  var e, n, i;
  return t11 === void 0 ? "Undefined" : t11 === null ? "Null" : typeof (n = function(r, o) {
    try {
      return r[o];
    } catch {
    }
  }(e = PP(t11), DP)) == "string" ? n : kP ? ol(e) : (i = ol(e)) == "Object" && NP(e.callee) ? "Arguments" : i;
};
var LP = Er;
var MP = String;
var oi = function(t11) {
  if (LP(t11) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
  return MP(t11);
};
var UP = pe("match");
var xP = xt;
var VP = function(t11) {
  if (bP(t11)) throw wP("The method doesn't accept regular expressions");
  return t11;
};
var FP = la;
var mg = oi;
var BP = function(t11) {
  var e = /./;
  try {
    "/./"[t11](e);
  } catch {
    try {
      return e[UP] = false, "/./"[t11](e);
    } catch {
    }
  }
  return false;
};
var jP = me("".indexOf);
xP({ target: "String", proto: true, forced: !BP("includes") }, { includes: function(t11) {
  return !!~jP(mg(FP(this)), mg(VP(t11)), arguments.length > 1 ? arguments[1] : void 0);
} });
var GP = bi("String").includes;
var fg = hn;
var WP = IP;
var HP = GP;
var vh = Array.prototype;
var yh = String.prototype;
var KP = function(t11) {
  var e = t11.includes;
  return t11 === vh || fg(vh, t11) && e === vh.includes ? WP : typeof t11 == "string" || t11 === yh || fg(yh, t11) && e === yh.includes ? HP : e;
};
var W = ae(KP);
var YP = yi;
var qP = _r;
var zP = bu;
var JP = Lr;
var XP = TypeError;
var gg = function(t11) {
  return function(e, n, i, r) {
    YP(n);
    var o = qP(e), s = zP(o), a = JP(o), c = t11 ? a - 1 : 0, d = t11 ? -1 : 1;
    if (i < 2) for (; ; ) {
      if (c in s) {
        r = s[c], c += d;
        break;
      }
      if (c += d, t11 ? c < 0 : a <= c) throw XP("Reduce of empty array with no initial value");
    }
    for (; t11 ? c >= 0 : a > c; c += d) c in s && (r = n(r, s[c], c, o));
    return r;
  };
};
var QP = { left: gg(false), right: gg(true) };
var ZP = Se;
var Nu = function(t11, e) {
  var n = [][t11];
  return !!n && ZP(function() {
    n.call(null, e || function() {
      return 1;
    }, 1);
  });
};
var Jc = typeof process < "u" && pr(process) == "process";
var $P = QP.left;
xt({ target: "Array", proto: true, forced: !Jc && zo > 79 && zo < 83 || !Nu("reduce") }, { reduce: function(t11) {
  var e = arguments.length;
  return $P(this, t11, e, e > 1 ? arguments[1] : void 0);
} });
var tk = bi("Array").reduce;
var ek = hn;
var nk = tk;
var Ah = Array.prototype;
var ik = function(t11) {
  var e = t11.reduce;
  return t11 === Ah || ek(Ah, t11) && e === Ah.reduce ? nk : e;
};
var VA = ik;
var ji = ae(VA);
var FA = true;
var BA = true;
function hd(t11, e, n) {
  let i = t11.match(e);
  return i && i.length >= n && parseInt(i[n], 10);
}
function ts(t11, e, n) {
  if (!t11.RTCPeerConnection) return;
  let i = t11.RTCPeerConnection.prototype, r = i.addEventListener;
  i.addEventListener = function(s, a) {
    if (s !== e) return r.apply(this, arguments);
    let c = (d) => {
      let l = n(d);
      l && (a.handleEvent ? a.handleEvent(l) : a(l));
    };
    return this._eventMap = this._eventMap || {}, this._eventMap[e] || (this._eventMap[e] = /* @__PURE__ */ new Map()), this._eventMap[e].set(a, c), r.apply(this, [s, c]);
  };
  let o = i.removeEventListener;
  i.removeEventListener = function(s, a) {
    if (s !== e || !this._eventMap || !this._eventMap[e]) return o.apply(this, arguments);
    if (!this._eventMap[e].has(a)) return o.apply(this, arguments);
    let c = this._eventMap[e].get(a);
    return this._eventMap[e].delete(a), this._eventMap[e].size === 0 && delete this._eventMap[e], Object.keys(this._eventMap).length === 0 && delete this._eventMap, o.apply(this, [s, c]);
  }, Object.defineProperty(i, "on" + e, { get() {
    return this["_on" + e];
  }, set(s) {
    this["_on" + e] && (this.removeEventListener(e, this["_on" + e]), delete this["_on" + e]), s && this.addEventListener(e, this["_on" + e] = s);
  }, enumerable: true, configurable: true });
}
function rk(t11) {
  return typeof t11 != "boolean" ? new Error("Argument type: " + typeof t11 + ". Please use a boolean.") : (FA = t11, t11 ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function ok(t11) {
  return typeof t11 != "boolean" ? new Error("Argument type: " + typeof t11 + ". Please use a boolean.") : (BA = !t11, "adapter.js deprecation warnings " + (t11 ? "disabled" : "enabled"));
}
function jA() {
  if (typeof window == "object") {
    if (FA) return;
    typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments);
  }
}
function Pm(t11, e) {
  BA && console.warn(t11 + " is deprecated, please use " + e + " instead.");
}
function Tg(t11) {
  return Object.prototype.toString.call(t11) === "[object Object]";
}
function GA(t11) {
  var e;
  return Tg(t11) ? ji(e = Object.keys(t11)).call(e, function(n, i) {
    let r = Tg(t11[i]), o = r ? GA(t11[i]) : t11[i], s = r && !Object.keys(o).length;
    return o === void 0 || s ? n : Object.assign(n, { [i]: o });
  }, {}) : t11;
}
function H_(t11, e, n) {
  e && !n.has(e.id) && (n.set(e.id, e), Object.keys(e).forEach((i) => {
    i.endsWith("Id") ? H_(t11, t11.get(e[i]), n) : i.endsWith("Ids") && e[i].forEach((r) => {
      H_(t11, t11.get(r), n);
    });
  }));
}
function Sg(t11, e, n) {
  let i = n ? "outbound-rtp" : "inbound-rtp", r = /* @__PURE__ */ new Map();
  if (e === null) return r;
  let o = [];
  return t11.forEach((s) => {
    s.type === "track" && s.trackIdentifier === e.id && o.push(s);
  }), o.forEach((s) => {
    t11.forEach((a) => {
      a.type === i && a.trackId === s.id && H_(t11, a, r);
    });
  }), r;
}
var sk = Am;
var Rg = pa("keys");
var Du = function(t11) {
  return Rg[t11] || (Rg[t11] = sk(t11));
};
var ak = !Se(function() {
  function t11() {
  }
  return t11.prototype.constructor = null, Object.getPrototypeOf(new t11()) !== t11.prototype;
});
var ck = Je;
var dk = He;
var lk = _r;
var uk = ak;
var Cg = Du("IE_PROTO");
var K_ = Object;
var hk = K_.prototype;
var km = uk ? K_.getPrototypeOf : function(t11) {
  var e = lk(t11);
  if (ck(e, Cg)) return e[Cg];
  var n = e.constructor;
  return dk(n) && e instanceof n ? n.prototype : e instanceof K_ ? hk : null;
};
var pk = me;
var _k = yi;
var Ek = He;
var mk = String;
var fk = TypeError;
var gk = function(t11, e, n) {
  try {
    return pk(_k(Object.getOwnPropertyDescriptor(t11, e)[n]));
  } catch {
  }
};
var Tk = Cn;
var Sk = function(t11) {
  if (typeof t11 == "object" || Ek(t11)) return t11;
  throw fk("Can't set " + mk(t11) + " as a prototype");
};
var Rk = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var t11, e = false, n = {};
  try {
    (t11 = gk(Object.prototype, "__proto__", "set"))(n, []), e = n instanceof Array;
  } catch {
  }
  return function(i, r) {
    return Tk(i), Sk(r), e ? t11(i, r) : i.__proto__ = r, i;
  };
}() : void 0);
var Pu = {};
var ku = {};
var bh = Je;
var Ck = Eo;
var Ik = Nm.indexOf;
var vk = ku;
var Ig = me([].push);
var WA = function(t11, e) {
  var n, i = Ck(t11), r = 0, o = [];
  for (n in i) !bh(vk, n) && bh(i, n) && Ig(o, n);
  for (; e.length > r; ) bh(i, n = e[r++]) && (~Ik(o, n) || Ig(o, n));
  return o;
};
var Lm = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
var yk = WA;
var Ak = Lm.concat("length", "prototype");
Pu.f = Object.getOwnPropertyNames || function(t11) {
  return yk(t11, Ak);
};
var Xc = {};
Xc.f = Object.getOwnPropertySymbols;
var bk = Dn;
var wk = Pu;
var Ok = Xc;
var Nk = Cn;
var Dk = me([].concat);
var Pk = bk("Reflect", "ownKeys") || function(t11) {
  var e = wk.f(Nk(t11)), n = Ok.f;
  return n ? Dk(e, n(t11)) : e;
};
var vg = Je;
var kk = Pk;
var Lk = Yc;
var Mk = Ai;
var Mm = {};
var Uk = WA;
var xk = Lm;
var Lu = Object.keys || function(t11) {
  return Uk(t11, xk);
};
var Vk = ri;
var Fk = LA;
var Bk = Ai;
var jk = Cn;
var Gk = Eo;
var Wk = Lu;
Mm.f = Vk && !Fk ? Object.defineProperties : function(t11, e) {
  jk(t11);
  for (var n, i = Gk(e), r = Wk(e), o = r.length, s = 0; o > s; ) Bk.f(t11, n = r[s++], i[n]);
  return t11;
};
var pd;
var HA = Dn("document", "documentElement");
var Hk = Cn;
var Kk = Mm;
var yg = Lm;
var Yk = ku;
var qk = HA;
var zk = bm;
var Y_ = "prototype";
var q_ = "script";
var KA = Du("IE_PROTO");
var wh = function() {
};
var YA = function(t11) {
  return "<" + q_ + ">" + t11 + "</" + q_ + ">";
};
var Ag = function(t11) {
  t11.write(YA("")), t11.close();
  var e = t11.parentWindow.Object;
  return t11 = null, e;
};
var sl = function() {
  try {
    pd = new ActiveXObject("htmlfile");
  } catch {
  }
  var t11, e, n;
  sl = typeof document < "u" ? document.domain && pd ? Ag(pd) : (e = zk("iframe"), n = "java" + q_ + ":", e.style.display = "none", qk.appendChild(e), e.src = String(n), (t11 = e.contentWindow.document).open(), t11.write(YA("document.F=Object")), t11.close(), t11.F) : Ag(pd);
  for (var i = yg.length; i--; ) delete sl[Y_][yg[i]];
  return sl();
};
Yk[KA] = true;
var Qc = Object.create || function(t11, e) {
  var n;
  return t11 !== null ? (wh[Y_] = Hk(t11), n = new wh(), wh[Y_] = null, n[KA] = t11) : n = sl(), e === void 0 ? n : Kk.f(n, e);
};
var Jk = Hn;
var Xk = fo;
var qA = Error;
var Qk = me("".replace);
var Zk = String(qA("zxcasd").stack);
var zA = /\n\s*at [^:]*:[^\n]*/;
var $k = zA.test(Zk);
var tL = _o;
var eL = !Se(function() {
  var t11 = Error("a");
  return !("stack" in t11) || (Object.defineProperty(t11, "stack", tL(1, 7)), t11.stack !== 7);
});
var nL = fo;
var iL = function(t11, e) {
  if ($k && typeof t11 == "string" && !qA.prepareStackTrace) for (; e--; ) t11 = Qk(t11, zA, "");
  return t11;
};
var rL = eL;
var bg = Error.captureStackTrace;
var es = {};
var oL = es;
var sL = pe("iterator");
var aL = Array.prototype;
var JA = function(t11) {
  return t11 !== void 0 && (oL.Array === t11 || aL[sL] === t11);
};
var cL = Er;
var wg = wu;
var dL = da;
var lL = es;
var uL = pe("iterator");
var Mu = function(t11) {
  if (!dL(t11)) return wg(t11, uL) || wg(t11, "@@iterator") || lL[cL(t11)];
};
var hL = Ke;
var pL = yi;
var _L = Cn;
var EL = ha;
var mL = Mu;
var fL = TypeError;
var Um = function(t11, e) {
  var n = arguments.length < 2 ? mL(t11) : e;
  if (pL(n)) return _L(hL(n, t11));
  throw fL(EL(t11) + " is not iterable");
};
var gL = Ke;
var Og = Cn;
var TL = wu;
var XA = function(t11, e, n) {
  var i, r;
  Og(t11);
  try {
    if (!(i = TL(t11, "return"))) {
      if (e === "throw") throw n;
      return n;
    }
    i = gL(i, t11);
  } catch (o) {
    r = true, i = o;
  }
  if (e === "throw") throw n;
  if (r) throw i;
  return Og(i), n;
};
var SL = mo;
var RL = Ke;
var CL = Cn;
var IL = ha;
var vL = JA;
var yL = Lr;
var Ng = hn;
var AL = Um;
var bL = Mu;
var Dg = XA;
var wL = TypeError;
var al = function(t11, e) {
  this.stopped = t11, this.result = e;
};
var Pg = al.prototype;
var Zc = function(t11, e, n) {
  var i, r, o, s, a, c, d, l = n && n.that, u = !(!n || !n.AS_ENTRIES), h = !(!n || !n.IS_RECORD), p = !(!n || !n.IS_ITERATOR), g = !(!n || !n.INTERRUPTED), E = SL(e, l), f = function(C) {
    return i && Dg(i, "normal", C), new al(true, C);
  }, S = function(C) {
    return u ? (CL(C), g ? E(C[0], C[1], f) : E(C[0], C[1])) : g ? E(C, f) : E(C);
  };
  if (h) i = t11.iterator;
  else if (p) i = t11;
  else {
    if (!(r = bL(t11))) throw wL(IL(t11) + " is not iterable");
    if (vL(r)) {
      for (o = 0, s = yL(t11); s > o; o++) if ((a = S(t11[o])) && Ng(Pg, a)) return a;
      return new al(false);
    }
    i = AL(t11, r);
  }
  for (c = h ? t11.next : i.next; !(d = RL(c, i)).done; ) {
    try {
      a = S(d.value);
    } catch (C) {
      Dg(i, "throw", C);
    }
    if (typeof a == "object" && a && Ng(Pg, a)) return a;
  }
  return new al(false);
};
var OL = oi;
var NL = xt;
var DL = hn;
var PL = km;
var Nl = Rk;
var kL = function(t11, e, n) {
  for (var i = kk(e), r = Mk.f, o = Lk.f, s = 0; s < i.length; s++) {
    var a = i[s];
    vg(t11, a) || n && vg(n, a) || r(t11, a, o(e, a));
  }
};
var QA = Qc;
var Oh = fo;
var Nh = _o;
var LL = function(t11, e) {
  Jk(e) && "cause" in e && Xk(t11, "cause", e.cause);
};
var ML = function(t11, e, n, i) {
  rL && (bg ? bg(t11, e) : nL(t11, "stack", iL(n, i)));
};
var UL = Zc;
var xL = function(t11, e) {
  return t11 === void 0 ? arguments.length < 2 ? "" : e : OL(t11);
};
var VL = pe("toStringTag");
var Dl = Error;
var FL = [].push;
var Js = function(t11, e) {
  var n, i = DL(Dh, this);
  Nl ? n = Nl(Dl(), i ? PL(this) : Dh) : (n = i ? this : QA(Dh), Oh(n, VL, "Error")), e !== void 0 && Oh(n, "message", xL(e)), ML(n, Js, n.stack, 1), arguments.length > 2 && LL(n, arguments[2]);
  var r = [];
  return UL(t11, FL, { that: r }), Oh(n, "errors", r), n;
};
Nl ? Nl(Js, Dl) : kL(Js, Dl, { name: true });
var Dh = Js.prototype = QA(Dl.prototype, { constructor: Nh(1, Js), message: Nh(1, ""), name: Nh(1, "AggregateError") });
NL({ global: true, constructor: true, arity: 2 }, { AggregateError: Js });
var Pl;
var nc;
var kl;
var BL = He;
var kg = We.WeakMap;
var jL = BL(kg) && /native code/.test(String(kg));
var ZA = We;
var GL = Hn;
var WL = fo;
var Ph = Je;
var kh = ym;
var HL = Du;
var KL = ku;
var Lg = "Object already initialized";
var z_ = ZA.TypeError;
var YL = ZA.WeakMap;
jL || kh.state ? (Ni = kh.state || (kh.state = new YL()), Ni.get = Ni.get, Ni.has = Ni.has, Ni.set = Ni.set, Pl = function(t11, e) {
  if (Ni.has(t11)) throw z_(Lg);
  return e.facade = t11, Ni.set(t11, e), e;
}, nc = function(t11) {
  return Ni.get(t11) || {};
}, kl = function(t11) {
  return Ni.has(t11);
}) : (Co = HL("state"), KL[Co] = true, Pl = function(t11, e) {
  if (Ph(t11, Co)) throw z_(Lg);
  return e.facade = t11, WL(t11, Co, e), e;
}, nc = function(t11) {
  return Ph(t11, Co) ? t11[Co] : {};
}, kl = function(t11) {
  return Ph(t11, Co);
});
var Ni;
var Co;
var Ho;
var Mg;
var Ug;
var ns = { set: Pl, get: nc, has: kl, enforce: function(t11) {
  return kl(t11) ? nc(t11) : Pl(t11, {});
}, getterFor: function(t11) {
  return function(e) {
    var n;
    if (!GL(e) || (n = nc(e)).type !== t11) throw z_("Incompatible receiver, " + t11 + " required");
    return n;
  };
} };
var J_ = ri;
var qL = Je;
var $A = Function.prototype;
var zL = J_ && Object.getOwnPropertyDescriptor;
var Lh = qL($A, "name");
var tb = { EXISTS: Lh, PROPER: Lh && (function() {
}).name === "something", CONFIGURABLE: Lh && (!J_ || J_ && zL($A, "name").configurable) };
var JL = fo;
var go = function(t11, e, n, i) {
  return i && i.enumerable ? t11[e] = n : JL(t11, e, n), t11;
};
var XL = Se;
var QL = He;
var ZL = Hn;
var $L = Qc;
var xg = km;
var t1 = go;
var X_ = pe("iterator");
var eb = false;
[].keys && ("next" in (Ug = [].keys()) ? (Mg = xg(xg(Ug))) !== Object.prototype && (Ho = Mg) : eb = true);
var e1 = !ZL(Ho) || XL(function() {
  var t11 = {};
  return Ho[X_].call(t11) !== t11;
});
QL((Ho = e1 ? {} : $L(Ho))[X_]) || t1(Ho, X_, function() {
  return this;
});
var nb = { IteratorPrototype: Ho, BUGGY_SAFARI_ITERATORS: eb };
var n1 = Er;
var i1 = Dm ? {}.toString : function() {
  return "[object " + n1(this) + "]";
};
var r1 = Dm;
var o1 = Ai.f;
var s1 = fo;
var a1 = Je;
var c1 = i1;
var Vg = pe("toStringTag");
var To = function(t11, e, n, i) {
  if (t11) {
    var r = n ? t11 : t11.prototype;
    a1(r, Vg) || o1(r, Vg, { configurable: true, value: e }), i && !r1 && s1(r, "toString", c1);
  }
};
var d1 = nb.IteratorPrototype;
var l1 = Qc;
var u1 = _o;
var h1 = To;
var p1 = es;
var _1 = function() {
  return this;
};
var xm = function(t11, e, n, i) {
  var r = e + " Iterator";
  return t11.prototype = l1(d1, { next: u1(+!i, n) }), h1(t11, r, false, true), p1[r] = _1, t11;
};
var E1 = xt;
var m1 = Ke;
var f1 = tb;
var g1 = xm;
var T1 = km;
var S1 = To;
var Fg = go;
var Bg = es;
var R1 = nb;
var C1 = f1.PROPER;
var _d = R1.BUGGY_SAFARI_ITERATORS;
var Mh = pe("iterator");
var jg = "keys";
var Ed = "values";
var Gg = "entries";
var I1 = function() {
  return this;
};
var ib = function(t11, e, n, i, r, o, s) {
  g1(n, e, i);
  var a, c, d, l = function(S) {
    if (S === r && E) return E;
    if (!_d && S in p) return p[S];
    switch (S) {
      case jg:
      case Ed:
      case Gg:
        return function() {
          return new n(this, S);
        };
    }
    return function() {
      return new n(this);
    };
  }, u = e + " Iterator", h = false, p = t11.prototype, g = p[Mh] || p["@@iterator"] || r && p[r], E = !_d && g || l(r), f = e == "Array" && p.entries || g;
  if (f && (a = T1(f.call(new t11()))) !== Object.prototype && a.next && (S1(a, u, true, true), Bg[u] = I1), C1 && r == Ed && g && g.name !== Ed && (h = true, E = function() {
    return m1(g, this);
  }), r) if (c = { values: l(Ed), keys: o ? E : l(jg), entries: l(Gg) }, s) for (d in c) (_d || h || !(d in p)) && Fg(p, d, c[d]);
  else E1({ target: e, proto: true, forced: _d || h }, c);
  return s && p[Mh] !== E && Fg(p, Mh, E, { name: r }), Bg[e] = E, c;
};
var Vm = function(t11, e) {
  return { value: t11, done: e };
};
var v1 = Eo;
var Wg = es;
var rb = ns;
Ai.f;
var y1 = ib;
var Hg = Vm;
var ob = "Array Iterator";
var A1 = rb.set;
var b1 = rb.getterFor(ob);
y1(Array, "Array", function(t11, e) {
  A1(this, { type: ob, target: v1(t11), index: 0, kind: e });
}, function() {
  var t11 = b1(this), e = t11.target, n = t11.kind, i = t11.index++;
  return !e || i >= e.length ? (t11.target = void 0, Hg(void 0, true)) : Hg(n == "keys" ? i : n == "values" ? e[i] : [i, e[i]], false);
}, "values"), Wg.Arguments = Wg.Array;
var w1 = Ai;
var Uu = function(t11, e, n) {
  return w1.f(t11, e, n);
};
var O1 = Dn;
var N1 = Uu;
var D1 = ri;
var Kg = pe("species");
var P1 = hn;
var k1 = TypeError;
var Fm = function(t11, e) {
  if (P1(e, t11)) return t11;
  throw k1("Incorrect invocation");
};
var L1 = He;
var Q_ = ym;
var M1 = me(Function.toString);
L1(Q_.inspectSource) || (Q_.inspectSource = function(t11) {
  return M1(t11);
});
var sb = Q_.inspectSource;
var U1 = me;
var x1 = Se;
var ab = He;
var V1 = Er;
var F1 = sb;
var cb = function() {
};
var B1 = [];
var db = Dn("Reflect", "construct");
var Bm = /^\s*(?:class|function)\b/;
var j1 = U1(Bm.exec);
var G1 = !Bm.exec(cb);
var Aa = function(t11) {
  if (!ab(t11)) return false;
  try {
    return db(cb, B1, t11), true;
  } catch {
    return false;
  }
};
var lb = function(t11) {
  if (!ab(t11)) return false;
  switch (V1(t11)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return G1 || !!j1(Bm, F1(t11));
  } catch {
    return true;
  }
};
lb.sham = true;
var Tc;
var as;
var Yg;
var Uh;
var xu = !db || x1(function() {
  var t11;
  return Aa(Aa.call) || !Aa(Object) || !Aa(function() {
    t11 = true;
  }) || t11;
}) ? lb : Aa;
var W1 = xu;
var H1 = ha;
var K1 = TypeError;
var qg = Cn;
var Y1 = function(t11) {
  if (W1(t11)) return t11;
  throw K1(H1(t11) + " is not a constructor");
};
var q1 = da;
var z1 = pe("species");
var jm = function(t11, e) {
  var n, i = qg(t11).constructor;
  return i === void 0 || q1(n = qg(i)[z1]) ? e : Y1(n);
};
var Gm = me([].slice);
var J1 = TypeError;
var Vu = function(t11, e) {
  if (t11 < e) throw J1("Not enough arguments");
  return t11;
};
var ub = /(?:ipad|iphone|ipod).*applewebkit/i.test($o);
var ei = We;
var X1 = vm;
var Q1 = mo;
var zg = He;
var Z1 = Je;
var hb = Se;
var Jg = HA;
var $1 = Gm;
var Xg = bm;
var tM = Vu;
var eM = ub;
var nM = Jc;
var Z_ = ei.setImmediate;
var $_ = ei.clearImmediate;
var iM = ei.process;
var xh = ei.Dispatch;
var rM = ei.Function;
var Qg = ei.MessageChannel;
var oM = ei.String;
var Vh = 0;
var ic = {};
var Zg = "onreadystatechange";
hb(function() {
  Tc = ei.location;
});
var Wm = function(t11) {
  if (Z1(ic, t11)) {
    var e = ic[t11];
    delete ic[t11], e();
  }
};
var Fh = function(t11) {
  return function() {
    Wm(t11);
  };
};
var $g = function(t11) {
  Wm(t11.data);
};
var tT = function(t11) {
  ei.postMessage(oM(t11), Tc.protocol + "//" + Tc.host);
};
Z_ && $_ || (Z_ = function(t11) {
  tM(arguments.length, 1);
  var e = zg(t11) ? t11 : rM(t11), n = $1(arguments, 1);
  return ic[++Vh] = function() {
    X1(e, void 0, n);
  }, as(Vh), Vh;
}, $_ = function(t11) {
  delete ic[t11];
}, nM ? as = function(t11) {
  iM.nextTick(Fh(t11));
} : xh && xh.now ? as = function(t11) {
  xh.now(Fh(t11));
} : Qg && !eM ? (Uh = (Yg = new Qg()).port2, Yg.port1.onmessage = $g, as = Q1(Uh.postMessage, Uh)) : ei.addEventListener && zg(ei.postMessage) && !ei.importScripts && Tc && Tc.protocol !== "file:" && !hb(tT) ? (as = tT, ei.addEventListener("message", $g, false)) : as = Zg in Xg("script") ? function(t11) {
  Jg.appendChild(Xg("script"))[Zg] = function() {
    Jg.removeChild(this), Wm(t11);
  };
} : function(t11) {
  setTimeout(Fh(t11), 0);
});
var pb = { set: Z_, clear: $_ };
var _b = function() {
  this.head = null, this.tail = null;
};
_b.prototype = { add: function(t11) {
  var e = { item: t11, next: null }, n = this.tail;
  n ? n.next = e : this.head = e, this.tail = e;
}, get: function() {
  var t11 = this.head;
  if (t11) return (this.head = t11.next) === null && (this.tail = null), t11.item;
} };
var cs;
var Bh;
var jh;
var Gh;
var eT;
var Eb = _b;
var sM = /ipad|iphone|ipod/i.test($o) && typeof Pebble < "u";
var aM = /web0s(?!.*chrome)/i.test($o);
var Jo = We;
var nT = mo;
var cM = Yc.f;
var Wh = pb.set;
var dM = Eb;
var lM = ub;
var uM = sM;
var hM = aM;
var Hh = Jc;
var iT = Jo.MutationObserver || Jo.WebKitMutationObserver;
var rT = Jo.document;
var oT = Jo.process;
var md = Jo.Promise;
var sT = cM(Jo, "queueMicrotask");
var tE = sT && sT.value;
tE || (ba = new dM(), wa = function() {
  var t11, e;
  for (Hh && (t11 = oT.domain) && t11.exit(); e = ba.get(); ) try {
    e();
  } catch (n) {
    throw ba.head && cs(), n;
  }
  t11 && t11.enter();
}, lM || Hh || hM || !iT || !rT ? !uM && md && md.resolve ? ((Gh = md.resolve(void 0)).constructor = md, eT = nT(Gh.then, Gh), cs = function() {
  eT(wa);
}) : Hh ? cs = function() {
  oT.nextTick(wa);
} : (Wh = nT(Wh, Jo), cs = function() {
  Wh(wa);
}) : (Bh = true, jh = rT.createTextNode(""), new iT(wa).observe(jh, { characterData: true }), cs = function() {
  jh.data = Bh = !Bh;
}), tE = function(t11) {
  ba.head || cs(), ba.add(t11);
});
var ba;
var wa;
var pM = tE;
var _a = function(t11) {
  try {
    return { error: false, value: t11() };
  } catch (e) {
    return { error: true, value: e };
  }
};
var Xo = We.Promise;
var mb = typeof Deno == "object" && Deno && typeof Deno.version == "object";
var _M = !mb && !Jc && typeof window == "object" && typeof document == "object";
var EM = We;
var rc = Xo;
var mM = He;
var fM = kA;
var gM = sb;
var TM = pe;
var SM = _M;
var RM = mb;
var Kh = zo;
var aT = rc && rc.prototype;
var CM = TM("species");
var fb = false;
var gb = mM(EM.PromiseRejectionEvent);
var IM = fM("Promise", function() {
  var t11 = gM(rc), e = t11 !== String(rc);
  if (!e && Kh === 66 || !aT.catch || !aT.finally) return true;
  if (!Kh || Kh < 51 || !/native code/.test(t11)) {
    var n = new rc(function(r) {
      r(1);
    }), i = function(r) {
      r(function() {
      }, function() {
      });
    };
    if ((n.constructor = {})[CM] = i, !(fb = n.then(function() {
    }) instanceof i)) return true;
  }
  return !e && (SM || RM) && !gb;
});
var $c = { CONSTRUCTOR: IM, REJECTION_EVENT: gb, SUBCLASSING: fb };
var mr = {};
var cT = yi;
var vM = TypeError;
var yM = function(t11) {
  var e, n;
  this.promise = new t11(function(i, r) {
    if (e !== void 0 || n !== void 0) throw vM("Bad Promise constructor");
    e = i, n = r;
  }), this.resolve = cT(e), this.reject = cT(n);
};
mr.f = function(t11) {
  return new yM(t11);
};
var Yh;
var dT;
var AM = xt;
var Ll = Jc;
var uo = We;
var td = Ke;
var bM = go;
var wM = To;
var OM = function(t11) {
  var e = O1(t11);
  D1 && e && !e[Kg] && N1(e, Kg, { configurable: true, get: function() {
    return this;
  } });
};
var NM = yi;
var eE = He;
var DM = Hn;
var PM = Fm;
var kM = jm;
var Tb = pb.set;
var Hm = pM;
var LM = function(t11, e) {
  try {
    arguments.length == 1 ? console.error(t11) : console.error(t11, e);
  } catch {
  }
};
var MM = _a;
var UM = Eb;
var Sb = ns;
var nE = Xo;
var Rb = $c;
var Cb = mr;
var cl = "Promise";
var lT = Rb.CONSTRUCTOR;
var xM = Rb.REJECTION_EVENT;
var qh = Sb.getterFor(cl);
var VM = Sb.set;
var FM = nE && nE.prototype;
var Oa = nE;
var zh = FM;
var Ib = uo.TypeError;
var iE = uo.document;
var Km = uo.process;
var rE = Cb.f;
var BM = rE;
var jM = !!(iE && iE.createEvent && uo.dispatchEvent);
var vb = "unhandledrejection";
var yb = function(t11) {
  var e;
  return !(!DM(t11) || !eE(e = t11.then)) && e;
};
var Ab = function(t11, e) {
  var n, i, r, o = e.value, s = e.state == 1, a = s ? t11.ok : t11.fail, c = t11.resolve, d = t11.reject, l = t11.domain;
  try {
    a ? (s || (e.rejection === 2 && WM(e), e.rejection = 1), a === true ? n = o : (l && l.enter(), n = a(o), l && (l.exit(), r = true)), n === t11.promise ? d(Ib("Promise-chain cycle")) : (i = yb(n)) ? td(i, n, c, d) : c(n)) : d(o);
  } catch (u) {
    l && !r && l.exit(), d(u);
  }
};
var bb = function(t11, e) {
  t11.notified || (t11.notified = true, Hm(function() {
    for (var n, i = t11.reactions; n = i.get(); ) Ab(n, t11);
    t11.notified = false, e && !t11.rejection && GM(t11);
  }));
};
var wb = function(t11, e, n) {
  var i, r;
  jM ? ((i = iE.createEvent("Event")).promise = e, i.reason = n, i.initEvent(t11, false, true), uo.dispatchEvent(i)) : i = { promise: e, reason: n }, !xM && (r = uo["on" + t11]) ? r(i) : t11 === vb && LM("Unhandled promise rejection", n);
};
var GM = function(t11) {
  td(Tb, uo, function() {
    var e, n = t11.facade, i = t11.value;
    if (uT(t11) && (e = MM(function() {
      Ll ? Km.emit("unhandledRejection", i, n) : wb(vb, n, i);
    }), t11.rejection = Ll || uT(t11) ? 2 : 1, e.error)) throw e.value;
  });
};
var uT = function(t11) {
  return t11.rejection !== 1 && !t11.parent;
};
var WM = function(t11) {
  td(Tb, uo, function() {
    var e = t11.facade;
    Ll ? Km.emit("rejectionHandled", e) : wb("rejectionhandled", e, t11.value);
  });
};
var Os = function(t11, e, n) {
  return function(i) {
    t11(e, i, n);
  };
};
var Fs = function(t11, e, n) {
  t11.done || (t11.done = true, n && (t11 = n), t11.value = e, t11.state = 2, bb(t11, true));
};
var oE = function(t11, e, n) {
  if (!t11.done) {
    t11.done = true, n && (t11 = n);
    try {
      if (t11.facade === e) throw Ib("Promise can't be resolved itself");
      var i = yb(e);
      i ? Hm(function() {
        var r = { done: false };
        try {
          td(i, e, Os(oE, r, t11), Os(Fs, r, t11));
        } catch (o) {
          Fs(r, o, t11);
        }
      }) : (t11.value = e, t11.state = 1, bb(t11, false));
    } catch (r) {
      Fs({ done: false }, r, t11);
    }
  }
};
lT && (zh = (Oa = function(t11) {
  PM(this, zh), NM(t11), td(Yh, this);
  var e = qh(this);
  try {
    t11(Os(oE, e), Os(Fs, e));
  } catch (n) {
    Fs(e, n);
  }
}).prototype, (Yh = function(t11) {
  VM(this, { type: cl, done: false, notified: false, parent: false, reactions: new UM(), rejection: false, state: 0, value: void 0 });
}).prototype = bM(zh, "then", function(t11, e) {
  var n = qh(this), i = rE(kM(this, Oa));
  return n.parent = true, i.ok = !eE(t11) || t11, i.fail = eE(e) && e, i.domain = Ll ? Km.domain : void 0, n.state == 0 ? n.reactions.add(i) : Hm(function() {
    Ab(i, n);
  }), i.promise;
}), dT = function() {
  var t11 = new Yh(), e = qh(t11);
  this.promise = t11, this.resolve = Os(oE, e), this.reject = Os(Fs, e);
}, Cb.f = rE = function(t11) {
  return t11 === Oa || t11 === void 0 ? new dT(t11) : BM(t11);
}), AM({ global: true, constructor: true, wrap: true, forced: lT }, { Promise: Oa }), wM(Oa, cl, false, true), OM(cl);
var Ob = pe("iterator");
var Nb = false;
try {
  hT = 0, Jh = { next: function() {
    return { done: !!hT++ };
  }, return: function() {
    Nb = true;
  } }, Jh[Ob] = function() {
    return this;
  }, Array.from(Jh, function() {
    throw 2;
  });
} catch {
}
var hT;
var Jh;
var HM = Xo;
var KM = function(t11, e) {
  if (!Nb) return false;
  var n = false;
  try {
    var i = {};
    i[Ob] = function() {
      return { next: function() {
        return { done: n = true };
      } };
    }, t11(i);
  } catch {
  }
  return n;
};
var Fu = $c.CONSTRUCTOR || !KM(function(t11) {
  HM.all(t11).then(void 0, function() {
  });
});
var YM = Ke;
var qM = yi;
var zM = mr;
var JM = _a;
var XM = Zc;
xt({ target: "Promise", stat: true, forced: Fu }, { all: function(t11) {
  var e = this, n = zM.f(e), i = n.resolve, r = n.reject, o = JM(function() {
    var s = qM(e.resolve), a = [], c = 0, d = 1;
    XM(t11, function(l) {
      var u = c++, h = false;
      d++, YM(s, e, l).then(function(p) {
        h || (h = true, a[u] = p, --d || i(a));
      }, r);
    }), --d || i(a);
  });
  return o.error && r(o.value), n.promise;
} });
var QM = xt;
var ZM = $c.CONSTRUCTOR;
Xo && Xo.prototype, QM({ target: "Promise", proto: true, forced: ZM, real: true }, { catch: function(t11) {
  return this.then(void 0, t11);
} });
var $M = Ke;
var tU = yi;
var eU = mr;
var nU = _a;
var iU = Zc;
xt({ target: "Promise", stat: true, forced: Fu }, { race: function(t11) {
  var e = this, n = eU.f(e), i = n.reject, r = nU(function() {
    var o = tU(e.resolve);
    iU(t11, function(s) {
      $M(o, e, s).then(n.resolve, i);
    });
  });
  return r.error && i(r.value), n.promise;
} });
var rU = Ke;
var oU = mr;
xt({ target: "Promise", stat: true, forced: $c.CONSTRUCTOR }, { reject: function(t11) {
  var e = oU.f(this);
  return rU(e.reject, void 0, t11), e.promise;
} });
var sU = Cn;
var aU = Hn;
var cU = mr;
var Db = function(t11, e) {
  if (sU(t11), aU(e) && e.constructor === t11) return e;
  var n = cU.f(t11);
  return (0, n.resolve)(e), n.promise;
};
var dU = xt;
var lU = Xo;
var uU = $c.CONSTRUCTOR;
var hU = Db;
var pU = Dn("Promise");
var _U = !uU;
dU({ target: "Promise", stat: true, forced: true }, { resolve: function(t11) {
  return hU(_U && this === pU ? lU : this, t11);
} });
var EU = Ke;
var mU = yi;
var fU = mr;
var gU = _a;
var TU = Zc;
xt({ target: "Promise", stat: true, forced: Fu }, { allSettled: function(t11) {
  var e = this, n = fU.f(e), i = n.resolve, r = n.reject, o = gU(function() {
    var s = mU(e.resolve), a = [], c = 0, d = 1;
    TU(t11, function(l) {
      var u = c++, h = false;
      d++, EU(s, e, l).then(function(p) {
        h || (h = true, a[u] = { status: "fulfilled", value: p }, --d || i(a));
      }, function(p) {
        h || (h = true, a[u] = { status: "rejected", reason: p }, --d || i(a));
      });
    }), --d || i(a);
  });
  return o.error && r(o.value), n.promise;
} });
var SU = Ke;
var RU = yi;
var CU = Dn;
var IU = mr;
var vU = _a;
var yU = Zc;
var pT = "No one promise resolved";
xt({ target: "Promise", stat: true, forced: Fu }, { any: function(t11) {
  var e = this, n = CU("AggregateError"), i = IU.f(e), r = i.resolve, o = i.reject, s = vU(function() {
    var a = RU(e.resolve), c = [], d = 0, l = 1, u = false;
    yU(t11, function(h) {
      var p = d++, g = false;
      l++, SU(a, e, h).then(function(E) {
        g || u || (u = true, r(E));
      }, function(E) {
        g || u || (g = true, c[p] = E, --l || o(new n(c, pT)));
      });
    }), --l || o(new n(c, pT));
  });
  return s.error && o(s.value), i.promise;
} });
var AU = xt;
var sE = Xo;
var bU = Se;
var wU = Dn;
var OU = He;
var NU = jm;
var _T = Db;
var DU = sE && sE.prototype;
AU({ target: "Promise", proto: true, real: true, forced: !!sE && bU(function() {
  DU.finally.call({ then: function() {
  } }, function() {
  });
}) }, { finally: function(t11) {
  var e = NU(this, wU("Promise")), n = OU(t11);
  return this.then(n ? function(i) {
    return _T(e, t11()).then(function() {
      return i;
    });
  } : t11, n ? function(i) {
    return _T(e, t11()).then(function() {
      throw i;
    });
  } : t11);
} });
var Ym = me;
var PU = wm;
var kU = oi;
var LU = la;
var MU = Ym("".charAt);
var ET = Ym("".charCodeAt);
var UU = Ym("".slice);
var mT = function(t11) {
  return function(e, n) {
    var i, r, o = kU(LU(e)), s = PU(n), a = o.length;
    return s < 0 || s >= a ? t11 ? "" : void 0 : (i = ET(o, s)) < 55296 || i > 56319 || s + 1 === a || (r = ET(o, s + 1)) < 56320 || r > 57343 ? t11 ? MU(o, s) : i : t11 ? UU(o, s, s + 2) : r - 56320 + (i - 55296 << 10) + 65536;
  };
};
var qm = { codeAt: mT(false), charAt: mT(true) };
var xU = qm.charAt;
var VU = oi;
var Pb = ns;
var FU = ib;
var fT = Vm;
var kb = "String Iterator";
var BU = Pb.set;
var jU = Pb.getterFor(kb);
FU(String, "String", function(t11) {
  BU(this, { type: kb, string: VU(t11), index: 0 });
}, function() {
  var t11, e = jU(this), n = e.string, i = e.index;
  return i >= n.length ? fT(void 0, true) : (t11 = xU(n, i), e.index += t11.length, fT(t11, false));
});
var GU = Gi.Promise;
var WU = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
var HU = We;
var KU = Er;
var YU = fo;
var gT = es;
var TT = pe("toStringTag");
for (fd in WU) Xh = HU[fd], gd = Xh && Xh.prototype, gd && KU(gd) !== TT && YU(gd, TT, fd), gT[fd] = gT.Array;
var Xh;
var gd;
var fd;
var Lb = GU;
var j = ae(Lb);
var ST = jA;
function Mb(t11, e) {
  let n = t11 && t11.navigator;
  if (!n.mediaDevices) return;
  let i = function(s) {
    if (typeof s != "object" || s.mandatory || s.optional) return s;
    let a = {};
    return Object.keys(s).forEach((c) => {
      if (c === "require" || c === "advanced" || c === "mediaSource") return;
      let d = typeof s[c] == "object" ? s[c] : { ideal: s[c] };
      d.exact !== void 0 && typeof d.exact == "number" && (d.min = d.max = d.exact);
      let l = function(u, h) {
        return u ? u + h.charAt(0).toUpperCase() + h.slice(1) : h === "deviceId" ? "sourceId" : h;
      };
      if (d.ideal !== void 0) {
        a.optional = a.optional || [];
        let u = {};
        typeof d.ideal == "number" ? (u[l("min", c)] = d.ideal, a.optional.push(u), u = {}, u[l("max", c)] = d.ideal, a.optional.push(u)) : (u[l("", c)] = d.ideal, a.optional.push(u));
      }
      d.exact !== void 0 && typeof d.exact != "number" ? (a.mandatory = a.mandatory || {}, a.mandatory[l("", c)] = d.exact) : ["min", "max"].forEach((u) => {
        d[u] !== void 0 && (a.mandatory = a.mandatory || {}, a.mandatory[l(u, c)] = d[u]);
      });
    }), s.advanced && (a.optional = (a.optional || []).concat(s.advanced)), a;
  }, r = function(s, a) {
    if (e.version >= 61) return a(s);
    if ((s = JSON.parse(JSON.stringify(s))) && typeof s.audio == "object") {
      let c = function(d, l, u) {
        l in d && !(u in d) && (d[u] = d[l], delete d[l]);
      };
      c((s = JSON.parse(JSON.stringify(s))).audio, "autoGainControl", "googAutoGainControl"), c(s.audio, "noiseSuppression", "googNoiseSuppression"), s.audio = i(s.audio);
    }
    if (s && typeof s.video == "object") {
      let c = s.video.facingMode;
      c = c && (typeof c == "object" ? c : { ideal: c });
      let d = e.version < 66;
      if (c && (c.exact === "user" || c.exact === "environment" || c.ideal === "user" || c.ideal === "environment") && (!n.mediaDevices.getSupportedConstraints || !n.mediaDevices.getSupportedConstraints().facingMode || d)) {
        let l;
        if (delete s.video.facingMode, c.exact === "environment" || c.ideal === "environment" ? l = ["back", "rear"] : c.exact !== "user" && c.ideal !== "user" || (l = ["front"]), l) return n.mediaDevices.enumerateDevices().then((u) => {
          let h = (u = u.filter((p) => p.kind === "videoinput")).find((p) => l.some((g) => {
            var E;
            return W(E = p.label.toLowerCase()).call(E, g);
          }));
          return !h && u.length && W(l).call(l, "back") && (h = u[u.length - 1]), h && (s.video.deviceId = c.exact ? { exact: h.deviceId } : { ideal: h.deviceId }), s.video = i(s.video), ST("chrome: " + JSON.stringify(s)), a(s);
        });
      }
      s.video = i(s.video);
    }
    return ST("chrome: " + JSON.stringify(s)), a(s);
  }, o = function(s) {
    return e.version >= 64 ? s : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[s.name] || s.name, message: s.message, constraint: s.constraint || s.constraintName, toString() {
      return this.name + (this.message && ": ") + this.message;
    } };
  };
  if (n.getUserMedia = (function(s, a, c) {
    r(s, (d) => {
      n.webkitGetUserMedia(d, a, (l) => {
        c && c(o(l));
      });
    });
  }).bind(n), n.mediaDevices.getUserMedia) {
    let s = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
    n.mediaDevices.getUserMedia = function(a) {
      return r(a, (c) => s(c).then((d) => {
        if (c.audio && !d.getAudioTracks().length || c.video && !d.getVideoTracks().length) throw d.getTracks().forEach((l) => {
          l.stop();
        }), new DOMException("", "NotFoundError");
        return d;
      }, (d) => j.reject(o(d))));
    };
  }
}
function Ub(t11) {
  t11.MediaStream = t11.MediaStream || t11.webkitMediaStream;
}
function xb(t11) {
  if (typeof t11 == "object" && t11.RTCPeerConnection && !("ontrack" in t11.RTCPeerConnection.prototype)) {
    Object.defineProperty(t11.RTCPeerConnection.prototype, "ontrack", { get() {
      return this._ontrack;
    }, set(n) {
      this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = n);
    }, enumerable: true, configurable: true });
    let e = t11.RTCPeerConnection.prototype.setRemoteDescription;
    t11.RTCPeerConnection.prototype.setRemoteDescription = function() {
      return this._ontrackpoly || (this._ontrackpoly = (n) => {
        n.stream.addEventListener("addtrack", (i) => {
          let r;
          r = t11.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((s) => s.track && s.track.id === i.track.id) : { track: i.track };
          let o = new Event("track");
          o.track = i.track, o.receiver = r, o.transceiver = { receiver: r }, o.streams = [n.stream], this.dispatchEvent(o);
        }), n.stream.getTracks().forEach((i) => {
          let r;
          r = t11.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((s) => s.track && s.track.id === i.id) : { track: i };
          let o = new Event("track");
          o.track = i, o.receiver = r, o.transceiver = { receiver: r }, o.streams = [n.stream], this.dispatchEvent(o);
        });
      }, this.addEventListener("addstream", this._ontrackpoly)), e.apply(this, arguments);
    };
  } else ts(t11, "track", (e) => (e.transceiver || Object.defineProperty(e, "transceiver", { value: { receiver: e.receiver } }), e));
}
function Vb(t11) {
  if (typeof t11 == "object" && t11.RTCPeerConnection && !("getSenders" in t11.RTCPeerConnection.prototype) && "createDTMFSender" in t11.RTCPeerConnection.prototype) {
    let e = function(r, o) {
      return { track: o, get dtmf() {
        return this._dtmf === void 0 && (o.kind === "audio" ? this._dtmf = r.createDTMFSender(o) : this._dtmf = null), this._dtmf;
      }, _pc: r };
    };
    if (!t11.RTCPeerConnection.prototype.getSenders) {
      t11.RTCPeerConnection.prototype.getSenders = function() {
        return this._senders = this._senders || [], this._senders.slice();
      };
      let r = t11.RTCPeerConnection.prototype.addTrack;
      t11.RTCPeerConnection.prototype.addTrack = function(s, a) {
        let c = r.apply(this, arguments);
        return c || (c = e(this, s), this._senders.push(c)), c;
      };
      let o = t11.RTCPeerConnection.prototype.removeTrack;
      t11.RTCPeerConnection.prototype.removeTrack = function(s) {
        o.apply(this, arguments);
        let a = this._senders.indexOf(s);
        a !== -1 && this._senders.splice(a, 1);
      };
    }
    let n = t11.RTCPeerConnection.prototype.addStream;
    t11.RTCPeerConnection.prototype.addStream = function(r) {
      this._senders = this._senders || [], n.apply(this, [r]), r.getTracks().forEach((o) => {
        this._senders.push(e(this, o));
      });
    };
    let i = t11.RTCPeerConnection.prototype.removeStream;
    t11.RTCPeerConnection.prototype.removeStream = function(r) {
      this._senders = this._senders || [], i.apply(this, [r]), r.getTracks().forEach((o) => {
        let s = this._senders.find((a) => a.track === o);
        s && this._senders.splice(this._senders.indexOf(s), 1);
      });
    };
  } else if (typeof t11 == "object" && t11.RTCPeerConnection && "getSenders" in t11.RTCPeerConnection.prototype && "createDTMFSender" in t11.RTCPeerConnection.prototype && t11.RTCRtpSender && !("dtmf" in t11.RTCRtpSender.prototype)) {
    let e = t11.RTCPeerConnection.prototype.getSenders;
    t11.RTCPeerConnection.prototype.getSenders = function() {
      let n = e.apply(this, []);
      return n.forEach((i) => i._pc = this), n;
    }, Object.defineProperty(t11.RTCRtpSender.prototype, "dtmf", { get() {
      return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
    } });
  }
}
function Fb(t11) {
  if (!t11.RTCPeerConnection) return;
  let e = t11.RTCPeerConnection.prototype.getStats;
  t11.RTCPeerConnection.prototype.getStats = function() {
    let [n, i, r] = arguments;
    if (arguments.length > 0 && typeof n == "function") return e.apply(this, arguments);
    if (e.length === 0 && (arguments.length === 0 || typeof n != "function")) return e.apply(this, []);
    let o = function(a) {
      let c = {};
      return a.result().forEach((d) => {
        let l = { id: d.id, timestamp: d.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[d.type] || d.type };
        d.names().forEach((u) => {
          l[u] = d.stat(u);
        }), c[l.id] = l;
      }), c;
    }, s = function(a) {
      return new Map(Object.keys(a).map((c) => [c, a[c]]));
    };
    if (arguments.length >= 2) {
      let a = function(c) {
        i(s(o(c)));
      };
      return e.apply(this, [a, n]);
    }
    return new j((a, c) => {
      e.apply(this, [function(d) {
        a(s(o(d)));
      }, c]);
    }).then(i, r);
  };
}
function Bb(t11) {
  if (!(typeof t11 == "object" && t11.RTCPeerConnection && t11.RTCRtpSender && t11.RTCRtpReceiver)) return;
  if (!("getStats" in t11.RTCRtpSender.prototype)) {
    let n = t11.RTCPeerConnection.prototype.getSenders;
    n && (t11.RTCPeerConnection.prototype.getSenders = function() {
      let r = n.apply(this, []);
      return r.forEach((o) => o._pc = this), r;
    });
    let i = t11.RTCPeerConnection.prototype.addTrack;
    i && (t11.RTCPeerConnection.prototype.addTrack = function() {
      let r = i.apply(this, arguments);
      return r._pc = this, r;
    }), t11.RTCRtpSender.prototype.getStats = function() {
      let r = this;
      return this._pc.getStats().then((o) => Sg(o, r.track, true));
    };
  }
  if (!("getStats" in t11.RTCRtpReceiver.prototype)) {
    let n = t11.RTCPeerConnection.prototype.getReceivers;
    n && (t11.RTCPeerConnection.prototype.getReceivers = function() {
      let i = n.apply(this, []);
      return i.forEach((r) => r._pc = this), i;
    }), ts(t11, "track", (i) => (i.receiver._pc = i.srcElement, i)), t11.RTCRtpReceiver.prototype.getStats = function() {
      let i = this;
      return this._pc.getStats().then((r) => Sg(r, i.track, false));
    };
  }
  if (!("getStats" in t11.RTCRtpSender.prototype) || !("getStats" in t11.RTCRtpReceiver.prototype)) return;
  let e = t11.RTCPeerConnection.prototype.getStats;
  t11.RTCPeerConnection.prototype.getStats = function() {
    if (arguments.length > 0 && arguments[0] instanceof t11.MediaStreamTrack) {
      let n = arguments[0], i, r, o;
      return this.getSenders().forEach((s) => {
        s.track === n && (i ? o = true : i = s);
      }), this.getReceivers().forEach((s) => (s.track === n && (r ? o = true : r = s), s.track === n)), o || i && r ? j.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : i ? i.getStats() : r ? r.getStats() : j.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return e.apply(this, arguments);
  };
}
function jb(t11) {
  t11.RTCPeerConnection.prototype.getLocalStreams = function() {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((o) => this._shimmedLocalStreams[o][0]);
  };
  let e = t11.RTCPeerConnection.prototype.addTrack;
  t11.RTCPeerConnection.prototype.addTrack = function(o, s) {
    if (!s) return e.apply(this, arguments);
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    let a = e.apply(this, arguments);
    return this._shimmedLocalStreams[s.id] ? this._shimmedLocalStreams[s.id].indexOf(a) === -1 && this._shimmedLocalStreams[s.id].push(a) : this._shimmedLocalStreams[s.id] = [s, a], a;
  };
  let n = t11.RTCPeerConnection.prototype.addStream;
  t11.RTCPeerConnection.prototype.addStream = function(o) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, o.getTracks().forEach((c) => {
      if (this.getSenders().find((l) => l.track === c)) throw new DOMException("Track already exists.", "InvalidAccessError");
    });
    let s = this.getSenders();
    n.apply(this, arguments);
    let a = this.getSenders().filter((c) => s.indexOf(c) === -1);
    this._shimmedLocalStreams[o.id] = [o].concat(a);
  };
  let i = t11.RTCPeerConnection.prototype.removeStream;
  t11.RTCPeerConnection.prototype.removeStream = function(o) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[o.id], i.apply(this, arguments);
  };
  let r = t11.RTCPeerConnection.prototype.removeTrack;
  t11.RTCPeerConnection.prototype.removeTrack = function(o) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, o && Object.keys(this._shimmedLocalStreams).forEach((s) => {
      let a = this._shimmedLocalStreams[s].indexOf(o);
      a !== -1 && this._shimmedLocalStreams[s].splice(a, 1), this._shimmedLocalStreams[s].length === 1 && delete this._shimmedLocalStreams[s];
    }), r.apply(this, arguments);
  };
}
function Gb(t11, e) {
  if (!t11.RTCPeerConnection) return;
  if (t11.RTCPeerConnection.prototype.addTrack && e.version >= 65) return jb(t11);
  let n = t11.RTCPeerConnection.prototype.getLocalStreams;
  t11.RTCPeerConnection.prototype.getLocalStreams = function() {
    let c = n.apply(this);
    return this._reverseStreams = this._reverseStreams || {}, c.map((d) => this._reverseStreams[d.id]);
  };
  let i = t11.RTCPeerConnection.prototype.addStream;
  t11.RTCPeerConnection.prototype.addStream = function(c) {
    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, c.getTracks().forEach((d) => {
      if (this.getSenders().find((u) => u.track === d)) throw new DOMException("Track already exists.", "InvalidAccessError");
    }), !this._reverseStreams[c.id]) {
      let d = new t11.MediaStream(c.getTracks());
      this._streams[c.id] = d, this._reverseStreams[d.id] = c, c = d;
    }
    i.apply(this, [c]);
  };
  let r = t11.RTCPeerConnection.prototype.removeStream;
  function o(c, d) {
    let l = d.sdp;
    return Object.keys(c._reverseStreams || []).forEach((u) => {
      let h = c._reverseStreams[u], p = c._streams[h.id];
      l = l.replace(new RegExp(p.id, "g"), h.id);
    }), new RTCSessionDescription({ type: d.type, sdp: l });
  }
  t11.RTCPeerConnection.prototype.removeStream = function(c) {
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, r.apply(this, [this._streams[c.id] || c]), delete this._reverseStreams[this._streams[c.id] ? this._streams[c.id].id : c.id], delete this._streams[c.id];
  }, t11.RTCPeerConnection.prototype.addTrack = function(c, d) {
    if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    let l = [].slice.call(arguments, 1);
    if (l.length !== 1 || !l[0].getTracks().find((p) => p === c)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    if (this.getSenders().find((p) => p.track === c)) throw new DOMException("Track already exists.", "InvalidAccessError");
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
    let h = this._streams[d.id];
    if (h) h.addTrack(c), j.resolve().then(() => {
      this.dispatchEvent(new Event("negotiationneeded"));
    });
    else {
      let p = new t11.MediaStream([c]);
      this._streams[d.id] = p, this._reverseStreams[p.id] = d, this.addStream(p);
    }
    return this.getSenders().find((p) => p.track === c);
  }, ["createOffer", "createAnswer"].forEach(function(c) {
    let d = t11.RTCPeerConnection.prototype[c], l = { [c]() {
      let u = arguments;
      return arguments.length && typeof arguments[0] == "function" ? d.apply(this, [(h) => {
        let p = o(this, h);
        u[0].apply(null, [p]);
      }, (h) => {
        u[1] && u[1].apply(null, h);
      }, arguments[2]]) : d.apply(this, arguments).then((h) => o(this, h));
    } };
    t11.RTCPeerConnection.prototype[c] = l[c];
  });
  let s = t11.RTCPeerConnection.prototype.setLocalDescription;
  t11.RTCPeerConnection.prototype.setLocalDescription = function() {
    return arguments.length && arguments[0].type ? (arguments[0] = function(c, d) {
      let l = d.sdp;
      return Object.keys(c._reverseStreams || []).forEach((u) => {
        let h = c._reverseStreams[u], p = c._streams[h.id];
        l = l.replace(new RegExp(h.id, "g"), p.id);
      }), new RTCSessionDescription({ type: d.type, sdp: l });
    }(this, arguments[0]), s.apply(this, arguments)) : s.apply(this, arguments);
  };
  let a = Object.getOwnPropertyDescriptor(t11.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(t11.RTCPeerConnection.prototype, "localDescription", { get() {
    let c = a.get.apply(this);
    return c.type === "" ? c : o(this, c);
  } }), t11.RTCPeerConnection.prototype.removeTrack = function(c) {
    if (this.signalingState === "closed") throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    if (!c._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    if (c._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    let d;
    this._streams = this._streams || {}, Object.keys(this._streams).forEach((l) => {
      this._streams[l].getTracks().find((u) => c.track === u) && (d = this._streams[l]);
    }), d && (d.getTracks().length === 1 ? this.removeStream(this._reverseStreams[d.id]) : d.removeTrack(c.track), this.dispatchEvent(new Event("negotiationneeded")));
  };
}
function aE(t11, e) {
  !t11.RTCPeerConnection && t11.webkitRTCPeerConnection && (t11.RTCPeerConnection = t11.webkitRTCPeerConnection), t11.RTCPeerConnection && e.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(n) {
    let i = t11.RTCPeerConnection.prototype[n], r = { [n]() {
      return arguments[0] = new (n === "addIceCandidate" ? t11.RTCIceCandidate : t11.RTCSessionDescription)(arguments[0]), i.apply(this, arguments);
    } };
    t11.RTCPeerConnection.prototype[n] = r[n];
  });
}
function Wb(t11, e) {
  ts(t11, "negotiationneeded", (n) => {
    let i = n.target;
    if (!(e.version < 72 || i.getConfiguration && i.getConfiguration().sdpSemantics === "plan-b") || i.signalingState === "stable") return n;
  });
}
var RT = Object.freeze({ __proto__: null, fixNegotiationNeeded: Wb, shimAddTrackRemoveTrack: Gb, shimAddTrackRemoveTrackWithNative: jb, shimGetDisplayMedia: function(t11, e) {
  t11.navigator.mediaDevices && "getDisplayMedia" in t11.navigator.mediaDevices || t11.navigator.mediaDevices && (typeof e == "function" ? t11.navigator.mediaDevices.getDisplayMedia = function(n) {
    return e(n).then((i) => {
      let r = n.video && n.video.width, o = n.video && n.video.height, s = n.video && n.video.frameRate;
      return n.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: i, maxFrameRate: s || 3 } }, r && (n.video.mandatory.maxWidth = r), o && (n.video.mandatory.maxHeight = o), t11.navigator.mediaDevices.getUserMedia(n);
    });
  } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
}, shimGetSendersWithDtmf: Vb, shimGetStats: Fb, shimGetUserMedia: Mb, shimMediaStream: Ub, shimOnTrack: xb, shimPeerConnection: aE, shimSenderReceiverGetStats: Bb });
function Hb(t11, e) {
  let n = t11 && t11.navigator, i = t11 && t11.MediaStreamTrack;
  if (n.getUserMedia = function(r, o, s) {
    Pm("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), n.mediaDevices.getUserMedia(r).then(o, s);
  }, !(e.version > 55 && "autoGainControl" in n.mediaDevices.getSupportedConstraints())) {
    let r = function(s, a, c) {
      a in s && !(c in s) && (s[c] = s[a], delete s[a]);
    }, o = n.mediaDevices.getUserMedia.bind(n.mediaDevices);
    if (n.mediaDevices.getUserMedia = function(s) {
      return typeof s == "object" && typeof s.audio == "object" && (s = JSON.parse(JSON.stringify(s)), r(s.audio, "autoGainControl", "mozAutoGainControl"), r(s.audio, "noiseSuppression", "mozNoiseSuppression")), o(s);
    }, i && i.prototype.getSettings) {
      let s = i.prototype.getSettings;
      i.prototype.getSettings = function() {
        let a = s.apply(this, arguments);
        return r(a, "mozAutoGainControl", "autoGainControl"), r(a, "mozNoiseSuppression", "noiseSuppression"), a;
      };
    }
    if (i && i.prototype.applyConstraints) {
      let s = i.prototype.applyConstraints;
      i.prototype.applyConstraints = function(a) {
        return this.kind === "audio" && typeof a == "object" && (a = JSON.parse(JSON.stringify(a)), r(a, "autoGainControl", "mozAutoGainControl"), r(a, "noiseSuppression", "mozNoiseSuppression")), s.apply(this, [a]);
      };
    }
  }
}
function Kb(t11) {
  typeof t11 == "object" && t11.RTCTrackEvent && "receiver" in t11.RTCTrackEvent.prototype && !("transceiver" in t11.RTCTrackEvent.prototype) && Object.defineProperty(t11.RTCTrackEvent.prototype, "transceiver", { get() {
    return { receiver: this.receiver };
  } });
}
function cE(t11, e) {
  if (typeof t11 != "object" || !t11.RTCPeerConnection && !t11.mozRTCPeerConnection) return;
  !t11.RTCPeerConnection && t11.mozRTCPeerConnection && (t11.RTCPeerConnection = t11.mozRTCPeerConnection), e.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(r) {
    let o = t11.RTCPeerConnection.prototype[r], s = { [r]() {
      return arguments[0] = new (r === "addIceCandidate" ? t11.RTCIceCandidate : t11.RTCSessionDescription)(arguments[0]), o.apply(this, arguments);
    } };
    t11.RTCPeerConnection.prototype[r] = s[r];
  });
  let n = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, i = t11.RTCPeerConnection.prototype.getStats;
  t11.RTCPeerConnection.prototype.getStats = function() {
    let [r, o, s] = arguments;
    return i.apply(this, [r || null]).then((a) => {
      if (e.version < 53 && !o) try {
        a.forEach((c) => {
          c.type = n[c.type] || c.type;
        });
      } catch (c) {
        if (c.name !== "TypeError") throw c;
        a.forEach((d, l) => {
          a.set(l, Object.assign({}, d, { type: n[d.type] || d.type }));
        });
      }
      return a;
    }).then(o, s);
  };
}
function Yb(t11) {
  if (typeof t11 != "object" || !t11.RTCPeerConnection || !t11.RTCRtpSender || t11.RTCRtpSender && "getStats" in t11.RTCRtpSender.prototype) return;
  let e = t11.RTCPeerConnection.prototype.getSenders;
  e && (t11.RTCPeerConnection.prototype.getSenders = function() {
    let i = e.apply(this, []);
    return i.forEach((r) => r._pc = this), i;
  });
  let n = t11.RTCPeerConnection.prototype.addTrack;
  n && (t11.RTCPeerConnection.prototype.addTrack = function() {
    let i = n.apply(this, arguments);
    return i._pc = this, i;
  }), t11.RTCRtpSender.prototype.getStats = function() {
    return this.track ? this._pc.getStats(this.track) : j.resolve(/* @__PURE__ */ new Map());
  };
}
function qb(t11) {
  if (typeof t11 != "object" || !t11.RTCPeerConnection || !t11.RTCRtpSender || t11.RTCRtpSender && "getStats" in t11.RTCRtpReceiver.prototype) return;
  let e = t11.RTCPeerConnection.prototype.getReceivers;
  e && (t11.RTCPeerConnection.prototype.getReceivers = function() {
    let n = e.apply(this, []);
    return n.forEach((i) => i._pc = this), n;
  }), ts(t11, "track", (n) => (n.receiver._pc = n.srcElement, n)), t11.RTCRtpReceiver.prototype.getStats = function() {
    return this._pc.getStats(this.track);
  };
}
function zb(t11) {
  t11.RTCPeerConnection && !("removeStream" in t11.RTCPeerConnection.prototype) && (t11.RTCPeerConnection.prototype.removeStream = function(e) {
    Pm("removeStream", "removeTrack"), this.getSenders().forEach((n) => {
      var i;
      n.track && W(i = e.getTracks()).call(i, n.track) && this.removeTrack(n);
    });
  });
}
function Jb(t11) {
  t11.DataChannel && !t11.RTCDataChannel && (t11.RTCDataChannel = t11.DataChannel);
}
function Xb(t11) {
  if (typeof t11 != "object" || !t11.RTCPeerConnection) return;
  let e = t11.RTCPeerConnection.prototype.addTransceiver;
  e && (t11.RTCPeerConnection.prototype.addTransceiver = function() {
    this.setParametersPromises = [];
    let n = arguments[1] && arguments[1].sendEncodings;
    n === void 0 && (n = []), n = [...n];
    let i = n.length > 0;
    i && n.forEach((o) => {
      if ("rid" in o && !/^[a-z0-9]{0,16}$/i.test(o.rid)) throw new TypeError("Invalid RID value provided.");
      if ("scaleResolutionDownBy" in o && !(parseFloat(o.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
      if ("maxFramerate" in o && !(parseFloat(o.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0");
    });
    let r = e.apply(this, arguments);
    if (i) {
      let { sender: o } = r, s = o.getParameters();
      (!("encodings" in s) || s.encodings.length === 1 && Object.keys(s.encodings[0]).length === 0) && (s.encodings = n, o.sendEncodings = n, this.setParametersPromises.push(o.setParameters(s).then(() => {
        delete o.sendEncodings;
      }).catch(() => {
        delete o.sendEncodings;
      })));
    }
    return r;
  });
}
function Qb(t11) {
  if (typeof t11 != "object" || !t11.RTCRtpSender) return;
  let e = t11.RTCRtpSender.prototype.getParameters;
  e && (t11.RTCRtpSender.prototype.getParameters = function() {
    let n = e.apply(this, arguments);
    return "encodings" in n || (n.encodings = [].concat(this.sendEncodings || [{}])), n;
  });
}
function Zb(t11) {
  if (typeof t11 != "object" || !t11.RTCPeerConnection) return;
  let e = t11.RTCPeerConnection.prototype.createOffer;
  t11.RTCPeerConnection.prototype.createOffer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? j.all(this.setParametersPromises).then(() => e.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : e.apply(this, arguments);
  };
}
function $b(t11) {
  if (typeof t11 != "object" || !t11.RTCPeerConnection) return;
  let e = t11.RTCPeerConnection.prototype.createAnswer;
  t11.RTCPeerConnection.prototype.createAnswer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? j.all(this.setParametersPromises).then(() => e.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : e.apply(this, arguments);
  };
}
var CT = Object.freeze({ __proto__: null, shimAddTransceiver: Xb, shimCreateAnswer: $b, shimCreateOffer: Zb, shimGetDisplayMedia: function(t11, e) {
  t11.navigator.mediaDevices && "getDisplayMedia" in t11.navigator.mediaDevices || t11.navigator.mediaDevices && (t11.navigator.mediaDevices.getDisplayMedia = function(n) {
    if (!n || !n.video) {
      let i = new DOMException("getDisplayMedia without video constraints is undefined");
      return i.name = "NotFoundError", i.code = 8, j.reject(i);
    }
    return n.video === true ? n.video = { mediaSource: e } : n.video.mediaSource = e, t11.navigator.mediaDevices.getUserMedia(n);
  });
}, shimGetParameters: Qb, shimGetUserMedia: Hb, shimOnTrack: Kb, shimPeerConnection: cE, shimRTCDataChannel: Jb, shimReceiverGetStats: qb, shimRemoveStream: zb, shimSenderGetStats: Yb });
function tw(t11) {
  if (typeof t11 == "object" && t11.RTCPeerConnection) {
    if ("getLocalStreams" in t11.RTCPeerConnection.prototype || (t11.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in t11.RTCPeerConnection.prototype)) {
      let e = t11.RTCPeerConnection.prototype.addTrack;
      t11.RTCPeerConnection.prototype.addStream = function(n) {
        var i;
        this._localStreams || (this._localStreams = []), W(i = this._localStreams).call(i, n) || this._localStreams.push(n), n.getAudioTracks().forEach((r) => e.call(this, r, n)), n.getVideoTracks().forEach((r) => e.call(this, r, n));
      }, t11.RTCPeerConnection.prototype.addTrack = function(n) {
        for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) r[o - 1] = arguments[o];
        return r && r.forEach((s) => {
          var a;
          this._localStreams ? W(a = this._localStreams).call(a, s) || this._localStreams.push(s) : this._localStreams = [s];
        }), e.apply(this, arguments);
      };
    }
    "removeStream" in t11.RTCPeerConnection.prototype || (t11.RTCPeerConnection.prototype.removeStream = function(e) {
      this._localStreams || (this._localStreams = []);
      let n = this._localStreams.indexOf(e);
      if (n === -1) return;
      this._localStreams.splice(n, 1);
      let i = e.getTracks();
      this.getSenders().forEach((r) => {
        W(i).call(i, r.track) && this.removeTrack(r);
      });
    });
  }
}
function ew(t11) {
  if (typeof t11 == "object" && t11.RTCPeerConnection && ("getRemoteStreams" in t11.RTCPeerConnection.prototype || (t11.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in t11.RTCPeerConnection.prototype))) {
    Object.defineProperty(t11.RTCPeerConnection.prototype, "onaddstream", { get() {
      return this._onaddstream;
    }, set(n) {
      this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = n), this.addEventListener("track", this._onaddstreampoly = (i) => {
        i.streams.forEach((r) => {
          var o;
          if (this._remoteStreams || (this._remoteStreams = []), W(o = this._remoteStreams).call(o, r)) return;
          this._remoteStreams.push(r);
          let s = new Event("addstream");
          s.stream = r, this.dispatchEvent(s);
        });
      });
    } });
    let e = t11.RTCPeerConnection.prototype.setRemoteDescription;
    t11.RTCPeerConnection.prototype.setRemoteDescription = function() {
      let n = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(i) {
        i.streams.forEach((r) => {
          if (n._remoteStreams || (n._remoteStreams = []), n._remoteStreams.indexOf(r) >= 0) return;
          n._remoteStreams.push(r);
          let o = new Event("addstream");
          o.stream = r, n.dispatchEvent(o);
        });
      }), e.apply(n, arguments);
    };
  }
}
function nw(t11) {
  if (typeof t11 != "object" || !t11.RTCPeerConnection) return;
  let e = t11.RTCPeerConnection.prototype, n = e.createOffer, i = e.createAnswer, r = e.setLocalDescription, o = e.setRemoteDescription, s = e.addIceCandidate;
  e.createOffer = function(c, d) {
    let l = arguments.length >= 2 ? arguments[2] : arguments[0], u = n.apply(this, [l]);
    return d ? (u.then(c, d), j.resolve()) : u;
  }, e.createAnswer = function(c, d) {
    let l = arguments.length >= 2 ? arguments[2] : arguments[0], u = i.apply(this, [l]);
    return d ? (u.then(c, d), j.resolve()) : u;
  };
  let a = function(c, d, l) {
    let u = r.apply(this, [c]);
    return l ? (u.then(d, l), j.resolve()) : u;
  };
  e.setLocalDescription = a, a = function(c, d, l) {
    let u = o.apply(this, [c]);
    return l ? (u.then(d, l), j.resolve()) : u;
  }, e.setRemoteDescription = a, a = function(c, d, l) {
    let u = s.apply(this, [c]);
    return l ? (u.then(d, l), j.resolve()) : u;
  }, e.addIceCandidate = a;
}
function iw(t11) {
  let e = t11 && t11.navigator;
  if (e.mediaDevices && e.mediaDevices.getUserMedia) {
    let n = e.mediaDevices, i = n.getUserMedia.bind(n);
    e.mediaDevices.getUserMedia = (r) => i(rw(r));
  }
  !e.getUserMedia && e.mediaDevices && e.mediaDevices.getUserMedia && (e.getUserMedia = (function(n, i, r) {
    e.mediaDevices.getUserMedia(n).then(i, r);
  }).bind(e));
}
function rw(t11) {
  return t11 && t11.video !== void 0 ? Object.assign({}, t11, { video: GA(t11.video) }) : t11;
}
function ow(t11) {
  if (!t11.RTCPeerConnection) return;
  let e = t11.RTCPeerConnection;
  t11.RTCPeerConnection = function(n, i) {
    if (n && n.iceServers) {
      let r = [];
      for (let o = 0; o < n.iceServers.length; o++) {
        let s = n.iceServers[o];
        !s.hasOwnProperty("urls") && s.hasOwnProperty("url") ? (Pm("RTCIceServer.url", "RTCIceServer.urls"), s = JSON.parse(JSON.stringify(s)), s.urls = s.url, delete s.url, r.push(s)) : r.push(n.iceServers[o]);
      }
      n.iceServers = r;
    }
    return new e(n, i);
  }, t11.RTCPeerConnection.prototype = e.prototype, "generateCertificate" in e && Object.defineProperty(t11.RTCPeerConnection, "generateCertificate", { get: () => e.generateCertificate });
}
function sw(t11) {
  typeof t11 == "object" && t11.RTCTrackEvent && "receiver" in t11.RTCTrackEvent.prototype && !("transceiver" in t11.RTCTrackEvent.prototype) && Object.defineProperty(t11.RTCTrackEvent.prototype, "transceiver", { get() {
    return { receiver: this.receiver };
  } });
}
function aw(t11) {
  let e = t11.RTCPeerConnection.prototype.createOffer;
  t11.RTCPeerConnection.prototype.createOffer = function(n) {
    if (n) {
      n.offerToReceiveAudio !== void 0 && (n.offerToReceiveAudio = !!n.offerToReceiveAudio);
      let i = this.getTransceivers().find((o) => o.receiver.track.kind === "audio");
      n.offerToReceiveAudio === false && i ? i.direction === "sendrecv" ? i.setDirection ? i.setDirection("sendonly") : i.direction = "sendonly" : i.direction === "recvonly" && (i.setDirection ? i.setDirection("inactive") : i.direction = "inactive") : n.offerToReceiveAudio !== true || i || this.addTransceiver("audio", { direction: "recvonly" }), n.offerToReceiveVideo !== void 0 && (n.offerToReceiveVideo = !!n.offerToReceiveVideo);
      let r = this.getTransceivers().find((o) => o.receiver.track.kind === "video");
      n.offerToReceiveVideo === false && r ? r.direction === "sendrecv" ? r.setDirection ? r.setDirection("sendonly") : r.direction = "sendonly" : r.direction === "recvonly" && (r.setDirection ? r.setDirection("inactive") : r.direction = "inactive") : n.offerToReceiveVideo !== true || r || this.addTransceiver("video", { direction: "recvonly" });
    }
    return e.apply(this, arguments);
  };
}
function cw(t11) {
  typeof t11 != "object" || t11.AudioContext || (t11.AudioContext = t11.webkitAudioContext);
}
var IT = Object.freeze({ __proto__: null, shimAudioContext: cw, shimCallbacksAPI: nw, shimConstraints: rw, shimCreateOfferLegacy: aw, shimGetUserMedia: iw, shimLocalStreamsAPI: tw, shimRTCIceServerUrls: ow, shimRemoteStreamsAPI: ew, shimTrackEventTransceiver: sw });
var dw = `	
\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF`;
var qU = la;
var zU = oi;
var dE = dw;
var vT = me("".replace);
var JU = RegExp("^[" + dE + "]+");
var XU = RegExp("(^|[^" + dE + "])[" + dE + "]+$");
var Qh = function(t11) {
  return function(e) {
    var n = zU(qU(e));
    return 1 & t11 && (n = vT(n, JU, "")), 2 & t11 && (n = vT(n, XU, "$1")), n;
  };
};
var QU = { start: Qh(1), end: Qh(2), trim: Qh(3) };
var ZU = tb.PROPER;
var $U = Se;
var yT = dw;
var t2 = QU.trim;
xt({ target: "String", proto: true, forced: function(t11) {
  return $U(function() {
    return !!yT[t11]() || "âÂá "[t11]() !== "âÂá " || ZU && yT[t11].name !== t11;
  });
}("trim") }, { trim: function() {
  return t2(this);
} });
var e2 = bi("String").trim;
var n2 = hn;
var i2 = e2;
var Zh = String.prototype;
var r2 = function(t11) {
  var e = t11.trim;
  return typeof t11 == "string" || t11 === Zh || n2(Zh, t11) && e === Zh.trim ? i2 : e;
};
var rn = ae(r2);
var lw = { exports: {} };
(function(t11) {
  let e = { generateIdentifier: function() {
    return Math.random().toString(36).substring(2, 12);
  } };
  e.localCName = e.generateIdentifier(), e.splitLines = function(n) {
    return n.trim().split(`
`).map((i) => i.trim());
  }, e.splitSections = function(n) {
    return n.split(`
m=`).map((i, r) => (r > 0 ? "m=" + i : i).trim() + `\r
`);
  }, e.getDescription = function(n) {
    let i = e.splitSections(n);
    return i && i[0];
  }, e.getMediaSections = function(n) {
    let i = e.splitSections(n);
    return i.shift(), i;
  }, e.matchPrefix = function(n, i) {
    return e.splitLines(n).filter((r) => r.indexOf(i) === 0);
  }, e.parseCandidate = function(n) {
    let i;
    i = n.indexOf("a=candidate:") === 0 ? n.substring(12).split(" ") : n.substring(10).split(" ");
    let r = { foundation: i[0], component: { 1: "rtp", 2: "rtcp" }[i[1]] || i[1], protocol: i[2].toLowerCase(), priority: parseInt(i[3], 10), ip: i[4], address: i[4], port: parseInt(i[5], 10), type: i[7] };
    for (let o = 8; o < i.length; o += 2) switch (i[o]) {
      case "raddr":
        r.relatedAddress = i[o + 1];
        break;
      case "rport":
        r.relatedPort = parseInt(i[o + 1], 10);
        break;
      case "tcptype":
        r.tcpType = i[o + 1];
        break;
      case "ufrag":
        r.ufrag = i[o + 1], r.usernameFragment = i[o + 1];
        break;
      default:
        r[i[o]] === void 0 && (r[i[o]] = i[o + 1]);
    }
    return r;
  }, e.writeCandidate = function(n) {
    let i = [];
    i.push(n.foundation);
    let r = n.component;
    r === "rtp" ? i.push(1) : r === "rtcp" ? i.push(2) : i.push(r), i.push(n.protocol.toUpperCase()), i.push(n.priority), i.push(n.address || n.ip), i.push(n.port);
    let o = n.type;
    return i.push("typ"), i.push(o), o !== "host" && n.relatedAddress && n.relatedPort && (i.push("raddr"), i.push(n.relatedAddress), i.push("rport"), i.push(n.relatedPort)), n.tcpType && n.protocol.toLowerCase() === "tcp" && (i.push("tcptype"), i.push(n.tcpType)), (n.usernameFragment || n.ufrag) && (i.push("ufrag"), i.push(n.usernameFragment || n.ufrag)), "candidate:" + i.join(" ");
  }, e.parseIceOptions = function(n) {
    return n.substring(14).split(" ");
  }, e.parseRtpMap = function(n) {
    let i = n.substring(9).split(" "), r = { payloadType: parseInt(i.shift(), 10) };
    return i = i[0].split("/"), r.name = i[0], r.clockRate = parseInt(i[1], 10), r.channels = i.length === 3 ? parseInt(i[2], 10) : 1, r.numChannels = r.channels, r;
  }, e.writeRtpMap = function(n) {
    let i = n.payloadType;
    n.preferredPayloadType !== void 0 && (i = n.preferredPayloadType);
    let r = n.channels || n.numChannels || 1;
    return "a=rtpmap:" + i + " " + n.name + "/" + n.clockRate + (r !== 1 ? "/" + r : "") + `\r
`;
  }, e.parseExtmap = function(n) {
    let i = n.substring(9).split(" ");
    return { id: parseInt(i[0], 10), direction: i[0].indexOf("/") > 0 ? i[0].split("/")[1] : "sendrecv", uri: i[1], attributes: i.slice(2).join(" ") };
  }, e.writeExtmap = function(n) {
    return "a=extmap:" + (n.id || n.preferredId) + (n.direction && n.direction !== "sendrecv" ? "/" + n.direction : "") + " " + n.uri + (n.attributes ? " " + n.attributes : "") + `\r
`;
  }, e.parseFmtp = function(n) {
    let i = {}, r, o = n.substring(n.indexOf(" ") + 1).split(";");
    for (let s = 0; s < o.length; s++) r = o[s].trim().split("="), i[r[0].trim()] = r[1];
    return i;
  }, e.writeFmtp = function(n) {
    let i = "", r = n.payloadType;
    if (n.preferredPayloadType !== void 0 && (r = n.preferredPayloadType), n.parameters && Object.keys(n.parameters).length) {
      let o = [];
      Object.keys(n.parameters).forEach((s) => {
        n.parameters[s] !== void 0 ? o.push(s + "=" + n.parameters[s]) : o.push(s);
      }), i += "a=fmtp:" + r + " " + o.join(";") + `\r
`;
    }
    return i;
  }, e.parseRtcpFb = function(n) {
    let i = n.substring(n.indexOf(" ") + 1).split(" ");
    return { type: i.shift(), parameter: i.join(" ") };
  }, e.writeRtcpFb = function(n) {
    let i = "", r = n.payloadType;
    return n.preferredPayloadType !== void 0 && (r = n.preferredPayloadType), n.rtcpFeedback && n.rtcpFeedback.length && n.rtcpFeedback.forEach((o) => {
      i += "a=rtcp-fb:" + r + " " + o.type + (o.parameter && o.parameter.length ? " " + o.parameter : "") + `\r
`;
    }), i;
  }, e.parseSsrcMedia = function(n) {
    let i = n.indexOf(" "), r = { ssrc: parseInt(n.substring(7, i), 10) }, o = n.indexOf(":", i);
    return o > -1 ? (r.attribute = n.substring(i + 1, o), r.value = n.substring(o + 1)) : r.attribute = n.substring(i + 1), r;
  }, e.parseSsrcGroup = function(n) {
    let i = n.substring(13).split(" ");
    return { semantics: i.shift(), ssrcs: i.map((r) => parseInt(r, 10)) };
  }, e.getMid = function(n) {
    let i = e.matchPrefix(n, "a=mid:")[0];
    if (i) return i.substring(6);
  }, e.parseFingerprint = function(n) {
    let i = n.substring(14).split(" ");
    return { algorithm: i[0].toLowerCase(), value: i[1].toUpperCase() };
  }, e.getDtlsParameters = function(n, i) {
    return { role: "auto", fingerprints: e.matchPrefix(n + i, "a=fingerprint:").map(e.parseFingerprint) };
  }, e.writeDtlsParameters = function(n, i) {
    let r = "a=setup:" + i + `\r
`;
    return n.fingerprints.forEach((o) => {
      r += "a=fingerprint:" + o.algorithm + " " + o.value + `\r
`;
    }), r;
  }, e.parseCryptoLine = function(n) {
    let i = n.substring(9).split(" ");
    return { tag: parseInt(i[0], 10), cryptoSuite: i[1], keyParams: i[2], sessionParams: i.slice(3) };
  }, e.writeCryptoLine = function(n) {
    return "a=crypto:" + n.tag + " " + n.cryptoSuite + " " + (typeof n.keyParams == "object" ? e.writeCryptoKeyParams(n.keyParams) : n.keyParams) + (n.sessionParams ? " " + n.sessionParams.join(" ") : "") + `\r
`;
  }, e.parseCryptoKeyParams = function(n) {
    if (n.indexOf("inline:") !== 0) return null;
    let i = n.substring(7).split("|");
    return { keyMethod: "inline", keySalt: i[0], lifeTime: i[1], mkiValue: i[2] ? i[2].split(":")[0] : void 0, mkiLength: i[2] ? i[2].split(":")[1] : void 0 };
  }, e.writeCryptoKeyParams = function(n) {
    return n.keyMethod + ":" + n.keySalt + (n.lifeTime ? "|" + n.lifeTime : "") + (n.mkiValue && n.mkiLength ? "|" + n.mkiValue + ":" + n.mkiLength : "");
  }, e.getCryptoParameters = function(n, i) {
    return e.matchPrefix(n + i, "a=crypto:").map(e.parseCryptoLine);
  }, e.getIceParameters = function(n, i) {
    let r = e.matchPrefix(n + i, "a=ice-ufrag:")[0], o = e.matchPrefix(n + i, "a=ice-pwd:")[0];
    return r && o ? { usernameFragment: r.substring(12), password: o.substring(10) } : null;
  }, e.writeIceParameters = function(n) {
    let i = "a=ice-ufrag:" + n.usernameFragment + `\r
a=ice-pwd:` + n.password + `\r
`;
    return n.iceLite && (i += `a=ice-lite\r
`), i;
  }, e.parseRtpParameters = function(n) {
    let i = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r = e.splitLines(n)[0].split(" ");
    i.profile = r[2];
    for (let s = 3; s < r.length; s++) {
      let a = r[s], c = e.matchPrefix(n, "a=rtpmap:" + a + " ")[0];
      if (c) {
        let d = e.parseRtpMap(c), l = e.matchPrefix(n, "a=fmtp:" + a + " ");
        switch (d.parameters = l.length ? e.parseFmtp(l[0]) : {}, d.rtcpFeedback = e.matchPrefix(n, "a=rtcp-fb:" + a + " ").map(e.parseRtcpFb), i.codecs.push(d), d.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            i.fecMechanisms.push(d.name.toUpperCase());
        }
      }
    }
    e.matchPrefix(n, "a=extmap:").forEach((s) => {
      i.headerExtensions.push(e.parseExtmap(s));
    });
    let o = e.matchPrefix(n, "a=rtcp-fb:* ").map(e.parseRtcpFb);
    return i.codecs.forEach((s) => {
      o.forEach((a) => {
        s.rtcpFeedback.find((c) => c.type === a.type && c.parameter === a.parameter) || s.rtcpFeedback.push(a);
      });
    }), i;
  }, e.writeRtpDescription = function(n, i) {
    let r = "";
    r += "m=" + n + " ", r += i.codecs.length > 0 ? "9" : "0", r += " " + (i.profile || "UDP/TLS/RTP/SAVPF") + " ", r += i.codecs.map((s) => s.preferredPayloadType !== void 0 ? s.preferredPayloadType : s.payloadType).join(" ") + `\r
`, r += `c=IN IP4 0.0.0.0\r
`, r += `a=rtcp:9 IN IP4 0.0.0.0\r
`, i.codecs.forEach((s) => {
      r += e.writeRtpMap(s), r += e.writeFmtp(s), r += e.writeRtcpFb(s);
    });
    let o = 0;
    return i.codecs.forEach((s) => {
      s.maxptime > o && (o = s.maxptime);
    }), o > 0 && (r += "a=maxptime:" + o + `\r
`), i.headerExtensions && i.headerExtensions.forEach((s) => {
      r += e.writeExtmap(s);
    }), r;
  }, e.parseRtpEncodingParameters = function(n) {
    let i = [], r = e.parseRtpParameters(n), o = r.fecMechanisms.indexOf("RED") !== -1, s = r.fecMechanisms.indexOf("ULPFEC") !== -1, a = e.matchPrefix(n, "a=ssrc:").map((h) => e.parseSsrcMedia(h)).filter((h) => h.attribute === "cname"), c = a.length > 0 && a[0].ssrc, d, l = e.matchPrefix(n, "a=ssrc-group:FID").map((h) => h.substring(17).split(" ").map((p) => parseInt(p, 10)));
    l.length > 0 && l[0].length > 1 && l[0][0] === c && (d = l[0][1]), r.codecs.forEach((h) => {
      if (h.name.toUpperCase() === "RTX" && h.parameters.apt) {
        let p = { ssrc: c, codecPayloadType: parseInt(h.parameters.apt, 10) };
        c && d && (p.rtx = { ssrc: d }), i.push(p), o && (p = JSON.parse(JSON.stringify(p)), p.fec = { ssrc: c, mechanism: s ? "red+ulpfec" : "red" }, i.push(p));
      }
    }), i.length === 0 && c && i.push({ ssrc: c });
    let u = e.matchPrefix(n, "b=");
    return u.length && (u = u[0].indexOf("b=TIAS:") === 0 ? parseInt(u[0].substring(7), 10) : u[0].indexOf("b=AS:") === 0 ? 1e3 * parseInt(u[0].substring(5), 10) * 0.95 - 16e3 : void 0, i.forEach((h) => {
      h.maxBitrate = u;
    })), i;
  }, e.parseRtcpParameters = function(n) {
    let i = {}, r = e.matchPrefix(n, "a=ssrc:").map((a) => e.parseSsrcMedia(a)).filter((a) => a.attribute === "cname")[0];
    r && (i.cname = r.value, i.ssrc = r.ssrc);
    let o = e.matchPrefix(n, "a=rtcp-rsize");
    i.reducedSize = o.length > 0, i.compound = o.length === 0;
    let s = e.matchPrefix(n, "a=rtcp-mux");
    return i.mux = s.length > 0, i;
  }, e.writeRtcpParameters = function(n) {
    let i = "";
    return n.reducedSize && (i += `a=rtcp-rsize\r
`), n.mux && (i += `a=rtcp-mux\r
`), n.ssrc !== void 0 && n.cname && (i += "a=ssrc:" + n.ssrc + " cname:" + n.cname + `\r
`), i;
  }, e.parseMsid = function(n) {
    let i, r = e.matchPrefix(n, "a=msid:");
    if (r.length === 1) return i = r[0].substring(7).split(" "), { stream: i[0], track: i[1] };
    let o = e.matchPrefix(n, "a=ssrc:").map((s) => e.parseSsrcMedia(s)).filter((s) => s.attribute === "msid");
    return o.length > 0 ? (i = o[0].value.split(" "), { stream: i[0], track: i[1] }) : void 0;
  }, e.parseSctpDescription = function(n) {
    let i = e.parseMLine(n), r = e.matchPrefix(n, "a=max-message-size:"), o;
    r.length > 0 && (o = parseInt(r[0].substring(19), 10)), isNaN(o) && (o = 65536);
    let s = e.matchPrefix(n, "a=sctp-port:");
    if (s.length > 0) return { port: parseInt(s[0].substring(12), 10), protocol: i.fmt, maxMessageSize: o };
    let a = e.matchPrefix(n, "a=sctpmap:");
    if (a.length > 0) {
      let c = a[0].substring(10).split(" ");
      return { port: parseInt(c[0], 10), protocol: c[1], maxMessageSize: o };
    }
  }, e.writeSctpDescription = function(n, i) {
    let r = [];
    return r = n.protocol !== "DTLS/SCTP" ? ["m=" + n.kind + " 9 " + n.protocol + " " + i.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + i.port + `\r
`] : ["m=" + n.kind + " 9 " + n.protocol + " " + i.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + i.port + " " + i.protocol + ` 65535\r
`], i.maxMessageSize !== void 0 && r.push("a=max-message-size:" + i.maxMessageSize + `\r
`), r.join("");
  }, e.generateSessionId = function() {
    return Math.random().toString().substr(2, 22);
  }, e.writeSessionBoilerplate = function(n, i, r) {
    let o, s = i !== void 0 ? i : 2;
    return o = n || e.generateSessionId(), `v=0\r
o=` + (r || "thisisadapterortc") + " " + o + " " + s + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`;
  }, e.getDirection = function(n, i) {
    let r = e.splitLines(n);
    for (let o = 0; o < r.length; o++) switch (r[o]) {
      case "a=sendrecv":
      case "a=sendonly":
      case "a=recvonly":
      case "a=inactive":
        return r[o].substring(2);
    }
    return i ? e.getDirection(i) : "sendrecv";
  }, e.getKind = function(n) {
    return e.splitLines(n)[0].split(" ")[0].substring(2);
  }, e.isRejected = function(n) {
    return n.split(" ", 2)[1] === "0";
  }, e.parseMLine = function(n) {
    let i = e.splitLines(n)[0].substring(2).split(" ");
    return { kind: i[0], port: parseInt(i[1], 10), protocol: i[2], fmt: i.slice(3).join(" ") };
  }, e.parseOLine = function(n) {
    let i = e.matchPrefix(n, "o=")[0].substring(2).split(" ");
    return { username: i[0], sessionId: i[1], sessionVersion: parseInt(i[2], 10), netType: i[3], addressType: i[4], address: i[5] };
  }, e.isValidSDP = function(n) {
    if (typeof n != "string" || n.length === 0) return false;
    let i = e.splitLines(n);
    for (let r = 0; r < i.length; r++) if (i[r].length < 2 || i[r].charAt(1) !== "=") return false;
    return true;
  }, t11.exports = e;
})(lw);
var uw = lw.exports;
var Bs = ae(uw);
var o2 = yN({ __proto__: null, default: Bs }, [uw]);
function dl(t11) {
  if (!t11.RTCIceCandidate || t11.RTCIceCandidate && "foundation" in t11.RTCIceCandidate.prototype) return;
  let e = t11.RTCIceCandidate;
  t11.RTCIceCandidate = function(n) {
    if (typeof n == "object" && n.candidate && n.candidate.indexOf("a=") === 0 && ((n = JSON.parse(JSON.stringify(n))).candidate = n.candidate.substr(2)), n.candidate && n.candidate.length) {
      let i = new e(n), r = Bs.parseCandidate(n.candidate), o = Object.assign(i, r);
      return o.toJSON = function() {
        return { candidate: o.candidate, sdpMid: o.sdpMid, sdpMLineIndex: o.sdpMLineIndex, usernameFragment: o.usernameFragment };
      }, o;
    }
    return new e(n);
  }, t11.RTCIceCandidate.prototype = e.prototype, ts(t11, "icecandidate", (n) => (n.candidate && Object.defineProperty(n, "candidate", { value: new t11.RTCIceCandidate(n.candidate), writable: "false" }), n));
}
function lE(t11) {
  !t11.RTCIceCandidate || t11.RTCIceCandidate && "relayProtocol" in t11.RTCIceCandidate.prototype || ts(t11, "icecandidate", (e) => {
    if (e.candidate) {
      let n = Bs.parseCandidate(e.candidate.candidate);
      n.type === "relay" && (e.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[n.priority >> 24]);
    }
    return e;
  });
}
function ll(t11, e) {
  if (!t11.RTCPeerConnection) return;
  "sctp" in t11.RTCPeerConnection.prototype || Object.defineProperty(t11.RTCPeerConnection.prototype, "sctp", { get() {
    return this._sctp === void 0 ? null : this._sctp;
  } });
  let n = function(a) {
    if (!a || !a.sdp) return false;
    let c = Bs.splitSections(a.sdp);
    return c.shift(), c.some((d) => {
      let l = Bs.parseMLine(d);
      return l && l.kind === "application" && l.protocol.indexOf("SCTP") !== -1;
    });
  }, i = function(a) {
    let c = a.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (c === null || c.length < 2) return -1;
    let d = parseInt(c[1], 10);
    return d != d ? -1 : d;
  }, r = function(a) {
    let c = 65536;
    return e.browser === "firefox" && (c = e.version < 57 ? a === -1 ? 16384 : 2147483637 : e.version < 60 ? e.version === 57 ? 65535 : 65536 : 2147483637), c;
  }, o = function(a, c) {
    let d = 65536;
    e.browser === "firefox" && e.version === 57 && (d = 65535);
    let l = Bs.matchPrefix(a.sdp, "a=max-message-size:");
    return l.length > 0 ? d = parseInt(l[0].substr(19), 10) : e.browser === "firefox" && c !== -1 && (d = 2147483637), d;
  }, s = t11.RTCPeerConnection.prototype.setRemoteDescription;
  t11.RTCPeerConnection.prototype.setRemoteDescription = function() {
    if (this._sctp = null, e.browser === "chrome" && e.version >= 76) {
      let { sdpSemantics: a } = this.getConfiguration();
      a === "plan-b" && Object.defineProperty(this, "sctp", { get() {
        return this._sctp === void 0 ? null : this._sctp;
      }, enumerable: true, configurable: true });
    }
    if (n(arguments[0])) {
      let a = i(arguments[0]), c = r(a), d = o(arguments[0], a), l;
      l = c === 0 && d === 0 ? Number.POSITIVE_INFINITY : c === 0 || d === 0 ? Math.max(c, d) : Math.min(c, d);
      let u = {};
      Object.defineProperty(u, "maxMessageSize", { get: () => l }), this._sctp = u;
    }
    return s.apply(this, arguments);
  };
}
function ul(t11) {
  if (!t11.RTCPeerConnection || !("createDataChannel" in t11.RTCPeerConnection.prototype)) return;
  function e(i, r) {
    let o = i.send;
    i.send = function() {
      let s = arguments[0], a = s.length || s.size || s.byteLength;
      if (i.readyState === "open" && r.sctp && a > r.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + r.sctp.maxMessageSize + " bytes)");
      return o.apply(i, arguments);
    };
  }
  let n = t11.RTCPeerConnection.prototype.createDataChannel;
  t11.RTCPeerConnection.prototype.createDataChannel = function() {
    let i = n.apply(this, arguments);
    return e(i, this), i;
  }, ts(t11, "datachannel", (i) => (e(i.channel, i.target), i));
}
function uE(t11) {
  if (!t11.RTCPeerConnection || "connectionState" in t11.RTCPeerConnection.prototype) return;
  let e = t11.RTCPeerConnection.prototype;
  Object.defineProperty(e, "connectionState", { get() {
    return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
  }, enumerable: true, configurable: true }), Object.defineProperty(e, "onconnectionstatechange", { get() {
    return this._onconnectionstatechange || null;
  }, set(n) {
    this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), n && this.addEventListener("connectionstatechange", this._onconnectionstatechange = n);
  }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach((n) => {
    let i = e[n];
    e[n] = function() {
      return this._connectionstatechangepoly || (this._connectionstatechangepoly = (r) => {
        let o = r.target;
        if (o._lastConnectionState !== o.connectionState) {
          o._lastConnectionState = o.connectionState;
          let s = new Event("connectionstatechange", r);
          o.dispatchEvent(s);
        }
        return r;
      }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i.apply(this, arguments);
    };
  });
}
function hE(t11, e) {
  if (!t11.RTCPeerConnection || e.browser === "chrome" && e.version >= 71 || e.browser === "safari" && e.version >= 605) return;
  let n = t11.RTCPeerConnection.prototype.setRemoteDescription;
  t11.RTCPeerConnection.prototype.setRemoteDescription = function(i) {
    if (i && i.sdp && i.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
      let r = i.sdp.split(`
`).filter((o) => rn(o).call(o) !== "a=extmap-allow-mixed").join(`
`);
      t11.RTCSessionDescription && i instanceof t11.RTCSessionDescription ? arguments[0] = new t11.RTCSessionDescription({ type: i.type, sdp: r }) : i.sdp = r;
    }
    return n.apply(this, arguments);
  };
}
function hl(t11, e) {
  if (!t11.RTCPeerConnection || !t11.RTCPeerConnection.prototype) return;
  let n = t11.RTCPeerConnection.prototype.addIceCandidate;
  n && n.length !== 0 && (t11.RTCPeerConnection.prototype.addIceCandidate = function() {
    return arguments[0] ? (e.browser === "chrome" && e.version < 78 || e.browser === "firefox" && e.version < 68 || e.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? j.resolve() : n.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), j.resolve());
  });
}
function pl(t11, e) {
  if (!t11.RTCPeerConnection || !t11.RTCPeerConnection.prototype) return;
  let n = t11.RTCPeerConnection.prototype.setLocalDescription;
  n && n.length !== 0 && (t11.RTCPeerConnection.prototype.setLocalDescription = function() {
    let i = arguments[0] || {};
    if (typeof i != "object" || i.type && i.sdp) return n.apply(this, arguments);
    if (i = { type: i.type, sdp: i.sdp }, !i.type) switch (this.signalingState) {
      case "stable":
      case "have-local-offer":
      case "have-remote-pranswer":
        i.type = "offer";
        break;
      default:
        i.type = "answer";
    }
    return i.sdp || i.type !== "offer" && i.type !== "answer" ? n.apply(this, [i]) : (i.type === "offer" ? this.createOffer : this.createAnswer).apply(this).then((r) => n.apply(this, [r]));
  });
}
var s2 = Object.freeze({ __proto__: null, removeExtmapAllowMixed: hE, shimAddIceCandidateNullOrEmpty: hl, shimConnectionState: uE, shimMaxMessageSize: ll, shimParameterlessSetLocalDescription: pl, shimRTCIceCandidate: dl, shimRTCIceCandidateRelayProtocol: lE, shimSendThrowTypeError: ul });
(function() {
  let { window: t11 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { shimChrome: true, shimFirefox: true, shimSafari: true }, n = jA, i = function(o) {
    let s = { browser: null, version: null };
    if (o === void 0 || !o.navigator) return s.browser = "Not a browser.", s;
    let { navigator: a } = o;
    if (a.mozGetUserMedia) s.browser = "firefox", s.version = hd(a.userAgent, /Firefox\/(\d+)\./, 1);
    else if (a.webkitGetUserMedia || o.isSecureContext === false && o.webkitRTCPeerConnection) s.browser = "chrome", s.version = hd(a.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
    else {
      if (!o.RTCPeerConnection || !a.userAgent.match(/AppleWebKit\/(\d+)\./)) return s.browser = "Not a supported browser.", s;
      s.browser = "safari", s.version = hd(a.userAgent, /AppleWebKit\/(\d+)\./, 1), s.supportsUnifiedPlan = o.RTCRtpTransceiver && "currentDirection" in o.RTCRtpTransceiver.prototype;
    }
    return s;
  }(t11), r = { browserDetails: i, commonShim: s2, extractVersion: hd, disableLog: rk, disableWarnings: ok, sdp: o2 };
  switch (i.browser) {
    case "chrome":
      if (!RT || !aE || !e.shimChrome) return n("Chrome shim is not included in this adapter release."), r;
      if (i.version === null) return n("Chrome shim can not determine version, not shimming."), r;
      n("adapter.js shimming chrome."), r.browserShim = RT, hl(t11, i), pl(t11), Mb(t11, i), Ub(t11), aE(t11, i), xb(t11), Gb(t11, i), Vb(t11), Fb(t11), Bb(t11), Wb(t11, i), dl(t11), lE(t11), uE(t11), ll(t11, i), ul(t11), hE(t11, i);
      break;
    case "firefox":
      if (!CT || !cE || !e.shimFirefox) return n("Firefox shim is not included in this adapter release."), r;
      n("adapter.js shimming firefox."), r.browserShim = CT, hl(t11, i), pl(t11), Hb(t11, i), cE(t11, i), Kb(t11), zb(t11), Yb(t11), qb(t11), Jb(t11), Xb(t11), Qb(t11), Zb(t11), $b(t11), dl(t11), uE(t11), ll(t11, i), ul(t11);
      break;
    case "safari":
      if (!IT || !e.shimSafari) return n("Safari shim is not included in this adapter release."), r;
      n("adapter.js shimming safari."), r.browserShim = IT, hl(t11, i), pl(t11), ow(t11), aw(t11), nw(t11), tw(t11), ew(t11), sw(t11), iw(t11), cw(t11), dl(t11), lE(t11), ll(t11, i), ul(t11), hE(t11, i);
      break;
    default:
      n("Unsupported browser!");
  }
})({ window: typeof window > "u" ? void 0 : window });
var a2 = bi("Array").keys;
var c2 = Er;
var d2 = Je;
var l2 = hn;
var u2 = a2;
var $h = Array.prototype;
var h2 = { DOMTokenList: true, NodeList: true };
var p2 = function(t11) {
  var e = t11.keys;
  return t11 === $h || l2($h, t11) && e === $h.keys || d2(h2, c2(t11)) ? u2 : e;
};
var xn = ae(p2);
var AT = ha;
var _2 = TypeError;
var E2 = Ou;
var m2 = Ai;
var f2 = _o;
var Bu = function(t11, e, n) {
  var i = E2(e);
  i in t11 ? m2.f(t11, i, f2(0, n)) : t11[i] = n;
};
var bT = Om;
var g2 = Lr;
var T2 = Bu;
var S2 = Array;
var R2 = Math.max;
var zm = function(t11, e, n) {
  for (var i = g2(t11), r = bT(e, i), o = bT(n === void 0 ? i : n, i), s = S2(R2(o - r, 0)), a = 0; r < o; r++, a++) T2(s, a, t11[r]);
  return s.length = a, s;
};
var wT = zm;
var C2 = Math.floor;
var pE = function(t11, e) {
  var n = t11.length, i = C2(n / 2);
  return n < 8 ? I2(t11, e) : v2(t11, pE(wT(t11, 0, i), e), pE(wT(t11, i), e), e);
};
var I2 = function(t11, e) {
  for (var n, i, r = t11.length, o = 1; o < r; ) {
    for (i = o, n = t11[o]; i && e(t11[i - 1], n) > 0; ) t11[i] = t11[--i];
    i !== o++ && (t11[i] = n);
  }
  return t11;
};
var v2 = function(t11, e, n, i) {
  for (var r = e.length, o = n.length, s = 0, a = 0; s < r || a < o; ) t11[s + a] = s < r && a < o ? i(e[s], n[a]) <= 0 ? e[s++] : n[a++] : s < r ? e[s++] : n[a++];
  return t11;
};
var hw = pE;
var OT = $o.match(/firefox\/(\d+)/i);
var y2 = !!OT && +OT[1];
var A2 = /MSIE|Trident/.test($o);
var NT = $o.match(/AppleWebKit\/(\d+)\./);
var b2 = !!NT && +NT[1];
var w2 = xt;
var pw = me;
var O2 = yi;
var N2 = _r;
var DT = Lr;
var D2 = function(t11, e) {
  if (!delete t11[e]) throw _2("Cannot delete property " + AT(e) + " of " + AT(t11));
};
var PT = oi;
var Jm = Se;
var P2 = hw;
var k2 = Nu;
var kT = y2;
var L2 = A2;
var LT = zo;
var MT = b2;
var Zr = [];
var UT = pw(Zr.sort);
var M2 = pw(Zr.push);
var U2 = Jm(function() {
  Zr.sort(void 0);
});
var x2 = Jm(function() {
  Zr.sort(null);
});
var V2 = k2("sort");
var xT = !Jm(function() {
  if (LT) return LT < 70;
  if (!(kT && kT > 3)) {
    if (L2) return true;
    if (MT) return MT < 603;
    var t11, e, n, i, r = "";
    for (t11 = 65; t11 < 76; t11++) {
      switch (e = String.fromCharCode(t11), t11) {
        case 66:
        case 69:
        case 70:
        case 72:
          n = 3;
          break;
        case 68:
        case 71:
          n = 4;
          break;
        default:
          n = 2;
      }
      for (i = 0; i < 47; i++) Zr.push({ k: e + i, v: n });
    }
    for (Zr.sort(function(o, s) {
      return s.v - o.v;
    }), i = 0; i < Zr.length; i++) e = Zr[i].k.charAt(0), r.charAt(r.length - 1) !== e && (r += e);
    return r !== "DGBEFHACIJK";
  }
});
w2({ target: "Array", proto: true, forced: U2 || !x2 || !V2 || !xT }, { sort: function(t11) {
  t11 !== void 0 && O2(t11);
  var e = N2(this);
  if (xT) return t11 === void 0 ? UT(e) : UT(e, t11);
  var n, i, r = [], o = DT(e);
  for (i = 0; i < o; i++) i in e && M2(r, e[i]);
  for (P2(r, /* @__PURE__ */ function(s) {
    return function(a, c) {
      return c === void 0 ? -1 : a === void 0 ? 1 : s !== void 0 ? +s(a, c) || 0 : PT(a) > PT(c) ? 1 : -1;
    };
  }(t11)), n = DT(r), i = 0; i < n; ) e[i] = r[i++];
  for (; i < o; ) D2(e, i++);
  return e;
} });
var tp;
var ep;
var F2 = bi("Array").sort;
var B2 = hn;
var j2 = F2;
var np = Array.prototype;
var G2 = function(t11) {
  var e = t11.sort;
  return t11 === np || B2(np, t11) && e === np.sort ? j2 : e;
};
var ed = ae(G2);
var _E = { exports: {} };
tp = _E, ep = _E.exports, function(t11, e) {
  var n = "function", i = "undefined", r = "object", o = "string", s = "major", a = "model", c = "name", d = "type", l = "vendor", u = "version", h = "architecture", p = "console", g = "mobile", E = "tablet", f = "smarttv", S = "wearable", C = "embedded", A = "Amazon", b = "Apple", w = "ASUS", D = "BlackBerry", k = "Browser", B = "Chrome", V = "Firefox", z = "Google", lt = "Huawei", vt = "LG", Dt = "Microsoft", ce = "Motorola", Wt = "Opera", si = "Samsung", L = "Sharp", F = "Sony", Y = "Xiaomi", M = "Zebra", m = "Facebook", I = "Chromium OS", y = "Mac OS", x = function(ee) {
    for (var _e = {}, Bt = 0; Bt < ee.length; Bt++) _e[ee[Bt].toUpperCase()] = ee[Bt];
    return _e;
  }, rt = function(ee, _e) {
    return typeof ee === o && bt(_e).indexOf(bt(ee)) !== -1;
  }, bt = function(ee) {
    return ee.toLowerCase();
  }, Re = function(ee, _e) {
    if (typeof ee === o) return ee = ee.replace(/^\s\s*/, ""), typeof _e === i ? ee : ee.substring(0, 350);
  }, fn = function(ee, _e) {
    for (var Bt, vn, Ki, ne, gt, gn, Ur = 0; Ur < _e.length && !gt; ) {
      var Oi = _e[Ur], Jf = _e[Ur + 1];
      for (Bt = vn = 0; Bt < Oi.length && !gt && Oi[Bt]; ) if (gt = Oi[Bt++].exec(ee)) for (Ki = 0; Ki < Jf.length; Ki++) gn = gt[++vn], typeof (ne = Jf[Ki]) === r && ne.length > 0 ? ne.length === 2 ? typeof ne[1] == n ? this[ne[0]] = ne[1].call(this, gn) : this[ne[0]] = ne[1] : ne.length === 3 ? typeof ne[1] !== n || ne[1].exec && ne[1].test ? this[ne[0]] = gn ? gn.replace(ne[1], ne[2]) : e : this[ne[0]] = gn ? ne[1].call(this, gn, ne[2]) : e : ne.length === 4 && (this[ne[0]] = gn ? ne[3].call(this, gn.replace(ne[1], ne[2])) : e) : this[ne] = gn || e;
      Ur += 2;
    }
  }, gr = function(ee, _e) {
    for (var Bt in _e) if (typeof _e[Bt] === r && _e[Bt].length > 0) {
      for (var vn = 0; vn < _e[Bt].length; vn++) if (rt(_e[Bt][vn], ee)) return Bt === "?" ? e : Bt;
    } else if (rt(_e[Bt], ee)) return Bt === "?" ? e : Bt;
    return ee;
  }, sd = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, ad = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [u, [c, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [u, [c, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [c, u], [/opios[\/ ]+([\w\.]+)/i], [u, [c, Wt + " Mini"]], [/\bopr\/([\w\.]+)/i], [u, [c, Wt]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [c, u], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [u, [c, "UC" + k]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [u, [c, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [u, [c, "WeChat"]], [/konqueror\/([\w\.]+)/i], [u, [c, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [u, [c, "IE"]], [/yabrowser\/([\w\.]+)/i], [u, [c, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[c, /(.+)/, "$1 Secure " + k], u], [/\bfocus\/([\w\.]+)/i], [u, [c, V + " Focus"]], [/\bopt\/([\w\.]+)/i], [u, [c, Wt + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [u, [c, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [u, [c, "Dolphin"]], [/coast\/([\w\.]+)/i], [u, [c, Wt + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [u, [c, "MIUI " + k]], [/fxios\/([-\w\.]+)/i], [u, [c, V]], [/\bqihu|(qi?ho?o?|360)browser/i], [[c, "360 " + k]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[c, /(.+)/, "$1 " + k], u], [/(comodo_dragon)\/([\w\.]+)/i], [[c, /_/g, " "], u], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [c, u], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [c], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[c, m], u], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [c, u], [/\bgsa\/([\w\.]+) .*safari\//i], [u, [c, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [u, [c, B + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[c, B + " WebView"], u], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [u, [c, "Android " + k]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [c, u], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [u, [c, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [u, c], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [c, [u, gr, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [c, u], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[c, "Netscape"], u], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [u, [c, V + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [c, u], [/(cobalt)\/([\w\.]+)/i], [c, [u, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[h, "amd64"]], [/(ia32(?=;))/i], [[h, bt]], [/((?:i[346]|x)86)[;\)]/i], [[h, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[h, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[h, "armhf"]], [/windows (ce|mobile); ppc;/i], [[h, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[h, /ower/, "", bt]], [/(sun4\w)[;\)]/i], [[h, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[h, bt]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [a, [l, si], [d, E]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [a, [l, si], [d, g]], [/\((ip(?:hone|od)[\w ]*);/i], [a, [l, b], [d, g]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [a, [l, b], [d, E]], [/(macintosh);/i], [a, [l, b]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [a, [l, L], [d, g]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [a, [l, lt], [d, E]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [a, [l, lt], [d, g]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[a, /_/g, " "], [l, Y], [d, g]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[a, /_/g, " "], [l, Y], [d, E]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [a, [l, "OPPO"], [d, g]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [a, [l, "Vivo"], [d, g]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [a, [l, "Realme"], [d, g]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [a, [l, ce], [d, g]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [a, [l, ce], [d, E]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [a, [l, vt], [d, E]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [a, [l, vt], [d, g]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [a, [l, "Lenovo"], [d, E]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[a, /_/g, " "], [l, "Nokia"], [d, g]], [/(pixel c)\b/i], [a, [l, z], [d, E]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [a, [l, z], [d, g]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [a, [l, F], [d, g]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[a, "Xperia Tablet"], [l, F], [d, E]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [a, [l, "OnePlus"], [d, g]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [a, [l, A], [d, E]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[a, /(.+)/g, "Fire Phone $1"], [l, A], [d, g]], [/(playbook);[-\w\),; ]+(rim)/i], [a, l, [d, E]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [a, [l, D], [d, g]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [a, [l, w], [d, E]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [a, [l, w], [d, g]], [/(nexus 9)/i], [a, [l, "HTC"], [d, E]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [l, [a, /_/g, " "], [d, g]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [a, [l, "Acer"], [d, E]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [a, [l, "Meizu"], [d, g]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [l, a, [d, g]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [l, a, [d, E]], [/(surface duo)/i], [a, [l, Dt], [d, E]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [a, [l, "Fairphone"], [d, g]], [/(u304aa)/i], [a, [l, "AT&T"], [d, g]], [/\bsie-(\w*)/i], [a, [l, "Siemens"], [d, g]], [/\b(rct\w+) b/i], [a, [l, "RCA"], [d, E]], [/\b(venue[\d ]{2,7}) b/i], [a, [l, "Dell"], [d, E]], [/\b(q(?:mv|ta)\w+) b/i], [a, [l, "Verizon"], [d, E]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [a, [l, "Barnes & Noble"], [d, E]], [/\b(tm\d{3}\w+) b/i], [a, [l, "NuVision"], [d, E]], [/\b(k88) b/i], [a, [l, "ZTE"], [d, E]], [/\b(nx\d{3}j) b/i], [a, [l, "ZTE"], [d, g]], [/\b(gen\d{3}) b.+49h/i], [a, [l, "Swiss"], [d, g]], [/\b(zur\d{3}) b/i], [a, [l, "Swiss"], [d, E]], [/\b((zeki)?tb.*\b) b/i], [a, [l, "Zeki"], [d, E]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[l, "Dragon Touch"], a, [d, E]], [/\b(ns-?\w{0,9}) b/i], [a, [l, "Insignia"], [d, E]], [/\b((nxa|next)-?\w{0,9}) b/i], [a, [l, "NextBook"], [d, E]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[l, "Voice"], a, [d, g]], [/\b(lvtel\-)?(v1[12]) b/i], [[l, "LvTel"], a, [d, g]], [/\b(ph-1) /i], [a, [l, "Essential"], [d, g]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [a, [l, "Envizen"], [d, E]], [/\b(trio[-\w\. ]+) b/i], [a, [l, "MachSpeed"], [d, E]], [/\btu_(1491) b/i], [a, [l, "Rotor"], [d, E]], [/(shield[\w ]+) b/i], [a, [l, "Nvidia"], [d, E]], [/(sprint) (\w+)/i], [l, a, [d, g]], [/(kin\.[onetw]{3})/i], [[a, /\./g, " "], [l, Dt], [d, g]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [a, [l, M], [d, E]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [a, [l, M], [d, g]], [/smart-tv.+(samsung)/i], [l, [d, f]], [/hbbtv.+maple;(\d+)/i], [[a, /^/, "SmartTV"], [l, si], [d, f]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[l, vt], [d, f]], [/(apple) ?tv/i], [l, [a, b + " TV"], [d, f]], [/crkey/i], [[a, B + "cast"], [l, z], [d, f]], [/droid.+aft(\w)( bui|\))/i], [a, [l, A], [d, f]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [a, [l, L], [d, f]], [/(bravia[\w ]+)( bui|\))/i], [a, [l, F], [d, f]], [/(mitv-\w{5}) bui/i], [a, [l, Y], [d, f]], [/Hbbtv.*(technisat) (.*);/i], [l, a, [d, f]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[l, Re], [a, Re], [d, f]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[d, f]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [l, a, [d, p]], [/droid.+; (shield) bui/i], [a, [l, "Nvidia"], [d, p]], [/(playstation [345portablevi]+)/i], [a, [l, F], [d, p]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [a, [l, Dt], [d, p]], [/((pebble))app/i], [l, a, [d, S]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [a, [l, b], [d, S]], [/droid.+; (glass) \d/i], [a, [l, z], [d, S]], [/droid.+; (wt63?0{2,3})\)/i], [a, [l, M], [d, S]], [/(quest( 2| pro)?)/i], [a, [l, m], [d, S]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [l, [d, C]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [a, [d, g]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [a, [d, E]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[d, E]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[d, g]], [/(android[-\w\. ]{0,9});.+buil/i], [a, [l, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [u, [c, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [u, [c, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [c, u], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [u, c]], os: [[/microsoft (windows) (vista|xp)/i], [c, u], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [c, [u, gr, sd]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[c, "Windows"], [u, gr, sd]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[u, /_/g, "."], [c, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[c, y], [u, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [u, c], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [c, u], [/\(bb(10);/i], [u, [c, D]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [u, [c, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [u, [c, V + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [u, [c, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [u, [c, "watchOS"]], [/crkey\/([\d\.]+)/i], [u, [c, B + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[c, I], u], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [c, u], [/(sunos) ?([\w\.\d]*)/i], [[c, "Solaris"], u], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [c, u]] }, qn = function(ee, _e) {
    if (typeof ee === r && (_e = ee, ee = e), !(this instanceof qn)) return new qn(ee, _e).getResult();
    var Bt = typeof t11 !== i && t11.navigator ? t11.navigator : e, vn = ee || (Bt && Bt.userAgent ? Bt.userAgent : ""), Ki = Bt && Bt.userAgentData ? Bt.userAgentData : e, ne = _e ? function(gt, gn) {
      var Ur = {};
      for (var Oi in gt) gn[Oi] && gn[Oi].length % 2 == 0 ? Ur[Oi] = gn[Oi].concat(gt[Oi]) : Ur[Oi] = gt[Oi];
      return Ur;
    }(ad, _e) : ad;
    return this.getBrowser = function() {
      var gt = {};
      return gt[c] = e, gt[u] = e, fn.call(gt, vn, ne.browser), gt[s] = function(gn) {
        return typeof gn === o ? gn.replace(/[^\d\.]/g, "").split(".")[0] : e;
      }(gt[u]), Bt && Bt.brave && typeof Bt.brave.isBrave == n && (gt[c] = "Brave"), gt;
    }, this.getCPU = function() {
      var gt = {};
      return gt[h] = e, fn.call(gt, vn, ne.cpu), gt;
    }, this.getDevice = function() {
      var gt = {};
      return gt[l] = e, gt[a] = e, gt[d] = e, fn.call(gt, vn, ne.device), !gt[d] && Ki && Ki.mobile && (gt[d] = g), gt[a] == "Macintosh" && Bt && typeof Bt.standalone !== i && Bt.maxTouchPoints && Bt.maxTouchPoints > 2 && (gt[a] = "iPad", gt[d] = E), gt;
    }, this.getEngine = function() {
      var gt = {};
      return gt[c] = e, gt[u] = e, fn.call(gt, vn, ne.engine), gt;
    }, this.getOS = function() {
      var gt = {};
      return gt[c] = e, gt[u] = e, fn.call(gt, vn, ne.os), !gt[c] && Ki && Ki.platform != "Unknown" && (gt[c] = Ki.platform.replace(/chrome os/i, I).replace(/macos/i, y)), gt;
    }, this.getResult = function() {
      return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
    }, this.getUA = function() {
      return vn;
    }, this.setUA = function(gt) {
      return vn = typeof gt === o && gt.length > 350 ? Re(gt, 350) : gt, this;
    }, this.setUA(vn), this;
  };
  qn.VERSION = "0.7.34", qn.BROWSER = x([c, u, s]), qn.CPU = x([h]), qn.DEVICE = x([a, l, d, p, g, f, E, S, C]), qn.ENGINE = qn.OS = x([c, u]), tp.exports && (ep = tp.exports = qn), ep.UAParser = qn;
  var Mr = typeof t11 !== i && (t11.jQuery || t11.Zepto);
  if (Mr && !Mr.ua) {
    var rs = new qn();
    Mr.ua = rs.getResult(), Mr.ua.get = function() {
      return rs.getUA();
    }, Mr.ua.set = function(ee) {
      rs.setUA(ee);
      var _e = rs.getResult();
      for (var Bt in _e) Mr.ua[Bt] = _e[Bt];
    };
  }
}(typeof window == "object" ? window : Vs);
var W2 = ae(_E.exports);
var H2 = Er;
var K2 = Je;
var Y2 = da;
var q2 = es;
var z2 = pe("iterator");
var J2 = Object;
var X2 = function(t11) {
  if (Y2(t11)) return false;
  var e = J2(t11);
  return e[z2] !== void 0 || "@@iterator" in e || K2(q2, H2(e));
};
var Q2 = ae(X2);
var ip = We;
xt({ global: true, forced: ip.globalThis !== ip }, { globalThis: ip });
var VT = ae(We);
function _w(t11, e) {
  return function() {
    return t11.apply(e, arguments);
  };
}
var { toString: Z2 } = Object.prototype;
var { getPrototypeOf: Xm } = Object;
var Ml = (rp = /* @__PURE__ */ Object.create(null), (t11) => {
  let e = Z2.call(t11);
  return rp[e] || (rp[e] = e.slice(8, -1).toLowerCase());
});
var rp;
var fr = (t11) => (t11 = t11.toLowerCase(), (e) => Ml(e) === t11);
var ju = (t11) => (e) => typeof e === t11;
var { isArray: Is } = Array;
var Wa = ju("undefined");
var FT = fr("ArrayBuffer");
var $2 = ju("string");
var ai = ju("function");
var BT = ju("number");
var Td = (t11) => t11 !== null && typeof t11 == "object";
var Sd = (t11) => {
  if (Ml(t11) !== "object") return false;
  let e = Xm(t11);
  return !(e !== null && e !== Object.prototype && Object.getPrototypeOf(e) !== null || Symbol.toStringTag in t11 || Q2(t11));
};
var tx = fr("Date");
var ex = fr("File");
var nx = fr("Blob");
var ix = fr("FileList");
var rx = fr("URLSearchParams");
function Ha(t11, e) {
  let n, i, { allOwnKeys: r = false } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (t11 != null) if (typeof t11 != "object" && (t11 = [t11]), Is(t11)) for (n = 0, i = t11.length; n < i; n++) e.call(null, t11[n], n, t11);
  else {
    let o = r ? Object.getOwnPropertyNames(t11) : Object.keys(t11), s = o.length, a;
    for (n = 0; n < s; n++) a = o[n], e.call(null, t11[a], a, t11);
  }
}
function jT(t11, e) {
  e = e.toLowerCase();
  let n = Object.keys(t11), i, r = n.length;
  for (; r-- > 0; ) if (i = n[r], e === i.toLowerCase()) return i;
  return null;
}
var Ew = VT !== void 0 ? VT : typeof self < "u" ? self : typeof window < "u" ? window : global;
var GT = (t11) => !Wa(t11) && t11 !== Ew;
var ox = (op = typeof Uint8Array < "u" && Xm(Uint8Array), (t11) => op && t11 instanceof op);
var op;
var sx = fr("HTMLFormElement");
var WT = ((t11) => {
  let { hasOwnProperty: e } = t11;
  return (n, i) => e.call(n, i);
})(Object.prototype);
var ax = fr("RegExp");
var HT = (t11, e) => {
  let n = Object.getOwnPropertyDescriptors(t11), i = {};
  Ha(n, (r, o) => {
    let s;
    (s = e(r, o, t11)) !== false && (i[o] = s || r);
  }), Object.defineProperties(t11, i);
};
var sp = "abcdefghijklmnopqrstuvwxyz";
var KT = "0123456789";
var YT = { DIGIT: KT, ALPHA: sp, ALPHA_DIGIT: sp + sp.toUpperCase() + KT };
var cx = fr("AsyncFunction");
var K = { isArray: Is, isArrayBuffer: FT, isBuffer: function(t11) {
  return t11 !== null && !Wa(t11) && t11.constructor !== null && !Wa(t11.constructor) && ai(t11.constructor.isBuffer) && t11.constructor.isBuffer(t11);
}, isFormData: (t11) => {
  let e;
  return t11 && (typeof FormData == "function" && t11 instanceof FormData || ai(t11.append) && ((e = Ml(t11)) === "formdata" || e === "object" && ai(t11.toString) && t11.toString() === "[object FormData]"));
}, isArrayBufferView: function(t11) {
  let e;
  return e = typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(t11) : t11 && t11.buffer && FT(t11.buffer), e;
}, isString: $2, isNumber: BT, isBoolean: (t11) => t11 === true || t11 === false, isObject: Td, isPlainObject: Sd, isUndefined: Wa, isDate: tx, isFile: ex, isBlob: nx, isRegExp: ax, isFunction: ai, isStream: (t11) => Td(t11) && ai(t11.pipe), isURLSearchParams: rx, isTypedArray: ox, isFileList: ix, forEach: Ha, merge: function t() {
  let { caseless: e } = GT(this) && this || {}, n = {}, i = (r, o) => {
    let s = e && jT(n, o) || o;
    Sd(n[s]) && Sd(r) ? n[s] = t(n[s], r) : Sd(r) ? n[s] = t({}, r) : Is(r) ? n[s] = r.slice() : n[s] = r;
  };
  for (let r = 0, o = arguments.length; r < o; r++) arguments[r] && Ha(arguments[r], i);
  return n;
}, extend: function(t11, e, n) {
  let { allOwnKeys: i } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  return Ha(e, (r, o) => {
    n && ai(r) ? t11[o] = _w(r, n) : t11[o] = r;
  }, { allOwnKeys: i }), t11;
}, trim: (t11) => rn(t11) ? rn(t11).call(t11) : t11.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: (t11) => (t11.charCodeAt(0) === 65279 && (t11 = t11.slice(1)), t11), inherits: (t11, e, n, i) => {
  t11.prototype = Object.create(e.prototype, i), t11.prototype.constructor = t11, Object.defineProperty(t11, "super", { value: e.prototype }), n && Object.assign(t11.prototype, n);
}, toFlatObject: (t11, e, n, i) => {
  let r, o, s, a = {};
  if (e = e || {}, t11 == null) return e;
  do {
    for (r = Object.getOwnPropertyNames(t11), o = r.length; o-- > 0; ) s = r[o], i && !i(s, t11, e) || a[s] || (e[s] = t11[s], a[s] = true);
    t11 = n !== false && Xm(t11);
  } while (t11 && (!n || n(t11, e)) && t11 !== Object.prototype);
  return e;
}, kindOf: Ml, kindOfTest: fr, endsWith: (t11, e, n) => {
  t11 = String(t11), (n === void 0 || n > t11.length) && (n = t11.length), n -= e.length;
  let i = t11.indexOf(e, n);
  return i !== -1 && i === n;
}, toArray: (t11) => {
  if (!t11) return null;
  if (Is(t11)) return t11;
  let e = t11.length;
  if (!BT(e)) return null;
  let n = new Array(e);
  for (; e-- > 0; ) n[e] = t11[e];
  return n;
}, forEachEntry: (t11, e) => {
  let n = (t11 && t11[Symbol.iterator]).call(t11), i;
  for (; (i = n.next()) && !i.done; ) {
    let r = i.value;
    e.call(t11, r[0], r[1]);
  }
}, matchAll: (t11, e) => {
  let n, i = [];
  for (; (n = t11.exec(e)) !== null; ) i.push(n);
  return i;
}, isHTMLForm: sx, hasOwnProperty: WT, hasOwnProp: WT, reduceDescriptors: HT, freezeMethods: (t11) => {
  HT(t11, (e, n) => {
    if (ai(t11) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return false;
    let i = t11[n];
    ai(i) && (e.enumerable = false, "writable" in e ? e.writable = false : e.set || (e.set = () => {
      throw Error("Can not rewrite read-only method '" + n + "'");
    }));
  });
}, toObjectSet: (t11, e) => {
  let n = {}, i = (r) => {
    r.forEach((o) => {
      n[o] = true;
    });
  };
  return Is(t11) ? i(t11) : i(String(t11).split(e)), n;
}, toCamelCase: (t11) => t11.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(e, n, i) {
  return n.toUpperCase() + i;
}), noop: () => {
}, toFiniteNumber: (t11, e) => (t11 = +t11, Number.isFinite(t11) ? t11 : e), findKey: jT, global: Ew, isContextDefined: GT, ALPHABET: YT, generateString: function() {
  let t11 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : YT.ALPHA_DIGIT, n = "", { length: i } = e;
  for (; t11--; ) n += e[Math.random() * i | 0];
  return n;
}, isSpecCompliantForm: function(t11) {
  return !!(t11 && ai(t11.append) && t11[Symbol.toStringTag] === "FormData" && t11[Symbol.iterator]);
}, toJSONObject: (t11) => {
  let e = new Array(10), n = (i, r) => {
    if (Td(i)) {
      if (e.indexOf(i) >= 0) return;
      if (!("toJSON" in i)) {
        e[r] = i;
        let o = Is(i) ? [] : {};
        return Ha(i, (s, a) => {
          let c = n(s, r + 1);
          !Wa(c) && (o[a] = c);
        }), e[r] = void 0, o;
      }
    }
    return i;
  };
  return n(t11, 0);
}, isAsyncFn: cx, isThenable: (t11) => t11 && (Td(t11) || ai(t11)) && ai(t11.then) && ai(t11.catch) };
function qt(t11, e, n, i, r) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t11, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), i && (this.request = i), r && (this.response = r);
}
K.inherits(qt, Error, { toJSON: function() {
  return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: K.toJSONObject(this.config), code: this.code, status: this.response && this.response.status ? this.response.status : null };
} });
var qT = qt.prototype;
var zT = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((t11) => {
  zT[t11] = { value: t11 };
}), Object.defineProperties(qt, zT), Object.defineProperty(qT, "isAxiosError", { value: true }), qt.from = (t11, e, n, i, r, o) => {
  let s = Object.create(qT);
  return K.toFlatObject(t11, s, function(a) {
    return a !== Error.prototype;
  }, (a) => a !== "isAxiosError"), qt.call(s, t11.message, e, n, i, r), s.cause = t11, s.name = t11.name, o && Object.assign(s, o), s;
};
function ap(t11) {
  return K.isPlainObject(t11) || K.isArray(t11);
}
function mw(t11) {
  return K.endsWith(t11, "[]") ? t11.slice(0, -2) : t11;
}
function JT(t11, e, n) {
  return t11 ? t11.concat(e).map(function(i, r) {
    return i = mw(i), !n && r ? "[" + i + "]" : i;
  }).join(n ? "." : "") : e;
}
var dx = K.toFlatObject(K, {}, null, function(t11) {
  return /^is[A-Z]/.test(t11);
});
function Ul(t11, e, n) {
  if (!K.isObject(t11)) throw new TypeError("target must be an object");
  e = e || new FormData();
  let i = (n = K.toFlatObject(n, { metaTokens: true, dots: false, indexes: false }, false, function(h, p) {
    return !K.isUndefined(p[h]);
  })).metaTokens, r = n.visitor || d, o = n.dots, s = n.indexes, a = (n.Blob || typeof Blob < "u" && Blob) && K.isSpecCompliantForm(e);
  if (!K.isFunction(r)) throw new TypeError("visitor must be a function");
  function c(h) {
    if (h === null) return "";
    if (K.isDate(h)) return h.toISOString();
    if (!a && K.isBlob(h)) throw new qt("Blob is not supported. Use a Buffer instead.");
    return K.isArrayBuffer(h) || K.isTypedArray(h) ? a && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  function d(h, p, g) {
    let E = h;
    if (h && !g && typeof h == "object") {
      if (K.endsWith(p, "{}")) p = i ? p : p.slice(0, -2), h = JSON.stringify(h);
      else if (K.isArray(h) && function(f) {
        return K.isArray(f) && !f.some(ap);
      }(h) || (K.isFileList(h) || K.endsWith(p, "[]")) && (E = K.toArray(h))) return p = mw(p), E.forEach(function(f, S) {
        !K.isUndefined(f) && f !== null && e.append(s === true ? JT([p], S, o) : s === null ? p : p + "[]", c(f));
      }), false;
    }
    return !!ap(h) || (e.append(JT(g, p, o), c(h)), false);
  }
  let l = [], u = Object.assign(dx, { defaultVisitor: d, convertValue: c, isVisitable: ap });
  if (!K.isObject(t11)) throw new TypeError("data must be an object");
  return function h(p, g) {
    if (!K.isUndefined(p)) {
      if (l.indexOf(p) !== -1) throw Error("Circular reference detected in " + g.join("."));
      l.push(p), K.forEach(p, function(E, f) {
        (!(K.isUndefined(E) || E === null) && r.call(e, E, K.isString(f) ? rn(f).call(f) : f, g, u)) === true && h(E, g ? g.concat(f) : [f]);
      }), l.pop();
    }
  }(t11), e;
}
function XT(t11) {
  let e = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
  return encodeURIComponent(t11).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function Qm(t11, e) {
  this._pairs = [], t11 && Ul(t11, this, e);
}
var QT = Qm.prototype;
function lx(t11) {
  return encodeURIComponent(t11).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function fw(t11, e, n) {
  if (!e) return t11;
  let i = n && n.encode || lx, r = n && n.serialize, o;
  if (o = r ? r(e, n) : K.isURLSearchParams(e) ? e.toString() : new Qm(e, n).toString(i), o) {
    let s = t11.indexOf("#");
    s !== -1 && (t11 = t11.slice(0, s)), t11 += (t11.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return t11;
}
QT.append = function(t11, e) {
  this._pairs.push([t11, e]);
}, QT.toString = function(t11) {
  let e = t11 ? function(n) {
    return t11.call(this, n, XT);
  } : XT;
  return this._pairs.map(function(n) {
    return e(n[0]) + "=" + e(n[1]);
  }, "").join("&");
};
var ZT = class {
  constructor() {
    this.handlers = [];
  }
  use(t11, e, n) {
    return this.handlers.push({ fulfilled: t11, rejected: e, synchronous: !!n && n.synchronous, runWhen: n ? n.runWhen : null }), this.handlers.length - 1;
  }
  eject(t11) {
    this.handlers[t11] && (this.handlers[t11] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(t11) {
    K.forEach(this.handlers, function(e) {
      e !== null && t11(e);
    });
  }
};
var gw = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false };
var Tw = { exports: {} };
var ux = xt;
var hx = ri;
var $T = Ai.f;
ux({ target: "Object", stat: true, forced: Object.defineProperty !== $T, sham: !hx }, { defineProperty: $T });
var Sw = Gi.Object;
var px = Tw.exports = function(t11, e, n) {
  return Sw.defineProperty(t11, e, n);
};
Sw.defineProperty.sham && (px.sham = true);
var Rw = ae(Tw.exports);
var _x = pr;
var nd = Array.isArray || function(t11) {
  return _x(t11) == "Array";
};
var Ex = TypeError;
var tS = nd;
var mx = xu;
var fx = Hn;
var gx = pe("species");
var eS = Array;
var Tx = function(t11) {
  var e;
  return tS(t11) && (e = t11.constructor, (mx(e) && (e === eS || tS(e.prototype)) || fx(e) && (e = e[gx]) === null) && (e = void 0)), e === void 0 ? eS : e;
};
var Cw = function(t11, e) {
  return new (Tx(t11))(e === 0 ? 0 : e);
};
var Sx = Se;
var Rx = zo;
var Cx = pe("species");
var Iw = function(t11) {
  return Rx >= 51 || !Sx(function() {
    var e = [];
    return (e.constructor = {})[Cx] = function() {
      return { foo: 1 };
    }, e[t11](Boolean).foo !== 1;
  });
};
var Ix = xt;
var vx = Se;
var yx = nd;
var Ax = Hn;
var bx = _r;
var wx = Lr;
var nS = function(t11) {
  if (t11 > 9007199254740991) throw Ex("Maximum allowed index exceeded");
  return t11;
};
var iS = Bu;
var Ox = Cw;
var Nx = Iw;
var Dx = zo;
var vw = pe("isConcatSpreadable");
var Px = Dx >= 51 || !vx(function() {
  var t11 = [];
  return t11[vw] = false, t11.concat()[0] !== t11;
});
var kx = function(t11) {
  if (!Ax(t11)) return false;
  var e = t11[vw];
  return e !== void 0 ? !!e : yx(t11);
};
Ix({ target: "Array", proto: true, arity: 1, forced: !Px || !Nx("concat") }, { concat: function(t11) {
  var e, n, i, r, o, s = bx(this), a = Ox(s, 0), c = 0;
  for (e = -1, i = arguments.length; e < i; e++) if (kx(o = e === -1 ? s : arguments[e])) for (r = wx(o), nS(c + r), n = 0; n < r; n++, c++) n in o && iS(a, c, o[n]);
  else nS(c + 1), iS(a, c++, o);
  return a.length = c, a;
} });
var yw = {};
var Lx = pr;
var Mx = Eo;
var rS = Pu.f;
var Ux = zm;
var oS = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
yw.f = function(t11) {
  return oS && Lx(t11) == "Window" ? function(e) {
    try {
      return rS(e);
    } catch {
      return Ux(oS);
    }
  }(t11) : rS(Mx(t11));
};
var Ea = {};
var xx = pe;
Ea.f = xx;
var sS = Gi;
var Vx = Je;
var Fx = Ea;
var Bx = Ai.f;
var Fe = function(t11) {
  var e = sS.Symbol || (sS.Symbol = {});
  Vx(e, t11) || Bx(e, t11, { value: Fx.f(t11) });
};
var jx = Ke;
var Gx = Dn;
var Wx = pe;
var Hx = go;
var Aw = function() {
  var t11 = Gx("Symbol"), e = t11 && t11.prototype, n = e && e.valueOf, i = Wx("toPrimitive");
  e && !e[i] && Hx(e, i, function(r) {
    return jx(n, this);
  }, { arity: 1 });
};
var Kx = mo;
var Yx = bu;
var qx = _r;
var zx = Lr;
var Jx = Cw;
var aS = me([].push);
var Vr = function(t11) {
  var e = t11 == 1, n = t11 == 2, i = t11 == 3, r = t11 == 4, o = t11 == 6, s = t11 == 7, a = t11 == 5 || o;
  return function(c, d, l, u) {
    for (var h, p, g = qx(c), E = Yx(g), f = Kx(d, l), S = zx(E), C = 0, A = u || Jx, b = e ? A(c, S) : n || s ? A(c, 0) : void 0; S > C; C++) if ((a || C in E) && (p = f(h = E[C], C, g), t11)) if (e) b[C] = p;
    else if (p) switch (t11) {
      case 3:
        return true;
      case 5:
        return h;
      case 6:
        return C;
      case 2:
        aS(b, h);
    }
    else switch (t11) {
      case 4:
        return false;
      case 7:
        aS(b, h);
    }
    return o ? -1 : i || r ? r : b;
  };
};
var bw = { forEach: Vr(0), map: Vr(1), filter: Vr(2), some: Vr(3), every: Vr(4), find: Vr(5), findIndex: Vr(6), filterReject: Vr(7) };
var Rd = xt;
var Zm = We;
var $m = Ke;
var Xx = me;
var js = ri;
var ds = ua;
var Qx = Se;
var dn = Je;
var Zx = hn;
var EE = Cn;
var Gu = Eo;
var tf = Ou;
var $x = oi;
var mE = _o;
var Sc = Qc;
var ww = Lu;
var tV = Pu;
var Ow = yw;
var eV = Xc;
var Nw = Yc;
var Dw = Ai;
var nV = Mm;
var Pw = Au;
var cS = go;
var iV = Uu;
var ef = pa;
var kw = ku;
var dS = Am;
var rV = pe;
var oV = Ea;
var sV = Fe;
var aV = Aw;
var cV = To;
var Lw = ns;
var Wu = bw.forEach;
var Vn = Du("hidden");
var xl = "Symbol";
var Rc = "prototype";
var dV = Lw.set;
var lS = Lw.getterFor(xl);
var Fi = Object[Rc];
var Ns = Zm.Symbol;
var _l = Ns && Ns[Rc];
var lV = Zm.TypeError;
var cp = Zm.QObject;
var Mw = Nw.f;
var ko = Dw.f;
var Uw = Ow.f;
var uV = Pw.f;
var xw = Xx([].push);
var kr = ef("symbols");
var id = ef("op-symbols");
var hV = ef("wks");
var dp = !cp || !cp[Rc] || !cp[Rc].findChild;
var fE = js && Qx(function() {
  return Sc(ko({}, "a", { get: function() {
    return ko(this, "a", { value: 7 }).a;
  } })).a != 7;
}) ? function(t11, e, n) {
  var i = Mw(Fi, e);
  i && delete Fi[e], ko(t11, e, n), i && t11 !== Fi && ko(Fi, e, i);
} : ko;
var lp = function(t11, e) {
  var n = kr[t11] = Sc(_l);
  return dV(n, { type: xl, tag: t11, description: e }), js || (n.description = e), n;
};
var Vl = function(t11, e, n) {
  t11 === Fi && Vl(id, e, n), EE(t11);
  var i = tf(e);
  return EE(n), dn(kr, i) ? (n.enumerable ? (dn(t11, Vn) && t11[Vn][i] && (t11[Vn][i] = false), n = Sc(n, { enumerable: mE(0, false) })) : (dn(t11, Vn) || ko(t11, Vn, mE(1, {})), t11[Vn][i] = true), fE(t11, i, n)) : ko(t11, i, n);
};
var up = function(t11, e) {
  EE(t11);
  var n = Gu(e), i = ww(n).concat(Fw(n));
  return Wu(i, function(r) {
    js && !$m(Vw, n, r) || Vl(t11, r, n[r]);
  }), t11;
};
var Vw = function(t11) {
  var e = tf(t11), n = $m(uV, this, e);
  return !(this === Fi && dn(kr, e) && !dn(id, e)) && (!(n || !dn(this, e) || !dn(kr, e) || dn(this, Vn) && this[Vn][e]) || n);
};
var uS = function(t11, e) {
  var n = Gu(t11), i = tf(e);
  if (n !== Fi || !dn(kr, i) || dn(id, i)) {
    var r = Mw(n, i);
    return !r || !dn(kr, i) || dn(n, Vn) && n[Vn][i] || (r.enumerable = true), r;
  }
};
var hS = function(t11) {
  var e = Uw(Gu(t11)), n = [];
  return Wu(e, function(i) {
    dn(kr, i) || dn(kw, i) || xw(n, i);
  }), n;
};
var Fw = function(t11) {
  var e = t11 === Fi, n = Uw(e ? id : Gu(t11)), i = [];
  return Wu(n, function(r) {
    !dn(kr, r) || e && !dn(Fi, r) || xw(i, kr[r]);
  }), i;
};
ds || (cS(_l = (Ns = function() {
  if (Zx(_l, this)) throw lV("Symbol is not a constructor");
  var t11 = arguments.length && arguments[0] !== void 0 ? $x(arguments[0]) : void 0, e = dS(t11), n = function(i) {
    this === Fi && $m(n, id, i), dn(this, Vn) && dn(this[Vn], e) && (this[Vn][e] = false), fE(this, e, mE(1, i));
  };
  return js && dp && fE(Fi, e, { configurable: true, set: n }), lp(e, t11);
})[Rc], "toString", function() {
  return lS(this).tag;
}), cS(Ns, "withoutSetter", function(t11) {
  return lp(dS(t11), t11);
}), Pw.f = Vw, Dw.f = Vl, nV.f = up, Nw.f = uS, tV.f = Ow.f = hS, eV.f = Fw, oV.f = function(t11) {
  return lp(rV(t11), t11);
}, js && iV(_l, "description", { configurable: true, get: function() {
  return lS(this).description;
} })), Rd({ global: true, constructor: true, wrap: true, forced: !ds, sham: !ds }, { Symbol: Ns }), Wu(ww(hV), function(t11) {
  sV(t11);
}), Rd({ target: xl, stat: true, forced: !ds }, { useSetter: function() {
  dp = true;
}, useSimple: function() {
  dp = false;
} }), Rd({ target: "Object", stat: true, forced: !ds, sham: !js }, { create: function(t11, e) {
  return e === void 0 ? Sc(t11) : up(Sc(t11), e);
}, defineProperty: Vl, defineProperties: up, getOwnPropertyDescriptor: uS }), Rd({ target: "Object", stat: true, forced: !ds }, { getOwnPropertyNames: hS }), aV(), cV(Ns, xl), kw[Vn] = true;
var Bw = ua && !!Symbol.for && !!Symbol.keyFor;
var pV = xt;
var _V = Dn;
var EV = Je;
var mV = oi;
var jw = pa;
var fV = Bw;
var hp = jw("string-to-symbol-registry");
var gV = jw("symbol-to-string-registry");
pV({ target: "Symbol", stat: true, forced: !fV }, { for: function(t11) {
  var e = mV(t11);
  if (EV(hp, e)) return hp[e];
  var n = _V("Symbol")(e);
  return hp[e] = n, gV[n] = e, n;
} });
var TV = xt;
var SV = Je;
var RV = qc;
var CV = ha;
var IV = Bw;
var pS = pa("symbol-to-string-registry");
TV({ target: "Symbol", stat: true, forced: !IV }, { keyFor: function(t11) {
  if (!RV(t11)) throw TypeError(CV(t11) + " is not a symbol");
  if (SV(pS, t11)) return pS[t11];
} });
var _S = nd;
var vV = He;
var ES = pr;
var yV = oi;
var mS = me([].push);
var AV = xt;
var Gw = Dn;
var Ww = vm;
var bV = Ke;
var rd = me;
var Hw = Se;
var fS = He;
var gS = qc;
var Kw = Gm;
var wV = function(t11) {
  if (vV(t11)) return t11;
  if (_S(t11)) {
    for (var e = t11.length, n = [], i = 0; i < e; i++) {
      var r = t11[i];
      typeof r == "string" ? mS(n, r) : typeof r != "number" && ES(r) != "Number" && ES(r) != "String" || mS(n, yV(r));
    }
    var o = n.length, s = true;
    return function(a, c) {
      if (s) return s = false, c;
      if (_S(this)) return c;
      for (var d = 0; d < o; d++) if (n[d] === a) return c;
    };
  }
};
var OV = ua;
var NV = String;
var ro = Gw("JSON", "stringify");
var Cd = rd(/./.exec);
var TS = rd("".charAt);
var DV = rd("".charCodeAt);
var PV = rd("".replace);
var kV = rd(1 .toString);
var LV = /[\uD800-\uDFFF]/g;
var SS = /^[\uD800-\uDBFF]$/;
var RS = /^[\uDC00-\uDFFF]$/;
var CS = !OV || Hw(function() {
  var t11 = Gw("Symbol")();
  return ro([t11]) != "[null]" || ro({ a: t11 }) != "{}" || ro(Object(t11)) != "{}";
});
var IS = Hw(function() {
  return ro("\uDF06\uD834") !== '"\\udf06\\ud834"' || ro("\uDEAD") !== '"\\udead"';
});
var MV = function(t11, e) {
  var n = Kw(arguments), i = wV(e);
  if (fS(i) || t11 !== void 0 && !gS(t11)) return n[1] = function(r, o) {
    if (fS(i) && (o = bV(i, this, NV(r), o)), !gS(o)) return o;
  }, Ww(ro, null, n);
};
var UV = function(t11, e, n) {
  var i = TS(n, e - 1), r = TS(n, e + 1);
  return Cd(SS, t11) && !Cd(RS, r) || Cd(RS, t11) && !Cd(SS, i) ? "\\u" + kV(DV(t11, 0), 16) : t11;
};
ro && AV({ target: "JSON", stat: true, arity: 3, forced: CS || IS }, { stringify: function(t11, e, n) {
  var i = Kw(arguments), r = Ww(CS ? MV : ro, null, i);
  return IS && typeof r == "string" ? PV(r, LV, UV) : r;
} });
var vS = Xc;
var xV = _r;
xt({ target: "Object", stat: true, forced: !ua || Se(function() {
  vS.f(1);
}) }, { getOwnPropertySymbols: function(t11) {
  var e = vS.f;
  return e ? e(xV(t11)) : [];
} }), Fe("asyncIterator"), Fe("hasInstance"), Fe("isConcatSpreadable"), Fe("iterator"), Fe("match"), Fe("matchAll"), Fe("replace"), Fe("search"), Fe("species"), Fe("split");
var VV = Aw;
Fe("toPrimitive"), VV();
var FV = Dn;
var BV = To;
Fe("toStringTag"), BV(FV("Symbol"), "Symbol"), Fe("unscopables"), To(We.JSON, "JSON", true);
var jV = Gi.Symbol;
var GV = pe;
var WV = Ai.f;
var yS = GV("metadata");
var AS = Function.prototype;
AS[yS] === void 0 && WV(AS, yS, { value: null }), Fe("dispose"), Fe("metadata");
var HV = jV;
Fe("asyncDispose");
var KV = me;
var nf = Dn("Symbol");
var YV = nf.keyFor;
var qV = KV(nf.prototype.valueOf);
var Yw = nf.isRegisteredSymbol || function(t11) {
  try {
    return YV(qV(t11)) !== void 0;
  } catch {
    return false;
  }
};
xt({ target: "Symbol", stat: true }, { isRegisteredSymbol: Yw });
for (bS = pa, pp = Dn, wS = me, OS = qc, NS = pe, Na = pp("Symbol"), gE = Na.isWellKnownSymbol, TE = pp("Object", "getOwnPropertyNames"), qw = wS(Na.prototype.valueOf), SE = bS("wks"), Id = 0, _p = TE(Na), DS = _p.length; Id < DS; Id++) try {
  Ep = _p[Id], OS(Na[Ep]) && NS(Ep);
} catch {
}
var Ep;
var bS;
var pp;
var wS;
var OS;
var NS;
var Na;
var gE;
var TE;
var qw;
var SE;
var Id;
var _p;
var DS;
var PS = function(t11) {
  if (gE && gE(t11)) return true;
  try {
    for (var e = qw(t11), n = 0, i = TE(SE), r = i.length; n < r; n++) if (SE[i[n]] == e) return true;
  } catch {
  }
  return false;
};
xt({ target: "Symbol", stat: true, forced: true }, { isWellKnownSymbol: PS }), Fe("matcher"), Fe("observable"), xt({ target: "Symbol", stat: true, name: "isRegisteredSymbol" }, { isRegistered: Yw }), xt({ target: "Symbol", stat: true, name: "isWellKnownSymbol", forced: true }, { isWellKnown: PS }), Fe("metadataKey"), Fe("patternMatch"), Fe("replaceAll");
var Ds = ae(HV);
var zw = ae(Ea.f("iterator"));
function oc(t11) {
  return oc = typeof Ds == "function" && typeof zw == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Ds == "function" && e.constructor === Ds && e !== Ds.prototype ? "symbol" : typeof e;
  }, oc(t11);
}
var zV = ae(Ea.f("toPrimitive"));
function JV(t11) {
  var e = function(n, i) {
    if (oc(n) !== "object" || n === null) return n;
    var r = n[zV];
    if (r !== void 0) {
      var o = r.call(n, i || "default");
      if (oc(o) !== "object") return o;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (i === "string" ? String : Number)(n);
  }(t11, "string");
  return oc(e) === "symbol" ? e : String(e);
}
function T(t11, e, n) {
  return (e = JV(e)) in t11 ? Rw(t11, e, { value: n, enumerable: true, configurable: true, writable: true }) : t11[e] = n, t11;
}
var XV = Se;
var QV = pe("iterator");
var rf = !XV(function() {
  var t11 = new URL("b?a=1&b=2&c=3", "http://a"), e = t11.searchParams, n = new URLSearchParams("a=1&a=2"), i = "";
  return t11.pathname = "c%20d", e.forEach(function(r, o) {
    e.delete("b"), i += o + r;
  }), n.delete("a", 2), !t11.toJSON || !n.has("a", 1) || n.has("a", 2) || !e.size && true || !e.sort || t11.href !== "http://a/c%20d?a=1&c=3" || e.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !e[QV] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://ÑÐµÑÑ").host !== "xn--e1aybc" || new URL("http://a#Ð±").hash !== "#%D0%B1" || i !== "a1c3" || new URL("http://x", void 0).host !== "x";
});
var ZV = go;
var mp = xt;
var Xs = We;
var vd = Ke;
var ur = me;
var Ps = ri;
var kS = rf;
var LS = go;
var $V = Uu;
var tF = function(t11, e, n) {
  for (var i in e) n && n.unsafe && t11[i] ? t11[i] = e[i] : ZV(t11, i, e[i], n);
  return t11;
};
var eF = To;
var nF = xm;
var of = ns;
var Jw = Fm;
var fp = He;
var iF = Je;
var rF = mo;
var oF = Er;
var sF = Cn;
var Xw = Hn;
var bn = oi;
var aF = Qc;
var MS = _o;
var RE = Um;
var cF = Mu;
var ls = Vu;
var dF = hw;
var lF = pe("iterator");
var Cc = "URLSearchParams";
var Qw = Cc + "Iterator";
var Zw = of.set;
var fi = of.getterFor(Cc);
var uF = of.getterFor(Qw);
var hF = Object.getOwnPropertyDescriptor;
var sf = function(t11) {
  if (!Ps) return Xs[t11];
  var e = hF(Xs, t11);
  return e && e.value;
};
var US = sf("fetch");
var Fl = sf("Request");
var sc = sf("Headers");
var gp = Fl && Fl.prototype;
var xS = sc && sc.prototype;
var pF = Xs.RegExp;
var _F = Xs.TypeError;
var $w = Xs.decodeURIComponent;
var EF = Xs.encodeURIComponent;
var mF = ur("".charAt);
var VS = ur([].join);
var xo = ur([].push);
var CE = ur("".replace);
var fF = ur([].shift);
var FS = ur([].splice);
var BS = ur("".split);
var gF = ur("".slice);
var TF = /\+/g;
var jS = Array(4);
var SF = function(t11) {
  return jS[t11 - 1] || (jS[t11 - 1] = pF("((?:%[\\da-f]{2}){" + t11 + "})", "gi"));
};
var RF = function(t11) {
  try {
    return $w(t11);
  } catch {
    return t11;
  }
};
var GS = function(t11) {
  var e = CE(t11, TF, " "), n = 4;
  try {
    return $w(e);
  } catch {
    for (; n; ) e = CE(e, SF(n--), RF);
    return e;
  }
};
var CF = /[!'()~]|%20/g;
var IF = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" };
var vF = function(t11) {
  return IF[t11];
};
var WS = function(t11) {
  return CE(EF(t11), CF, vF);
};
var Tp = nF(function(t11, e) {
  Zw(this, { type: Qw, iterator: RE(fi(t11).entries), kind: e });
}, "Iterator", function() {
  var t11 = uF(this), e = t11.kind, n = t11.iterator.next(), i = n.value;
  return n.done || (n.value = e === "keys" ? i.key : e === "values" ? i.value : [i.key, i.value]), n;
}, true);
var tO = function(t11) {
  this.entries = [], this.url = null, t11 !== void 0 && (Xw(t11) ? this.parseObject(t11) : this.parseQuery(typeof t11 == "string" ? mF(t11, 0) === "?" ? gF(t11, 1) : t11 : bn(t11)));
};
tO.prototype = { type: Cc, bindURL: function(t11) {
  this.url = t11, this.update();
}, parseObject: function(t11) {
  var e, n, i, r, o, s, a, c = cF(t11);
  if (c) for (n = (e = RE(t11, c)).next; !(i = vd(n, e)).done; ) {
    if (o = (r = RE(sF(i.value))).next, (s = vd(o, r)).done || (a = vd(o, r)).done || !vd(o, r).done) throw _F("Expected sequence with length 2");
    xo(this.entries, { key: bn(s.value), value: bn(a.value) });
  }
  else for (var d in t11) iF(t11, d) && xo(this.entries, { key: d, value: bn(t11[d]) });
}, parseQuery: function(t11) {
  if (t11) for (var e, n, i = BS(t11, "&"), r = 0; r < i.length; ) (e = i[r++]).length && (n = BS(e, "="), xo(this.entries, { key: GS(fF(n)), value: GS(VS(n, "=")) }));
}, serialize: function() {
  for (var t11, e = this.entries, n = [], i = 0; i < e.length; ) t11 = e[i++], xo(n, WS(t11.key) + "=" + WS(t11.value));
  return VS(n, "&");
}, update: function() {
  this.entries.length = 0, this.parseQuery(this.url.query);
}, updateURL: function() {
  this.url && this.url.update();
} };
var Bl = function() {
  Jw(this, vs);
  var t11 = Zw(this, new tO(arguments.length > 0 ? arguments[0] : void 0));
  Ps || (this.size = t11.entries.length);
};
var vs = Bl.prototype;
tF(vs, { append: function(t11, e) {
  var n = fi(this);
  ls(arguments.length, 2), xo(n.entries, { key: bn(t11), value: bn(e) }), Ps || this.length++, n.updateURL();
}, delete: function(t11) {
  for (var e = fi(this), n = ls(arguments.length, 1), i = e.entries, r = bn(t11), o = n < 2 ? void 0 : arguments[1], s = o === void 0 ? o : bn(o), a = 0; a < i.length; ) {
    var c = i[a];
    if (c.key !== r || s !== void 0 && c.value !== s) a++;
    else if (FS(i, a, 1), s !== void 0) break;
  }
  Ps || (this.size = i.length), e.updateURL();
}, get: function(t11) {
  var e = fi(this).entries;
  ls(arguments.length, 1);
  for (var n = bn(t11), i = 0; i < e.length; i++) if (e[i].key === n) return e[i].value;
  return null;
}, getAll: function(t11) {
  var e = fi(this).entries;
  ls(arguments.length, 1);
  for (var n = bn(t11), i = [], r = 0; r < e.length; r++) e[r].key === n && xo(i, e[r].value);
  return i;
}, has: function(t11) {
  for (var e = fi(this).entries, n = ls(arguments.length, 1), i = bn(t11), r = n < 2 ? void 0 : arguments[1], o = r === void 0 ? r : bn(r), s = 0; s < e.length; ) {
    var a = e[s++];
    if (a.key === i && (o === void 0 || a.value === o)) return true;
  }
  return false;
}, set: function(t11, e) {
  var n = fi(this);
  ls(arguments.length, 1);
  for (var i, r = n.entries, o = false, s = bn(t11), a = bn(e), c = 0; c < r.length; c++) (i = r[c]).key === s && (o ? FS(r, c--, 1) : (o = true, i.value = a));
  o || xo(r, { key: s, value: a }), Ps || (this.size = r.length), n.updateURL();
}, sort: function() {
  var t11 = fi(this);
  dF(t11.entries, function(e, n) {
    return e.key > n.key ? 1 : -1;
  }), t11.updateURL();
}, forEach: function(t11) {
  for (var e, n = fi(this).entries, i = rF(t11, arguments.length > 1 ? arguments[1] : void 0), r = 0; r < n.length; ) i((e = n[r++]).value, e.key, this);
}, keys: function() {
  return new Tp(this, "keys");
}, values: function() {
  return new Tp(this, "values");
}, entries: function() {
  return new Tp(this, "entries");
} }, { enumerable: true }), LS(vs, lF, vs.entries, { name: "entries" }), LS(vs, "toString", function() {
  return fi(this).serialize();
}, { enumerable: true }), Ps && $V(vs, "size", { get: function() {
  return fi(this).entries.length;
}, configurable: true, enumerable: true }), eF(Bl, Cc), mp({ global: true, constructor: true, forced: !kS }, { URLSearchParams: Bl }), !kS && fp(sc) && (HS = ur(xS.has), KS = ur(xS.set), Sp = function(t11) {
  if (Xw(t11)) {
    var e, n = t11.body;
    if (oF(n) === Cc) return e = t11.headers ? new sc(t11.headers) : new sc(), HS(e, "content-type") || KS(e, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), aF(t11, { body: MS(0, bn(n)), headers: MS(0, e) });
  }
  return t11;
}, fp(US) && mp({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, { fetch: function(t11) {
  return US(t11, arguments.length > 1 ? Sp(arguments[1]) : {});
} }), fp(Fl) && (yd = function(t11) {
  return Jw(this, gp), new Fl(t11, arguments.length > 1 ? Sp(arguments[1]) : {});
}, gp.constructor = yd, yd.prototype = gp, mp({ global: true, constructor: true, dontCallGetSet: true, forced: true }, { Request: yd })));
var HS;
var KS;
var Sp;
var yd;
var yF = { URLSearchParams: Bl, getState: fi };
var YS = ae(Gi.URLSearchParams);
var AF = { isBrowser: true, classes: { URLSearchParams: YS !== void 0 ? YS : Qm, FormData: typeof FormData < "u" ? FormData : null, Blob: typeof Blob < "u" ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] };
var eO = typeof window < "u" && typeof document < "u";
var bF = (qS = typeof navigator < "u" && navigator.product, eO && ["ReactNative", "NativeScript", "NS"].indexOf(qS) < 0);
var qS;
var wF = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function";
function zS(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function JS(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? zS(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : zS(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var sr = JS(JS({}, Object.freeze({ __proto__: null, hasBrowserEnv: eO, hasStandardBrowserEnv: bF, hasStandardBrowserWebWorkerEnv: wF })), AF);
var OF = Cn;
var NF = Ke;
var DF = Je;
var PF = hn;
var kF = function() {
  var t11 = OF(this), e = "";
  return t11.hasIndices && (e += "d"), t11.global && (e += "g"), t11.ignoreCase && (e += "i"), t11.multiline && (e += "m"), t11.dotAll && (e += "s"), t11.unicode && (e += "u"), t11.unicodeSets && (e += "v"), t11.sticky && (e += "y"), e;
};
var XS = RegExp.prototype;
var nO = function(t11) {
  var e = t11.flags;
  return e !== void 0 || "flags" in XS || DF(t11, "flags") || !PF(XS, t11) ? e : NF(kF, t11);
};
var LF = qm.charAt;
var QS = Ke;
var MF = Cn;
var UF = He;
var xF = pr;
var VF = /./.exec;
var FF = TypeError;
var BF = xt;
var ZS = Ke;
var iO = gc;
var jF = xm;
var Ad = Vm;
var $S = la;
var rO = MA;
var Ic = oi;
var GF = Cn;
var WF = da;
var HF = pr;
var KF = UA;
var oO = nO;
var YF = wu;
var qF = Se;
var zF = jm;
var JF = function(t11, e, n) {
  return e + (n ? LF(t11, e).length : 1);
};
var XF = function(t11, e) {
  var n = t11.exec;
  if (UF(n)) {
    var i = QS(n, t11, e);
    return i !== null && MF(i), i;
  }
  if (xF(t11) === "RegExp") return QS(VF, t11, e);
  throw FF("RegExp#exec called on incompatible receiver");
};
var sO = ns;
var QF = pe("matchAll");
var aO = "RegExp String";
var cO = aO + " Iterator";
var ZF = sO.set;
var $F = sO.getterFor(cO);
var tB = TypeError;
var IE = iO("".indexOf);
var jl = iO("".matchAll);
var Rp = !!jl && !qF(function() {
  jl("a", /./);
});
var eB = jF(function(t11, e, n, i) {
  ZF(this, { type: cO, regexp: t11, string: e, global: n, unicode: i, done: false });
}, aO, function() {
  var t11 = $F(this);
  if (t11.done) return Ad(void 0, true);
  var e = t11.regexp, n = t11.string, i = XF(e, n);
  return i === null ? (t11.done = true, Ad(void 0, true)) : t11.global ? (Ic(i[0]) === "" && (e.lastIndex = JF(n, rO(e.lastIndex), t11.unicode)), Ad(i, false)) : (t11.done = true, Ad(i, false));
});
var tR = function(t11) {
  var e, n, i, r = GF(this), o = Ic(t11), s = zF(r, RegExp), a = Ic(oO(r));
  return e = new s(s === RegExp ? r.source : r, a), n = !!~IE(a, "g"), i = !!~IE(a, "u"), e.lastIndex = rO(r.lastIndex), new eB(e, o, n, i);
};
BF({ target: "String", proto: true, forced: Rp }, { matchAll: function(t11) {
  var e, n, i, r, o = $S(this);
  if (WF(t11)) {
    if (Rp) return jl(o, t11);
  } else {
    if (KF(t11) && (e = Ic($S(oO(t11))), !~IE(e, "g"))) throw tB("`.matchAll` does not allow non-global regexes");
    if (Rp) return jl(o, t11);
    if ((i = YF(t11, QF)) === void 0 && HF(t11) == "RegExp" && (i = tR), i) return ZS(i, t11, o);
  }
  return n = Ic(o), r = new RegExp(t11, "g"), ZS(tR, r, n);
} });
var nB = bi("String").matchAll;
var iB = hn;
var rB = nB;
var Cp = String.prototype;
var oB = function(t11) {
  var e = t11.matchAll;
  return typeof t11 == "string" || t11 === Cp || iB(Cp, t11) && e === Cp.matchAll ? rB : e;
};
var sB = ae(oB);
function dO(t11) {
  function e(n, i, r, o) {
    let s = n[o++];
    if (s === "__proto__") return true;
    let a = Number.isFinite(+s), c = o >= n.length;
    return s = !s && K.isArray(r) ? r.length : s, c ? (K.hasOwnProp(r, s) ? r[s] = [r[s], i] : r[s] = i, !a) : (r[s] && K.isObject(r[s]) || (r[s] = []), e(n, i, r[s], o) && K.isArray(r[s]) && (r[s] = function(d) {
      let l = {}, u = Object.keys(d), h, p = u.length, g;
      for (h = 0; h < p; h++) g = u[h], l[g] = d[g];
      return l;
    }(r[s])), !a);
  }
  if (K.isFormData(t11) && K.isFunction(t11.entries)) {
    let n = {};
    return K.forEachEntry(t11, (i, r) => {
      e(function(o) {
        return sB(K).call(K, /\w+|\[(\w*)]/g, o).map((s) => s[0] === "[]" ? "" : s[1] || s[0]);
      }(i), r, n, 0);
    }), n;
  }
  return null;
}
var af = { transitional: gw, adapter: ["xhr", "http"], transformRequest: [function(t11, e) {
  let n = e.getContentType() || "", i = n.indexOf("application/json") > -1, r = K.isObject(t11);
  if (r && K.isHTMLForm(t11) && (t11 = new FormData(t11)), K.isFormData(t11)) return i ? JSON.stringify(dO(t11)) : t11;
  if (K.isArrayBuffer(t11) || K.isBuffer(t11) || K.isStream(t11) || K.isFile(t11) || K.isBlob(t11)) return t11;
  if (K.isArrayBufferView(t11)) return t11.buffer;
  if (K.isURLSearchParams(t11)) return e.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), t11.toString();
  let o;
  if (r) {
    if (n.indexOf("application/x-www-form-urlencoded") > -1) return function(s, a) {
      return Ul(s, new sr.classes.URLSearchParams(), Object.assign({ visitor: function(c, d, l, u) {
        return sr.isNode && K.isBuffer(c) ? (this.append(d, c.toString("base64")), false) : u.defaultVisitor.apply(this, arguments);
      } }, a));
    }(t11, this.formSerializer).toString();
    if ((o = K.isFileList(t11)) || n.indexOf("multipart/form-data") > -1) {
      let s = this.env && this.env.FormData;
      return Ul(o ? { "files[]": t11 } : t11, s && new s(), this.formSerializer);
    }
  }
  return r || i ? (e.setContentType("application/json", false), function(s, a, c) {
    if (K.isString(s)) try {
      return (a || JSON.parse)(s), rn(K).call(K, s);
    } catch (d) {
      if (d.name !== "SyntaxError") throw d;
    }
    return (0, JSON.stringify)(s);
  }(t11)) : t11;
}], transformResponse: [function(t11) {
  let e = this.transitional || af.transitional, n = e && e.forcedJSONParsing, i = this.responseType === "json";
  if (t11 && K.isString(t11) && (n && !this.responseType || i)) {
    let r = !(e && e.silentJSONParsing) && i;
    try {
      return JSON.parse(t11);
    } catch (o) {
      if (r) throw o.name === "SyntaxError" ? qt.from(o, qt.ERR_BAD_RESPONSE, this, null, this.response) : o;
    }
  }
  return t11;
}], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: sr.classes.FormData, Blob: sr.classes.Blob }, validateStatus: function(t11) {
  return t11 >= 200 && t11 < 300;
}, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } };
K.forEach(["delete", "get", "head", "post", "put", "patch"], (t11) => {
  af.headers[t11] = {};
});
var cf = af;
var aB = K.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
var eR = Symbol("internals");
function Da(t11) {
  var e;
  return t11 && rn(e = String(t11)).call(e).toLowerCase();
}
function El(t11) {
  return t11 === false || t11 == null ? t11 : K.isArray(t11) ? t11.map(El) : String(t11);
}
function Ip(t11, e, n, i, r) {
  return K.isFunction(i) ? i.call(this, e, n) : (r && (e = n), K.isString(e) ? K.isString(i) ? e.indexOf(i) !== -1 : K.isRegExp(i) ? i.test(e) : void 0 : void 0);
}
var Gs = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, n, i) {
    let r = this;
    function o(c, d, l) {
      let u = Da(d);
      if (!u) throw new Error("header name must be a non-empty string");
      let h = K.findKey(r, u);
      (!h || r[h] === void 0 || l === true || l === void 0 && r[h] !== false) && (r[h || d] = El(c));
    }
    let s = (c, d) => K.forEach(c, (l, u) => o(l, u, d));
    var a;
    return K.isPlainObject(e) || e instanceof this.constructor ? s(e, n) : K.isString(e) && (e = rn(e).call(e)) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(rn(a = e).call(a)) ? s(((c) => {
      let d = {}, l, u, h;
      return c && c.split(`
`).forEach(function(p) {
        var g, E;
        h = p.indexOf(":"), l = rn(g = p.substring(0, h)).call(g).toLowerCase(), u = rn(E = p.substring(h + 1)).call(E), !l || d[l] && aB[l] || (l === "set-cookie" ? d[l] ? d[l].push(u) : d[l] = [u] : d[l] = d[l] ? d[l] + ", " + u : u);
      }), d;
    })(e), n) : e != null && o(n, e, i), this;
  }
  get(e, n) {
    if (e = Da(e)) {
      let i = K.findKey(this, e);
      if (i) {
        let r = this[i];
        if (!n) return r;
        if (n === true) return function(o) {
          let s = /* @__PURE__ */ Object.create(null), a = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g, c;
          for (; c = a.exec(o); ) s[c[1]] = c[2];
          return s;
        }(r);
        if (K.isFunction(n)) return n.call(this, r, i);
        if (K.isRegExp(n)) return n.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, n) {
    if (e = Da(e)) {
      let i = K.findKey(this, e);
      return !(!i || this[i] === void 0 || n && !Ip(0, this[i], i, n));
    }
    return false;
  }
  delete(e, n) {
    let i = this, r = false;
    function o(s) {
      if (s = Da(s)) {
        let a = K.findKey(i, s);
        !a || n && !Ip(0, i[a], a, n) || (delete i[a], r = true);
      }
    }
    return K.isArray(e) ? e.forEach(o) : o(e), r;
  }
  clear(e) {
    let n = Object.keys(this), i = n.length, r = false;
    for (; i--; ) {
      let o = n[i];
      e && !Ip(0, this[o], o, e, true) || (delete this[o], r = true);
    }
    return r;
  }
  normalize(e) {
    let n = this, i = {};
    return K.forEach(this, (r, o) => {
      var s;
      let a = K.findKey(i, o);
      if (a) return n[a] = El(r), void delete n[o];
      let c = e ? function(d) {
        return rn(d).call(d).toLowerCase().replace(/([a-z\d])(\w*)/g, (l, u, h) => u.toUpperCase() + h);
      }(o) : rn(s = String(o)).call(s);
      c !== o && delete n[o], n[c] = El(r), i[c] = true;
    }), this;
  }
  concat() {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
    return this.constructor.concat(this, ...n);
  }
  toJSON(e) {
    let n = /* @__PURE__ */ Object.create(null);
    return K.forEach(this, (i, r) => {
      i != null && i !== false && (n[r] = e && K.isArray(i) ? i.join(", ") : i);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map((e) => {
      let [n, i] = e;
      return n + ": " + i;
    }).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e) {
    let n = new this(e);
    for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) r[o - 1] = arguments[o];
    return r.forEach((s) => n.set(s)), n;
  }
  static accessor(e) {
    let n = (this[eR] = this[eR] = { accessors: {} }).accessors, i = this.prototype;
    function r(o) {
      let s = Da(o);
      n[s] || (function(a, c) {
        let d = K.toCamelCase(" " + c);
        ["get", "set", "has"].forEach((l) => {
          Object.defineProperty(a, l + d, { value: function(u, h, p) {
            return this[l].call(this, c, u, h, p);
          }, configurable: true });
        });
      }(i, o), n[s] = true);
    }
    return K.isArray(e) ? e.forEach(r) : r(e), this;
  }
};
Gs.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), K.reduceDescriptors(Gs.prototype, (t11, e) => {
  let { value: n } = t11, i = e[0].toUpperCase() + e.slice(1);
  return { get: () => n, set(r) {
    this[i] = r;
  } };
}), K.freezeMethods(Gs);
var Dr = Gs;
function vp(t11, e) {
  let n = this || cf, i = e || n, r = Dr.from(i.headers), o = i.data;
  return K.forEach(t11, function(s) {
    o = s.call(n, o, r.normalize(), e ? e.status : void 0);
  }), r.normalize(), o;
}
function lO(t11) {
  return !(!t11 || !t11.__CANCEL__);
}
function od(t11, e, n) {
  qt.call(this, t11 ?? "canceled", qt.ERR_CANCELED, e, n), this.name = "CanceledError";
}
K.inherits(od, qt, { __CANCEL__: true });
var cB = sr.hasStandardBrowserEnv ? { write(t11, e, n, i, r, o) {
  let s = [t11 + "=" + encodeURIComponent(e)];
  K.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()), K.isString(i) && s.push("path=" + i), K.isString(r) && s.push("domain=" + r), o === true && s.push("secure"), document.cookie = s.join("; ");
}, read(t11) {
  let e = document.cookie.match(new RegExp("(^|;\\s*)(" + t11 + ")=([^;]*)"));
  return e ? decodeURIComponent(e[3]) : null;
}, remove(t11) {
  this.write(t11, "", Date.now() - 864e5);
} } : { write() {
}, read: () => null, remove() {
} };
function uO(t11, e) {
  return t11 && !function(n) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
  }(e) ? function(n, i) {
    return i ? n.replace(/\/?\/$/, "") + "/" + i.replace(/^\/+/, "") : n;
  }(t11, e) : e;
}
var dB = sr.hasStandardBrowserEnv ? function() {
  let t11 = /(msie|trident)/i.test(navigator.userAgent), e = document.createElement("a"), n;
  function i(r) {
    let o = r;
    return t11 && (e.setAttribute("href", o), o = e.href), e.setAttribute("href", o), { href: e.href, protocol: e.protocol ? e.protocol.replace(/:$/, "") : "", host: e.host, search: e.search ? e.search.replace(/^\?/, "") : "", hash: e.hash ? e.hash.replace(/^#/, "") : "", hostname: e.hostname, port: e.port, pathname: e.pathname.charAt(0) === "/" ? e.pathname : "/" + e.pathname };
  }
  return n = i(window.location.href), function(r) {
    let o = K.isString(r) ? i(r) : r;
    return o.protocol === n.protocol && o.host === n.host;
  };
}() : function() {
  return true;
};
function nR(t11, e) {
  let n = 0, i = function(r, o) {
    r = r || 10;
    let s = new Array(r), a = new Array(r), c, d = 0, l = 0;
    return o = o !== void 0 ? o : 1e3, function(u) {
      let h = Date.now(), p = a[l];
      c || (c = h), s[d] = u, a[d] = h;
      let g = l, E = 0;
      for (; g !== d; ) E += s[g++], g %= r;
      if (d = (d + 1) % r, d === l && (l = (l + 1) % r), h - c < o) return;
      let f = p && h - p;
      return f ? Math.round(1e3 * E / f) : void 0;
    };
  }(50, 250);
  return (r) => {
    let o = r.loaded, s = r.lengthComputable ? r.total : void 0, a = o - n, c = i(a);
    n = o;
    let d = { loaded: o, total: s, progress: s ? o / s : void 0, bytes: a, rate: c || void 0, estimated: c && s && o <= s ? (s - o) / c : void 0, event: r };
    d[e ? "download" : "upload"] = true, t11(d);
  };
}
var lB = typeof XMLHttpRequest < "u" && function(t11) {
  return new j(function(e, n) {
    let i = t11.data, r = Dr.from(t11.headers).normalize(), o, s, { responseType: a, withXSRFToken: c } = t11;
    function d() {
      t11.cancelToken && t11.cancelToken.unsubscribe(o), t11.signal && t11.signal.removeEventListener("abort", o);
    }
    if (K.isFormData(i)) {
      if (sr.hasStandardBrowserEnv || sr.hasStandardBrowserWebWorkerEnv) r.setContentType(false);
      else if ((s = r.getContentType()) !== false) {
        let [g, ...E] = s ? s.split(";").map((f) => rn(f).call(f)).filter(Boolean) : [];
        r.setContentType([g || "multipart/form-data", ...E].join("; "));
      }
    }
    let l = new XMLHttpRequest();
    if (t11.auth) {
      let g = t11.auth.username || "", E = t11.auth.password ? unescape(encodeURIComponent(t11.auth.password)) : "";
      r.set("Authorization", "Basic " + btoa(g + ":" + E));
    }
    let u = uO(t11.baseURL, t11.url);
    function h() {
      if (!l) return;
      let g = Dr.from("getAllResponseHeaders" in l && l.getAllResponseHeaders());
      (function(E, f, S) {
        let C = S.config.validateStatus;
        S.status && C && !C(S.status) ? f(new qt("Request failed with status code " + S.status, [qt.ERR_BAD_REQUEST, qt.ERR_BAD_RESPONSE][Math.floor(S.status / 100) - 4], S.config, S.request, S)) : E(S);
      })(function(E) {
        e(E), d();
      }, function(E) {
        n(E), d();
      }, { data: a && a !== "text" && a !== "json" ? l.response : l.responseText, status: l.status, statusText: l.statusText, headers: g, config: t11, request: l }), l = null;
    }
    if (l.open(t11.method.toUpperCase(), fw(u, t11.params, t11.paramsSerializer), true), l.timeout = t11.timeout, "onloadend" in l ? l.onloadend = h : l.onreadystatechange = function() {
      l && l.readyState === 4 && (l.status !== 0 || l.responseURL && l.responseURL.indexOf("file:") === 0) && setTimeout(h);
    }, l.onabort = function() {
      l && (n(new qt("Request aborted", qt.ECONNABORTED, t11, l)), l = null);
    }, l.onerror = function() {
      n(new qt("Network Error", qt.ERR_NETWORK, t11, l)), l = null;
    }, l.ontimeout = function() {
      let g = t11.timeout ? "timeout of " + t11.timeout + "ms exceeded" : "timeout exceeded", E = t11.transitional || gw;
      t11.timeoutErrorMessage && (g = t11.timeoutErrorMessage), n(new qt(g, E.clarifyTimeoutError ? qt.ETIMEDOUT : qt.ECONNABORTED, t11, l)), l = null;
    }, sr.hasStandardBrowserEnv && (c && K.isFunction(c) && (c = c(t11)), c || c !== false && dB(u))) {
      let g = t11.xsrfHeaderName && t11.xsrfCookieName && cB.read(t11.xsrfCookieName);
      g && r.set(t11.xsrfHeaderName, g);
    }
    i === void 0 && r.setContentType(null), "setRequestHeader" in l && K.forEach(r.toJSON(), function(g, E) {
      l.setRequestHeader(E, g);
    }), K.isUndefined(t11.withCredentials) || (l.withCredentials = !!t11.withCredentials), a && a !== "json" && (l.responseType = t11.responseType), typeof t11.onDownloadProgress == "function" && l.addEventListener("progress", nR(t11.onDownloadProgress, true)), typeof t11.onUploadProgress == "function" && l.upload && l.upload.addEventListener("progress", nR(t11.onUploadProgress)), (t11.cancelToken || t11.signal) && (o = (g) => {
      l && (n(!g || g.type ? new od(null, t11, l) : g), l.abort(), l = null);
    }, t11.cancelToken && t11.cancelToken.subscribe(o), t11.signal && (t11.signal.aborted ? o() : t11.signal.addEventListener("abort", o)));
    let p = function(g) {
      let E = /^([-+\w]{1,25})(:?\/\/|:)/.exec(g);
      return E && E[1] || "";
    }(u);
    p && sr.protocols.indexOf(p) === -1 ? n(new qt("Unsupported protocol " + p + ":", qt.ERR_BAD_REQUEST, t11)) : l.send(i || null);
  });
};
var vE = { http: null, xhr: lB };
K.forEach(vE, (t11, e) => {
  if (t11) {
    try {
      Object.defineProperty(t11, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t11, "adapterName", { value: e });
  }
});
var iR = (t11) => "- ".concat(t11);
var uB = (t11) => K.isFunction(t11) || t11 === null || t11 === false;
var hO = { getAdapter: (t11) => {
  t11 = K.isArray(t11) ? t11 : [t11];
  let { length: e } = t11, n, i, r = {};
  for (let o = 0; o < e; o++) {
    let s;
    if (n = t11[o], i = n, !uB(n) && (i = vE[(s = String(n)).toLowerCase()], i === void 0)) throw new qt("Unknown adapter '".concat(s, "'"));
    if (i) break;
    r[s || "#" + o] = i;
  }
  if (!i) {
    let o = Object.entries(r).map((s) => {
      let [a, c] = s;
      return "adapter ".concat(a, " ") + (c === false ? "is not supported by the environment" : "is not available in the build");
    });
    throw new qt("There is no suitable adapter to dispatch the request " + (e ? o.length > 1 ? `since :
` + o.map(iR).join(`
`) : " " + iR(o[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT");
  }
  return i;
}, adapters: vE };
function yp(t11) {
  if (t11.cancelToken && t11.cancelToken.throwIfRequested(), t11.signal && t11.signal.aborted) throw new od(null, t11);
}
function rR(t11) {
  return yp(t11), t11.headers = Dr.from(t11.headers), t11.data = vp.call(t11, t11.transformRequest), ["post", "put", "patch"].indexOf(t11.method) !== -1 && t11.headers.setContentType("application/x-www-form-urlencoded", false), hO.getAdapter(t11.adapter || cf.adapter)(t11).then(function(e) {
    return yp(t11), e.data = vp.call(t11, t11.transformResponse, e), e.headers = Dr.from(e.headers), e;
  }, function(e) {
    return lO(e) || (yp(t11), e && e.response && (e.response.data = vp.call(t11, t11.transformResponse, e.response), e.response.headers = Dr.from(e.response.headers))), j.reject(e);
  });
}
function oR(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
var sR = (t11) => t11 instanceof Dr ? function(e) {
  for (var n = 1; n < arguments.length; n++) {
    var i = arguments[n] != null ? arguments[n] : {};
    n % 2 ? oR(Object(i), true).forEach(function(r) {
      T(e, r, i[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : oR(Object(i)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(i, r));
    });
  }
  return e;
}({}, t11) : t11;
function Qs(t11, e) {
  e = e || {};
  let n = {};
  function i(d, l, u) {
    return K.isPlainObject(d) && K.isPlainObject(l) ? K.merge.call({ caseless: u }, d, l) : K.isPlainObject(l) ? K.merge({}, l) : K.isArray(l) ? l.slice() : l;
  }
  function r(d, l, u) {
    return K.isUndefined(l) ? K.isUndefined(d) ? void 0 : i(void 0, d, u) : i(d, l, u);
  }
  function o(d, l) {
    if (!K.isUndefined(l)) return i(void 0, l);
  }
  function s(d, l) {
    return K.isUndefined(l) ? K.isUndefined(d) ? void 0 : i(void 0, d) : i(void 0, l);
  }
  function a(d, l, u) {
    return u in e ? i(d, l) : u in t11 ? i(void 0, d) : void 0;
  }
  let c = { url: o, method: o, data: o, baseURL: s, transformRequest: s, transformResponse: s, paramsSerializer: s, timeout: s, timeoutMessage: s, withCredentials: s, withXSRFToken: s, adapter: s, responseType: s, xsrfCookieName: s, xsrfHeaderName: s, onUploadProgress: s, onDownloadProgress: s, decompress: s, maxContentLength: s, maxBodyLength: s, beforeRedirect: s, transport: s, httpAgent: s, httpsAgent: s, cancelToken: s, socketPath: s, responseEncoding: s, validateStatus: a, headers: (d, l) => r(sR(d), sR(l), true) };
  return K.forEach(Object.keys(Object.assign({}, t11, e)), function(d) {
    let l = c[d] || r, u = l(t11[d], e[d], d);
    K.isUndefined(u) && l !== a || (n[d] = u);
  }), n;
}
var pO = "1.6.8";
var df = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t11, e) => {
  df[t11] = function(n) {
    return typeof n === t11 || "a" + (e < 1 ? "n " : " ") + t11;
  };
});
var aR = {};
df.transitional = function(t11, e, n) {
  function i(r, o) {
    return "[Axios v" + pO + "] Transitional option '" + r + "'" + o + (n ? ". " + n : "");
  }
  return (r, o, s) => {
    if (t11 === false) throw new qt(i(o, " has been removed" + (e ? " in " + e : "")), qt.ERR_DEPRECATED);
    return e && !aR[o] && (aR[o] = true, console.warn(i(o, " has been deprecated since v" + e + " and will be removed in the near future"))), !t11 || t11(r, o, s);
  };
};
var yE = { assertOptions: function(t11, e, n) {
  if (typeof t11 != "object") throw new qt("options must be an object", qt.ERR_BAD_OPTION_VALUE);
  let i = Object.keys(t11), r = i.length;
  for (; r-- > 0; ) {
    let o = i[r], s = e[o];
    if (s) {
      let a = t11[o], c = a === void 0 || s(a, o, t11);
      if (c !== true) throw new qt("option " + o + " must be " + c, qt.ERR_BAD_OPTION_VALUE);
    } else if (n !== true) throw new qt("Unknown option " + o, qt.ERR_BAD_OPTION);
  }
}, validators: df };
var Fr = yE.validators;
var ml = class {
  constructor(t11) {
    this.defaults = t11, this.interceptors = { request: new ZT(), response: new ZT() };
  }
  async request(t11, e) {
    try {
      return await this._request(t11, e);
    } catch (n) {
      if (n instanceof Error) {
        let i;
        Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error();
        let r = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        n.stack ? r && !String(n.stack).endsWith(r.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + r) : n.stack = r;
      }
      throw n;
    }
  }
  _request(t11, e) {
    typeof t11 == "string" ? (e = e || {}).url = t11 : e = t11 || {}, e = Qs(this.defaults, e);
    let { transitional: n, paramsSerializer: i, headers: r } = e;
    n !== void 0 && yE.assertOptions(n, { silentJSONParsing: Fr.transitional(Fr.boolean), forcedJSONParsing: Fr.transitional(Fr.boolean), clarifyTimeoutError: Fr.transitional(Fr.boolean) }, false), i != null && (K.isFunction(i) ? e.paramsSerializer = { serialize: i } : yE.assertOptions(i, { encode: Fr.function, serialize: Fr.function }, true)), e.method = (e.method || this.defaults.method || "get").toLowerCase();
    let o = r && K.merge(r.common, r[e.method]);
    r && K.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (p) => {
      delete r[p];
    }), e.headers = Dr.concat(o, r);
    let s = [], a = true;
    this.interceptors.request.forEach(function(p) {
      typeof p.runWhen == "function" && p.runWhen(e) === false || (a = a && p.synchronous, s.unshift(p.fulfilled, p.rejected));
    });
    let c = [], d;
    this.interceptors.response.forEach(function(p) {
      c.push(p.fulfilled, p.rejected);
    });
    let l, u = 0;
    if (!a) {
      let p = [rR.bind(this), void 0];
      for (p.unshift.apply(p, s), p.push.apply(p, c), l = p.length, d = j.resolve(e); u < l; ) d = d.then(p[u++], p[u++]);
      return d;
    }
    l = s.length;
    let h = e;
    for (u = 0; u < l; ) {
      let p = s[u++], g = s[u++];
      try {
        h = p(h);
      } catch (E) {
        g.call(this, E);
        break;
      }
    }
    try {
      d = rR.call(this, h);
    } catch (p) {
      return j.reject(p);
    }
    for (u = 0, l = c.length; u < l; ) d = d.then(c[u++], c[u++]);
    return d;
  }
  getUri(t11) {
    return fw(uO((t11 = Qs(this.defaults, t11)).baseURL, t11.url), t11.params, t11.paramsSerializer);
  }
};
K.forEach(["delete", "get", "head", "options"], function(t11) {
  ml.prototype[t11] = function(e, n) {
    return this.request(Qs(n || {}, { method: t11, url: e, data: (n || {}).data }));
  };
}), K.forEach(["post", "put", "patch"], function(t11) {
  function e(n) {
    return function(i, r, o) {
      return this.request(Qs(o || {}, { method: t11, headers: n ? { "Content-Type": "multipart/form-data" } : {}, url: i, data: r }));
    };
  }
  ml.prototype[t11] = e(), ml.prototype[t11 + "Form"] = e(true);
});
var fl = ml;
var AE = class t3 {
  constructor(e) {
    if (typeof e != "function") throw new TypeError("executor must be a function.");
    let n;
    this.promise = new j(function(r) {
      n = r;
    });
    let i = this;
    this.promise.then((r) => {
      if (!i._listeners) return;
      let o = i._listeners.length;
      for (; o-- > 0; ) i._listeners[o](r);
      i._listeners = null;
    }), this.promise.then = (r) => {
      let o, s = new j((a) => {
        i.subscribe(a), o = a;
      }).then(r);
      return s.cancel = function() {
        i.unsubscribe(o);
      }, s;
    }, e(function(r, o, s) {
      i.reason || (i.reason = new od(r, o, s), n(i.reason));
    });
  }
  throwIfRequested() {
    if (this.reason) throw this.reason;
  }
  subscribe(e) {
    this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  unsubscribe(e) {
    if (!this._listeners) return;
    let n = this._listeners.indexOf(e);
    n !== -1 && this._listeners.splice(n, 1);
  }
  static source() {
    let e;
    return { token: new t3(function(n) {
      e = n;
    }), cancel: e };
  }
};
var hB = AE;
var bE = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 };
Object.entries(bE).forEach((t11) => {
  let [e, n] = t11;
  bE[n] = e;
});
var pB = bE;
var Xe = function t4(e) {
  let n = new fl(e), i = _w(fl.prototype.request, n);
  return K.extend(i, fl.prototype, n, { allOwnKeys: true }), K.extend(i, n, null, { allOwnKeys: true }), i.create = function(r) {
    return t4(Qs(e, r));
  }, i;
}(cf);
Xe.Axios = fl, Xe.CanceledError = od, Xe.CancelToken = hB, Xe.isCancel = lO, Xe.VERSION = pO, Xe.toFormData = Ul, Xe.AxiosError = qt, Xe.Cancel = Xe.CanceledError, Xe.all = function(t11) {
  return j.all(t11);
}, Xe.spread = function(t11) {
  return function(e) {
    return t11.apply(null, e);
  };
}, Xe.isAxiosError = function(t11) {
  return K.isObject(t11) && t11.isAxiosError === true;
}, Xe.mergeConfig = Qs, Xe.AxiosHeaders = Dr, Xe.formToJSON = (t11) => dO(K.isHTMLForm(t11) ? new FormData(t11) : t11), Xe.getAdapter = hO.getAdapter, Xe.HttpStatusCode = pB, Xe.default = Xe;
var mn = Xe;
var _B = () => {
};
function vc() {
  let t11 = { promise: void 0, isResolved: false, isRejected: false, isFinished: false, resolve: void 0, reject: void 0, cancel: _B };
  return t11.promise = new j((e, n) => {
    t11.resolve = (i) => {
      t11.isFinished || (t11.isResolved = true, t11.isFinished = true, e(i), t11.value = i);
    }, t11.reject = (i) => {
      t11.isFinished || (t11.isRejected = true, t11.isFinished = true, n(i));
    };
  }), t11;
}
var bd = /* @__PURE__ */ new Map();
var wd = /* @__PURE__ */ new Map();
var Yi = /* @__PURE__ */ new Map();
var ye = function(t11) {
  return t11.WIN_10 = "Windows 10", t11.WIN_81 = "Windows 8.1", t11.WIN_8 = "Windows 8", t11.WIN_7 = "Windows 7", t11.WIN_VISTA = "Windows Vista", t11.WIN_SERVER_2003 = "Windows Server 2003", t11.WIN_XP = "Windows XP", t11.WIN_2000 = "Windows 2000", t11.ANDROID = "Android", t11.HARMONY_OS = "HarmonyOS", t11.OPEN_BSD = "Open BSD", t11.SUN_OS = "Sun OS", t11.LINUX = "Linux", t11.IOS = "iOS", t11.MAC_OS = "Mac OS", t11.CHROMIUM_OS = "Chromium OS", t11.QNX = "QNX", t11.UNIX = "UNIX", t11.BEOS = "BeOS", t11.OS_2 = "OS/2", t11.SEARCH_BOT = "Search Bot", t11;
}({});
var It = function(t11) {
  return t11.CHROME = "Chrome", t11.SAFARI = "Safari", t11.EDGE = "Edge", t11.FIREFOX = "Firefox", t11.OPERA = "OPR", t11.QQ = "QQBrowser", t11.WECHAT = "MicroMessenger", t11;
}({});
var wE = new W2();
var Vi = wE.getResult();
var Ap = null;
function mt(t11) {
  if (!Ap) {
    Vi = wE.getResult();
    let e = function(a) {
      if (a.engine.name === "Blink" && a.browser.name !== "WeChat") return It.CHROME;
      switch (a.browser.name) {
        case "Chrome Headless":
        case "Chrome":
        case "Chromium":
          return It.CHROME;
        case "Safari":
        case "Mobile Safari":
          return It.SAFARI;
        case "Edge":
          return It.EDGE;
        case "Firefox":
          return It.FIREFOX;
        case "QQ":
        case "QQBrowser":
          return It.QQ;
        case "Opera":
          return It.OPERA;
        case "WeChat":
          return It.WECHAT;
        default:
          return a.browser.name || "";
      }
    }(Vi), n = cR(Vi), i = function(a) {
      return a.os.name === "Windows" ? a.os.version ? a.os.name + " " + a.os.version : a.os.name : a.os.name || "";
    }(Vi), r = Vi.os.version, o = cR(Vi, false), s = Vi.device.type;
    if (!(e && n && i && r)) return { name: e, version: n, os: i, osVersion: r, browserVersion: o, deviceType: s };
    Ap = { name: e, version: n, os: i, osVersion: r, browserVersion: o, deviceType: s };
  }
  return Ap;
}
function cR(t11) {
  let e, n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
  return e = t11.engine.name === "Blink" ? t11.engine.version || "" : t11.browser.version || "", n ? e.split(".")[0] : e;
}
function Hu() {
  return mt().os;
}
function dR() {
  let t11 = mt();
  return "".concat(t11.os, " ").concat(t11.osVersion);
}
function Gl() {
  let t11 = mt();
  return !!(Vi.engine.name === "WebKit" && t11.os === ye.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && t11.name !== It.SAFARI || ln() && t11.name !== It.SAFARI);
}
function oo() {
  return mt().name === It.CHROME;
}
function je() {
  return mt().name === It.SAFARI;
}
function _O() {
  return mt().name === It.EDGE;
}
function $t() {
  return mt().name === It.FIREFOX;
}
function ln() {
  return mt().os === ye.IOS;
}
function OE(t11) {
  let e = mt();
  return !(e.name !== It.CHROME || !e.osVersion) && Number(e.version) >= t11;
}
function EO(t11) {
  let e = mt();
  return !(e.name !== It.CHROME || !e.osVersion) && Number(e.version) < t11;
}
function lR(t11) {
  let e = mt();
  return !(e.name !== It.EDGE || !e.osVersion) && Number(e.version) >= t11;
}
function mO(t11) {
  let e = mt();
  return !(e.name !== It.SAFARI || !e.osVersion) && Number(e.version) >= t11;
}
function fO(t11, e, n) {
  let i = mt();
  if (i.os !== ye.IOS || !i.osVersion) return false;
  let r = i.osVersion.split(".");
  return e && Number(r[0]) === t11 && Number(r[1]) < e || Number(r[0]) < t11;
}
function gO(t11, e, n) {
  let i = mt();
  if (i.name !== It.SAFARI || !i.osVersion || !i.browserVersion) return false;
  let r = i.browserVersion.split(".");
  return e && Number(r[0]) === t11 && Number(r[1]) < e || Number(r[0]) < t11;
}
function uR(t11) {
  let e = mt();
  return !(e.name !== It.OPERA || !e.osVersion) && Number(e.version) >= t11;
}
function hR() {
  let t11 = mt();
  if (t11.os !== ye.IOS || !t11.osVersion) return false;
  let e = t11.osVersion.split(".");
  return Number(e[0]) < 14 || Number(e[0]) === 14 && Number(e[1]) <= 6;
}
function Zs() {
  let t11 = mt();
  if (t11.os !== ye.IOS || !t11.osVersion) return false;
  let e = t11.osVersion.split(".");
  return Number(e[0]) === 15;
}
function NE() {
  let t11 = mt();
  if (t11.os !== ye.IOS || !t11.osVersion) return false;
  let e = t11.osVersion.split(".");
  return Number(e[0]) === 16;
}
function pR() {
  let t11 = mt();
  if (t11.os !== ye.IOS || !t11.osVersion) return false;
  let e = t11.osVersion.split(".");
  return Number(e[0]) === 15 && Number(e[1]) >= 1;
}
function vi() {
  return je() && navigator.maxTouchPoints > 0;
}
function TO() {
  return mt().name === It.WECHAT;
}
function SO() {
  return window.navigator.appVersion && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) !== null && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
}
function lf() {
  let t11 = Hu();
  return function() {
    let { deviceType: e } = mt();
    return e === "mobile" || e === "tablet";
  }() || t11 === ye.ANDROID || t11 === ye.IOS || t11 === ye.HARMONY_OS;
}
function ho() {
  let t11 = mt();
  return t11.name !== It.EDGE && t11.name !== It.SAFARI && !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i);
}
function Ku() {
  return Hu() === ye.ANDROID;
}
function yc() {
  let t11 = mt();
  return Ku() && (t11.name === It.CHROME || t11.name === It.WECHAT || /chrome|chromium/i.test(navigator.userAgent));
}
function jt(t11, e, n) {
  return (e = function(i) {
    var r = function(o, s) {
      if (typeof o != "object" || !o) return o;
      var a = o[Symbol.toPrimitive];
      if (a !== void 0) {
        var c = a.call(o, "string");
        if (typeof c != "object") return c;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(o);
    }(i);
    return typeof r == "symbol" ? r : r + "";
  }(e)) in t11 ? Object.defineProperty(t11, e, { value: n, enumerable: true, configurable: true, writable: true }) : t11[e] = n, t11;
}
function _R(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function J(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? _R(Object(n), true).forEach(function(i) {
      jt(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : _R(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var R = function(t11) {
  return t11.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", t11.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", t11.TIMEOUT = "TIMEOUT", t11.INVALID_PARAMS = "INVALID_PARAMS", t11.NOT_READABLE = "NOT_READABLE", t11.NOT_SUPPORTED = "NOT_SUPPORTED", t11.INVALID_OPERATION = "INVALID_OPERATION", t11.OPERATION_ABORTED = "OPERATION_ABORTED", t11.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", t11.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", t11.ADD_CANDIDATE_FAILED = "ADD_CANDIDATE_FAILED", t11.DATACHANNEL_FAILED = "DATACHANNEL_FAILED", t11.NETWORK_ERROR = "NETWORK_ERROR", t11.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", t11.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", t11.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", t11.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", t11.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", t11.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", t11.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", t11.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", t11.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", t11.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", t11.PERMISSION_DENIED = "PERMISSION_DENIED", t11.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", t11.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", t11.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", t11.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", t11.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", t11.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", t11.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", t11.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", t11.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", t11.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", t11.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", t11.UID_CONFLICT = "UID_CONFLICT", t11.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", t11.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", t11.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", t11.INVALID_TRACK = "INVALID_TRACK", t11.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", t11.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", t11.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", t11.ICE_FAILED = "ICE_FAILED", t11.PC_CLOSED = "PC_CLOSED", t11.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", t11.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", t11.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", t11.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", t11.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", t11.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", t11.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", t11.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", t11.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", t11.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", t11.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", t11.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", t11.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", t11.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", t11.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", t11.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", t11.WS_ABORT = "WS_ABORT", t11.WS_DISCONNECT = "WS_DISCONNECT", t11.WS_ERR = "WS_ERR", t11.EXTERNAL_SIGNAL_ABORT = "EXTERNAL_SIGNAL_ABORT", t11.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", t11.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", t11.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", t11.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", t11.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", t11.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", t11.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", t11.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", t11.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", t11.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", t11.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", t11.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", t11.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", t11.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", t11.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", t11.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", t11.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", t11.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", t11.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", t11.INVALID_PLUGIN = "INVALID_PLUGIN", t11.DISCONNECT_P2P = "DISCONNECT_P2P", t11.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", t11.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", t11.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", t11.CREATE_DATACHANNEL_ERROR = "CREATE_DATACHANNEL_ERROR", t11.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT", t11.PROHIBITED_OPERATION = "PROHIBITED_OPERATION", t11.IMAGE_MODERATION_UPLOAD_FAILED = "IMAGE_MODERATION_UPLOAD_FAILED", t11.P2P_MESSAGE_FAILED = "P2P_MESSAGE_FAILED", t11;
}({});
var N = class extends Error {
  constructor(t11) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", n = arguments.length > 2 ? arguments[2] : void 0;
    super(e), jt(this, "code", void 0), jt(this, "message", void 0), jt(this, "data", void 0), jt(this, "name", "AgoraRTCException"), this.code = t11, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(e), this.data = n;
  }
  toString() {
    return this.data ? "data: ".concat(JSON.stringify(this.data), `
`).concat(this.stack) : "".concat(this.stack);
  }
  print() {
    let t11 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "error", e = arguments.length > 1 ? arguments[1] : void 0;
    return t11 === "error" && (e || console).error(this.toString()), t11 === "warning" && (e || console).warn(this.toString()), this;
  }
  throw(t11) {
    throw this.print("error", t11), this;
  }
};
function Nr(t11, e) {
  if (typeof t11 != "boolean") throw new N(R.INVALID_PARAMS, "Invalid ".concat(e, ": The value is of the boolean type."));
}
function Ce(t11, e, n) {
  if (!W(n).call(n, t11)) throw new N(R.INVALID_PARAMS, "".concat(e, " can only be set as ").concat(JSON.stringify(n)));
}
function Nt(t11, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1e4;
  if (t11 < n || t11 > i || (!(arguments.length > 4 && arguments[4] !== void 0) || arguments[4]) && !function(r) {
    return typeof r == "number" && r % 1 == 0;
  }(t11)) throw new N(R.INVALID_PARAMS, "invalid ".concat(e, ": the value range is [").concat(n, ", ").concat(i, "]. integer only"));
}
function bp(t11, e) {
  if (typeof t11 != "number") {
    if (!(t11.min || t11.max || t11.ideal || t11.exact)) throw new N(R.INVALID_PARAMS, "".concat(e, " is not a valid ConstrainLong"));
    t11.min !== void 0 && Nt(t11.min, "".concat(e, ".min"), 0, 1 / 0), t11.max !== void 0 && Nt(t11.max, "".concat(e, ".max"), 1, 1 / 0), t11.exact !== void 0 && Nt(t11.exact, "".concat(e, ".exact"), 1, 1 / 0), t11.ideal !== void 0 && Nt(t11.ideal, "".concat(e, ".ideal"), 1, 1 / 0);
  } else Nt(t11, e, 1, 1 / 0);
}
function Pe(t11, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 255, r = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4];
  if (t11 == null) throw new N(R.INVALID_PARAMS, "".concat(e || "param", " cannot be empty"));
  if (!RO(t11, n, i, r)) throw new N(R.INVALID_PARAMS, "Invalid ".concat(e || "string param", ": Length of the string: [").concat(n, ",").concat(i, "].").concat(r ? " ASCII characters only." : ""));
}
function br(t11, e) {
  if (!Array.isArray(t11)) throw new N(R.INVALID_PARAMS, "".concat(e, " should be an array"));
}
function zt(t11) {
  return t11 == null;
}
function RO(t11) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 255, i = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
  return typeof t11 == "string" && t11.length <= n && t11.length >= e && (!i || function(r) {
    if (typeof r != "string") return false;
    for (let o = 0; o < r.length; o += 1) {
      let s = r.charCodeAt(o);
      if (s < 0 || s > 255) return false;
    }
    return true;
  }(t11));
}
var Ka = function(t11) {
  return t11.COVERED = "COVERED", t11.POSITION = "POSITION", t11.SIZE = "SIZE", t11.STYLE = "STYLE", t11;
}(Ka || {});
var DE = function(t11) {
  return t11.UNMOUNTED = "UNMOUNTED", t11.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT", t11;
}(DE || {});
var CO = new class {
  constructor() {
    jt(this, "_clientSize", null), jt(this, "getClientWidth", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), jt(this, "getClientHeight", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), jt(this, "getStyle", (t11) => window.getComputedStyle(t11, null)), jt(this, "checkCssVisibleProperty", (t11) => {
      var e;
      let n = true, i = this.getStyle(t11), { display: r, visibility: o, opacity: s, filter: a } = i;
      return (r === "none" || W(e = ["hidden", "collapse"]).call(e, o) || Number(s) < 0.1) && (n = false), !!n && (a && a.split(" ").filter((c) => {
        var d;
        let l = c.split("(")[0];
        return W(d = ["brightness", "blur", "opacity"]).call(d, l);
      }).map((c) => {
        let [d, l] = c.split(/\(|\)/);
        return [d, Number(l.match(/^[0-9\.]+/))];
      }).forEach((c) => {
        let [d, l] = c;
        switch (d) {
          case "brightness":
            (l < 0.1 || l > 3) && (n = false);
            break;
          case "blur":
            l > 3 && (n = false);
            break;
          case "opacity":
            l < 0.1 && (n = false);
        }
      }), n);
    }), jt(this, "checkPropertyUpToAllParentNodes", (t11, e) => {
      let n = true, i = true, r = (s) => e(s), o = t11;
      for (; o && i; ) r(o) || (n = false, i = false), o = o.parentElement, o || (i = false);
      return n;
    }), jt(this, "checkActualCssVisibleIncludeInherit", (t11) => this.checkPropertyUpToAllParentNodes(t11, this.checkCssVisibleProperty)), jt(this, "getSizeAboutClient", (t11) => {
      let { width: e, height: n, left: i, right: r, top: o, bottom: s } = t11.getBoundingClientRect(), a = this.getClientWidth(), c = this.getClientHeight();
      return { width: e, height: n, left: i, right: r, top: o, bottom: s, clientWidth: a, clientHeight: c, clientMin: Math.min(a, c) };
    }), jt(this, "checkActualSize", () => {
      let { width: t11, height: e, clientMin: n } = this._clientSize;
      return this.checkSizeIsVisible(t11, e, n);
    }), jt(this, "elementFromPoint", (t11, e) => document.elementFromPoint ? document.elementFromPoint(t11, e) : null), jt(this, "checkCoverForAPoint", (t11, e, n) => {
      let i = this.elementFromPoint(t11, e);
      return i !== null && i !== n;
    }), jt(this, "getPointPositionList", () => {
      let { width: t11, height: e, left: n, top: i } = this._clientSize, r = t11 / 6, o = e / 6, s = [], a = 10 ** 6;
      for (let c = 0; c < 5; c++) for (let d = 0; d < 5; d++) {
        let l = (n * a + (c === 0 ? 0.1 : c === 4 ? (r * c * a - 1e5) / a : r * c) * a) / a, u = (i * a + (d === 0 ? 0.1 : d === 4 ? (o * d * a - 1e5) / a : o * d) * a) / a;
        s.push({ x: l, y: u });
      }
      return [...s];
    }), jt(this, "checkElementCover", (t11) => this.getPointPositionList().map((e) => this.checkCoverForAPoint(e.x, e.y, t11)).filter((e) => !!e).length > 6), jt(this, "checkSizeIsVisible", (t11, e, n) => (t11 > 50 || n / t11 <= 10) && (e > 50 || n / e <= 10)), jt(this, "checkSizeOfPartInClient", () => {
      let { left: t11, right: e, top: n, bottom: i, clientHeight: r, clientWidth: o, clientMin: s } = this._clientSize, a, c, d, l;
      if (t11 < 0) a = 0;
      else {
        if (!(t11 < o)) return false;
        a = t11;
      }
      if (e < 0) return false;
      if (c = e < o ? e : o, n < 0) d = 0;
      else {
        if (!(n < r)) return false;
        d = n;
      }
      if (i < 0) return false;
      l = i < r ? i : r;
      let u = c - a, h = l - d;
      return this.checkSizeIsVisible(u, h, s);
    }), jt(this, "returnHiddenResult", (t11) => (this._clientSize = null, { visible: false, reason: t11 })), jt(this, "checkOneElementVisible", (t11) => {
      if (t11 instanceof HTMLElement) {
        if (this.checkElementIsMountedOnDom(t11)) {
          if (this.checkActualCssVisibleIncludeInherit(t11)) {
            if (this._clientSize = this.getSizeAboutClient(t11), this.checkElementCover(t11)) return this.returnHiddenResult(Ka.COVERED);
            {
              let e = this.checkActualSize(), n = this.checkSizeOfPartInClient();
              return e && !n ? this.returnHiddenResult(Ka.POSITION) : e ? (this._clientSize = null, { visible: true }) : this.returnHiddenResult(Ka.SIZE);
            }
          }
          return this.returnHiddenResult(Ka.STYLE);
        }
        return this.returnHiddenResult(DE.UNMOUNTED);
      }
      return this.returnHiddenResult(DE.INVALID_HTML_ELEMENT);
    }), jt(this, "checkElementIsMountedOnDom", (t11) => this.checkPropertyUpToAllParentNodes(t11, (e) => e.nodeName.toUpperCase() !== "HTML" ? e.parentElement !== null : !!document.documentElement));
  }
}();
function uf(t11) {
  return new TextEncoder().encode(t11);
}
var ER = function(t11, e) {
  let n = new Uint8Array(t11.byteLength + e.byteLength);
  return n.set(new Uint8Array(t11), 0), n.set(new Uint8Array(e), t11.byteLength), n;
};
var PE = async (t11) => function(e, n) {
  let i = "";
  return new Uint8Array(e).forEach((r) => {
    i += r.toString(n).padStart(2, "0");
  }), i;
}(await crypto.subtle.digest("SHA-256", uf(t11)), 16);
var Xt = class {
  constructor() {
    jt(this, "_events", {}), jt(this, "addListener", this.on);
  }
  getListeners(t11) {
    return this._events[t11] ? this._events[t11].map((e) => e.listener) : [];
  }
  on(t11, e) {
    this._events[t11] || (this._events[t11] = []);
    let n = this._events[t11];
    this._indexOfListener(n, e) === -1 && n.push({ listener: e, once: false });
  }
  once(t11, e) {
    this._events[t11] || (this._events[t11] = []);
    let n = this._events[t11];
    this._indexOfListener(n, e) === -1 && n.push({ listener: e, once: true });
  }
  off(t11, e) {
    if (!this._events[t11]) return;
    let n = this._events[t11], i = this._indexOfListener(n, e);
    i !== -1 && n.splice(i, 1), this._events[t11].length === 0 && delete this._events[t11];
  }
  removeAllListeners(t11) {
    t11 ? delete this._events[t11] : this._events = {};
  }
  emit(t11) {
    this._events[t11] || (this._events[t11] = []);
    let e = this._events[t11].map((o) => o);
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
    for (let o = 0; o < e.length; o += 1) {
      let s = e[o];
      s.once && this.off(t11, s.listener), s.listener.apply(this, i || []);
    }
  }
  safeEmit(t11) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
    [...this._events[t11] || []].forEach((r) => {
      r.once && this.off(t11, r.listener);
      try {
        r.listener.apply(this, n);
      } catch (o) {
        console.error("safeEmit event:".concat(t11, " error ").concat(o == null ? void 0 : o.toString()));
      }
    });
  }
  _indexOfListener(t11, e) {
    let n = t11.length;
    for (; n--; ) if (t11[n].listener === e) return n;
    return -1;
  }
};
var Pa = null;
function IO() {
  if (Pa) return Pa;
  if (window.electron) return Pa = window.electron;
  if (!window.require) return null;
  try {
    return Pa = window.require("electron"), Pa;
  } catch {
    return null;
  }
}
var Te = function(t11) {
  return t11.CREATE_CLIENT = "createClient", t11.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", t11.SET_AREA = "setArea", t11.PRELOAD = "PRELOAD", t11.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", t11.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", t11.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", t11.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", t11.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", t11.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", t11.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", t11.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", t11.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", t11.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", t11.START_PROXY_SERVER = "Client.startProxyServer", t11.STOP_PROXY_SERVER = "Client.stopProxyServer", t11.SET_PROXY_SERVER = "Client.setProxyServer", t11.SET_TURN_SERVER = "Client.setTurnServer", t11.SET_CLIENT_ROLE = "Client.setClientRole", t11.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", t11.ENABLE_DUAL_STREAM = "Client.enableDualStream", t11.DISABLE_DUAL_STREAM = "Client.disableDualStream", t11.JOIN = "Client.join", t11.LEAVE = "Client.leave", t11.PUBLISH = "Client.publish", t11.UNPUBLISH = "Client.unpublish", t11.SUBSCRIBE = "Client.subscribe", t11.MASS_SUBSCRIBE = "Client.massSubscribe", t11.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", t11.UNSUBSCRIBE = "Client.unsubscribe", t11.RENEW_TOKEN = "Client.renewToken", t11.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", t11.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", t11.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", t11.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", t11.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent", t11.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent", t11.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", t11.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", t11.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", t11.START_LIVE_STREAMING = "Client.startLiveStreaming", t11.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", t11.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", t11.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", t11.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", t11.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", t11.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", t11.SET_CONFIG_DISTRIBUTE = "_configDistribute", t11.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", t11.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", t11.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", t11.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", t11.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", t11.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", t11.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", t11.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", t11.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", t11.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", t11.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", t11.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", t11.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", t11.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", t11.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", t11.LOCAL_VIDEO_SEND_SEI_DATA = "LocalVideoTrack.sendSeiData", t11.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", t11.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", t11.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", t11.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", t11.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", t11.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", t11.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", t11.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", t11.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", t11.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", t11.STREAM_TYPE_CHANGE = "streamTypeChange", t11.CONNECTION_STATE_CHANGE = "connectionStateChange", t11.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage", t11.IMAGE_MODERATION_UPLOAD = "imageModerationUpload", t11;
}({});
var Zt = function(t11) {
  return t11.TRACER = "tracer", t11;
}({});
function mR(t11) {
  return Nt(t11.timeout, "config.timeout", 0, 1e5), Nt(t11.timeoutFactor, "config.timeoutFactor", 0, 100, false), Nt(t11.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), Nt(t11.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), true;
}
var EB = function(t11) {
  return t11[t11.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", t11[t11.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", t11[t11.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY", t11;
}({});
var At = function(t11) {
  return t11.LEAVE = "LEAVE", t11.NETWORK_ERROR = "NETWORK_ERROR", t11.SERVER_ERROR = "SERVER_ERROR", t11.UID_BANNED = "UID_BANNED", t11.FALLBACK = "FALLBACK", t11.IP_BANNED = "IP_BANNED", t11.CHANNEL_BANNED = "CHANNEL_BANNED", t11.LICENSE_MISSING = "LICENSE_MISSING", t11.LICENSE_EXPIRED = "LICENSE_EXPIRED", t11.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED", t11.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID", t11.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE", t11.LICENSE_ILLEGAL = "LICENSE_ILLEGAL", t11.TOKEN_EXPIRE = "TOKEN_EXPIRE", t11;
}({});
function Yu(t11) {
  if (!Array.isArray(t11) || t11.length < 1) return false;
  try {
    t11.forEach((e) => {
      if (!e.urls) throw Error();
    });
  } catch {
    return false;
  }
  return true;
}
function vO(t11) {
  return Pe(t11.turnServerURL, "turnServerURL"), Pe(t11.username, "username"), Pe(t11.password, "password"), t11.udpport && Nt(t11.udpport, "udpport", 1, 99999, true), t11.forceturn && Nr(t11.forceturn, "forceturn"), t11.security && Nr(t11.security, "security"), t11.tcpport && Nt(t11.tcpport, "tcpport", 1, 99999, true), true;
}
function fR(t11) {
  return t11.level !== void 0 && Ce(t11.level, "level", [1, 2, 3]), t11.delay !== void 0 && Nt(t11.delay, "delay", 0, 3e3, true), true;
}
var ut = function(t11) {
  return t11.CONNECTION_STATE_CHANGE = "connection-state-change", t11.MEDIA_RECONNECT_START = "media-reconnect-start", t11.MEDIA_RECONNECT_END = "media-reconnect-end", t11.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", t11.USER_JOINED = "user-joined", t11.USER_LEAVED = "user-left", t11.USER_PUBLISHED = "user-published", t11.USER_UNPUBLISHED = "user-unpublished", t11.USER_INFO_UPDATED = "user-info-updated", t11.CLIENT_BANNED = "client-banned", t11.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", t11.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", t11.VOLUME_INDICATOR = "volume-indicator", t11.CRYPT_ERROR = "crypt-error", t11.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", t11.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", t11.NETWORK_QUALITY = "network-quality", t11.STREAM_TYPE_CHANGED = "stream-type-changed", t11.STREAM_FALLBACK = "stream-fallback", t11.RECEIVE_METADATA = "receive-metadata", t11.STREAM_MESSAGE = "stream-message", t11.LIVE_STREAMING_ERROR = "live-streaming-error", t11.LIVE_STREAMING_WARNING = "live-streaming-warning", t11.EXCEPTION = "exception", t11.ERROR = "error", t11.P2P_LOST = "p2p_lost", t11.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", t11.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket", t11.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", t11.PUBLISHED_USER_LIST = "published-user-list", t11.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = "content-inspect-connection-state-change", t11.CONTENT_INSPECT_ERROR = "content-inspect-error", t11.CONTENT_INSPECT_RESULT = "content-inspect-result", t11.IMAGE_MODERATION_CONNECTION_STATE_CHANGE = "image-moderation-connection-state-change", t11;
}({});
var Be = function(t11) {
  return t11.NETWORK_ERROR = "NETWORK_ERROR", t11.SERVER_ERROR = "SERVER_ERROR", t11.MULTI_IP = "MULTI_IP", t11.TIMEOUT = "TIMEOUT", t11.OFFLINE = "OFFLINE", t11.LEAVE = "LEAVE", t11.P2P_FAILED = "P2P_FAILED", t11.FALLBACK = "FALLBACK", t11;
}({});
var wn = function(t11) {
  return t11.ONLINE = "ONLINE", t11.OFFLINE = "OFFLINE", t11;
}({});
var ks = function(t11) {
  return t11.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", t11.ONLINE = "ONLINE", t11.OFFLINE = "OFFLINE", t11;
}({});
function Ge(t11, e) {
  for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) i[r - 2] = arguments[r];
  return t11.getListeners(e).length === 0 ? j.reject(new N(R.UNEXPECTED_ERROR, "can not emit promise")) : new j((o, s) => {
    t11.emit(e, ...i, o, s);
  });
}
function kt(t11, e) {
  if (t11.getListeners(e).length === 0) return j.resolve();
  for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) i[r - 2] = arguments[r];
  return Ge(t11, e, ...i);
}
function ni(t11, e) {
  if (t11.getListeners(e).length === 0) return null;
  for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) i[r - 2] = arguments[r];
  return Ac(t11, e, ...i);
}
function Ac(t11, e) {
  let n = null, i = null;
  for (var r = arguments.length, o = new Array(r > 2 ? r - 2 : 0), s = 2; s < r; s++) o[s - 2] = arguments[s];
  if (t11.emit(e, ...o, (a) => {
    n = a;
  }, (a) => {
    i = a;
  }), i !== null) throw i;
  if (n === null) throw new N(R.UNEXPECTED_ERROR, "handler is not sync");
  return n;
}
var he = new class extends Xt {
  set networkState(t11) {
    this.emit(ks.NETWORK_STATE_CHANGE, t11, this._networkState), t11 === wn.ONLINE ? this.emit(ks.ONLINE) : t11 === wn.OFFLINE && (this.onlineWaiter = new j((e) => {
      this.once(ks.ONLINE, () => {
        this.onlineWaiter = void 0, e(wn.ONLINE);
      });
    }), this.emit(ks.OFFLINE)), this._networkState = t11;
  }
  get networkState() {
    return this._networkState;
  }
  get isOnline() {
    return this._networkState === wn.ONLINE;
  }
  constructor() {
    super(), jt(this, "_moduleName", "network-indicator"), jt(this, "_networkState", wn.ONLINE), jt(this, "onlineWaiter", void 0), window.addEventListener("online", () => {
      this.networkState = wn.ONLINE;
    }), window.addEventListener("offline", () => {
      this.networkState = wn.OFFLINE;
    });
  }
}();
function Wl(t11, e) {
  let n = t11.indexOf(e);
  n !== -1 && t11.splice(n, 1);
}
function Ls(t11) {
  let e = [];
  return t11.forEach((n) => {
    e.indexOf(n) === -1 && e.push(n);
  }), e;
}
function qu(t11) {
  j !== void 0 ? j.resolve().then(t11) : setTimeout(t11, 0);
}
function le(t11) {
  return JSON.parse(JSON.stringify(t11));
}
function Vo(t11) {
  try {
    return le(t11);
  } catch {
    return t11;
  }
}
var gR = {};
function po(t11, e) {
  gR[e] || (gR[e] = true, t11());
}
function Fo(t11) {
  let e = window.atob(t11), n = new Uint8Array(new ArrayBuffer(e.length));
  for (let i = 0; i < e.length; i += 1) n[i] = e.charCodeAt(i);
  return n;
}
function so(t11) {
  let e = "";
  for (let n = 0; n < t11.length; n += 1) e += String.fromCharCode(t11[n]);
  return window.btoa(e);
}
function yO(t11) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16, n = new TextEncoder().encode(t11);
  if (n.length > e) n = n.slice(0, e);
  else if (n.length < e) {
    let i = new Uint8Array(e);
    i.set(n), n = i;
  }
  return n;
}
function TR() {
  for (var t11 = arguments.length, e = new Array(t11), n = 0; n < t11; n++) e[n] = arguments[n];
  let i = ji(e).call(e, (s, a) => s + a.length, 0), r = new Uint8Array(new ArrayBuffer(i)), o = 0;
  return e.forEach((s) => {
    r.set(s, o), o += s.length;
  }), r;
}
function ar(t11) {
  return window.TextEncoder ? new TextEncoder().encode(t11).length : t11.length;
}
function AO(t11) {
  let e = 0;
  return (/DingTalk/i.test(navigator.userAgent) || /AliApp/i.test(navigator.userAgent)) && t11.realFormData && (t11 = t11.realFormData), t11.forEach((n) => {
    e += typeof n == "string" ? ar(n) : n.size;
  }), e + 138;
}
function mB(t11) {
  let e = new N(R.TIMEOUT, "timeout");
  return new j((n, i) => {
    window.setTimeout(() => i(e), t11);
  });
}
function Me(t11) {
  return new j((e) => {
    window.setTimeout(e, t11);
  });
}
function Ut() {
  let t11 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 7, e = arguments.length > 1 ? arguments[1] : void 0, n = Math.random().toString(16).substr(2, t11).toLowerCase();
  return n.length === t11 ? "".concat(e).concat(n) : "".concat(e).concat(n) + Ut(t11 - n.length, "");
}
function Ms() {
  return Ut(32, "").toUpperCase();
}
var zu = () => {
};
var SR = new class {
  constructor() {
    jt(this, "fnMap", /* @__PURE__ */ new Map());
  }
  throttleByKey(t11, e, n, i) {
    for (var r = arguments.length, o = new Array(r > 4 ? r - 4 : 0), s = 4; s < r; s++) o[s - 4] = arguments[s];
    if (this.fnMap.has(e)) {
      let a = this.fnMap.get(e);
      if (a.threshold !== n) {
        a.fn(...a.args), clearTimeout(a.timer);
        let c = window.setTimeout(() => {
          let d = this.fnMap.get(e);
          d && d.fn(...d.args), this.fnMap.delete(e);
        }, n);
        this.fnMap.set(e, { fn: t11, threshold: n, timer: c, args: o, skipFn: i });
      } else a.skipFn && a.skipFn(...a.args), this.fnMap.set(e, J(J({}, a), {}, { fn: t11, args: o, skipFn: i }));
    } else {
      let a = window.setTimeout(() => {
        let c = this.fnMap.get(e);
        c && c.fn(...c.args), this.fnMap.delete(e);
      }, n);
      this.fnMap.set(e, { fn: t11, threshold: n, timer: a, args: o, skipFn: i });
    }
  }
}();
var RR = SR.throttleByKey.bind(SR);
function CR(t11) {
  return typeof t11 == "object" && t11 !== null && !(t11 instanceof RegExp);
}
function kE(t11, e) {
  if (!CR(t11) || !CR(e) || Array.isArray(t11) && !Array.isArray(e) || !Array.isArray(t11) && Array.isArray(e)) return e;
  if (Array.isArray(e) && Array.isArray(t11)) {
    let n = [...t11];
    for (let i = 0; i < e.length; i++) n[i] = kE(t11[i], e[i]);
    return n;
  }
  {
    let n = J({}, t11);
    for (let i in e) Object.prototype.hasOwnProperty.call(e, i) && (Object.prototype.hasOwnProperty.call(t11, i) ? n[i] = kE(t11[i], e[i]) : n[i] = e[i]);
    return n;
  }
}
function IR(t11, e) {
  let n = [0];
  if (n = new Array(e).fill(0), t11 === 0) return n;
  let i = 0;
  for (; t11 > 0 && (n[i] = 255 & t11, t11 >>= 8, i++, i !== e); ) ;
  return n;
}
function wp(t11) {
  return typeof t11 == "number" ? t11 : t11.exact || t11.ideal || t11.max || t11.min || 0;
}
function bO(t11) {
  let e = "0123456789abcdef";
  function n(A) {
    let b, w = "";
    for (b = 0; b <= 3; b++) w += e.charAt(A >> 8 * b + 4 & 15) + e.charAt(A >> 8 * b & 15);
    return w;
  }
  function i(A, b) {
    let w = (65535 & A) + (65535 & b);
    return (A >> 16) + (b >> 16) + (w >> 16) << 16 | 65535 & w;
  }
  function r(A, b, w, D, k, B) {
    return i(function(V, z) {
      return V << z | V >>> 32 - z;
    }(i(i(b, A), i(D, B)), k), w);
  }
  function o(A, b, w, D, k, B, V) {
    return r(b & w | ~b & D, A, b, k, B, V);
  }
  function s(A, b, w, D, k, B, V) {
    return r(b & D | w & ~D, A, b, k, B, V);
  }
  function a(A, b, w, D, k, B, V) {
    return r(b ^ w ^ D, A, b, k, B, V);
  }
  function c(A, b, w, D, k, B, V) {
    return r(w ^ (b | ~D), A, b, k, B, V);
  }
  let d = function(A) {
    let b, w = 1 + (A.length + 8 >> 6), D = new Array(16 * w);
    for (b = 0; b < 16 * w; b++) D[b] = 0;
    for (b = 0; b < A.length; b++) D[b >> 2] |= A.charCodeAt(b) << b % 4 * 8;
    return D[b >> 2] |= 128 << b % 4 * 8, D[16 * w - 2] = 8 * A.length, D;
  }(t11), l, u, h, p, g, E = 1732584193, f = -271733879, S = -1732584194, C = 271733878;
  for (l = 0; l < d.length; l += 16) u = E, h = f, p = S, g = C, E = o(E, f, S, C, d[l + 0], 7, -680876936), C = o(C, E, f, S, d[l + 1], 12, -389564586), S = o(S, C, E, f, d[l + 2], 17, 606105819), f = o(f, S, C, E, d[l + 3], 22, -1044525330), E = o(E, f, S, C, d[l + 4], 7, -176418897), C = o(C, E, f, S, d[l + 5], 12, 1200080426), S = o(S, C, E, f, d[l + 6], 17, -1473231341), f = o(f, S, C, E, d[l + 7], 22, -45705983), E = o(E, f, S, C, d[l + 8], 7, 1770035416), C = o(C, E, f, S, d[l + 9], 12, -1958414417), S = o(S, C, E, f, d[l + 10], 17, -42063), f = o(f, S, C, E, d[l + 11], 22, -1990404162), E = o(E, f, S, C, d[l + 12], 7, 1804603682), C = o(C, E, f, S, d[l + 13], 12, -40341101), S = o(S, C, E, f, d[l + 14], 17, -1502002290), f = o(f, S, C, E, d[l + 15], 22, 1236535329), E = s(E, f, S, C, d[l + 1], 5, -165796510), C = s(C, E, f, S, d[l + 6], 9, -1069501632), S = s(S, C, E, f, d[l + 11], 14, 643717713), f = s(f, S, C, E, d[l + 0], 20, -373897302), E = s(E, f, S, C, d[l + 5], 5, -701558691), C = s(C, E, f, S, d[l + 10], 9, 38016083), S = s(S, C, E, f, d[l + 15], 14, -660478335), f = s(f, S, C, E, d[l + 4], 20, -405537848), E = s(E, f, S, C, d[l + 9], 5, 568446438), C = s(C, E, f, S, d[l + 14], 9, -1019803690), S = s(S, C, E, f, d[l + 3], 14, -187363961), f = s(f, S, C, E, d[l + 8], 20, 1163531501), E = s(E, f, S, C, d[l + 13], 5, -1444681467), C = s(C, E, f, S, d[l + 2], 9, -51403784), S = s(S, C, E, f, d[l + 7], 14, 1735328473), f = s(f, S, C, E, d[l + 12], 20, -1926607734), E = a(E, f, S, C, d[l + 5], 4, -378558), C = a(C, E, f, S, d[l + 8], 11, -2022574463), S = a(S, C, E, f, d[l + 11], 16, 1839030562), f = a(f, S, C, E, d[l + 14], 23, -35309556), E = a(E, f, S, C, d[l + 1], 4, -1530992060), C = a(C, E, f, S, d[l + 4], 11, 1272893353), S = a(S, C, E, f, d[l + 7], 16, -155497632), f = a(f, S, C, E, d[l + 10], 23, -1094730640), E = a(E, f, S, C, d[l + 13], 4, 681279174), C = a(C, E, f, S, d[l + 0], 11, -358537222), S = a(S, C, E, f, d[l + 3], 16, -722521979), f = a(f, S, C, E, d[l + 6], 23, 76029189), E = a(E, f, S, C, d[l + 9], 4, -640364487), C = a(C, E, f, S, d[l + 12], 11, -421815835), S = a(S, C, E, f, d[l + 15], 16, 530742520), f = a(f, S, C, E, d[l + 2], 23, -995338651), E = c(E, f, S, C, d[l + 0], 6, -198630844), C = c(C, E, f, S, d[l + 7], 10, 1126891415), S = c(S, C, E, f, d[l + 14], 15, -1416354905), f = c(f, S, C, E, d[l + 5], 21, -57434055), E = c(E, f, S, C, d[l + 12], 6, 1700485571), C = c(C, E, f, S, d[l + 3], 10, -1894986606), S = c(S, C, E, f, d[l + 10], 15, -1051523), f = c(f, S, C, E, d[l + 1], 21, -2054922799), E = c(E, f, S, C, d[l + 8], 6, 1873313359), C = c(C, E, f, S, d[l + 15], 10, -30611744), S = c(S, C, E, f, d[l + 6], 15, -1560198380), f = c(f, S, C, E, d[l + 13], 21, 1309151649), E = c(E, f, S, C, d[l + 4], 6, -145523070), C = c(C, E, f, S, d[l + 11], 10, -1120210379), S = c(S, C, E, f, d[l + 2], 15, 718787259), f = c(f, S, C, E, d[l + 9], 21, -343485551), E = i(E, u), f = i(f, h), S = i(S, p), C = i(C, g);
  return n(E) + n(f) + n(S) + n(C);
}
var fB = 1;
var Od = console;
var ze = class {
  static setLogger(t11) {
    Od = t11;
  }
  constructor(t11) {
    jt(this, "lockingPromise", j.resolve()), jt(this, "locks", 0), jt(this, "name", ""), jt(this, "lockId", void 0), this.lockId = fB++, t11 && (this.name = t11), Od.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is created."));
  }
  get isLocked() {
    return this.locks > 0;
  }
  lock(t11) {
    let e;
    this.locks += 1, Od.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is locked, current queue ").concat(this.locks, ". ").concat(typeof t11 == "string" ? t11 : ""));
    let n = new j((r) => {
      e = () => {
        this.locks -= 1, Od.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is not locked, current queue ").concat(this.locks, ". ").concat(typeof t11 == "string" ? t11 : "")), r();
      };
    }), i = this.lockingPromise.then(() => e);
    return this.lockingPromise = this.lockingPromise.then(() => n), i;
  }
};
function $s(t11, e) {
  return function(n, i, r) {
    let o = r.value;
    if (typeof o != "function") throw new Error("Cannot use mutex on object property.");
    return r.value = async function() {
      let s = this[e];
      if (!s) throw new Error("mutex property key ".concat(e, " doesn't exist on ").concat(t11));
      let a = await s.lock("From ".concat(t11, ".").concat(i));
      try {
        for (var c = arguments.length, d = new Array(c), l = 0; l < c; l++) d[l] = arguments[l];
        return await o.apply(this, d);
      } finally {
        a();
      }
    }, r;
  };
}
var Ee = { timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4 };
function hf(t11, e) {
  let n = Math.floor(e.timeout * Math.pow(e.timeoutFactor, t11));
  return Math.min(e.maxRetryTimeout, n);
}
function Wi(t11, e, n, i) {
  let r = Object.assign({}, Ee, i), o = r.timeout, s = async () => {
    await function(d) {
      return new j((l) => {
        window.setTimeout(l, d);
      });
    }(o), o *= r.timeoutFactor, o = Math.min(r.maxRetryTimeout, o);
  }, a = false, c = new j(async (d, l) => {
    e = e || (() => false), n = n || (() => true);
    for (let u = 0; u < r.maxRetryCount; u += 1) {
      if (a) return l(new N(R.OPERATION_ABORTED));
      try {
        let h = await t11();
        if (!e(h, u) || u + 1 === r.maxRetryCount) return d(h);
        await s();
      } catch (h) {
        if (!n(h, u) || u + 1 === r.maxRetryCount) return l(h);
        await s();
      }
    }
  });
  return c.cancel = () => a = true, c;
}
var Hl = class {
  constructor(e) {
    jt(this, "input", []), jt(this, "size", void 0), this.size = e;
  }
  add(e) {
    this.input.push(e), this.input.length > this.size && this.input.splice(0, 1);
  }
  mean() {
    var e;
    return this.input.length === 0 ? 0 : ji(e = this.input).call(e, (n, i) => n + i) / this.input.length;
  }
};
var Nd;
var Dd = 0;
var Op = 0;
function LE(t11, e, n, i) {
  return new j((r, o) => {
    e.responseType = e.responseType || "json", e.data && !n ? (e.data = JSON.stringify(e.data), Dd += ar(e.data)) : n && (e.data.size ? Dd += e.data.size : e.data instanceof FormData ? Dd += AO(e.data) : Dd += ar(JSON.stringify(e.data))), e.headers = e.headers || {}, e.headers["Content-Type"] = e.headers["Content-Type"] || "application/json", e.method = "POST", e.url = t11, mn.request(e).then((s) => {
      typeof s.data == "string" ? Op += ar(s.data) : s.data instanceof ArrayBuffer || s.data instanceof Uint8Array ? Op += s.data.byteLength : Op += ar(JSON.stringify(s.data)), r(s.data);
    }).catch((s) => {
      mn.isCancel(s) ? o(new N(R.OPERATION_ABORTED, "cancel token canceled")) : s.code === "ECONNABORTED" ? o(new N(R.NETWORK_TIMEOUT, s.message)) : s.response ? o(new N(R.NETWORK_RESPONSE_ERROR, s.response.status)) : o(new N(R.NETWORK_ERROR, s.message));
    });
  });
}
async function gB(t11, e) {
  let n = new Blob([e.data], { type: "buffer" });
  return await LE(t11, J(J({}, e), {}, { data: n, headers: { "Content-Type": "application/octet-stream" } }), true);
}
var vR = () => window.isSecureContext !== void 0;
var ii = function(t11) {
  if (t11.match(/[0-9]+\.[0-9]+\.[0-9]+$/)) return t11;
  let e = t11.match(/([0-9]+\.[0-9]+\.[0-9]+)\-alpha\.([0-9]+)/);
  if (e && e[1] && e[2]) {
    let i = e[1], r = e[2];
    return "".concat(i, ".").concat(r);
  }
  let n = t11.match(/([0-9]+\.[0-9]+\.[0-9]+)\-special\.([0-9]+)/);
  if (n && n[1] && n[2]) {
    let i = n[1], r = n[2];
    return "".concat(i, ".").concat(100 * (Number(r) + 1));
  }
  return "4.0.0.999";
}("4.22.0");
var pf = function() {
  try {
    return JSON.parse("true") === true;
  } catch {
    return true;
  }
}();
var Oo = function(t11) {
  return t11.Default = "default", t11.Auto = "auto", t11.Relay = "relay", t11.SdRtn = "sd-rtn", t11;
}({});
var _f = { MIN_FRAME_RATE: 1, MAX_FRAME_RATE: 30, MAX_THRESHOLD_FRAMERATE: 30, BITRATE_MIN_THRESHOLD: 100, BITRATE_MAX_THRESHOLD: 100, MAX_SCALE: 5, BWE_SCALE_UP_THRESHOLD: 0.6, BWE_SCALE_DOWN_THRESHOLD: 0.6, PERF_SCALE_UP_THRESHOLD: 0.7, PERF_SCALE_DOWN_THRESHOLD: 0.6, MOTION_RESOLUTION_FACTOR: 0.8, MOTION_BITRATE_FACTOR: 0.6, DETAIL_FRAMERATE_FACTOR: 0.8, DETAIL_BITRATE_FACTOR: 0.6, BALANCE_RESOLUTION_FACTOR: 0.9, BALANCE_FRAMERATE_FACTOR: 0.9, BALANCE_BITRATE_FACTOR: 0.6, OVERUSE_TIMES_THRESHOLD: 10, UNDERUSE_TIMES_THRESHOLD: 40 };
var Ef = "v4.22.0-0-g8569241d-dirty(8/15/2024, 7:04:06 PM)";
var oe = J(J({ PROCESS_ID: "", ENCRYPT_AES: true, AREAS: ["CHINA", "GLOBAL"], WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"], LOG_UPLOAD_SERVER: "logservice.agora.io", EVENT_REPORT_DOMAIN: "statscollector-1.agora.io", EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com", ENABLE_EVENT_REPORT: true, GATEWAY_ADDRESS: [], GATEWAY_WSS_ADDRESS: "", LIVE_STREAMING_ADDRESS: "", HTTP_CONNECT_TIMEOUT: 5e3, SIGNAL_REQUEST_TIMEOUT: 1e4, REPORT_STATS: true, UPLOAD_LOG: false, NOT_REPORT_EVENT: [], PING_PONG_TIME_OUT: 10, WEBSOCKET_TIMEOUT_MIN: 1e4, EVENT_REPORT_SEND_INTERVAL: 3e3, CONFIG_DISTRIBUTE_INTERVAL: 3e5, ENABLE_CONFIG_DISTRIBUTE: true, CANDIDATE_TIMEOUT: 5e3, SHOW_REPORT_INVOKER_LOG: false, JOIN_EXTEND: "", PUB_EXTEND: "", SUB_EXTEND: "", FORCE_TURN: false, TURN_ENABLE_TCP: true, TURN_ENABLE_UDP: true, MAX_UPLOAD_CACHE: 50, UPLOAD_CACHE_INTERVAL: 2e3, AJAX_REQUEST_CONCURRENT: 3, REPORT_APP_SCENARIO: void 0, GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"], CONNECT_GATEWAY_WITHOUT_DOMAIN: false, WORKER_DOMAIN: "edge.agora.io", TURN_DOMAIN: "edge.agora.io", EVENT_REPORT_RETRY: true, CHROME_FORCE_PLAN_B: false, AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400, AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3, AUDIO_VOLUME_INDICATION_INTERVAL: 2e3, VOLUME_VOICE_WEIGHT: 10, GET_VOLUME_OF_MUTED_AUDIO_TRACK: false, STATS_UPDATE_INTERVAL: 250, NORMAL_EVENT_QUEUE_CAPACITY: 100, CUSTOM_REPORT: true, CUSTOM_REPORT_LIMIT: 20, PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io", PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"], CUSTOM_PUB_ANSWER_MODIFIER: null, CUSTOM_SUB_ANSWER_MODIFIER: null, CUSTOM_PUB_OFFER_MODIFIER: null, CUSTOM_SUB_OFFER_MODIFIER: null, DSCP_TYPE: "high", REMOVE_NEW_CODECS: true, FRAGEMENT_LENGTH: 3, WEBSOCKET_COMPRESS: false, SIMULCAST: false, PRELOAD_MEDIA_COUNT: 0, CHECK_VIDEO_VISIBLE_INTERVAL: 3e4, CHECK_LOCAL_STATS_INTERVAL: 250, PROFILE_SWITCH_INTERVAL: 2e3, UNSUPPORTED_VIDEO_CODEC: [], ENUMERATE_DEVICES_INTERVAL: false, ENUMERATE_DEVICES_INTERVAL_TIME: 1e4, USE_NEW_TOKEN: false, CLOSE_AFB_FOR_LOCAL_AP: true, JOIN_MAX_CONCURRENCY: 6, JOIN_WITH_FALLBACK_SIGNAL_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY: true, JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: false, JOIN_GATEWAY_TRY_443PORT_DURATION: 2e3, JOIN_GATEWAY_USE_443PORT_ONLY: false, JOIN_GATEWAY_USE_DUAL_DOMAIN: true, JOIN_GATEWAY_FALLBACK_PORT: 443, USE_TURN_SERVER_OF_GATEWAY: false, H264_PROFILE_LEVEL_ID: "", USE_NEW_LOG: false, LOG_VERSION: 3, MEDIA_DEVICE_CONSTRAINTS: null, ENCRYPT_PROXY_USERNAME_AND_PSW: true, SDP_LOGGING: false, CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"], REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: false, LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: false, BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE", AI_DENOISER_PARAMETERS: { excludedLinks: [] }, ADJUST_3A_FROM_PLUGINS: true, RAISE_H264_BASELINE_PRIORITY: true, FILTER_SEND_H264_BASELINE: false, X_GOOGLE_START_BITRATE: void 0, NEW_REPORT_SERVER: false, NEW_REPORT_SERVER_DOMAINS: ["data-reporting.agora.io", "data-reporting.agora.io"], VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3, VIDEO_INSPECT_QUALITY_RATIO: 0.9, VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io", VIDEO_INSPECT_WORKER_MANAGER_PORT: "", VIDEO_INSPECT_WORKER_PORT: "", SHOW_VIDEO_INSPECT_WORKER_MESSAGE: false, STATS_COLLECTOR_PORT: 443, FORCE_TURN_TCP: false, WEBAUDIO_INIT_OPTIONS: void 0, FILTER_VIDEO_FEC: true, FILTER_AUDIO_FEC: false, CHROME_DUAL_STREAM_USE_ENCODING: true, DISABLE_DUAL_STREAM_USE_ENCODING: false, EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4, ICE_RESTART: true, ICE_RESTART_INTERVAL: 1e4, NEW_ICE_RESTART: false, TRANSMITTER_INITIAL_RTT: 30, TRANSMITTER_INITIAL_RTO: 30, TRANSMITTER_MAX_BATCH_ACK_COUNT: 2, TRANSMITTER_MAX_RTO: 500, DATACHANNEL_COMPRESS: false, FINGERPRINT: null, DC_JOIN_WITH_FAILBACK: 5e3, ENABLE_VIDEO_FRAME_CALLBACK: true, VIDEO_FREEZE_DURATION: 500, SPATIALIZER_PARAMETERS: {}, UPLOAD_LOG_INTERVAL: 3e3, UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3, UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4, UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3, UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4, UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200, UPLOAD_LOG_LENGTH_EACH_TIME: 10, APP_TYPE: 0, DISABLE_WEBAUDIO: false, CHANNEL_MEDIA_RELAY_SERVERS: void 0, KEEP_LAST_FRAME: true, FORWARD_P2P_CREATION: true, SYNC_GROUP: true, BLOCK_LOCAL_CLIENT: false, AP_AREA: true, ENABLE_ENCODED_TRANSFORM: false, ENABLE_VIDEO_SEI: false, IMAGE_MODERATION_WORKER_HOST: "edge.agora.io", IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT: 3e5, IMAGE_MODERATION_INTERVAL_MINIMUM: 1e3, SHOW_IMAGE_MODERATION_WORKER_MESSAGE: false, IMAGE_MODERATION_QUALITY_RATIO: 0.9, IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL: 5e3, SHOW_GLOBAL_CLIENT_LIST: false, DATASTREAM_MAX_RETRANSMITS: 10, TCP_CANDIDATE_ONLY: false, EXTERNAL_SIGNAL_REQUEST_TIMEOUT: 3e3, SHOW_P2P_LOG: false, MAX_P2P_TIMEOUT: 3e4, P2P_TOKEN_INTERVAL: 1e3, SHOW_DATASTREAM2_LOG: false, RESTRICTION_SET_PLAYBACK_DEVICE: true, USE_PURE_ENCRYPTION_MASTER_KEY: false, ACCOUNT_REGISTER_RETRY_TIMEOUT: 1, ACCOUNT_REGISTER_RETRY_RATIO: 2, ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4, ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5, AUDIO_CONTEXT: null, WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3, PLAYER_STATE_DEFER: 2e3, SIGNAL_REQUEST_WATCH_INTERVAL: 1e3, FILEPATH_LENMAX: 255, DUALSTREAM_OPERATION_CHECK: true, MEDIA_ELEMENT_EXISTS_DEPTH: 3, SHIM_CANDIDATE: false, LEAVE_MSG_TIMEOUT: 2e3, STATS_FILTER: { transportId: true, googTrackId: true }, FILTER_VIDEO_CODEC: [], USE_NEW_NETWORK_CONFIG: false, AUTO_RESET_AUDIO_ROUTE: false, PLUGIN_INFO: [], OVERUSE_DETECTOR_PARAMS: _f, ENABLE_AG_ADAPTATION: true, FORCE_AG_HIGH_FRAMERATE: false, FORCE_SUPPORT_AG_ADAPTATION: false, CUSTOM_ADAPTATION_DEFAULT_MODE: "", ENCODER_CONFIG_LIMIT: {}, CAMERA_CAPTURE_CONFIG: void 0, HIDE_NO_POSTER: false, AP_CACHE_NUM: 10, AP_UPDATE_INTERVAL: 12e4, AP_CACHE_LIFETIME: 12e4, MAX_PRELOAD_ASYNC_LENGTH: 3, ENABLE_PRELOAD: true }, { ENABLE_PUBLISHED_USER_LIST: true, MAX_SUBSCRIPTION: 50, SUBSCRIBE_AUDIO_FILTER_TOPN: void 0, ENABLE_PUBLISH_AUDIO_FILTER: void 0, ENABLE_USER_LICENSE_CHECK: true, USE_PUB_RTX: true, USE_SUB_RTX: true, DISABLE_FEC: void 0, ENABLE_NTP_REPORT: false, ENABLE_INSTANT_VIDEO: false, ENABLE_DATASTREAM_2: false, ENABLE_USER_AUTO_REBALANCE_CHECK: true, USE_XR: true, ENABLE_LOSSBASED_BWE: true, ENABLE_AUT_CC: false, ENABLE_CC_FALLBACK: void 0, ENABLE_PREALLOC_PC: false, SUBSCRIBE_TWCC: true, PUBLISH_TWCC: false, ENABLE_SVC: false, ENABLE_SVC_DEFAULT_CODECS: ["H264", "VP8", "VP9", "AV1"], SVC: [], ENABLE_FULL_LINK_AV_SYNC: false, SVC_MODE: null, PRE_SUB_NUM: 2, ENABLE_PRE_SUB: false, ENABLE_AUT_FEEDBACK: false }), {}, { USE_CANDIDATE_FROM_AP_DETAIL: false });
function Ot(t11, e, n) {
  var i, r, o;
  W(i = Object.keys(oe)).call(i, t11) && (!n && W(r = Object.keys($r)).call(r, t11) || (oe[t11] = e, t11 === "ENABLE_VIDEO_SEI" && e === true && (oe.ENABLE_ENCODED_TRANSFORM = true), t11 === "USE_NEW_NETWORK_CONFIG" && e && (o = !!e, oe.USE_NEW_NETWORK_CONFIG = o, o && (oe.WEBCS_DOMAIN = ["webrtc2-2.ap.sd-rtn.com"], oe.WEBCS_DOMAIN_BACKUP_LIST = ["webrtc2-4.ap.sd-rtn.com"], oe.CDS_AP = ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], oe.ACCOUNT_REGISTER = ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], oe.EVENT_REPORT_DOMAIN = "web-2.statscollector.sd-rtn.com", oe.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-1.agora.io", oe.GATEWAY_DOMAINS = ["edge.sd-rtn.com"])), t11 === "ENABLE_PRE_SUB" && e && (oe.ENABLE_INSTANT_VIDEO = true, oe.ENABLE_PREALLOC_PC = true), t11 === "ENABLE_SVC" && e && (oe.ENABLE_AUT_CC = true)));
}
function v(t11) {
  return oe[t11];
}
var $r = {};
var ct = function(t11) {
  return t11.SET_SESSION_ID = "SET_SESSION_ID", t11.SET_P2P_ID = "SET_P2P_id", t11.SET_DC_ID = "SET_DC_id", t11.SET_UID = "SET_UID", t11.SET_INT_UID = "SET_INT_UID", t11.SET_PUB_ID = "SET_PUB_ID", t11.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", t11.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", t11.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", t11.AVOID_JOIN_START = "AVOID_JOIN_START", t11.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", t11.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", t11.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", t11.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", t11.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", t11.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", t11.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", t11.KEY_METRIC_DESCRIPTION_START = "KEY_METRIC_DESCRIPTION_START", t11.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END", t11.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN", t11.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", t11.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", t11.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", t11.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", t11.RESET_KEY_METRICS = "RESET_KEY_METRICS", t11.SET_USE_P2P = "SET_USE_P2P", t11.SET_TRANSPORT_TYPE = "SET_TRANSPORT_TYPE", t11;
}(ct || {});
var ME = class {
  constructor(e, n, i, r) {
    jt(this, "state", void 0), this.state = { codec: e, audioCodec: n, mode: i, clientId: r, sessionId: null, p2pId: 0, dcId: 0, pubId: 0, subId: 0, avoidJoinStart: 0, keyMetrics: { publish: [], subscribe: [] }, joinChannelServiceRecords: [], cloudProxyServerMode: "disabled", useP2P: false, p2pTransport: Oo.Default };
  }
  dispatch(e) {
    this.state = function(n, i) {
      switch (i.type) {
        case ct.SET_SESSION_ID:
          return J(J({}, n), {}, { sessionId: i.sessionId });
        case ct.SET_P2P_ID:
          return J(J({}, n), {}, { p2pId: i.p2pId });
        case ct.SET_UID:
          return J(J({}, n), {}, { uid: i.uid });
        case ct.SET_INT_UID:
          return J(J({}, n), {}, { intUid: i.intUid });
        case ct.SET_PUB_ID:
          return J(J({}, n), {}, { pubId: i.pubId });
        case ct.KEY_METRIC_CLIENT_CREATED:
          return J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { clientCreated: i.metric }) });
        case ct.KEY_METRIC_JOIN_START:
          return J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { joinStart: i.metric }) });
        case ct.AVOID_JOIN_START:
          return J(J({}, n), {}, { avoidJoinStart: i.avoidJoinStart });
        case ct.KEY_METRIC_JOIN_END:
          return J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { joinEnd: i.metric }) });
        case ct.KEY_METRIC_REQUEST_AP_START:
          return J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { requestAPStart: i.metric }) });
        case ct.KEY_METRIC_REQUEST_AP_END:
          return J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { requestAPEnd: i.metric }) });
        case ct.KEY_METRIC_JOIN_GATEWAY_START:
          return J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { joinGatewayStart: i.metric }) });
        case ct.KEY_METRIC_JOIN_GATEWAY_END:
          return J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { joinGatewayEnd: i.metric }) });
        case ct.KEY_METRIC_PEER_CONNECTION_START:
          return J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { peerConnectionStart: i.metric }) });
        case ct.KEY_METRIC_PEER_CONNECTION_END:
          return J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { peerConnectionEnd: i.metric }) });
        case ct.KEY_METRIC_DESCRIPTION_START:
          return J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { descriptionStart: i.metric }) });
        case ct.KEY_METRIC_SIGNAL_CHANNEL_OPEN:
          return J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { signalChannelOpen: i.metric }) });
        case ct.KEY_METRIC_ICE_CONNECTION_END:
          return J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { iceConnectionEnd: i.metric }) });
        case ct.KEY_METRIC_PUBLISH: {
          let r = n.keyMetrics.publish, o = r.findIndex((s) => s.trackId === i.metric.trackId);
          return o !== -1 ? (r[o] = J(J({}, r[o]), i.metric), J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { publish: [...r] }) })) : J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { publish: [...n.keyMetrics.publish, i.metric] }) });
        }
        case ct.KEY_METRIC_SUBSCRIBE: {
          let r = n.keyMetrics.subscribe, o = r.findIndex((s) => s.userId === i.metric.userId && s.type === i.metric.type);
          return o !== -1 ? (r[o] = J(J({}, r[o]), i.metric), J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { subscribe: [...r] }) })) : J(J({}, n), {}, { keyMetrics: J(J({}, n.keyMetrics), {}, { subscribe: [...n.keyMetrics.subscribe, i.metric] }) });
        }
        case ct.SET_CLOUD_PROXY_SERVER_MODE:
          return n.cloudProxyServerMode = i.mode, n;
        case ct.RECORD_JOIN_CHANNEL_SERVICE:
          return typeof i.index != "number" ? n.joinChannelServiceRecords = [...n.joinChannelServiceRecords, i.record] : (n.joinChannelServiceRecords[i.index] = J(J({}, n.joinChannelServiceRecords[i.index]), i.record), n.joinChannelServiceRecords = [...n.joinChannelServiceRecords]), n;
        case ct.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
          return n.joinChannelServiceRecords = [], n;
        case ct.RESET_KEY_METRICS:
          return n.keyMetrics = { publish: [], subscribe: [] }, n;
        case ct.SET_USE_P2P:
          return J(J({}, n), {}, { useP2P: i.val });
        case ct.SET_TRANSPORT_TYPE:
          return J(J({}, n), {}, { p2pTransport: i.val });
        default:
          return n;
      }
    }(this.state, e);
  }
  set sessionId(e) {
    this.dispatch({ type: ct.SET_SESSION_ID, sessionId: e });
  }
  get sessionId() {
    return this.state.sessionId;
  }
  set codec(e) {
    this.state.codec = e;
  }
  get codec() {
    return this.state.codec;
  }
  get mode() {
    return this.state.mode;
  }
  get audioCodec() {
    return this.state.audioCodec;
  }
  get clientId() {
    return this.state.clientId;
  }
  set p2pId(e) {
    this.dispatch({ type: ct.SET_P2P_ID, p2pId: e });
  }
  get p2pId() {
    return this.state.p2pId;
  }
  set dcId(e) {
    this.dispatch({ type: ct.SET_DC_ID, dcId: e });
  }
  get dcId() {
    return this.state.dcId;
  }
  set uid(e) {
    this.dispatch({ type: ct.SET_UID, uid: e });
  }
  get uid() {
    return this.state.uid;
  }
  set intUid(e) {
    this.dispatch({ type: ct.SET_INT_UID, intUid: e });
  }
  get intUid() {
    return this.state.intUid;
  }
  set pubId(e) {
    this.dispatch({ type: ct.SET_PUB_ID, pubId: e });
  }
  get pubId() {
    return this.state.pubId;
  }
  set cloudProxyServerMode(e) {
    this.dispatch({ type: ct.SET_CLOUD_PROXY_SERVER_MODE, mode: e });
  }
  get cloudProxyServerMode() {
    return this.state.cloudProxyServerMode;
  }
  set useP2P(e) {
    this.dispatch({ type: ct.SET_USE_P2P, val: e });
  }
  get useP2P() {
    return this.state.useP2P;
  }
  set p2pTransport(e) {
    this.dispatch({ type: ct.SET_TRANSPORT_TYPE, val: e });
  }
  get p2pTransport() {
    return this.state.p2pTransport;
  }
  clientCreated() {
    this.dispatch({ type: ct.KEY_METRIC_CLIENT_CREATED, metric: Date.now() });
  }
  joinStart() {
    this.dispatch({ type: ct.KEY_METRIC_JOIN_START, metric: Date.now() });
  }
  joinEnd() {
    this.dispatch({ type: ct.KEY_METRIC_JOIN_END, metric: Date.now() });
  }
  requestAPStart() {
    this.dispatch({ type: ct.KEY_METRIC_REQUEST_AP_START, metric: Date.now() });
  }
  requestAPEnd() {
    this.dispatch({ type: ct.KEY_METRIC_REQUEST_AP_END, metric: Date.now() });
  }
  joinGatewayStart() {
    this.dispatch({ type: ct.KEY_METRIC_JOIN_GATEWAY_START, metric: Date.now() });
  }
  joinGatewayEnd() {
    this.dispatch({ type: ct.KEY_METRIC_JOIN_GATEWAY_END, metric: Date.now() });
  }
  peerConnectionStart() {
    this.dispatch({ type: ct.KEY_METRIC_PEER_CONNECTION_START, metric: Date.now() });
  }
  peerConnectionEnd() {
    this.dispatch({ type: ct.KEY_METRIC_PEER_CONNECTION_END, metric: Date.now() });
  }
  descriptionStart() {
    this.dispatch({ type: ct.KEY_METRIC_DESCRIPTION_START, metric: Date.now() });
  }
  signalChannelOpen() {
    this.dispatch({ type: ct.KEY_METRIC_SIGNAL_CHANNEL_OPEN, metric: Date.now() });
  }
  iceConnectionEnd() {
    this.dispatch({ type: ct.KEY_METRIC_ICE_CONNECTION_END, metric: Date.now() });
  }
  publish(e, n, i, r) {
    this.dispatch({ type: ct.KEY_METRIC_PUBLISH, metric: J(J({ trackId: e, type: n }, i && { publishStart: i }), r && { publishEnd: r }) });
  }
  subscribe(e, n, i, r, o, s, a) {
    this.dispatch({ type: ct.KEY_METRIC_SUBSCRIBE, metric: J(J(J(J(J({ userId: e, type: n }, i && { subscribeStart: i }), r && { subscribeEnd: r }), o && { firstFrame: o }), s && { streamAdded: s }), a && { firstDecoded: a }) });
  }
  massSubscribe(e, n, i, r) {
    e.forEach((o) => {
      this.dispatch({ type: ct.KEY_METRIC_SUBSCRIBE, metric: J(J(J({ userId: o.userId, type: o.type }, n && { subscribeStart: n }), i && { subscribeEnd: i }), r && { firstFrame: r }) });
    });
  }
  get keyMetrics() {
    return this.state.keyMetrics;
  }
  recordJoinChannelService(e, n) {
    e.service === "gateway" && Array.isArray(e.urls) && (e.urls = e.urls.map((i) => i.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")));
    try {
      return typeof n != "number" ? (this.dispatch({ type: ct.RECORD_JOIN_CHANNEL_SERVICE, record: J(J({}, e), {}, { sessionId: this.sessionId, cloudProxyMode: this.cloudProxyServerMode, uid: this.uid }) }), this.state.joinChannelServiceRecords.length - 1) : (n < 0 || n >= this.state.joinChannelServiceRecords.length || this.dispatch({ type: ct.RECORD_JOIN_CHANNEL_SERVICE, record: e, index: n }), n);
    } catch {
      return 0;
    }
  }
  resetJoinChannelServiceRecords() {
    this.dispatch({ type: ct.RESET_JOIN_CHANNEL_SERVICE_RECORDS });
  }
  resetKeyMetrics() {
    this.dispatch({ type: ct.RESET_KEY_METRICS });
  }
  get joinChannelServiceRecords() {
    try {
      return this.state.joinChannelServiceRecords;
    } catch {
      return [];
    }
  }
  get avoidJoinStart() {
    return this.state.avoidJoinStart;
  }
  set avoidJoinStart(e) {
    this.dispatch({ type: ct.AVOID_JOIN_START, avoidJoinStart: e });
  }
};
var Ju = function(t11) {
  return t11.h264 = "h264", t11.h265 = "h265", t11.vp8 = "vp8", t11.vp9 = "vp9", t11.av1 = "av1", t11;
}({});
(function(t11) {
  t11.opus = "opus", t11.pcma = "pcma", t11.pcmu = "pcmu", t11.g722 = "g722";
})({});
var yR = 128;
var TB = 96;
var AR = 1e3;
var us = 10;
var SB = 0;
function re(t11, e, n) {
  return (e = function(i) {
    var r = function(o, s) {
      if (typeof o != "object" || !o) return o;
      var a = o[Symbol.toPrimitive];
      if (a !== void 0) {
        var c = a.call(o, "string");
        if (typeof c != "object") return c;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(o);
    }(i);
    return typeof r == "symbol" ? r : r + "";
  }(e)) in t11 ? Object.defineProperty(t11, e, { value: n, enumerable: true, configurable: true, writable: true }) : t11[e] = n, t11;
}
function bR(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function ot(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? bR(Object(n), true).forEach(function(i) {
      re(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : bR(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var wO = new class extends Xt {
  constructor() {
    super(...arguments), re(this, "currentUploadLogID", 0);
  }
  reportLogUploadError(t11) {
    let { errorRange: e } = t11;
    e[e.length - 1] && e[e.length - 1] > this.currentUploadLogID && (this.currentUploadLogID = e[e.length - 1], this.emit("REPORT_LOG_UPLOAD", t11));
  }
}();
var UE = class {
  constructor(e) {
    re(this, "logger", void 0), re(this, "prefixLists", []), this.logger = e;
  }
  debug() {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
    this.logger.debug(...this.prefixLists, ...n);
  }
  info() {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
    this.logger.info(...this.prefixLists, ...n);
  }
  warning() {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
    this.logger.warning(...this.prefixLists, ...n);
  }
  error() {
    for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
    this.logger.error(...this.prefixLists, ...n);
  }
  prefix(e) {
    return this.prefixLists.push(e), this;
  }
  popPrefix() {
    return this.prefixLists.pop(), this;
  }
};
function Np() {
  let t11 = /* @__PURE__ */ new Date();
  return t11.toTimeString().split(" ")[0] + ":" + t11.getMilliseconds();
}
function wR() {
  let t11 = /* @__PURE__ */ new Date(), e = /((\d+:){2}\d+)/.exec((/* @__PURE__ */ new Date()).toUTCString());
  return e ? (e == null ? void 0 : e[0]) + ":" + t11.getUTCMilliseconds() : t11.toTimeString().split(" ")[0] + ":" + t11.getMilliseconds();
}
var Qn = { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4 };
var Pd = Date.now();
var ka = (t11) => {
  for (let e in Qn) if (Object.prototype.hasOwnProperty.call(Qn, e) && Qn[e] === t11) return e;
  return "DEFAULT";
};
var _ = new class {
  constructor() {
    re(this, "proxyServerURL", void 0), re(this, "logLevel", Qn.DEBUG), re(this, "uploadState", "collecting"), re(this, "uploadLogWaitingList", []), re(this, "uploadLogUploadingList", []), re(this, "uploadErrorCount", 0), re(this, "currentLogID", 0), re(this, "url", void 0), re(this, "extLog", (t11, e) => {
      this.appendLogToWaitingList(t11, ...e);
    });
  }
  debug() {
    for (var t11 = arguments.length, e = new Array(t11), n = 0; n < t11; n++) e[n] = arguments[n];
    let i = [Qn.DEBUG].concat(e);
    this.log.apply(this, i);
  }
  info() {
    for (var t11 = arguments.length, e = new Array(t11), n = 0; n < t11; n++) e[n] = arguments[n];
    let i = [Qn.INFO].concat(e);
    this.log.apply(this, i);
  }
  warning() {
    for (var t11 = arguments.length, e = new Array(t11), n = 0; n < t11; n++) e[n] = arguments[n];
    let i = [Qn.WARNING].concat(e);
    this.log.apply(this, i);
  }
  warn() {
    this.warning(...arguments);
  }
  error() {
    for (var t11 = arguments.length, e = new Array(t11), n = 0; n < t11; n++) e[n] = arguments[n];
    let i = [Qn.ERROR].concat(e);
    this.log.apply(this, i);
  }
  upload() {
    for (var t11 = arguments.length, e = new Array(t11), n = 0; n < t11; n++) e[n] = arguments[n];
    let i = [Qn.DEBUG].concat(e);
    this.uploadLog.apply(this, i);
  }
  setLogLevel(t11) {
    t11 = Math.min(Math.max(0, t11), 4), this.logLevel = t11;
  }
  enableLogUpload() {
    Ot("UPLOAD_LOG", true);
  }
  disableLogUpload() {
    Ot("UPLOAD_LOG", false), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];
  }
  setProxyServer(t11) {
    this.proxyServerURL = t11;
  }
  prefix(t11) {
    return new UE(this).prefix(t11);
  }
  log() {
    for (var t11 = arguments.length, e = new Array(t11), n = 0; n < t11; n++) e[n] = arguments[n];
    if (Date.now() - Pd < 100) return void setTimeout(() => {
      this.log(...e);
    }, Date.now() - Pd);
    let i = Math.max(0, Math.min(4, e[0]));
    if (e[0] = Np() + " Agora-SDK [".concat(ka(i), "]:"), this.appendLogToWaitingList(i, ...e), i < this.logLevel) return;
    let r = Np() + " %cAgora-SDK [".concat(ka(i), "]:"), o = [];
    if (!v("USE_NEW_LOG")) switch (i) {
      case Qn.DEBUG:
        o = [r, "color: #64B5F6;"].concat(e.slice(1)), console.log.apply(console, o);
        break;
      case Qn.INFO:
        o = [r, "color: #1E88E5; font-weight: bold;"].concat(e.slice(1)), console.log.apply(console, o);
        break;
      case Qn.WARNING:
        o = [r, "color: #FB8C00; font-weight: bold;"].concat(e.slice(1)), console.warn.apply(console, o);
        break;
      case Qn.ERROR:
        o = [r, "color: #B00020; font-weight: bold;"].concat(e.slice(1)), console.error.apply(console, o);
    }
  }
  uploadLog() {
    for (var t11 = arguments.length, e = new Array(t11), n = 0; n < t11; n++) e[n] = arguments[n];
    if (Date.now() - Pd < 100) return void setTimeout(() => {
      this.uploadLog(...e);
    }, Date.now() - Pd);
    let i = Math.max(0, Math.min(4, e[0]));
    e[0] = Np() + " Agora-SDK [".concat(ka(i), "]:"), this.appendLogToWaitingList(i, ...e);
  }
  appendLogToWaitingList(t11) {
    if (!v("UPLOAD_LOG")) return;
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
    Array.isArray(n[0]) ? n[0][0] = wR() + " Agora-SDK [".concat(ka(t11), "]:") : n[0] = wR() + " Agora-SDK [".concat(ka(t11), "]:");
    let r = "";
    n.forEach((o) => {
      typeof o == "object" && (o = JSON.stringify(o)), r += "".concat(o, " ");
    }), this.uploadLogWaitingList.push({ payload_str: r, log_level: t11, log_item_id: this.currentLogID++ }), this.uploadState === "uploading" && this.uploadLogUploadingList.length === 0 && this.uploadLogInterval();
  }
  startUpload() {
    this.uploadState = "uploading", this.uploadLogUploadingList.length === 0 && this.uploadLogInterval();
  }
  async uploadLogs() {
    let t11 = this.uploadLogUploadingList, e = { sdk_version: ii, process_id: v("PROCESS_ID"), payload: JSON.stringify(t11) };
    return Wi(async () => {
      let n = await mn.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(v("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(v("LOG_UPLOAD_SERVER"), "/upload/v1")), e, { responseType: "text" });
      if (n.data !== "OK") {
        let i = new Error("unexpected upload log response");
        throw i.response = n, i;
      }
    }, () => (this.uploadLogUploadingList = [], false), (n) => {
      let i = { status: -1, message: n.message, errorRange: t11.map((r) => r.log_item_id) };
      return n.response ? (i.status = n.response.status, i.data = n.response.data, i.headers = n.response.headers) : n.request && (i.status = n.request.status), wO.reportLogUploadError(i), true;
    }, { timeout: v("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"), maxRetryTimeout: v("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL") });
  }
  uploadLogInterval() {
    this.uploadLogUploadingList.length === 0 && this.uploadLogWaitingList.length === 0 || (this.uploadLogUploadingList.length === 0 && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, v("UPLOAD_LOG_LENGTH_EACH_TIME"))), this.uploadLogs().then(() => {
      this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), v("UPLOAD_LOG_INTERVAL"));
    }).catch((t11) => {
      this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), v("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")) : window.setTimeout(() => this.uploadLogInterval(), v("UPLOAD_LOG_RETRY_INTERVAL_V1"));
    }));
  }
}();
var OR;
function RB(t11) {
  return Pe(t11.reportId, "params.reportId", 0, 100, false), Pe(t11.category, "params.category", 0, 100, false), Pe(t11.event, "params.event", 0, 100, false), Pe(t11.label, "params.label", 0, 100, false), Nt(t11.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, false), true;
}
(OR = {}).FREE = "free", OR.UPLOADING = "uploading", function(t11) {
  t11[t11.MISC = 0] = "MISC", t11[t11.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", t11[t11.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", t11[t11.WEB_EVENT = 3] = "WEB_EVENT", t11[t11.INTERNAL_API = 4] = "INTERNAL_API", t11[t11.WEB_API = 5] = "WEB_API", t11[t11.PUBLIC_API = 6] = "PUBLIC_API";
}({});
var CB = { sid: "", lts: 0, success: null, cname: null, uid: null, peer: null, cid: null, elapse: null, extend: null, vid: 0 };
var De = function(t11) {
  return t11.PUBLISH = "publish", t11.SUBSCRIBE = "subscribe", t11.WS_COMPRESSOR_INIT = "ws_compressor_init", t11.SESSION_INIT = "session_init", t11.JOIN_CHOOSE_SERVER = "join_choose_server", t11.REQ_USER_ACCOUNT = "req_user_account", t11.JOIN_GATEWAY = "join_gateway", t11.REJOIN_GATEWAY = "rejoin_gateway", t11.STREAM_SWITCH = "stream_switch", t11.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", t11.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", t11.FIRST_VIDEO_RECEIVED = "first_video_received", t11.FIRST_AUDIO_RECEIVED = "first_audio_received", t11.FIRST_VIDEO_DECODE = "first_video_decode", t11.FIRST_AUDIO_DECODE = "first_audio_decode", t11.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", t11.ON_ADD_VIDEO_STREAM = "on_add_video_stream", t11.ON_UPDATE_STREAM = "on_update_stream", t11.ON_REMOVE_STREAM = "on_remove_stream", t11.USER_ANALYTICS = "req_user_analytics", t11.PC_STATS = "pc_stats", t11.UPDATE_REMOTE_RTPCAPABILITIES = "update_remote_rtpCapabilities", t11;
}({});
var Jt = function(t11) {
  return t11.SESSION = "io.agora.pb.Wrtc.Session", t11.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", t11.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", t11.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway", t11.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", t11.PUBLISH = "io.agora.pb.Wrtc.Publish", t11.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", t11.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", t11.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", t11.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", t11.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", t11.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", t11.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", t11.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", t11.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", t11.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", t11.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", t11.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", t11.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", t11.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", t11.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", t11.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", t11.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", t11.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", t11.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", t11.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", t11.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", t11.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", t11.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", t11.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed", t11.PC_STATS = "io.agora.pb.Wrtc.PCStats", t11.UPDATE_REMOTE_RTPCAPABILITIES = "io.agora.pb.Wrtc.UpdateRemoteRTPCapabilities", t11;
}({});
(function(t11) {
  t11[t11.WORKER_EVENT = 156] = "WORKER_EVENT", t11[t11.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT";
})({});
var IB = function(t11) {
  return t11[t11.SESSION = 26] = "SESSION", t11[t11.JOIN_CHOOSE_SERVER = 27] = "JOIN_CHOOSE_SERVER", t11[t11.REQ_USER_ACCOUNT = 196] = "REQ_USER_ACCOUNT", t11[t11.JOIN_GATEWAY = 28] = "JOIN_GATEWAY", t11[t11.PUBLISH = 30] = "PUBLISH", t11[t11.SUBSCRIBE = 29] = "SUBSCRIBE", t11[t11.WS_COMPRESSOR_INIT = 9430] = "WS_COMPRESSOR_INIT", t11[t11.STREAM_SWITCH = 32] = "STREAM_SWITCH", t11[t11.AUDIO_SENDING_STOPPED = 33] = "AUDIO_SENDING_STOPPED", t11[t11.VIDEO_SENDING_STOPPED = 34] = "VIDEO_SENDING_STOPPED", t11[t11.REQUEST_PROXY_APPCENTER = 35] = "REQUEST_PROXY_APPCENTER", t11[t11.REQUEST_PROXY_WORKER_MANAGER = 36] = "REQUEST_PROXY_WORKER_MANAGER", t11[t11.API_INVOKE = 41] = "API_INVOKE", t11[t11.FIRST_VIDEO_RECEIVED = 348] = "FIRST_VIDEO_RECEIVED", t11[t11.FIRST_AUDIO_RECEIVED = 349] = "FIRST_AUDIO_RECEIVED", t11[t11.FIRST_VIDEO_DECODE = 350] = "FIRST_VIDEO_DECODE", t11[t11.FIRST_AUDIO_DECODE = 351] = "FIRST_AUDIO_DECODE", t11[t11.ON_ADD_AUDIO_STREAM = 352] = "ON_ADD_AUDIO_STREAM", t11[t11.ON_ADD_VIDEO_STREAM = 353] = "ON_ADD_VIDEO_STREAM", t11[t11.ON_UPDATE_STREAM = 356] = "ON_UPDATE_STREAM", t11[t11.ON_REMOVE_STREAM = 355] = "ON_REMOVE_STREAM", t11[t11.JOIN_CHANNEL_TIMEOUT = 407] = "JOIN_CHANNEL_TIMEOUT", t11[t11.PEER_PUBLISH_STATUS = 408] = "PEER_PUBLISH_STATUS", t11[t11.WORKER_EVENT = 156] = "WORKER_EVENT", t11[t11.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT", t11[t11.JOIN_WEB_PROXY_AP = 700] = "JOIN_WEB_PROXY_AP", t11[t11.WEBSOCKET_QUIT = 671] = "WEBSOCKET_QUIT", t11[t11.USER_ANALYTICS = 1e4] = "USER_ANALYTICS", t11[t11.AUTOPLAY_FAILED = 9178] = "AUTOPLAY_FAILED", t11;
}({});
var bc = class t5 {
  constructor() {
    re(this, "baseInfoMap", /* @__PURE__ */ new Map()), re(this, "proxyServer", void 0), re(this, "eventUploadTimer", void 0), re(this, "setSessionIdTimer", void 0), re(this, "url", void 0), re(this, "backupUrl", void 0), re(this, "_appId", void 0), re(this, "keyEventUploadPendingItems", []), re(this, "normalEventUploadPendingItems", []), re(this, "apiInvokeUploadPendingItems", []), re(this, "apiInvokeCount", 0), re(this, "ltsList", []), re(this, "lastSendNormalEventTime", Date.now()), re(this, "customReportCounterTimer", void 0), re(this, "customReportCount", 0), re(this, "extApiInvoke", async (e) => {
      for (let n of e) {
        let i = ot(ot({}, n), {}, { sid: null, invokeId: ++this.apiInvokeCount, tag: Zt.TRACER });
        this.sendApiInvoke(i);
      }
    }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), v("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), v("EVENT_REPORT_SEND_INTERVAL"));
  }
  getBaseInfoBySessionId(e) {
    return this.baseInfoMap.get(e);
  }
  adjustSessionStartTime(e) {
    if (!this.baseInfoMap.has(e) && !this.baseInfoMap.get(e)) return void _.error("adjust session ".concat(e, " start time, sid is not exist or info is undefined"));
    let n = this.baseInfoMap.get(e), i = Date.now(), r = n.startTime;
    n.startTime = i, _.debug("rewrite session ".concat(e, " startTime: ").concat(i, " , ").concat(i - r, "ms")), this.baseInfoMap.set(e, n);
  }
  setAppId(e) {
    this._appId = e;
  }
  reportApiInvoke(e, n, i) {
    n.timeout = n.timeout || 6e4, n.reportResult = n.reportResult === void 0 || n.reportResult;
    let r = Date.now();
    this.apiInvokeCount += 1;
    let o = this.apiInvokeCount, s = () => ({ tag: n.tag, invokeId: o, sid: e, name: n.name, apiInvokeTime: r, options: n.options, states: n.states || null }), a = !!v("SHOW_REPORT_INVOKER_LOG");
    a && _.info("".concat(n.name, " start"), n.options);
    let c = false;
    Me(n.timeout).then(() => {
      c || (this.sendApiInvoke(ot(ot({}, s()), {}, { error: R.API_INVOKE_TIMEOUT, success: false })), _.debug("".concat(n.name, " timeout")));
    });
    let d = new N(R.UNEXPECTED_ERROR, "".concat(n.name, ": this api invoke is end"));
    return { onSuccess: (l) => {
      let u = () => {
        if (c) throw d;
        return c = true, this.sendApiInvoke(ot(ot({}, s()), {}, { success: true }, n.reportResult && { result: l })), a && _.info("".concat(n.name, " onSuccess")), l;
      };
      return i ? RR(u, n.name + "Success", i, () => c = true) : u();
    }, onError: (l) => {
      let u = () => {
        if (c) throw l;
        c = true, this.sendApiInvoke(ot(ot({}, s()), {}, { success: false, error: l })), a && _.info("".concat(n.name, " onFailure"), l.toString());
      };
      return i ? RR(u, n.name + "Error", i, () => c = true) : u();
    } };
  }
  sessionInit(e, n) {
    if (this.baseInfoMap.has(e)) return;
    let i = Date.now(), r = this.createBaseInfo(e, i);
    r.cname = n.cname;
    let o = Object.assign({}, { willUploadConsoleLog: v("UPLOAD_LOG"), maxTouchPoints: navigator.maxTouchPoints, areaVersion: pf ? "global" : "oversea", areas: v("AREAS") && v("AREAS").join(",") }, n.extend), { stringUid: s, channelProfile: a, channelMode: c, isABTestSuccess: d, lsid: l, clientRole: u } = n, h = Date.now(), p = ot(ot({}, r), {}, { eventType: De.SESSION_INIT, appid: n.appid, browser: navigator.userAgent, buildFormat: n.buildFormat, build: Ef, lts: h, elapse: h - i, extend: JSON.stringify(o), mode: n.mode, process: v("PROCESS_ID"), appType: v("APP_TYPE"), success: true, version: ii, stringUid: s, channelProfile: a, channelMode: c, isABTestSuccess: d, lsid: l, clientType: W(g = window.navigator.userAgent).call(g, "AgoraWebView") ? 42 : 20, clientRole: u, serviceId: v("PROCESS_ID"), extensionID: v("PLUGIN_INFO").join(",") || "" });
    var g;
    this.send({ type: Jt.SESSION, data: p }, true);
  }
  joinChooseServer(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info, o = Date.now(), s = ot(ot({}, r), {}, { eventType: De.JOIN_CHOOSE_SERVER, lts: o, eventElapse: n.elapse || o - n.lts, chooseServerAddr: n.csAddr, errorCode: n.ec, elapse: o - i.startTime, success: n.succ, chooseServerAddrList: JSON.stringify(n.serverList), uid: n.uid ? parseInt(n.uid) : null, cid: n.cid ? parseInt(n.cid) : null, chooseServerIp: n.csIp || "", opid: n.opid, unilbsServerIds: n.unilbsServerIds, extend: n.extend || void 0, isHttp3: n.isHttp3 });
    this.send({ type: Jt.JOIN_CHOOSE_SERVER, data: s }, true);
  }
  reqUserAccount(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info, o = Date.now(), s = ot(ot({}, r), {}, { eventType: De.REQ_USER_ACCOUNT, lts: o, success: n.success, serverAddress: n.serverAddr, stringUid: n.stringUid, uid: n.uid, errorCode: n.errorCode, elapse: n.elapse || o - i.startTime, eventElapse: o - n.lts, extend: JSON.stringify(n.extend) });
    this.send({ type: Jt.REQ_USER_ACCOUNT, data: s }, true);
  }
  joinGateway(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info;
    n.vid && (r.vid = n.vid), r.uid = n.uid, r.cid = n.cid;
    let o = Date.now(), { firstSuccess: s, avoidJoinStartTime: a } = n, c = o - (s && a ? a : i.startTime), d = ot(ot({}, r), {}, { eventType: De.JOIN_GATEWAY, lts: o, gatewayAddr: n.addr, success: n.succ, errorCode: n.ec, errorMsg: n.errorMsg || "", elapse: c, eventElapse: o - n.lts, firstSuccess: s, signalChannel: n.signalChannel, preload: n.preload ? 1 : 0 });
    n.succ && (i.lastJoinSuccessTime = o), this.send({ type: Jt.JOIN_GATEWAY, data: d }, true);
  }
  joinChannelTimeout(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = Date.now(), o = ot(ot({}, i.info), {}, { lts: r, timeout: n, elapse: r - i.startTime });
    this.send({ type: Jt.JOIN_CHANNEL_TIMEOUT, data: o }, true);
  }
  publish(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info, o = Date.now(), s = ot(ot({}, r), {}, { eventType: De.PUBLISH, lts: o, eventElapse: n.eventElapse, elapse: o - i.startTime, success: n.succ, errorCode: n.ec, videoName: n.videoName, audioName: n.audioName, screenName: n.screenName, screenshare: n.screenshare, audio: n.audio, video: n.video, p2pid: n.p2pid, publishRequestid: n.publishRequestid });
    this.send({ type: Jt.PUBLISH, data: s }, true);
  }
  subscribe(e, n, i) {
    let r = this.baseInfoMap.get(e);
    if (!r) return;
    let o = r.info, s = Date.now(), a = ot(ot({}, o), {}, { eventType: De.SUBSCRIBE, lts: s, eventElapse: n.eventElapse, elapse: s - r.startTime, success: n.succ, errorCode: n.ec, video: n.video, audio: n.audio, subscribeRequestid: n.subscribeRequestid, p2pid: n.p2pid, preSsrc: n.preSsrc ? 1 : 0 }, i && { extend: JSON.stringify({ isMassSubscribe: true }) });
    typeof n.peerid == "string" ? a.peerSuid = n.peerid : a.peer = n.peerid, this.send({ type: Jt.SUBSCRIBE, data: a }, true);
  }
  wsCompressorInit(e) {
    var n;
    let i = [...xn(n = this.baseInfoMap).call(n)], r = i.length ? i[0] : "UnableToGetSid", o = this.baseInfoMap.get(r);
    if (!o) return;
    let s = o.info, a = Date.now(), c = ot(ot({}, s), {}, { eventType: De.WS_COMPRESSOR_INIT, lts: a, eventElapse: e.eventElapse, elapse: a - o.startTime, status: e.status ? 1 : 2 });
    this.send({ type: Jt.WS_COMPRESSOR_INIT, data: c }, true);
  }
  firstRemoteVideoDecode(e, n, i, r) {
    let o = this.baseInfoMap.get(e);
    if (!o) return;
    let s = o.info, a = Date.now(), c = ot(ot(ot({}, s), r), {}, { elapse: a - o.startTime, eventType: n, lts: a, firstDecodeFrame: Math.max((r.firstFrame || a) - o.startTime, 0), apEnd: Math.max(r.apEnd - o.startTime, 0), apStart: Math.max(r.apStart - o.startTime, 0), joinGwEnd: Math.max(r.joinGwEnd - o.startTime, 0), joinGwStart: Math.max(r.joinGwStart - o.startTime, 0), pcEnd: Math.max(r.pcEnd - o.startTime, 0), pcStart: Math.max(r.pcStart - o.startTime, 0), subscriberEnd: Math.max(r.subscriberEnd - o.startTime, 0), subscriberStart: Math.max(r.subscriberStart - o.startTime, 0), videoAddNotify: Math.max(r.videoAddNotify - o.startTime, 0) });
    this.send({ type: i, data: c }, true);
  }
  firstRemoteFrame(e, n, i, r) {
    let o = this.baseInfoMap.get(e);
    if (!o) return;
    let s = o.info, a = Date.now(), c = ot(ot(ot({}, s), r), {}, { elapse: a - o.startTime, eventType: n, lts: a });
    this.send({ type: i, data: c }, true);
  }
  pcStats(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info, o = Date.now(), s = ot(ot(ot({}, r), n), {}, { vid: r.vid === void 0 ? 0 : Number(r.vid), elapse: o - i.startTime, eventType: De.PC_STATS, lts: o, preallocation: n.preallocation ? 1 : 0 });
    this.send({ type: Jt.PC_STATS, data: s }, true);
  }
  updateRemoteRTPCapabilities(e, n) {
    if (e) {
      let i = this.baseInfoMap.get(e);
      if (!i) return;
      let r = i.info, o = Date.now(), s = ot(ot(ot({}, r), n), {}, { vid: r.vid === void 0 ? 0 : Number(r.vid), eventType: De.UPDATE_REMOTE_RTPCAPABILITIES, lts: o });
      this.send({ type: Jt.UPDATE_REMOTE_RTPCAPABILITIES, data: s }, true);
    }
  }
  onGatewayStream(e, n, i, r) {
    let o = this.baseInfoMap.get(e);
    if (!o) return;
    let s = o.info, a = Date.now(), c = ot(ot(ot({}, s), r), {}, { eventType: n, lts: a });
    this.send({ type: i, data: c }, true);
  }
  streamSwitch(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info, o = Date.now(), s = ot(ot({}, r), {}, { eventType: De.STREAM_SWITCH, lts: o, isDual: n.isdual, elapse: o - i.startTime, success: n.succ });
    this.send({ type: Jt.STREAM_SWITCH, data: s }, true);
  }
  requestProxyAppCenter(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info, o = Date.now(), s = ot(ot({}, r), {}, { eventType: De.REQUEST_PROXY_APPCENTER, lts: o, eventElapse: o - n.lts, elapse: o - i.startTime, APAddr: n.APAddr, workerManagerList: n.workerManagerList, response: n.response, errorCode: n.ec, success: n.succ });
    this.send({ type: Jt.REQUEST_PROXY_APPCENTER, data: s }, true);
  }
  requestProxyWorkerManager(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info, o = Date.now(), s = ot(ot({}, r), {}, { eventType: De.REQUEST_PROXY_WORKER_MANAGER, lts: o, eventElapse: o - n.lts, elapse: o - i.startTime, workerManagerAddr: n.workerManagerAddr, response: n.response, errorCode: n.ec, success: n.succ });
    this.send({ type: Jt.REQUEST_PROXY_WORKER_MANAGER, data: s }, true);
  }
  setProxyServer(e) {
    this.proxyServer = e, e ? _.debug("reportProxyServerurl: ".concat(e)) : _.debug("disable reportProxyServerurl: ".concat(e));
  }
  peerPublishStatus(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info, o = Date.now(), s = ot(ot({}, r), {}, { subscribeElapse: n.subscribeElapse, peer: n.peer, peerPublishDuration: Math.max(n.audioPublishDuration, n.videoPublishDuration), audiotag: n.audioPublishDuration > 0 ? 1 : -1, videotag: n.videoPublishDuration > 0 ? 1 : -1, lts: o, elapse: o - i.startTime, joinChannelSuccessElapse: o - (i.lastJoinSuccessTime || o), peerPublishDurationVideo: n.videoPublishDuration, peerPublishDurationAudio: n.audioPublishDuration });
    this.send({ type: Jt.PEER_PUBLISH_STATUS, data: s }, true);
  }
  workerEvent(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info, o = Date.now();
    (function(s, a, c) {
      let d = s[a];
      if (!d || typeof d != "string") return [s];
      s[a] = "";
      let l = ar(JSON.stringify(s)), u = 0, h = [], p = 0;
      for (let g = 0; g < d.length; g++) p += d.charCodeAt(g) <= 127 ? 1 : 3, p <= c - l || (h[h.length] = J(J({}, s), {}, { [a]: d.substring(u, g) }), u = g, p = d.charCodeAt(g) <= 127 ? 1 : 3);
      return u !== d.length - 1 && (h[h.length] = J(J({}, s), {}, { [a]: d.substring(u) })), h;
    })(ot(ot(ot({}, r), n), {}, { elapse: o - i.startTime, lts: o, productType: "WebRTC" }), "payload", 1300).forEach((s) => this.send({ type: Jt.WORKER_EVENT, data: s }, true));
  }
  apworkerEvent(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info, o = Date.now(), s = ot(ot(ot({}, r), n), {}, { elapse: o - i.startTime, lts: o });
    this.send({ type: Jt.AP_WORKER_EVENT, data: s }, true);
  }
  joinWebProxyAP(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info, o = Date.now(), s = ot(ot(ot({}, r), n), {}, { elapse: o - i.startTime, lts: o, extend: n.extend || void 0 });
    this.send({ type: Jt.JOIN_WEB_PROXY_AP, data: s }, true);
  }
  WebSocketQuit(e, n) {
    let i = this.baseInfoMap.get(e);
    if (!i) return;
    let r = i.info, o = Date.now(), s = ot(ot(ot({}, r), n), {}, { elapse: o - i.startTime, lts: o });
    this.send({ type: Jt.WEBSOCKET_QUIT, data: s }, true);
  }
  async sendCustomReportMessage(e, n) {
    if (this.customReportCount += n.length, this.customReportCount > v("CUSTOM_REPORT_LIMIT")) throw new N(R.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
    this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {
      this.customReportCount = 0;
    }, 5e3));
    let i = Date.now(), r = n.map((o) => ({ type: Jt.USER_ANALYTICS, data: ot(ot({ sid: e }, o), {}, { lts: i }) }));
    try {
      v("NEW_REPORT_SERVER") ? await this.postDataToStatsCollector2(r) : await this.postDataToStatsCollector(r);
    } catch (o) {
      throw _.error("send custom report message failed", o.toString()), new N(R.CUSTOM_REPORT_SEND_FAILED, o.message);
    }
  }
  sendApiInvoke(e) {
    let n = v("NOT_REPORT_EVENT");
    if (e.tag && W(n) && W(n).call(n, e.tag)) return false;
    if (e.sid === null) return this.apiInvokeUploadPendingItems.push(e), false;
    let i = this.baseInfoMap.get(e.sid);
    if (!i) return this.apiInvokeUploadPendingItems.push(e), false;
    let { cname: r, uid: o, cid: s } = i.info, a;
    if (e.lts = e.lts || Date.now(), e.error) if (e.error instanceof N) {
      let { code: d, message: l } = e.error;
      a = d || l || e.error.toString();
    } else a = e.error.toString();
    let c = { invokeId: e.invokeId, sid: e.sid, cname: r, cid: s, uid: o, lts: e.lts, success: e.success, elapse: e.lts - i.startTime, execElapse: e.lts - e.apiInvokeTime, apiName: e.name, options: e.options ? JSON.stringify(e.options) : void 0, execStates: e.states ? JSON.stringify(e.states) : void 0, execResult: e.result ? JSON.stringify(e.result) : void 0, errorCode: e.error ? a : void 0, errorMsg: e.error ? JSON.stringify(e.error) : void 0 };
    return this.send({ type: Jt.API_INVOKE, data: c }, false), true;
  }
  appendSessionId() {
    t5.__CLIENT_LIST__.forEach((e) => {
      if (e._sessionId) {
        let n = this.apiInvokeUploadPendingItems.length;
        for (let i = 0; i < n; i++) {
          let r = this.apiInvokeUploadPendingItems.shift();
          r && (r.sid = e._sessionId, this.sendApiInvoke(Object.assign({}, r)));
        }
      }
    });
  }
  send(e, n) {
    if (n) return this.keyEventUploadPendingItems.push(e), void this.sendItems(this.keyEventUploadPendingItems, true);
    this.normalEventUploadPendingItems.push(e), this.normalEventUploadPendingItems.length > v("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, false);
  }
  doSend() {
    this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, true), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, false);
  }
  sendItems(e, n) {
    let i = [], r = [];
    for (; e.length; ) {
      let s = e.shift();
      i.length < 20 ? i.push(s) : r.push(s);
    }
    e.push(...r);
    for (let s of [...i]) {
      var o;
      this.ltsList.indexOf(s.data.lts) !== -1 ? (s.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(s.data.lts)) : (this.ltsList.push(s.data.lts), ed(o = this.ltsList).call(o, (a, c) => a - c));
    }
    return n || (this.lastSendNormalEventTime = Date.now()), v("ENABLE_EVENT_REPORT") && i.length && (v("NEW_REPORT_SERVER") ? this.postDataToStatsCollector2(i) : this.postDataToStatsCollector(i)).catch(/* @__PURE__ */ ((s) => (a) => {
      v("EVENT_REPORT_RETRY") && (n ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(s) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(s), this.normalEventUploadPendingItems.length > v("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - v("NORMAL_EVENT_QUEUE_CAPACITY")), _.warning("report: drop normal events"))));
    })(i)), e;
  }
  async postDataToStatsCollector2(e) {
    he.networkState === wn.OFFLINE && await j.race([he.onlineWaiter, Me(2 * Ee.maxRetryTimeout)]);
    let n = (o) => {
      let s = new Uint8Array();
      return o.forEach((a) => {
        let c = uf(JSON.stringify(a.data)), d = new ArrayBuffer(5), l = ((h) => {
          let p = 0;
          return Object.entries(Jt).forEach((g) => {
            let [E, f] = g;
            f === h.type && (p = IB[E]);
          }), p;
        })(a), u = new DataView(d);
        u.setUint16(0, c.byteLength, true), u.setUint8(2, 255 & l), u.setUint8(3, l >>> 8 & 255), u.setUint8(4, l >>> 16 & 255), s = ER(s, new Uint8Array(d)), s = ER(s, c);
      }), s;
    }, i = "event", r = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(v("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=").concat(i) : "https://".concat(v("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(i);
    for (let o = 0; o < 2; o += 1) {
      o === 1 && (r = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(v("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=").concat(i) : "https://".concat(v("NEW_REPORT_SERVER_DOMAINS")[1], "/").concat(i));
      try {
        await LE(r, { timeout: 1e4, data: n(e), headers: ot(ot({ biz: "webrtc", sendts: Math.round(Date.now() / 1e3), debug: "false" }, this._appId && { appid: this._appId }), {}, { "Content-Type": "application/octet-stream" }) }, true);
      } catch (s) {
        if (o === 1) throw s;
        continue;
      }
      return;
    }
  }
  async postDataToStatsCollector(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], i = { msgType: "EventMessages", sentTs: Math.round(Date.now() / 1e3), payloads: e.map((s) => JSON.stringify(s)), vid: ((s) => {
      let a = s && s.data.sid && this.baseInfoMap.get(s.data.sid);
      return a && a.info.vid && +a.info.vid || 0;
    })(e[0]) };
    he.networkState === wn.OFFLINE && await j.race([he.onlineWaiter, Me(2 * Ee.maxRetryTimeout)]);
    let r = n ? "/events/proto-raws" : "/events/messages", o = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(v("EVENT_REPORT_DOMAIN"), "&p=").concat(v("STATS_COLLECTOR_PORT"), "&d=").concat(r) : "https://".concat(v("EVENT_REPORT_DOMAIN"), ":").concat(v("STATS_COLLECTOR_PORT")).concat(r));
    for (let s = 0; s < 2; s += 1) {
      s === 1 && (o = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(v("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(v("STATS_COLLECTOR_PORT"), "&d=").concat(r) : "https://".concat(v("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(v("STATS_COLLECTOR_PORT")).concat(r)));
      try {
        n ? await gB(o, { timeout: 1e4, data: i }) : await LE(o, { timeout: 1e4, data: i });
      } catch (a) {
        if (s === 1) throw a;
        continue;
      }
      return;
    }
  }
  createBaseInfo(e, n) {
    let i = Object.assign({}, CB);
    return i.sid = e, this.baseInfoMap.set(e, { info: i, startTime: n }), i;
  }
  reportResourceTiming(e, n) {
    let i = performance.getEntriesByName(e), r = i[i.length - 1];
    r && this.reportApiInvoke(n, { name: "Client.resourceTiming", options: r, tag: Zt.TRACER }).onSuccess();
  }
};
function $() {
  let t11 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return function(e, n, i) {
    let r = i.value;
    if (typeof r == "function") {
      let o = t11.className || e.__className__ || (e.constructor.name === "AgoraRTCClient" ? "Client" : e.constructor.name);
      i.value = function() {
        for (var s = arguments.length, a = new Array(s), c = 0; c < s; c++) a[c] = arguments[c];
        let d = a;
        if (t11.argsMap) try {
          d = t11.argsMap(this, ...a);
        } catch (u) {
          _.warning(u), d = [];
        }
        try {
          JSON.stringify(d);
        } catch {
          _.warning("arguments for method ".concat(o, ".").concat(String(n), " not serializable for apiInvoke.")), d = [];
        }
        let l = (t11.report || X).reportApiInvoke(this._sessionId || null, { name: "".concat(o, ".").concat(String(n)), options: d, tag: Zt.TRACER, reportResult: t11.reportResult }, t11.throttleTime);
        try {
          let u = r.apply(this, a);
          return u instanceof j ? u.then((h) => (l.onSuccess(t11.reportResult && h), h)).catch((h) => {
            throw l.onError(h), h;
          }) : (l.onSuccess(t11.reportResult && u), u);
        } catch (u) {
          throw l.onError(u), u;
        }
      };
    }
    return i;
  };
}
re(bc, "__CLIENT_LIST__", []);
var X = new bc();
wO.on("REPORT_LOG_UPLOAD", (t11) => {
  t11.networkState = he.networkState, X.reportApiInvoke(null, { name: "logUploadError", options: t11, tag: Zt.TRACER }).onSuccess("logUploadError");
});
var vB = ["CHINA", "GLOBAL"];
var Ve = function() {
  let t11 = "us".concat("erna", "me"), e = "pa".concat("sswo", "rd"), n = ["t", "s", "t"];
  n.splice(1, 0, "e");
  let i = n.join(""), r = [];
  for (let a = 0; a < 6; a++) r.push("1");
  let o = r.join(""), s = {};
  return s[t11] = i, s[e] = o, Object.assign(s, { turnServerURL: "", tcpport: 3433, udpport: 3478, forceturn: false });
}();
window.DEFAULT_TURN_CONFIG = Ve, pf || (oe.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], oe.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], oe.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], oe.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], oe.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], oe.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], oe.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", oe.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", oe.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", oe.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", oe.AREAS = ["NORTH_AMERICA", "OVERSEA"]);
var OO = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]];
var Jr = [];
function Io(t11, e) {
  return !!e && Jr.some((n) => n.uid === t11 && n.channelName === e);
}
bc.__CLIENT_LIST__ = Jr;
var yB = bw.forEach;
var NR = Nu("forEach") ? [].forEach : function(t11) {
  return yB(this, t11, arguments.length > 1 ? arguments[1] : void 0);
};
xt({ target: "Array", proto: true, forced: [].forEach != NR }, { forEach: NR });
var AB = bi("Array").forEach;
var bB = Er;
var wB = Je;
var OB = hn;
var NB = AB;
var Dp = Array.prototype;
var DB = { DOMTokenList: true, NodeList: true };
var PB = function(t11) {
  var e = t11.forEach;
  return t11 === Dp || OB(Dp, t11) && e === Dp.forEach || wB(DB, bB(t11)) ? NB : e;
};
var kB = ae(PB);
var LB = _r;
var DR = Lu;
xt({ target: "Object", stat: true, forced: Se(function() {
  DR(1);
}) }, { keys: function(t11) {
  return DR(LB(t11));
} });
var NO = ae(Gi.Object.keys);
var MB = ae(VA);
var UB = xt;
var xB = nd;
var VB = me([].reverse);
var PR = [1, 2];
UB({ target: "Array", proto: true, forced: String(PR) === String(PR.reverse()) }, { reverse: function() {
  return xB(this) && (this.length = this.length), VB(this);
} });
var FB = bi("Array").reverse;
var BB = hn;
var jB = FB;
var Pp = Array.prototype;
var GB = function(t11) {
  var e = t11.reverse;
  return t11 === Pp || BB(Pp, t11) && e === Pp.reverse ? jB : e;
};
var DO = GB;
var WB = ae(DO);
var HB = xt;
var kR = nd;
var KB = xu;
var YB = Hn;
var LR = Om;
var qB = Lr;
var zB = Eo;
var JB = Bu;
var XB = pe;
var QB = Gm;
var ZB = Iw("slice");
var $B = XB("species");
var kp = Array;
var tj = Math.max;
HB({ target: "Array", proto: true, forced: !ZB }, { slice: function(t11, e) {
  var n, i, r, o = zB(this), s = qB(o), a = LR(t11, s), c = LR(e === void 0 ? s : e, s);
  if (kR(o) && (n = o.constructor, (KB(n) && (n === kp || kR(n.prototype)) || YB(n) && (n = n[$B]) === null) && (n = void 0), n === kp || n === void 0)) return QB(o, a, c);
  for (i = new (n === void 0 ? kp : n)(tj(c - a, 0)), r = 0; a < c; a++, r++) a in o && JB(i, r, o[a]);
  return i.length = r, i;
} });
var ej = bi("Array").slice;
var nj = hn;
var ij = ej;
var Lp = Array.prototype;
var rj = function(t11) {
  var e = t11.slice;
  return t11 === Lp || nj(Lp, t11) && e === Lp.slice ? ij : e;
};
var oj = ae(rj);
function q(t11, e, n, i, r) {
  var o, s, a, c = {};
  return kB(o = NO(i)).call(o, function(d) {
    c[d] = i[d];
  }), c.enumerable = !!c.enumerable, c.configurable = !!c.configurable, ("value" in c || c.initializer) && (c.writable = true), c = MB(s = WB(a = oj(n).call(n)).call(a)).call(s, function(d, l) {
    return l(t11, e, d) || d;
  }, c), r && c.initializer !== void 0 && (c.value = c.initializer ? c.initializer.call(r) : void 0, c.initializer = void 0), c.initializer === void 0 && (Rw(t11, e, c), c = null), c;
}
var xE = function(t11) {
  return t11.L1T1 = "L1T1", t11.L1T2 = "L1T2", t11.L1T3 = "L1T3", t11.L1T3_KEY = "L1T3_KEY", t11.L2T1_KEY = "L2T1_KEY", t11.L2T2_KEY = "L2T2_KEY", t11.L2T3_KEY = "L2T3_KEY", t11.L3T1_KEY = "L3T1_KEY", t11.L3T2_KEY = "L3T2_KEY", t11.L3T3_KEY = "L3T3_KEY", t11;
}({});
var kn = function(t11) {
  return t11.CERTIFICATE = "certificate", t11.CODEC = "codec", t11.CANDIDATE_PAIR = "candidate-pair", t11.LOCAL_CANDIDATE = "local-candidate", t11.REMOTE_CANDIDATE = "remote-candidate", t11.INBOUND = "inbound-rtp", t11.TRACK = "track", t11.OUTBOUND = "outbound-rtp", t11.PC = "peer-connection", t11.REMOTE_INBOUND = "remote-inbound-rtp", t11.REMOTE_OUTBOUND = "remote-outbound-rtp", t11.TRANSPORT = "transport", t11.CSRC = "csrc", t11.DATA_CHANNEL = "data-channel", t11.STREAM = "stream", t11.SENDER = "sender", t11.RECEIVER = "receiver", t11;
}({});
var gl = function(t11) {
  return t11[t11.ACCESS_POINT = 101] = "ACCESS_POINT", t11[t11.UNILBS = 201] = "UNILBS", t11[t11.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR", t11;
}({});
var Mp = function(t11) {
  return t11[t11.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", t11[t11.IIIEGAL_UID = 2] = "IIIEGAL_UID", t11[t11.INTERNAL_ERROR = 3] = "INTERNAL_ERROR", t11;
}({});
var ci = function(t11) {
  return t11[t11.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", t11[t11.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", t11[t11.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", t11[t11.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", t11[t11.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", t11[t11.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", t11[t11.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", t11[t11.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", t11[t11.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", t11[t11.USER_OVERLOAD = 16] = "USER_OVERLOAD", t11[t11.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", t11[t11.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND", t11;
}({});
var on = function(t11) {
  return t11[t11.NO_FLAG_SET = 100] = "NO_FLAG_SET", t11[t11.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", t11[t11.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", t11[t11.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", t11[t11.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", t11[t11.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", t11[t11.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", t11[t11.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", t11[t11.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", t11[t11.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", t11[t11.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", t11[t11.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", t11[t11.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", t11[t11.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", t11[t11.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", t11[t11.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", t11[t11.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", t11[t11.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", t11[t11.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV", t11;
}({});
var Z = function(t11) {
  return t11[t11.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", t11[t11.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", t11[t11.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", t11[t11.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", t11[t11.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", t11[t11.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", t11[t11.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", t11[t11.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", t11[t11.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", t11[t11.K_UID_BANNED = 14] = "K_UID_BANNED", t11[t11.K_IP_BANNED = 15] = "K_IP_BANNED", t11[t11.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", t11[t11.K_AUTO_REBALANCE = 28] = "K_AUTO_REBALANCE", t11[t11.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", t11[t11.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", t11[t11.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", t11[t11.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", t11[t11.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", t11[t11.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", t11[t11.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", t11[t11.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", t11[t11.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", t11[t11.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", t11[t11.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", t11[t11.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", t11[t11.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", t11[t11.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", t11[t11.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", t11[t11.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", t11[t11.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", t11[t11.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", t11[t11.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", t11[t11.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", t11[t11.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", t11[t11.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", t11[t11.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", t11[t11.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", t11[t11.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", t11[t11.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", t11[t11.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", t11[t11.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", t11[t11.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", t11[t11.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", t11[t11.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", t11[t11.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", t11[t11.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", t11[t11.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", t11[t11.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", t11[t11.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", t11[t11.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", t11[t11.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", t11[t11.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", t11[t11.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", t11[t11.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", t11[t11.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", t11[t11.ERR_LICENSE_MISSING = 32769] = "ERR_LICENSE_MISSING", t11[t11.ERR_LICENSE_EXPIRED = 32771] = "ERR_LICENSE_EXPIRED", t11[t11.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = "ERR_LICENSE_MINUTES_EXCEEDED", t11[t11.ERR_LICENSE_PERIOD_INVALID = 32774] = "ERR_LICENSE_PERIOD_INVALID", t11[t11.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = "ERR_LICENSE_MULTIPLE_SDK_SERVICE", t11[t11.ERR_LICENSE_ILLEGAL = 32783] = "ERR_LICENSE_ILLEGAL", t11[t11.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", t11[t11.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", t11[t11.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY", t11;
}({});
var Lt = function(t11) {
  return t11.CONNECTING = "connecting", t11.CONNECTED = "connected", t11.RECONNECTING = "reconnecting", t11.CLOSED = "closed", t11;
}({});
var nt = function(t11) {
  return t11.WS_CONNECTED = "ws_connected", t11.WS_RECONNECTING = "ws_reconnecting", t11.WS_CLOSED = "ws_closed", t11.WS_RECONNECT_WAITTING_FINISH = "ws_reconnect_waitting_finish", t11.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", t11.ON_BINARY_DATA = "on_binary_data", t11.REQUEST_RECOVER = "request_recover", t11.REQUEST_JOIN_INFO = "request_join_info", t11.REQUEST_REJOIN_INFO = "req_rejoin_info", t11.IS_P2P_DISCONNECTED = "is_p2p_dis", t11.DISCONNECT_P2P = "dis_p2p", t11.ABORT_P2P_EXECUTION = "abort_p2p_execution", t11.NEED_RENEW_SESSION = "need-sid", t11.REPORT_JOIN_GATEWAY = "report_join_gateway", t11.REQUEST_TIMEOUT = "request_timeout", t11.REQUEST_SUCCESS = "request_success", t11.JOIN_RESPONSE = "join_response", t11.PRE_CONNECT_PC = "pre_connect_pc", t11.P2P_CONNECTION = "p2p_connection", t11.P2P_REMOTE_CANDIDATE_UPDATE = "p2p_remote_candidate_update", t11.P2P_SUBSCRIBE = "p2p_subscribe", t11.P2P_UNSUBSCRIBE = "p2p_unsubscribe", t11.P2P_EXCHANGE_SDP = "p2p_exchange_sdp", t11.P2P_ON_ADD_VIDEO_STREAM = "p2p_on_add_video_stream", t11.P2P_ON_ADD_AUDIO_STREAM = "p2p_on_add_audio_stream", t11;
}({});
var et = function(t11) {
  return t11.PING = "ping", t11.PING_BACK = "ping_back", t11.JOIN = "join_v3", t11.REJOIN = "rejoin_v3", t11.LEAVE = "leave", t11.SET_CLIENT_ROLE = "set_client_role", t11.PUBLISH = "publish", t11.PUBLISH_DATASTREAM = "publish_datastream", t11.UNPUBLISH = "unpublish", t11.UNPUBLISH_DATASTREAM = "unpublish_datastream", t11.SUBSCRIBE = "subscribe", t11.PRE_SUBSCRIBE = "pre_subscribe", t11.SUBSCRIBE_DATASTREAM = "subscribe_datastream", t11.SUBSCRIBE_STREAMS = "subscribe_streams", t11.UNSUBSCRIBE = "unsubscribe", t11.UNSUBSCRIBE_DATASTREAM = "unsubscribe_datastream", t11.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", t11.SUBSCRIBE_CHANGE = "subscribe_change", t11.TRAFFIC_STATS = "traffic_stats", t11.RENEW_TOKEN = "renew_token", t11.SWITCH_VIDEO_STREAM = "switch_video_stream", t11.DEFAULT_VIDEO_STREAM = "default_video_stream", t11.SET_FALLBACK_OPTION = "set_fallback_option", t11.GATEWAY_INFO = "gateway_info", t11.CONTROL = "control", t11.SEND_METADATA = "send_metadata", t11.DATA_STREAM = "data_stream", t11.PICK_SVC_LAYER = "pick_svc_layer", t11.RESTART_ICE = "restart_ice", t11.CONNECT_PC = "connect_pc", t11.SET_VIDEO_PROFILE = "set_video_profile", t11.SET_PARAMETER = "set_parameter", t11.SET_RTM2_FLAG = "set_rtm2_flag", t11;
}({});
var wc = function(t11) {
  return t11.WRTC_STATS = "wrtc_stats", t11.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", t11.DENOISER_STATS = "denoiser_stats", t11.EXTENSION_USAGE_STATS = "extension_usage_stats", t11;
}({});
var dt = function(t11) {
  return t11.ON_USER_ONLINE = "on_user_online", t11.ON_USER_OFFLINE = "on_user_offline", t11.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", t11.ON_PUBLISH_STREAM = "on_publish_stream", t11.ON_UPLINK_STATS = "on_uplink_stats", t11.ON_P2P_LOST = "on_p2p_lost", t11.ON_REMOVE_STREAM = "on_remove_stream", t11.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", t11.ON_ADD_VIDEO_STREAM = "on_add_video_stream", t11.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", t11.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", t11.ON_USER_BANNED = "on_user_banned", t11.ON_USER_LICENSE_BANNED = "on_user_license_banned", t11.ON_NOTIFICATION = "on_notification", t11.ON_CRYPT_ERROR = "on_crypt_error", t11.MUTE_AUDIO = "mute_audio", t11.MUTE_VIDEO = "mute_video", t11.UNMUTE_AUDIO = "unmute_audio", t11.UNMUTE_VIDEO = "unmute_video", t11.ON_P2P_OK = "on_p2p_ok", t11.RECEIVE_METADATA = "receive_metadata", t11.ON_DATA_STREAM = "on_data_stream", t11.ON_RTP_CAPABILITY_CHANGE = "on_rtp_capability_change", t11.ON_REMOTE_DATASTREAM_UPDATE = "on_remote_datastream_update", t11.ON_REMOTE_FULL_DATASTREAM_INFO = "on_remote_full_datastream_info", t11.ENABLE_LOCAL_VIDEO = "enable_local_video", t11.DISABLE_LOCAL_VIDEO = "disable_local_video", t11.ENABLE_LOCAL_AUDIO = "enable_local_audio", t11.DISABLE_LOCAL_AUDIO = "disable_local_audio", t11.ON_PUBLISHED_USER_LIST = "on_published_user_list", t11;
}({});
var cn = function(t11) {
  return t11.SEND_ONLY = "SEND_ONLY", t11.RECEIVE_ONLY = "RECEIVE_ONLY", t11;
}({});
var it = function(t11) {
  return t11.CONNECTED = "websocket:connected", t11.RECONNECTING = "websocket:reconnecting", t11.WILL_RECONNECT = "websocket:will_reconnect", t11.CLOSED = "websocket:closed", t11.FAILED = "websocket:failed", t11.ON_MESSAGE = "websocket:on_message", t11.REQUEST_NEW_URLS = "websocket:request_new_urls", t11.RECONNECT_WAITTING_FINISH = "websocket:reconnect_waitting_finish", t11.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection", t11.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "websocket:on_token_privilege_did_expire", t11;
}({});
var O = class extends N {
  constructor(e) {
    super(e, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", arguments.length > 2 ? arguments[2] : void 0), T(this, "name", "AgoraRTCException");
  }
  print() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "error";
    return super.print(e, _);
  }
  throw() {
    super.throw(_);
  }
};
function Xu(t11) {
  if (typeof t11 != "string" || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(t11)) throw _.error("Invalid Channel Name ".concat(t11)), new O(R.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,");
}
function Qu(t11) {
  if (!function(e) {
    return typeof e == "number" && Math.floor(e) === e && 0 <= e && e <= 4294967295;
  }(t11) && !RO(t11, 1, 255)) throw new O(R.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
  typeof t11 == "string" && _.warn("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");
}
var er = function(t11) {
  return t11.TRANSCODE = "mix_streaming", t11.RAW = "raw_streaming", t11;
}({});
var sj = { alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0 };
var Up = { x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1 };
function xp(t11, e) {
  Pe(t11.url, "".concat(e, ".url"), 1, 1e3, false), zt(t11.x) || Nt(t11.x, "".concat(e, ".x"), 0, 1e4), zt(t11.y) || Nt(t11.y, "".concat(e, ".y"), 0, 1e4), zt(t11.width) || Nt(t11.width, "".concat(e, ".width"), 0, 1e4), zt(t11.height) || Nt(t11.height, "".concat(e, ".height"), 0, 1e4), zt(t11.zOrder) || Nt(t11.zOrder, "".concat(e, ".zOrder"), 0, 255), zt(t11.alpha) || Nt(t11.alpha, "".concat(e, ".alpha"), 0, 1, false);
}
var aj = { audioBitrate: 48, audioChannels: 1, audioSampleRate: 48e3, backgroundColor: 0, height: 360, lowLatency: false, videoBitrate: 400, videoCodecProfile: 100, videoCodecType: 1, videoFrameRate: 15, videoGop: 30, width: 640, images: [], userConfigs: [], userConfigExtraInfo: "" };
var Xr = function(t11) {
  return t11.WARNING = "@live_uap-warning", t11.ERROR = "@line_uap-error", t11.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", t11.WORKER_STATUS = "@live_uap-worker-status", t11.REQUEST_NEW_ADDRESS = "@live_uap-request-address", t11;
}({});
var VE = function(t11) {
  return t11.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager", t11;
}({});
var fe = function(t11) {
  return t11[t11.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", t11[t11.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", t11[t11.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", t11[t11.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", t11[t11.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", t11[t11.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", t11[t11.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", t11[t11.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", t11[t11.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", t11[t11.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", t11[t11.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", t11[t11.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", t11[t11.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", t11[t11.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", t11[t11.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", t11[t11.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", t11[t11.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", t11[t11.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", t11[t11.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", t11[t11.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", t11[t11.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN", t11;
}({});
function MR(t11) {
  if (!t11.channelName) throw new O(R.INVALID_PARAMS, "invalid channelName in info");
  if (typeof t11.uid != "number") throw new O(R.INVALID_PARAMS, "invalid uid in info, uid must be a number");
  return t11.token && Pe(t11.token, "info.token", 1, 2047), Qu(t11.uid), Xu(t11.channelName), true;
}
var sn = function(t11) {
  return t11[t11.SetSdkProfile = 0] = "SetSdkProfile", t11[t11.SetSourceChannel = 1] = "SetSourceChannel", t11[t11.SetSourceUserId = 2] = "SetSourceUserId", t11[t11.SetDestChannel = 3] = "SetDestChannel", t11[t11.StartPacketTransfer = 4] = "StartPacketTransfer", t11[t11.StopPacketTransfer = 5] = "StopPacketTransfer", t11[t11.UpdateDestChannel = 6] = "UpdateDestChannel", t11[t11.Reconnect = 7] = "Reconnect", t11[t11.SetVideoProfile = 8] = "SetVideoProfile", t11;
}({});
var Ir = function(t11) {
  return t11.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", t11.NETWORK_CONNECTED = "NETWORK_CONNECTED", t11.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", t11.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", t11.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", t11.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", t11.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", t11.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", t11.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", t11.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE", t11;
}({});
var Sn = function(t11) {
  return t11.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", t11.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", t11.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", t11.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE", t11;
}({});
var ys = function(t11) {
  return t11.RELAY_OK = "RELAY_OK", t11.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", t11.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", t11.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED", t11;
}({});
var Ct = function(t11) {
  return t11.High = "high", t11.Low = "low", t11.Audio = "audio", t11.Screen = "screen", t11.ScreenLow = "screen_low", t11;
}({});
var xe = function(t11) {
  return t11.DISCONNECT = "disconnect", t11.CONNECTION_STATE_CHANGE = "connection-state-change", t11.NETWORK_QUALITY = "network-quality", t11.STREAM_TYPE_CHANGE = "stream-type-change", t11.IS_P2P_DISCONNECTED = "is-p2p-dis", t11.DISCONNECT_P2P = "dis-p2p", t11.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", t11.NEED_RENEW_SESSION = "need-sid", t11.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", t11.JOIN_RESPONSE = "join-response", t11.RESET_CONNECTION_EVENTS = "reset-connection-events", t11.PRE_CONNECT_PC = "pre-connect_pc", t11;
}({});
var Tl = function(t11) {
  return t11.P2P_DISCONNECTED = "P2P_DISCONNECTED", t11.A_ROUND_WS_FAILED = "A_ROUND_WS_FAILED", t11.TIMEOUT = "TIMEOUT", t11.UNKNOWN_REASON = "UNKNOWN_REASON", t11;
}({});
var ve = function(t11) {
  return t11[t11.Nothing = 0] = "Nothing", t11[t11.Audio = 1] = "Audio", t11[t11.LwoVideo = 2] = "LwoVideo", t11[t11.Video = 4] = "Video", t11[t11.Data = 8] = "Data", t11[t11.DataStream0 = 256] = "DataStream0", t11[t11.DataStream1 = 512] = "DataStream1", t11[t11.DataStream2 = 1024] = "DataStream2", t11[t11.DataStream3 = 2048] = "DataStream3", t11[t11.DataStream4 = 4096] = "DataStream4", t11[t11.DataStream5 = 8192] = "DataStream5", t11[t11.DataStream6 = 16384] = "DataStream6", t11[t11.DataStream7 = 32768] = "DataStream7", t11;
}({});
var St = function(t11) {
  return t11.CHINA = "CHINA", t11.ASIA = "ASIA", t11.NORTH_AMERICA = "NORTH_AMERICA", t11.EUROPE = "EUROPE", t11.JAPAN = "JAPAN", t11.INDIA = "INDIA", t11.KOREA = "KOREA", t11.HKMC = "HKMC", t11.US = "US", t11.OCEANIA = "OCEANIA", t11.SOUTH_AMERICA = "SOUTH_AMERICA", t11.AFRICA = "AFRICA", t11.OVERSEA = "OVERSEA", t11.GLOBAL = "GLOBAL", t11.EXTENSIONS = "EXTENSIONS", t11;
}({});
var UR = [St.AFRICA, St.ASIA, St.CHINA, St.EUROPE, St.GLOBAL, St.INDIA, St.JAPAN, St.NORTH_AMERICA, St.OCEANIA, St.OVERSEA, St.SOUTH_AMERICA];
var Ye = function(t11) {
  return t11.CHINA = "CN", t11.ASIA = "AS", t11.NORTH_AMERICA = "NA", t11.EUROPE = "EU", t11.JAPAN = "JP", t11.INDIA = "IN", t11.KOREA = "KR", t11.HKMC = "HK", t11.US = "US", t11.OCEANIA = "OC", t11.SOUTH_AMERICA = "SA", t11.AFRICA = "AF", t11.OVERSEA = "OVERSEA", t11.GLOBAL = "GLOBAL", t11.EXTENSIONS = "GLOBAL", t11;
}({});
var Zu = { CHINA: {}, ASIA: { CODE: Ye.ASIA, WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"], PROXY_CS: ["proxy-ap-web-asia.agora.io"], CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"], UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"], LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"], PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"] }, NORTH_AMERICA: { CODE: Ye.NORTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"], PROXY_CS: ["proxy-ap-web-america.agora.io"], CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"], PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"] }, EUROPE: { CODE: Ye.EUROPE, WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"], PROXY_CS: ["proxy-ap-web-europe.agora.io"], CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"], UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"], LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"], PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"] }, JAPAN: { CODE: Ye.JAPAN, WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"], PROXY_CS: ["proxy-ap-web-japan.agora.io"], CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"], UAP_AP: ["uap-ap-web-japan.agora.io", "uap-ap-web-japan2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"], LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"], PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"] }, INDIA: { CODE: Ye.INDIA, WEBCS_DOMAIN: ["ap-web-1-india.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"], PROXY_CS: ["proxy-ap-web-india.agora.io"], CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"], UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"], LOG_UPLOAD_SERVER: ["logservice-india.agora.io"], PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"] }, KOREA: { CODE: Ye.KOREA, WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"], PROXY_CS: ["proxy-ap-web-korea.agora.io"], CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"], UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"], PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"] }, HKMC: { CODE: Ye.HKMC, WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"], PROXY_CS: ["proxy-ap-web-hkmc.agora.io"], CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"], UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"], LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"], PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"] }, US: { CODE: Ye.US, WEBCS_DOMAIN: ["ap-web-1-us.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"], PROXY_CS: ["proxy-ap-web-us.agora.io"], CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"], UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"], LOG_UPLOAD_SERVER: ["logservice-us.agora.io"], PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"] }, OVERSEA: { CODE: Ye.OVERSEA, WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"], PROXY_CS: ["proxy-ap-web-oversea.agora.io"], CDS_AP: ["cds-ap-web-oversea.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"], UAP_AP: ["uap-ap-web-oversea.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"] }, GLOBAL: { CODE: Ye.GLOBAL, WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"], PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"], CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"], UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"], LOG_UPLOAD_SERVER: ["logservice.agora.io"], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"] }, OCEANIA: { CODE: Ye.OCEANIA, WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"], PROXY_CS: ["proxy-ap-web-oceania.agora.io"], CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"], UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"], LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"], PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"] }, SOUTH_AMERICA: { CODE: Ye.SOUTH_AMERICA, WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"], PROXY_CS: ["proxy-ap-web-south-america.agora.io"], CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"], UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"], PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"] }, AFRICA: { CODE: Ye.AFRICA, WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"], PROXY_CS: ["proxy-ap-web-africa.agora.io"], CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"], ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"], UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"], EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"], LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"], PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"] }, EXTENSIONS: {} };
pf && (Zu.CHINA = { CODE: Ye.CHINA, WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"], WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"], PROXY_CS: ["proxy-web.ap.sd-rtn.com"], CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"], ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"], UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"], EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"], EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"], LOG_UPLOAD_SERVER: ["logservice-china.agora.io"], PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"] });
var FE = function(t11) {
  return t11.UPDATE_BITRATE_LIMIT = "update_bitrate_limit", t11;
}({});
var Kl = class extends Xt {
  constructor(e, n) {
    super(), T(this, "onICEConnectionStateChange", void 0), T(this, "onConnectionStateChange", void 0), T(this, "onDTLSTransportStateChange", void 0), T(this, "onDTLSTransportError", void 0), T(this, "onICETransportStateChange", void 0), T(this, "onFirstAudioReceived", void 0), T(this, "onFirstVideoReceived", void 0), T(this, "onFirstAudioDecoded", void 0), T(this, "onFirstVideoDecoded", void 0), T(this, "onFirstVideoDecodedTimeout", void 0), T(this, "onSelectedLocalCandidateChanged", void 0), T(this, "onSelectedRemoteCandidateChanged", void 0), T(this, "getLocalVideoStats", void 0);
  }
};
var Yl = class extends Kl {
  constructor(e, n) {
    super(e, n), T(this, "establishPromise", void 0);
  }
};
var Q = function(t11) {
  return t11.VIDEO = "video", t11.AUDIO = "audio", t11;
}({});
var On = function(t11) {
  return t11[t11.UDP = 0] = "UDP", t11[t11.TCP = 1] = "TCP", t11[t11.RELAY = 2] = "RELAY", t11;
}({});
var Tr = function(t11) {
  return t11[t11.FIRST_CONNECTION = 0] = "FIRST_CONNECTION", t11[t11.TCP_RESTART = 1] = "TCP_RESTART", t11[t11.RELAY_RESTART = 2] = "RELAY_RESTART", t11[t11.OLD_FIRST_CONNECTION = 10] = "OLD_FIRST_CONNECTION", t11[t11.OLD_RESTART = 11] = "OLD_RESTART", t11[t11.DISCONNECTED_OR_FAILED = 20] = "DISCONNECTED_OR_FAILED", t11;
}({});
var U = function(t11) {
  return t11.LocalVideoTrack = "videoTrack", t11.LocalAudioTrack = "audioTrack", t11.LocalVideoLowTrack = "videoLowTrack", t11;
}({});
var Rt = function(t11) {
  return t11.New = "new", t11.Connected = "connected", t11.Reconnecting = "reconnecting", t11.Disconnected = "disconnected", t11;
}({});
var tt = function(t11) {
  return t11.StateChange = "stateChange", t11.IceConnectionStateChange = "iceConnectionStateChange", t11.RequestMuteLocal = "requestMuteLocal", t11.RequestUnmuteLocal = "requestUnmuteLocal", t11.RequestRePublish = "requestRePublish", t11.RequestRePublishDataChannel = "requestRePublishDataChannel", t11.RequestReSubscribe = "requestReSubscribe", t11.RequestUploadStats = "requestUploadStats", t11.RequestUpload = "requestUpload", t11.MediaReconnectStart = "MediaReconnectStart", t11.MediaReconnectEnd = "MediaReconnectEnd", t11.NeedSignalRTT = "NeedSignalRTT", t11.RequestRestartICE = "RequestRestartIce", t11.PeerConnectionStateChange = "PeerConnectionStateChange", t11.RequestReconnect = "RequestReconnect", t11.RequestReconnectPC = "RequestReconnectPC", t11.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", t11.P2PLost = "P2PLost", t11.UpdateVideoEncoder = "UpdateVideoEncoder", t11.ConnectionTypeChange = "ConnectionTypeChange", t11.RequestLowStreamParameter = "RequestLowStreamParameter", t11.QueryClientConnectionState = "QueryClientConnectionState", t11.LocalCandidate = "LocalCandidate", t11.RequestP2PMuteLocal = "requestP2PMuteLocal", t11.RequestP2PUnPublish = "RequestP2PUnPublish", t11.RequestP2PUnmuteRemote = "RequestP2PUnmuteRemote", t11.RequestP2PMuteRemote = "RequestP2PMuteRemote", t11.RequestP2PRestartICE = "RequestP2PRestartICE", t11;
}({});
var Ei = function(t11) {
  return t11.CONNECTING = "CONNECTING", t11.RECONNECTING = "RECONNECTING", t11.CONNECTED = "CONNECTED", t11.CLOSED = "CLOSED", t11;
}({});
var di = function(t11) {
  return t11[t11.CONNECT_AP = 0] = "CONNECT_AP", t11[t11.AP_CONNECTED = 1] = "AP_CONNECTED", t11[t11.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", t11[t11.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", t11[t11.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", t11[t11.CONNECT_WORKER = 5] = "CONNECT_WORKER", t11[t11.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", t11[t11.CLOSED = 7] = "CLOSED", t11;
}({});
var we = function(t11) {
  return t11.CONNECTION_STATE_CHANGE = "connection-state-change", t11.STATE_CHANGE = "state-change", t11.INSPECT_RESULT = "inspect-result", t11.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", t11.REQUEST_NEW_WORKER_URL = "request-new-worker-url", t11;
}({});
var PO = function(t11) {
  return t11.CONNECTED = "transmitter:connected", t11.RECONNECTING = "transmitter:reconnecting", t11.WILL_RECONNECT = "transmitter:will_reconnect", t11.CLOSED = "transmitter:closed", t11.FAILED = "transmitter:failed", t11.ON_MESSAGE = "transmitter:on_message", t11.REQUEST_NEW_URLS = "transmitter:request_new_urls", t11.RECONNECT_WAITTING_FINISH = "transmitter:reconnect_waitting_finish", t11.RECONNECT_CREATE_CONNECTION = "transmitter:reconnect_create_connection", t11.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "transmitter:on_token_privilege_did_expire", t11.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel", t11.FAILBACK = "transmitter:failback", t11.PRE_CONNECT_PC = "transmitter:pre_connect_pc", t11;
}({});
var nr = function(t11) {
  return t11.CAMERA_CHANGED = "camera-changed", t11.MICROPHONE_CHANGED = "microphone-changed", t11.PLAYBACK_DEVICE_CHANGED = "playback-device-changed", t11.AUDIO_AUTOPLAY_FAILED = "audio-autoplay-failed", t11.AUTOPLAY_FAILED = "autoplay-failed", t11.AUDIO_CONTEXT_STATE_CHANGED = "audio-context-state-changed", t11.SECURITY_POLICY_VIOLATION = "security-policy-violation", t11;
}({});
var Xn = function(t11) {
  return t11.CONNECTING = "CONNECTING", t11.RECONNECTING = "RECONNECTING", t11.CONNECTED = "CONNECTED", t11.CLOSED = "CLOSED", t11;
}({});
var Mi = function(t11) {
  return t11.CONNECTION_STATE_CHANGE = "connection-state-change", t11.STATE_CHANGE = "state-change", t11.INSPECT_RESULT = "inspect-result", t11.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", t11.REQUEST_NEW_WORKER_URL = "request-new-worker-url", t11;
}({});
var hs = function(t11) {
  return t11[t11.CONNECT_AP = 0] = "CONNECT_AP", t11[t11.AP_CONNECTED = 1] = "AP_CONNECTED", t11[t11.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", t11[t11.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", t11[t11.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", t11[t11.CONNECT_WORKER = 5] = "CONNECT_WORKER", t11[t11.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", t11[t11.CLOSED = 7] = "CLOSED", t11;
}({});
var ie = function(t11) {
  return t11.CALL = "call", t11.CANDIDATE = "candidate", t11.PUBLISH = "publish", t11.UNPUBLISH = "unpublish", t11.CONTROL = "control", t11.RESTART_ICE = "restart_ice", t11.ACK = "ack", t11.RESPONSE = "response", t11.JOIN = "join", t11.CHECK = "check", t11;
}({});
var ps = function(t11) {
  return t11.ABORT = "abort", t11;
}({});
var to = function(t11) {
  return t11.MUTE_LOCAL_AUDIO = "mute_local_audio", t11.MUTE_LOCAL_VIDEO = "mute_local_video", t11.UNMUTE_LOCAL_AUDIO = "unmute_local_audio", t11.UNMUTE_LOCAL_VIDEO = "unmute_local_video", t11;
}({});
var cj = function(t11) {
  return t11.P2P_TOKEN_TIMEOUT = "p2p_token_timeout", t11.P2P_TOKEN_CHANGED = "p2p_token_changed", t11;
}({});
var dj = { [gl.ACCESS_POINT]: { [on.NO_FLAG_SET]: { desc: "flag is zero", retry: false }, [on.FLAG_SET_BUT_EMPTY]: { desc: "flag is empty", retry: false }, [on.INVALID_FALG_SET]: { desc: "invalid flag", retry: false }, [on.FLAG_SET_BUT_NO_RE]: { desc: "flag set unilbs but no request", retry: false }, [on.INVALID_SERVICE_ID]: { desc: "invalid service id", retry: false }, [on.NO_SERVICE_AVAILABLE]: { desc: "no service available", retry: true }, [on.NO_SERVICE_AVAILABLE_P2P]: { desc: "no unilbs p2p service available", retry: true }, [on.NO_SERVICE_AVAILABLE_VOICE]: { desc: "no unilbs voice service available", retry: true }, [on.NO_SERVICE_AVAILABLE_WEBRTC]: { desc: "no unilbs webrtc service available", retry: true }, [on.NO_SERVICE_AVAILABLE_CDS]: { desc: "no cds service available", retry: true }, [on.NO_SERVICE_AVAILABLE_CDN]: { desc: "no cdn dispatcher service available", retry: true }, [on.NO_SERVICE_AVAILABLE_TDS]: { desc: "no tds service available", retry: true }, [on.NO_SERVICE_AVAILABLE_REPORT]: { desc: "no unilbs report service available", retry: true }, [on.NO_SERVICE_AVAILABLE_APP_CENTER]: { desc: "no app center service available", retry: true }, [on.NO_SERVICE_AVAILABLE_ENV0]: { desc: "no unilbs sig env0 service available", retry: true }, [on.NO_SERVICE_AVAILABLE_VOET]: { desc: "no unilbs voet service available", retry: true }, [on.NO_SERVICE_AVAILABLE_STRING_UID]: { desc: "no string uid service available", retry: true }, [on.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: { desc: "no webrtc unilbs service available", retry: true } }, [gl.UNILBS]: { [ci.INVALID_VENDOR_KEY]: { desc: "invalid vendor key, can not find appid", retry: false }, [ci.INVALID_CHANNEL_NAME]: { desc: "invalid channel name", retry: false }, [ci.INTERNAL_ERROR]: { desc: "unilbs internal error", retry: false }, [ci.NO_AUTHORIZED]: { desc: "invalid token, authorized failed", retry: false }, [ci.DYNAMIC_KEY_TIMEOUT]: { desc: "dynamic key or token timeout", retry: false }, [ci.NO_ACTIVE_STATUS]: { desc: "no active status", retry: false }, [ci.DYNAMIC_KEY_EXPIRED]: { desc: "dynamic key expired", retry: false }, [ci.STATIC_USE_DYNAMIC_KEY]: { desc: "static use dynamic key", retry: false }, [ci.DYNAMIC_USE_STATIC_KEY]: { desc: "dynamic use static key", retry: false }, [ci.USER_OVERLOAD]: { desc: "amount of users over load", retry: false }, [ci.FORBIDDEN_REGION]: { desc: "the request is forbidden in this area", retry: false }, [ci.CANNOT_MEET_AREA_DEMAND]: { desc: "unable to allocate services in this area", retry: false } }, [gl.STRING_UID_ALLOCATOR]: { [Mp.IIIEGAL_APPID]: { desc: "invalid appid", retry: false }, [Mp.IIIEGAL_UID]: { desc: "invalid string uid", retry: false }, [Mp.INTERNAL_ERROR]: { desc: "string uid allocator internal error", retry: true } } };
function ta(t11) {
  let e = dj[Math.floor(t11 / 1e4)];
  if (!e) return { desc: "unknown error", retry: false };
  let n = e[t11 % 1e4];
  if (!n) {
    if (Math.floor(t11 / 1e4) === gl.ACCESS_POINT) {
      let i = t11 % 1e4;
      if (i.toString()[0] === "1") return { desc: t11.toString(), retry: false };
      if (i.toString()[0] === "2") return { desc: t11.toString(), retry: true };
    }
    return { desc: "unknown error", retry: false };
  }
  return n;
}
var lj = { [Z.K_TIMESTAMP_EXPIRED]: { desc: "K_TIMESTAMP_EXPIRED", action: "failed" }, [Z.K_CHANNEL_PERMISSION_INVALID]: { desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed" }, [Z.K_CERTIFICATE_INVALID]: { desc: "K_CERTIFICATE_INVALID", action: "failed" }, [Z.K_CHANNEL_NAME_EMPTY]: { desc: "K_CHANNEL_NAME_EMPTY", action: "failed" }, [Z.K_CHANNEL_NOT_FOUND]: { desc: "K_CHANNEL_NOT_FOUND", action: "failed" }, [Z.K_TICKET_INVALID]: { desc: "K_TICKET_INVALID", action: "failed" }, [Z.K_CHANNEL_CONFLICTED]: { desc: "K_CHANNEL_CONFLICTED", action: "failed" }, [Z.K_SERVICE_NOT_READY]: { desc: "K_SERVICE_NOT_READY", action: "tryNext" }, [Z.K_SERVICE_TOO_HEAVY]: { desc: "K_SERVICE_TOO_HEAVY", action: "tryNext" }, [Z.K_UID_BANNED]: { desc: "K_UID_BANNED", action: "failed" }, [Z.K_IP_BANNED]: { desc: "K_IP_BANNED", action: "failed" }, [Z.K_AUTO_REBALANCE]: { desc: "k_AUTO_REBALANCE", action: "recover" }, [Z.ERR_INVALID_VENDOR_KEY]: { desc: "ERR_INVALID_VENDOR_KEY", action: "failed" }, [Z.ERR_INVALID_CHANNEL_NAME]: { desc: "ERR_INVALID_CHANNEL_NAME", action: "failed" }, [Z.WARN_NO_AVAILABLE_CHANNEL]: { desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed" }, [Z.WARN_LOOKUP_CHANNEL_TIMEOUT]: { desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext" }, [Z.WARN_LOOKUP_CHANNEL_REJECTED]: { desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed" }, [Z.WARN_OPEN_CHANNEL_TIMEOUT]: { desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext" }, [Z.WARN_OPEN_CHANNEL_REJECTED]: { desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed" }, [Z.WARN_REQUEST_DEFERRED]: { desc: "WARN_REQUEST_DEFERRED", action: "failed" }, [Z.ERR_DYNAMIC_KEY_TIMEOUT]: { desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed" }, [Z.ERR_NO_AUTHORIZED]: { desc: "ERR_NO_AUTHORIZED", action: "failed" }, [Z.ERR_VOM_SERVICE_UNAVAILABLE]: { desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext" }, [Z.ERR_NO_CHANNEL_AVAILABLE_CODE]: { desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed" }, [Z.ERR_MASTER_VOCS_UNAVAILABLE]: { desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext" }, [Z.ERR_INTERNAL_ERROR]: { desc: "ERR_INTERNAL_ERROR", action: "tryNext" }, [Z.ERR_NO_ACTIVE_STATUS]: { desc: "ERR_NO_ACTIVE_STATUS", action: "failed" }, [Z.ERR_INVALID_UID]: { desc: "ERR_INVALID_UID", action: "failed" }, [Z.ERR_DYNAMIC_KEY_EXPIRED]: { desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed" }, [Z.ERR_STATIC_USE_DYANMIC_KE]: { desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed" }, [Z.ERR_DYNAMIC_USE_STATIC_KE]: { desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed" }, [Z.ERR_NO_VOCS_AVAILABLE]: { desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext" }, [Z.ERR_NO_VOS_AVAILABLE]: { desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext" }, [Z.ERR_JOIN_CHANNEL_TIMEOUT]: { desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext" }, [Z.ERR_JOIN_BY_MULTI_IP]: { desc: "ERR_JOIN_BY_MULTI_IP", action: "recover" }, [Z.ERR_NOT_JOINED]: { desc: "ERR_NOT_JOINED", action: "failed" }, [Z.ERR_REPEAT_JOIN_REQUEST]: { desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit" }, [Z.ERR_REPEAT_JOIN_CHANNEL]: { desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit" }, [Z.ERR_INVALID_STRINGUID]: { desc: "ERR_INVALID_STRINGUID", action: "failed" }, [Z.ERR_TOO_MANY_USERS]: { desc: "ERR_TOO_MANY_USERS", action: "tryNext" }, [Z.ERR_SET_CLIENT_ROLE_TIMEOUT]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [Z.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: { desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed" }, [Z.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: { desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", action: "success" }, [Z.ERR_PUBLISH_REQUEST_INVALID]: { desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed" }, [Z.ERR_SUBSCRIBE_REQUEST_INVALID]: { desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed" }, [Z.ERR_NOT_SUPPORTED_MESSAGE]: { desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed" }, [Z.ERR_ILLEAGAL_PLUGIN]: { desc: "ERR_ILLEAGAL_PLUGIN", action: "failed" }, [Z.ILLEGAL_CLIENT_ROLE_LEVEL]: { desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed" }, [Z.ERR_REJOIN_TOKEN_INVALID]: { desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed" }, [Z.ERR_REJOIN_USER_NOT_JOINED]: { desc: "ERR_REJOIN_NOT_JOINED", action: "failed" }, [Z.ERR_INVALID_OPTIONAL_INFO]: { desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit" }, [Z.ERR_TEST_RECOVER]: { desc: "ERR_TEST_RECOVER", action: "recover" }, [Z.ERR_TEST_TRYNEXT]: { desc: "ERR_TEST_TRYNEXT", action: "recover" }, [Z.ERR_TEST_RETRY]: { desc: "ERR_TEST_RETRY", action: "recover" }, [Z.ILLEGAL_AES_PASSWORD]: { desc: "ERR_TEST_RETRY", action: "failed" }, [Z.ERR_TOO_MANY_BROADCASTERS]: { desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed" }, [Z.ERR_TOO_MANY_SUBSCRIBERS]: { desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed" }, [Z.ERR_LICENSE_ILLEGAL]: { desc: "ERR_LICENSE_ILLEGAL", action: "quit" }, [Z.ERR_LICENSE_MISSING]: { desc: "ERR_LICENSE_MISSING", action: "quit" }, [Z.ERR_LICENSE_EXPIRED]: { desc: "ERR_LICENSE_EXPIRED", action: "quit" }, [Z.ERR_LICENSE_MINUTES_EXCEEDED]: { desc: "ERR_LICENSE_MINUTES_EXCEEDED", action: "quit" }, [Z.ERR_LICENSE_PERIOD_INVALID]: { desc: "ERR_LICENSE_PERIOD_INVALID", action: "quit" }, [Z.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: { desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE", action: "quit" } };
function Oc(t11) {
  return lj[t11] || { desc: "UNKNOWN_ERROR_".concat(t11), action: "failed" };
}
function xR(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Vp(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? xR(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : xR(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
function VR(t11) {
  return t11.every((e) => e.readyState === WebSocket.CLOSED || e.readyState === WebSocket.CLOSING);
}
function FR(t11, e) {
  if (typeof t11 == "string") return t11;
  let { proxy: n, host: i, port: r } = t11;
  if (e) {
    let o = v("JOIN_GATEWAY_FALLBACK_PORT") || 443;
    return o === 443 ? "wss://".concat(i, "/ws/?p=").concat(Number(r) + 150) : "wss://".concat(i, ":").concat(o, "/ws/?p=").concat(Number(r) + 150);
  }
  return n ? "wss://".concat(n, "/ws/?h=").concat(i, "&p=").concat(r) : "wss://".concat(i, ":").concat(r);
}
var uj = /wss:\/\/(.+)\/ws\/\?h=(.+)&p=([0-9]+)\/?/;
var hj = /wss:\/\/(.+)\/ws\/\?p=([0-9]+)\/?/;
var pj = /wss:\/\/(.+):([0-9]+)\/?/;
var _j = /wss:\/\/(.[^\/]+)\/?/;
var Ej = 0;
var BE = class {
  constructor(e, n) {
    T(this, "id", 0), T(this, "store", void 0), T(this, "recordIndex", void 0), T(this, "websockets", []), T(this, "try443PortDuration", 2e3), T(this, "forceCloseWSDuration", 5e3), T(this, "try443PortTimeout", null), T(this, "forceCloseTimeout", null), T(this, "isTry443PortFailed", false), T(this, "isNormalPortFailed", false), T(this, "useDoubleDomain", false), T(this, "useProxy", false), T(this, "startTime", Date.now()), this.id = ++Ej, this.try443PortDuration = v("JOIN_GATEWAY_TRY_443PORT_DURATION") || 2e3, this.forceCloseWSDuration = e || 5e3, this.store = n;
  }
  closeAllWebsockets() {
    this.websockets.forEach((e) => {
      e.onopen = null, e.onclose = null, e.onmessage = null, e.close();
    }), this.websockets.length = 0;
  }
  clearTimeout() {
    this.forceCloseTimeout && clearTimeout(this.forceCloseTimeout), this.try443PortTimeout && clearTimeout(this.try443PortTimeout);
  }
  logger() {
    var e;
    let n = Date.now() - this.startTime;
    for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++) r[o] = arguments[o];
    _.debug("[choose-best-ws ".concat((e = this.store) === null || e === void 0 ? void 0 : e.clientId, " ").concat(this.id, "] ").concat(n, "ms:"), ...r);
  }
  createWebSocket(e, n, i) {
    this.logger("createWebSocket:", e, { isTry443Port: n, hasTimeoutDetection: i });
    let r = v("GATEWAY_DOMAINS"), o = Date.now(), s = [], a = r.find((l) => {
      var u;
      return W(u = e.host).call(u, l);
    });
    a || (this.useDoubleDomain = false);
    let c = [];
    if (this.useDoubleDomain) r.forEach((l) => {
      c.push(FR(Vp(Vp({}, e), {}, { host: e.host.replace(a, l) }), n));
    });
    else {
      let l = Vp({}, e);
      if (n && a) {
        let u = r.find((h) => h !== a);
        u && (l.host = l.host.replace(a, u));
      }
      c.push(FR(l, n));
    }
    try {
      c.forEach((l) => {
        let u = new WebSocket(l);
        u.binaryType = "arraybuffer", s.push(u), this.logger("ws is connecting:", u.url);
      });
    } catch (l) {
      if (this.logger("ws create failed"), s.forEach((u) => u.close()), s.length = 0, this.useDoubleDomain) return this.useDoubleDomain = false, this.createWebSocket(e, n, i);
      if (!n && Number(e.port) !== 443) return this.createWebSocket(e, true, i);
      throw new O(R.WS_ERR, "init websocket failed! Error: ".concat(l.toString()));
    }
    let d = vc();
    return this.store && this.store.recordJoinChannelService({ urls: s.map((l) => l.url), service: "gateway" }, this.recordIndex), s.forEach((l) => {
      l.onopen = () => {
        this.logger("onopen: ws ".concat(l.url, " open cost ").concat(Date.now() - o, "ms")), this.websockets.forEach((u) => {
          u !== l && (u.onopen = null, u.onclose = null, u.onmessage = null, u.close(), this.logger("close backup websocket: ".concat(u.url)));
        }), this.websockets.length = 0, d.resolve(l);
      }, l.onclose = (u) => {
        this.logger("onclose: ws ".concat(l.url, " closed cost ").concat(Date.now() - o, "ms state: ").concat(l.readyState)), n ? this.isTry443PortFailed = VR(s) : this.isNormalPortFailed = VR(s), this.logger("443: ".concat(this.useProxy ? "not try" : this.isTry443PortFailed ? "failed" : "trying", " 47xx: ").concat(this.isNormalPortFailed ? "failed" : "trying")), (n && this.isTry443PortFailed || !n && (this.isTry443PortFailed || this.useProxy) && this.isNormalPortFailed) && (this.logger("onclose: all websocket is closed, ".concat(u.reason)), d.reject({ code: u.code, reason: Tl.A_ROUND_WS_FAILED }));
      }, l.onmessage = (u) => this.logger("".concat(l.url, " onmessage: ").concat(u.data));
    }), this.websockets.push(...s), i || (() => {
      let l = () => {
        this.logger("5s timeout close un-opens, isWebsocket created: ", d.isResolved), this.websockets.forEach((u) => u.readyState !== WebSocket.OPEN && u.close());
      };
      if (n || this.useProxy) return this.logger("add 5s timeout at ".concat(n ? "try-443" : "proxy", " condition")), this.forceCloseTimeout = window.setTimeout(l, this.forceCloseWSDuration);
      this.try443PortTimeout = window.setTimeout(() => {
        if (this.logger("2s timeout, isWebsocket created: ", d.isResolved), d.isResolved) return l();
        mt().os === ye.MAC_OS && $t() && l(), this.createWebSocket(e, true, true).then((u) => d.resolve(u)).catch((u) => {
          this.isNormalPortFailed && d.reject(u), this.logger("try 443 port to create ws failed");
        }), this.forceCloseTimeout = window.setTimeout(l, this.forceCloseWSDuration);
      }, this.try443PortDuration);
    })(), d.promise;
  }
  chooseBestWebsocket(e, n, i, r) {
    return this.useDoubleDomain = !!n, typeof e == "string" && (e = function(o) {
      let s, a, c;
      return [, s, a, c] = o.match(uj) || [], s || ([, a, c] = o.match(hj) || []), a && c || ([, a, c] = o.match(pj) || []), a && c || ([, a] = o.match(_j) || []), a || _.warning("un-destructible url: ", o), { proxy: s, host: a, port: c || "443" };
    }(e)), this.recordIndex = r, this.useProxy = !!e.proxy, i && this.useProxy && (_.warn("cannot use 443 only when use proxy"), i = false), this.createWebSocket(e, !!i, false).finally(() => this.clearTimeout());
  }
};
function BR(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
var ql = class extends Xt {
  get url() {
    return this.websocket && this.websocket.url || null;
  }
  get reconnectMode() {
    return this._reconnectMode;
  }
  set reconnectMode(e) {
    var n;
    W(n = ["tryNext", "recover"]).call(n, e) && this.resetReconnectCount(e), this._reconnectMode = e;
  }
  get state() {
    return this._state;
  }
  set state(e) {
    e !== this._state && (this._state = e, this._state === "reconnecting" ? this.emit(it.RECONNECTING, this.reconnectReason) : this._state === "connected" ? this.emit(it.CONNECTED) : this._state === "closed" ? this.emit(it.CLOSED) : this._state === "failed" && this.emit(it.FAILED));
  }
  resetReconnectCount(e) {
    _.debug("websocket reset reconnect count, reason: " + e), this.reconnectCount = 0;
  }
  constructor(e, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 && arguments[2], r = arguments.length > 3 && arguments[3] !== void 0 && arguments[3], o = arguments.length > 4 && arguments[4] !== void 0 && arguments[4], s = arguments.length > 5 ? arguments[5] : void 0;
    super(), T(this, "connectionID", 0), T(this, "currentURLIndex", 0), T(this, "urls", []), T(this, "_reconnectMode", "tryNext"), T(this, "reconnectReason", void 0), T(this, "_initMutex", new ze("websocket")), T(this, "name", void 0), T(this, "_state", "closed"), T(this, "reconnectInterrupter", void 0), T(this, "websocket", void 0), T(this, "retryConfig", void 0), T(this, "reconnectCount", 0), T(this, "forceCloseTimeout", 5e3), T(this, "onlineReconnectListener", void 0), T(this, "useCompress", void 0), T(this, "tryDoubleDomain", false), T(this, "use443PortOnly", false), T(this, "wsInflateLength", 0), T(this, "wsDeflateLength", 0), T(this, "closeEstablishingWs", () => {
    }), T(this, "store", void 0), T(this, "joinGatewayRecordIndex", void 0), this.store = s, this.name = e, this.retryConfig = function(u) {
      for (var h = 1; h < arguments.length; h++) {
        var p = arguments[h] != null ? arguments[h] : {};
        h % 2 ? BR(Object(p), true).forEach(function(g) {
          T(u, g, p[g]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(u, Object.getOwnPropertyDescriptors(p)) : BR(Object(p)).forEach(function(g) {
          Object.defineProperty(u, g, Object.getOwnPropertyDescriptor(p, g));
        });
      }
      return u;
    }({}, n), this.useCompress = i, this.tryDoubleDomain = r, this.use443PortOnly = o;
    let { timeout: a, timeoutFactor: c } = n, d = Math.max(300, Math.floor(3 * a / 5)), l = Math.max(1.2, Math.floor(8 * c) / 10);
    wn.ONLINE && (this.retryConfig.timeout = d, this.retryConfig.timeoutFactor = l), he.on(ks.NETWORK_STATE_CHANGE, (u, h) => {
      u !== h && (this.resetReconnectCount("network state change: ".concat(h, " -> ").concat(u)), u === wn.ONLINE ? (this.retryConfig.timeout = d, this.retryConfig.timeoutFactor = l) : (this.retryConfig.timeout = a, this.retryConfig.timeoutFactor = c));
    });
  }
  getConnection() {
    return this.websocket || void 0;
  }
  async init(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5e3, i = await this._initMutex.lock();
    this.forceCloseTimeout = n, this.urls = e, this.state = "connecting";
    try {
      let r = vc(), o = this.urls[this.currentURLIndex];
      v("ENABLE_PREALLOC_PC") && this.emit(PO.PRE_CONNECT_PC), this.createWebSocketConnection(o).then(r.resolve).catch(r.reject), this.once(it.CLOSED, () => {
        r.reject(new N(R.WS_DISCONNECT));
      }), this.once(it.CONNECTED, r.resolve), await r.promise;
    } catch {
    } finally {
      i();
    }
  }
  close(e, n) {
    if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {
      this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;
      let i = this.websocket;
      n ? setTimeout(() => i.close(), 500) : i.close(), this.websocket = void 0;
    }
    this.state = e ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs();
  }
  reconnect(e, n) {
    if (!this.websocket) return void _.warning("[".concat(this.name, "] can not reconnect, no websocket"));
    e !== void 0 && (this.reconnectMode = e), _.debug("[".concat(this.name, "] reconnect is triggered initiative")), typeof this.joinGatewayRecordIndex == "number" && this.store && this.store.recordJoinChannelService({ status: "error", errors: [new Error(n)] }, this.joinGatewayRecordIndex);
    let i = this.websocket.onclose;
    this.websocket.onclose = null, this.websocket.close(), i && i.bind(this.websocket)({ code: 9999, reason: n });
  }
  sendMessage(e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new N(R.WS_ABORT, "websocket is not ready");
    try {
      n || (e = JSON.stringify(e)), this.websocket.send(e);
    } catch (i) {
      throw new N(R.WS_ERR, "send websocket message error" + i.toString());
    }
  }
  setWsInflateData(e) {
    this.wsDeflateLength = this.wsDeflateLength + e.originLength, this.wsInflateLength = this.wsInflateLength + e.compressedLength;
  }
  getWsInflateData() {
    let e = this.wsInflateLength, n = this.wsDeflateLength;
    return this.clearWsInflateData(), { wsInflateLength: e, wsDeflateLength: n };
  }
  clearWsInflateData() {
    this.wsInflateLength = 0, this.wsDeflateLength = 0;
  }
  async createWebSocketConnection(e) {
    var n;
    let i = vc();
    this.connectionID += 1, this.joinGatewayRecordIndex = void 0;
    let r = (l) => {
      var u;
      (u = this.store) === null || u === void 0 || u.signalChannelOpen(), _.debug("[".concat(this.name, "] websocket opened:"), l), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), i.resolve();
    }, o = async (l) => {
      var u;
      if (_.debug("[".concat(this.name, "] websocket close ").concat((u = this.websocket) === null || u === void 0 ? void 0 : u.url, ", code: ").concat(l.code, ", reason: ").concat(l.reason, ", current mode: ").concat(this.reconnectMode)), this.reconnectCount >= this.retryConfig.maxRetryCount) i.reject(new N(R.WS_DISCONNECT, "websocket close: ".concat(l.code))), this.close();
      else {
        this.state === "connected" && (this.reconnectReason = l.reason, this.state = "reconnecting");
        let h = ni(this, it.WILL_RECONNECT, this.reconnectMode, l.reason) || this.reconnectMode, p = await this.reconnectWithAction(h);
        if (this.state === "closed") return void _.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect"));
        if (!p) return i.reject(new N(R.WS_DISCONNECT, "websocket reconnect failed: ".concat(l.code))), this.close(true);
        i.resolve();
      }
    }, s = (l) => {
      this.emit(it.ON_MESSAGE, l);
    }, a = (l) => {
      _.warn("[".concat(this.connectionID, "] ws open error ").concat(l));
    };
    this.websocket && (this.websocket.onclose = null, this.websocket.close()), v("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e = v("GATEWAY_WSS_ADDRESS")), _.debug("[".concat(this.name, "] start connect, url:"), e);
    let c = (n = this.store) === null || n === void 0 ? void 0 : n.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "gateway" });
    try {
      var d;
      let l = await this.chooseBestWebsocketConnection(e);
      this.websocket = l, r && r(this.websocket.url), this.websocket.onclose = o, this.websocket.onmessage = s, this.websocket.onerror = a, (d = this.store) === null || d === void 0 || d.recordJoinChannelService({ endTs: Date.now(), status: "success" }, c), this.joinGatewayRecordIndex = c;
    } catch (l) {
      let u = this.state === "closed", h = l instanceof N, p = h && l.code === R.WS_ABORT, g = h && l.code === R.WS_ERR, E = h ? l.message : l && (l.reason || l.toString());
      _.warning("[choose-best-ws] chooseBestWebsocket error: ".concat(E)), this.store && this.store.recordJoinChannelService({ endTs: Date.now(), status: p ? "aborted" : "error", errors: [l] }, c), u || g ? (i.reject(u ? new N(R.WS_DISCONNECT, "websocket is closed: ".concat(E)) : new N(R.WS_ERR, "init websocket failed: ".concat(E))), g && _.error("[".concat(this.name, "] init websocket failed: ").concat(E))) : o && o(l);
    }
    return i.promise;
  }
  async reconnectWithAction(e) {
    let n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
    if (this.reconnectCount >= this.retryConfig.maxRetryCount || this.urls.length === 0 || this.state === "closed") return false;
    _.warning("[choose-best-ws] action: =>", e), this.onlineReconnectListener || he.isOnline || !he.onlineWaiter || (this.onlineReconnectListener = he.onlineWaiter.then(() => {
      this.onlineReconnectListener = void 0;
    }));
    let i = true;
    if (this.reconnectInterrupter = () => i = false, n) {
      let s = hf(this.reconnectCount, this.retryConfig);
      _.debug("[".concat(this.name, "] wait ").concat(s, "ms to reconnect websocket, mode: ").concat(e)), await j.race([Me(s), this.onlineReconnectListener || new j(() => {
      })]);
    }
    if (this._state === "closed" || !i) return false;
    this.reconnectCount += 1;
    let r = async (s, a) => {
      this.emit(it.RECONNECT_CREATE_CONNECTION, a), await this.createWebSocketConnection(s);
    };
    try {
      if (e === "retry") this.emit(it.RECONNECT_WAITTING_FINISH, e), await r(this.urls[this.currentURLIndex], e);
      else if (e === "tryNext") {
        if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length) return this.reconnectWithAction("recover", false);
        _.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex)), this.emit(it.RECONNECT_WAITTING_FINISH, e), await r(this.urls[this.currentURLIndex], e);
      } else e === "recover" && (_.debug("[".concat(this.name, "] request new urls")), this.resetReconnectCount("recover mode"), this.emit(it.RECONNECT_WAITTING_FINISH, e), this.urls = await Ge(this, it.REQUEST_NEW_URLS), this.currentURLIndex = 0, await r(this.urls[this.currentURLIndex], e));
    } catch (s) {
      var o;
      _.error("[".concat(this.name, "] reconnect failed ").concat(s && s.toString()));
      let a = s == null || (o = s.data) === null || o === void 0 ? void 0 : o.desc;
      return Array.isArray(a) && W(a).call(a, "dynamic key expired") ? (this.emit(it.ON_TOKEN_PRIVILEGE_DID_EXPIRE), false) : this.reconnectWithAction(e, n);
    }
    return true;
  }
};
var Nc = class extends ql {
  constructor(e, n) {
    super(e, n, arguments.length > 2 && arguments[2] !== void 0 && arguments[2], arguments.length > 3 && arguments[3] !== void 0 && arguments[3], arguments.length > 4 && arguments[4] !== void 0 && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
  }
  async chooseBestWebsocketConnection(e, n) {
    let i = vc(), r = function(s, a) {
      return new BE(s, a);
    }(this.forceCloseTimeout, this.store);
    this.closeEstablishingWs = () => {
      _.debug("[choose-best-ws] close establishing websockets"), r.closeAllWebsockets(), i.reject(new N(R.WS_ABORT, "choose best websocket aborted"));
    };
    let o = v("GATEWAY_DOMAINS");
    return _.debug("[choose-best-ws] currentDomain: ", e, ", domains: ", o, "total: ".concat(this.urls.length), "current: ".concat(this.currentURLIndex + 1)), r.chooseBestWebsocket(e, this.tryDoubleDomain, this.use443PortOnly, n).then(i.resolve).catch(i.reject), i.promise.finally(() => {
      this.closeEstablishingWs = void 0;
    });
  }
};
var Qo = class extends ql {
  constructor(e, n) {
    super(e, n, arguments.length > 2 && arguments[2] !== void 0 && arguments[2], arguments.length > 3 && arguments[3] !== void 0 && arguments[3], arguments.length > 4 && arguments[4] !== void 0 && arguments[4], arguments.length > 5 ? arguments[5] : void 0);
  }
  async chooseBestWebsocketConnection(e, n) {
    return new j((i, r) => {
      let o = false, s = [];
      this.closeEstablishingWs = () => {
        _.debug("[choose-best-ws] close establishing websockets"), s.forEach((g) => {
          g.onclose = null, g.onopen = null, g.onmessage = null, g.close();
        }), r(new N(R.WS_ABORT, "choose best websocket aborted"));
      };
      let a = v("GATEWAY_DOMAINS"), c, d = e.indexOf("?h="), l = a.find((g) => d !== -1 ? W(e).call(e, g, d) : W(e).call(e, g));
      _.debug("[choose-best-ws] currentDomain: ", l, ", domains: ", a);
      let u = !this.tryDoubleDomain || !l;
      if (!u && l) {
        var h;
        let g = Date.now();
        try {
          a.forEach((E) => {
            let f = d === -1 ? e.replace(l, E) : e.substr(0, d) + e.substr(d).replace(l, E), S = new WebSocket(f);
            S.binaryType = "arraybuffer", s.push(S), _.debug("[choose-best-ws] ws is connecting:", S.url);
          });
        } catch {
          for (_.debug("[choose-best-ws] ws create failed, fallback to single url"), s.forEach((f) => f.close()); s.length; ) s.pop();
          u = true;
        }
        (h = this.store) === null || h === void 0 || h.recordJoinChannelService({ urls: s.map((E) => E.url), service: "gateway" }, n), s.forEach((E) => {
          E.onopen = () => {
            if (o) return;
            let f = Date.now() - g;
            _.debug("[choose-best-ws] ws open cost ".concat(f, "ms")), s.filter((S) => S !== E).forEach((S) => {
              _.debug("[choose-best-ws]close backup websocket: ".concat(S.url)), S.close();
            }), o = true, i(E);
          }, E.onclose = (f) => {
            c = f, !o && (s.find((S) => !(S.readyState === WebSocket.CLOSED || S.readyState === WebSocket.CLOSING)) || (_.debug("[choose-best-ws] all websocket is closed"), o = true, r(c)));
          }, E.onmessage = (f) => {
            _.debug("[choose-best-ws]".concat(E.url, " onmessage: ").concat(f.data));
          };
        }), Me(this.forceCloseTimeout).then(() => {
          s.forEach((E) => {
            E.readyState !== WebSocket.OPEN && E.close();
          });
        });
      }
      if (u) {
        var p;
        let g;
        _.debug("[choose-best-ws] use single url: ", e), (p = this.store) === null || p === void 0 || p.recordJoinChannelService({ urls: [e], service: "gateway" }, n);
        try {
          g = new WebSocket(e), s.push(g), g.binaryType = "arraybuffer";
        } catch (E) {
          let f = new N(R.WS_ERR, "init websocket failed! Error: ".concat(E.toString()));
          return _.error("[".concat(this.name, "]").concat(f)), void r(f);
        }
        g.onopen = () => {
          i(g);
        }, g.onclose = (E) => {
          r(E);
        }, g.onmessage = (E) => {
          _.debug("[choose-best-ws]".concat(g.url, " onmessage: ").concat(E.data));
        }, Me(this.forceCloseTimeout).then(() => {
          g && g.readyState !== WebSocket.OPEN && g.close();
        });
      }
    }).then((i) => (this.closeEstablishingWs = void 0, i)).catch((i) => {
      throw this.closeEstablishingWs = void 0, i;
    });
  }
};
var jE = class extends Xt {
  get connectionState() {
    return this._connectionState;
  }
  set connectionState(e) {
    e !== this._connectionState && (this._connectionState = e, e === Lt.CONNECTED ? this.emit(nt.WS_CONNECTED) : e === Lt.RECONNECTING ? this.emit(nt.WS_RECONNECTING, this._websocketReconnectReason) : e === Lt.CLOSED && this.emit(nt.WS_CLOSED, this._disconnectedReason));
  }
  get currentURLIndex() {
    return this.websocket.currentURLIndex;
  }
  get url() {
    return this.websocket && this.websocket.url || null;
  }
  get rtt() {
    return this.rttRolling.mean();
  }
  constructor(e, n) {
    super(), T(this, "_disconnectedReason", void 0), T(this, "_websocketReconnectReason", void 0), T(this, "_connectionState", Lt.CLOSED), T(this, "reconnectToken", void 0), T(this, "websocket", void 0), T(this, "openConnectionTime", void 0), T(this, "clientId", void 0), T(this, "lastMsgTime", Date.now()), T(this, "uploadCache", []), T(this, "uploadCacheInterval", void 0), T(this, "rttRolling", new Hl(5)), T(this, "pingpongTimer", void 0), T(this, "wsInflateDataTimer", void 0), T(this, "pingpongTimeoutCount", 0), T(this, "joinResponse", void 0), T(this, "multiIpOption", void 0), T(this, "initError", void 0), T(this, "spec", void 0), T(this, "store", void 0), T(this, "onWebsocketMessage", (i) => {
      if (i.data instanceof ArrayBuffer) return void this.emit(nt.ON_BINARY_DATA, i.data);
      let r = JSON.parse(i.data);
      if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(r, "_id")) {
        let o = "res-@".concat(r._id);
        this.emit(o, r._result, r._message);
      } else if (Object.prototype.hasOwnProperty.call(r, "_type")) {
        if (this.emit(r._type, r._message), r._type === dt.ON_NOTIFICATION && this.handleNotification(r._message), r._type === dt.ON_USER_BANNED) switch (r._message.error_code) {
          case 14:
            this.close(At.UID_BANNED);
            break;
          case 15:
            this.close(At.IP_BANNED);
            break;
          case 16:
            this.close(At.CHANNEL_BANNED);
        }
        if (r._type === dt.ON_USER_LICENSE_BANNED) switch (r._message.error_code) {
          case Z.ERR_LICENSE_MISSING:
            this.close(At.LICENSE_MISSING);
            break;
          case Z.ERR_LICENSE_EXPIRED:
            this.close(At.LICENSE_EXPIRED);
            break;
          case Z.ERR_LICENSE_MINUTES_EXCEEDED:
            this.close(At.LICENSE_MINUTES_EXCEEDED);
            break;
          case Z.ERR_LICENSE_PERIOD_INVALID:
            this.close(At.LICENSE_PERIOD_INVALID);
            break;
          case Z.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
            this.close(At.LICENSE_MULTIPLE_SDK_SERVICE);
            break;
          case Z.ERR_LICENSE_ILLEGAL:
            this.close(At.LICENSE_ILLEGAL);
            break;
          default:
            this.close();
        }
      }
    }), this.clientId = e.clientId, this.spec = e, this.store = n, this.websocket = new Nc("gateway-".concat(this.clientId), this.spec.retryConfig, true, v("JOIN_GATEWAY_USE_DUAL_DOMAIN"), v("JOIN_GATEWAY_USE_443PORT_ONLY"), n), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
      this.connectionState === Lt.CONNECTED && this.reconnect("retry", Be.OFFLINE);
    });
  }
  async request(e, n, i, r) {
    let o = Ut(6, ""), s = { _id: o, _type: e, _message: n }, a = this.websocket.connectionID, c = () => new j((g, E) => {
      if (this.connectionState === Lt.CONNECTED) return g();
      let f = () => {
        this.off(nt.WS_CLOSED, S), g();
      }, S = () => {
        this.off(nt.WS_CONNECTED, f), E(new O(R.WS_ABORT));
      };
      this.once(nt.WS_CONNECTED, f), this.once(nt.WS_CLOSED, S), e !== et.PUBLISH && e !== et.PUBLISH_DATASTREAM && e !== et.SUBSCRIBE && e !== et.SUBSCRIBE_DATASTREAM && e !== et.UNSUBSCRIBE && e !== et.UNSUBSCRIBE_DATASTREAM && e !== et.UNPUBLISH && e !== et.UNPUBLISH_DATASTREAM && e !== et.CONTROL && e !== et.RESTART_ICE || this.once(nt.DISCONNECT_P2P, () => {
        E(new O(R.DISCONNECT_P2P));
      }), e !== et.PUBLISH && e !== et.RESTART_ICE || this.once(nt.ABORT_P2P_EXECUTION, () => {
        E(new O(R.DISCONNECT_P2P));
      });
    });
    if (this.connectionState !== Lt.CONNECTING && this.connectionState !== Lt.RECONNECTING || e === et.JOIN || e === et.REJOIN || await c(), this.websocket.sendMessage(s, true), r) return;
    let d = new j((g, E) => {
      let f = false, S = (A, b) => {
        f = true, g({ isSuccess: A === "success", message: b || {} }), this.off(nt.WS_CLOSED, C), this.off(nt.WS_RECONNECTING, C), this.emit(nt.REQUEST_SUCCESS, e, n);
      };
      this.once("res-@".concat(o), S);
      let C = () => {
        E(new O(R.WS_ABORT, "type: ".concat(e))), this.off(nt.WS_CLOSED, C), this.off(nt.WS_RECONNECTING, C), this.off("res-@".concat(o), S);
      };
      this.once(nt.WS_CLOSED, C), this.once(nt.WS_RECONNECTING, C), Me(v("SIGNAL_REQUEST_TIMEOUT")).then(() => {
        this.websocket.connectionID !== a || f || (_.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e)), this.emit(nt.REQUEST_TIMEOUT, e, n));
      });
    }), l = null;
    try {
      l = await d;
    } catch (g) {
      if (this.connectionState === Lt.CLOSED || e === et.LEAVE) throw new O(R.WS_ABORT);
      return !this.spec.forceWaitGatewayResponse || i ? g.throw() : e === et.JOIN || e === et.REJOIN ? null : (await c(), await this.request(e, n));
    }
    if (l.isSuccess) return l.message;
    let u = Number(l.message.error_code || l.message.code), h = Oc(u), p = new O(R.UNEXPECTED_RESPONSE, "".concat(h.desc, ": ").concat(l.message.error_str), { code: u, data: l.message, desc: h.desc });
    return h.action === "success" ? l.message : (_.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e, ", error_code: ").concat(u, ", message: ").concat(h.desc, ", action: ").concat(h.action)), u === Z.ERR_TOO_MANY_BROADCASTERS ? ((e === et.JOIN || e === et.REJOIN) && (this.initError = p, this.close()), p.throw()) : h.action === "failed" ? p.throw() : h.action === "quit" ? (this.initError = p, this.close(), p.throw()) : (u === Z.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = l.message.option, _.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", Be.MULTI_IP)) : this.reconnect(h.action, Be.SERVER_ERROR), e === et.JOIN || e === et.REJOIN ? null : await this.request(e, n)));
  }
  waitMessage(e, n) {
    return new j((i) => {
      let r = (o) => {
        (!n || n(o)) && (this.off(e, r), i(o));
      };
      this.on(e, r);
    });
  }
  uploadWRTCStats(e) {
    if (!this.store.sessionId) return void _.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
    let n = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e };
    this.upload(wc.WRTC_STATS, n);
  }
  upload(e, n) {
    let i = { _type: e, _message: n };
    try {
      this.websocket.sendMessage(i);
    } catch {
      let o = v("MAX_UPLOAD_CACHE") || 50;
      this.uploadCache.push(i), this.uploadCache.length > o && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
        if (this.connectionState !== Lt.CONNECTED) return;
        let s = this.uploadCache.splice(0, 1)[0];
        this.uploadCache.length === 0 && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(s._type, s._message);
      }, v("UPLOAD_CACHE_INTERVAL") || 2e3));
    }
  }
  send(e, n) {
    let i = { _type: e, _message: n };
    this.websocket.sendMessage(i);
  }
  init(e, n) {
    return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new j((i, r) => {
      this.once(nt.WS_CONNECTED, () => i(this.joinResponse)), this.once(nt.WS_CLOSED, () => r(this.initError || new O(R.WS_ABORT))), this.connectionState = Lt.CONNECTING, this.websocket.init(e).catch(r), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {
        this.handleWsInflateData();
      }, 2e4);
    });
  }
  close(e) {
    this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e || At.LEAVE, this.connectionState = Lt.CLOSED, _.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close();
  }
  async join() {
    if (!this.joinResponse) {
      this.emit(nt.ABORT_P2P_EXECUTION);
      let e = await Ge(this, nt.REQUEST_JOIN_INFO), n = await this.request(et.JOIN, e);
      if (!n) return this.emit(nt.REPORT_JOIN_GATEWAY, Tl.TIMEOUT, this.url || ""), false;
      this.joinResponse = n, this.emit(nt.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
    }
    return this.connectionState = Lt.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
  }
  async rejoin() {
    if (!this.reconnectToken) throw new O(R.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
    let e = Ac(this, nt.REQUEST_REJOIN_INFO);
    e.token = this.reconnectToken;
    let n = await this.request(et.REJOIN, e);
    return !!n && (this.connectionState = Lt.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), n.peers && n.peers.forEach((i) => {
      this.emit(dt.ON_USER_ONLINE, { uid: i.uid }), i.audio && this.emit(dt.ON_ADD_AUDIO_STREAM, { uid: i.uid, uint_id: i.uint_id, audio: true, ssrcId: i.audio_ssrc }), i.video && this.emit(dt.ON_ADD_VIDEO_STREAM, { uid: i.uid, uint_id: i.uint_id, video: true, ssrcId: i.video_ssrc }), i.audio_mute ? this.emit(dt.MUTE_AUDIO, { uid: i.uid }) : this.emit(dt.UNMUTE_AUDIO, { uid: i.uid }), i.video_mute ? this.emit(dt.MUTE_VIDEO, { uid: i.uid }) : this.emit(dt.UNMUTE_VIDEO, { uid: i.uid }), i.audio_enable_local ? this.emit(dt.ENABLE_LOCAL_AUDIO, { uid: i.uid }) : this.emit(dt.DISABLE_LOCAL_AUDIO, { uid: i.uid }), i.video_enable_local ? this.emit(dt.ENABLE_LOCAL_VIDEO, { uid: i.uid }) : this.emit(dt.DISABLE_LOCAL_VIDEO, { uid: i.uid }), i.audio || i.video || this.emit(dt.ON_REMOVE_STREAM, { uid: i.uid, uint_id: i.uint_id });
    }), true);
  }
  reconnect(e, n) {
    this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e, n);
  }
  handleNotification(e) {
    _.debug("[".concat(this.clientId, "] receive notification: "), e);
    let n = Oc(e.code);
    if (n.action !== "success") {
      if (n.action !== "failed") return n.action === "quit" ? (n.desc === "ERR_REPEAT_JOIN_CHANNEL" && this.close(At.UID_BANNED), void this.close()) : void this.reconnect(n.action, Be.SERVER_ERROR);
      _.error("[".concat(this.clientId, "] ignore error: "), n.desc);
    }
  }
  handlePingPong() {
    if (!this.websocket || this.websocket.state !== "connected") return;
    this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
    let e = v("PING_PONG_TIME_OUT"), n = Date.now();
    this.pingpongTimeoutCount >= e && (_.warning("[".concat(this.clientId, "] PING-PONG Timeout. Last Socket Message: ").concat(n - this.lastMsgTime, "ms")), n - this.lastMsgTime > v("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", Be.TIMEOUT) : this.request(et.PING, void 0, true).then(() => {
      this.pingpongTimeoutCount = 0;
      let i = Date.now() - n;
      this.rttRolling.add(i), v("REPORT_STATS") && this.send(et.PING_BACK, { pingpongElapse: i });
    }).catch((i) => {
    });
  }
  handleWsInflateData() {
    let { wsInflateLength: e, wsDeflateLength: n } = this.websocket.getWsInflateData();
    e !== 0 && n !== 0 && this.upload(wc.WS_INFLATE_DATA_LENGTH, { ws_deflate_length: n, ws_inflate_length: e });
  }
  handleWebsocketEvents() {
    this.websocket.on(it.RECONNECT_WAITTING_FINISH, (e) => {
      this.emit(nt.WS_RECONNECT_WAITTING_FINISH, e);
    }), this.websocket.on(it.RECONNECT_CREATE_CONNECTION, (e) => {
      this.emit(nt.WS_RECONNECT_CREATE_CONNECTION, e);
    }), this.websocket.on(it.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(it.CLOSED, () => {
      this.connectionState = Lt.CLOSED;
    }), this.websocket.on(it.FAILED, () => {
      this._disconnectedReason = At.NETWORK_ERROR, this.connectionState = Lt.CLOSED;
    }), this.websocket.on(it.RECONNECTING, (e) => {
      this._websocketReconnectReason = e, this.joinResponse = void 0, this.connectionState === Lt.CONNECTED ? this.connectionState = Lt.RECONNECTING : this.connectionState = Lt.CONNECTING;
    }), this.websocket.on(it.WILL_RECONNECT, (e, n, i) => {
      let r = Ac(this, nt.IS_P2P_DISCONNECTED), o = r || e !== "retry";
      r && e === "retry" && (_.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), e = "tryNext", n = Tl.P2P_DISCONNECTED), o && (_.debug("".concat(this.clientId, " will renewSession, reconnect mode: ").concat(e)), this.emit(nt.REPORT_JOIN_GATEWAY, n || Tl.UNKNOWN_REASON, this.url || ""), this.reconnectToken = void 0, this.emit(nt.DISCONNECT_P2P)), i(e);
    }), this.websocket.on(it.CONNECTED, () => {
      this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch((e) => {
        _.warning("[".concat(this.clientId, "] rejoin failed ").concat(e)), this.reconnect("tryNext", Be.SERVER_ERROR);
      }) : this.join().catch((e) => {
        if (this.emit(nt.REPORT_JOIN_GATEWAY, e, this.url || ""), e instanceof O) {
          if (e.code === R.UNEXPECTED_RESPONSE && e.data.code === Z.ERR_NO_AUTHORIZED) return this.initError = new O(R.CAN_NOT_GET_GATEWAY_SERVER, "AgoraRTCError CAN_NOT_GET_GATEWAY_SERVER: dynamic key expired"), _.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", Be.SERVER_ERROR);
          _.error("[".concat(this.clientId, "] join gateway request failed"), e.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", Be.SERVER_ERROR) : (this.initError = e, this.close());
        }
      });
    }), this.websocket.on(it.REQUEST_NEW_URLS, (e, n) => {
      Ge(this, nt.REQUEST_RECOVER, this.multiIpOption).then(e).catch(n);
    }), this.websocket.on(it.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
      this.emit(dt.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
    }), this.websocket.on(PO.PRE_CONNECT_PC, () => {
      this.emit(nt.PRE_CONNECT_PC);
    });
  }
};
var ue = function(t11) {
  return t11[t11.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", t11[t11.CLOUD_PROXY = 18] = "CLOUD_PROXY", t11[t11.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", t11[t11.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK", t11;
}({});
function jR(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function kd(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? jR(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : jR(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
function Us(t11) {
  return t11.match(/^[\.\:\d]+$/) ? "".concat(t11.replace(/[^\d]/g, "-"), ".").concat(v("TURN_DOMAIN")) : (_.info("Unidentified as ip: ".concat(t11, ", use as host")), t11);
}
function mf(t11, e) {
  t11.addresses || (t11.addresses = []);
  let n = function(a, c) {
    if (v("CONNECT_GATEWAY_WITHOUT_DOMAIN")) return a.map((u) => {
      let { ip: h, port: p } = u;
      return { address: "".concat(h, ":").concat(p) };
    });
    let d = v("GATEWAY_DOMAINS"), l = d[1] && W(c).call(c, d[1]) ? 1 : 0;
    return a.map((u) => {
      let { domain_prefix: h, port: p, ip: g } = u;
      if (h) return { address: "".concat(h, ".").concat(d[l++ % d.length], ":").concat(p) };
      let E = /^[\.\:\d]+$/.test(g), f = E ? "".concat(g.replace(/[^\d]/g, "-"), ".").concat(d[l++ % d.length], ":").concat(p) : "".concat(g, ":").concat(p);
      return E || _.info("Unidentified as ip: ".concat(g, ", use as host")), { ip: g, port: p, address: f };
    });
  }(t11.addresses, e), i = Array.isArray(t11.detail) && t11.detail[18];
  if (i && typeof i == "string") {
    let a = i.split(";");
    for (let c = 0; c < a.length; c++) {
      var r;
      let d = rn(r = a[c]).call(r);
      n[c] && d && (n[c].ip6 = d);
    }
  }
  let o = t11.detail && t11.detail.candidate, s;
  if (o) {
    let [a, c] = o.split(":");
    a && c && (s = { port: Number(c), ip: a, address: "".concat(a, ":").concat(c) });
  }
  return { gatewayAddrs: n, apGatewayAddress: s, uid: t11.uid, cid: t11.cid, cert: t11.cert, vid: t11.detail && t11.detail[8], uni_lbs_ip: t11.detail && t11.detail[1], res: t11, csIp: t11.detail && t11.detail[502] };
}
function Nn(t11) {
  return typeof t11 == "number" ? t11 : t11.exact || t11.ideal || t11.max || t11.min || 0;
}
function GR(t11) {
  let e = t11._encoderConfig;
  if (!e) return {};
  let n = { resolution: e.width && e.height ? "".concat(Nn(e.width), "x").concat(Nn(e.height)) : void 0, maxVideoBW: e.bitrateMax, minVideoBW: e.bitrateMin };
  return typeof e.frameRate == "number" ? (n.maxFrameRate = e.frameRate, n.minFrameRate = e.frameRate) : e.frameRate && (n.maxFrameRate = e.frameRate.max || e.frameRate.ideal || e.frameRate.exact || e.frameRate.min, n.minFrameRate = e.frameRate.min || e.frameRate.ideal || e.frameRate.exact || e.frameRate.max), n;
}
function WR(t11) {
  return t11 >= 0 && t11 < 0.17 ? 1 : t11 >= 0.17 && t11 < 0.36 ? 2 : t11 >= 0.36 && t11 < 0.59 ? 3 : t11 >= 0.59 && t11 <= 1 ? 4 : t11 > 1 ? 5 : 0;
}
function Dc(t11, e) {
  let n, i, r;
  switch (e) {
    case ue.CHOOSE_SERVER:
      i = 4096, r = "choose server";
      break;
    case ue.CLOUD_PROXY:
      i = 1048576, r = "proxy";
      break;
    case ue.CLOUD_PROXY_5:
      i = 4194304, r = "proxy5";
      break;
    case ue.CLOUD_PROXY_FALLBACK:
      i = 4194310, r = "proxy fallback";
      break;
    default:
      throw new O(R.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", { csIp: t11.detail && t11.detail[502], retry: false });
  }
  if (t11.response_body.forEach((o) => {
    o.buffer && o.buffer.flag === i && (n = { code: o.buffer.code, addresses: (o.buffer.edges_services || []).map((s) => kd(kd({}, s), {}, { ticket: o.buffer.cert })), server_ts: t11.enter_ts, uid: o.buffer.uid, cid: o.buffer.cid, cname: o.buffer.cname, detail: kd(kd({}, o.buffer.detail), t11.detail), flag: o.buffer.flag, opid: t11.opid, cert: o.buffer.cert });
  }), !n) throw new O(R.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(r, " from multi unilbs response"), { csIp: t11.detail && t11.detail[502] });
  return n;
}
async function kO(t11, e) {
  return await j.all(t11.addresses.map(async (n) => ({ address: Us(n.ip), tcpport: n.port, udpport: n.port, username: e && v("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? e.toString() : Ve.username, password: e && v("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await PE(e.toString()) : Ve.password })));
}
function GE(t11, e) {
  let n = e.getMediaStreamTrack(true).getSettings(), i = e.videoHeight || n.height, r = e.videoWidth || n.width;
  return i && r ? Math.max(Math.min(i, r) / Math.min(Nn(t11.height), Nn(t11.width)), 1) : (_.warning("can't get ori-track's height, default scale down 4 times for low stream"), 4);
}
function eo(t11) {
  let { candidateType: e, relayProtocol: n, type: i, address: r, port: o, protocol: s } = t11;
  return i === "local-candidate" ? { candidateType: e, relayProtocol: n, protocol: s } : { candidateType: e, relayProtocol: n, address: r, port: o, protocol: s };
}
var li;
var mj = ae(DO);
var fj = bi("Array").values;
var gj = Er;
var Tj = Je;
var Sj = hn;
var Rj = fj;
var Fp = Array.prototype;
var Cj = { DOMTokenList: true, NodeList: true };
var Ij = function(t11) {
  var e = t11.values;
  return t11 === Fp || Sj(Fp, t11) && e === Fp.values || Tj(Cj, gj(t11)) ? Rj : e;
};
var Pr = ae(Ij);
var HR = ri;
var vj = me;
var yj = Ke;
var Aj = Se;
var Bp = Lu;
var bj = Xc;
var wj = Au;
var Oj = _r;
var Nj = bu;
var _s = Object.assign;
var KR = Object.defineProperty;
var Dj = vj([].concat);
var Pj = !_s || Aj(function() {
  if (HR && _s({ b: 1 }, _s(KR({}, "a", { enumerable: true, get: function() {
    KR(this, "b", { value: 3, enumerable: false });
  } }), { b: 2 })).b !== 1) return true;
  var t11 = {}, e = {}, n = Symbol(), i = "abcdefghijklmnopqrst";
  return t11[n] = 7, i.split("").forEach(function(r) {
    e[r] = r;
  }), _s({}, t11)[n] != 7 || Bp(_s({}, e)).join("") != i;
}) ? function(t11, e) {
  for (var n = Oj(t11), i = arguments.length, r = 1, o = bj.f, s = wj.f; i > r; ) for (var a, c = Nj(arguments[r++]), d = o ? Dj(Bp(c), o(c)) : Bp(c), l = d.length, u = 0; l > u; ) a = d[u++], HR && !yj(s, c, a) || (n[a] = c[a]);
  return n;
} : _s;
var kj = Cn;
var Lj = XA;
var Mj = mo;
var Uj = Ke;
var xj = _r;
var Vj = function(t11, e, n, i) {
  try {
    return i ? e(kj(n)[0], n[1]) : e(n);
  } catch (r) {
    Lj(t11, "throw", r);
  }
};
var Fj = JA;
var Bj = xu;
var jj = Lr;
var YR = Bu;
var Gj = Um;
var Wj = Mu;
var qR = Array;
var is = me;
var jp = 2147483647;
var Hj = /[^\0-\u007E]/;
var LO = /[.\u3002\uFF0E\uFF61]/g;
var zR = "Overflow: input needs wider integers to process";
var JR = RangeError;
var Kj = is(LO.exec);
var xs = Math.floor;
var Gp = String.fromCharCode;
var XR = is("".charCodeAt);
var MO = is([].join);
var qr = is([].push);
var Yj = is("".replace);
var qj = is("".split);
var zj = is("".toLowerCase);
var QR = function(t11) {
  return t11 + 22 + 75 * (t11 < 26);
};
var Jj = function(t11, e, n) {
  var i = 0;
  for (t11 = n ? xs(t11 / 700) : t11 >> 1, t11 += xs(t11 / e); t11 > 455; ) t11 = xs(t11 / 35), i += 36;
  return xs(i + 36 * t11 / (t11 + 38));
};
var Xj = function(t11) {
  var e = [];
  t11 = function(S) {
    for (var C = [], A = 0, b = S.length; A < b; ) {
      var w = XR(S, A++);
      if (w >= 55296 && w <= 56319 && A < b) {
        var D = XR(S, A++);
        (64512 & D) == 56320 ? qr(C, ((1023 & w) << 10) + (1023 & D) + 65536) : (qr(C, w), A--);
      } else qr(C, w);
    }
    return C;
  }(t11);
  var n, i, r = t11.length, o = 128, s = 0, a = 72;
  for (n = 0; n < t11.length; n++) (i = t11[n]) < 128 && qr(e, Gp(i));
  var c = e.length, d = c;
  for (c && qr(e, "-"); d < r; ) {
    var l = jp;
    for (n = 0; n < t11.length; n++) (i = t11[n]) >= o && i < l && (l = i);
    var u = d + 1;
    if (l - o > xs((jp - s) / u)) throw JR(zR);
    for (s += (l - o) * u, o = l, n = 0; n < t11.length; n++) {
      if ((i = t11[n]) < o && ++s > jp) throw JR(zR);
      if (i == o) {
        for (var h = s, p = 36; ; ) {
          var g = p <= a ? 1 : p >= a + 26 ? 26 : p - a;
          if (h < g) break;
          var E = h - g, f = 36 - g;
          qr(e, Gp(QR(g + E % f))), h = xs(E / f), p += 36;
        }
        qr(e, Gp(QR(h))), a = Jj(s, u, d == c), s = 0, d++;
      }
    }
    s++, o++;
  }
  return MO(e, "");
};
var Qj = xt;
var ff = ri;
var Zj = rf;
var gf = We;
var ZR = mo;
var wi = me;
var Ld = go;
var ui = Uu;
var $j = Fm;
var WE = Je;
var Tf = Pj;
var Es = function(t11) {
  var e = xj(t11), n = Bj(this), i = arguments.length, r = i > 1 ? arguments[1] : void 0, o = r !== void 0;
  o && (r = Mj(r, i > 2 ? arguments[2] : void 0));
  var s, a, c, d, l, u, h = Wj(e), p = 0;
  if (!h || this === qR && Fj(h)) for (s = jj(e), a = n ? new this(s) : qR(s); s > p; p++) u = o ? r(e[p], p) : e[p], YR(a, p, u);
  else for (l = (d = Gj(e, h)).next, a = n ? new this() : []; !(c = Uj(l, d)).done; p++) u = o ? Vj(d, r, [c.value, p], true) : c.value, YR(a, p, u);
  return a.length = p, a;
};
var Di = zm;
var tG = qm.codeAt;
var eG = function(t11) {
  var e, n, i = [], r = qj(Yj(zj(t11), LO, "."), ".");
  for (e = 0; e < r.length; e++) n = r[e], qr(i, Kj(Hj, n) ? "xn--" + Xj(n) : n);
  return MO(i, ".");
};
var vr = oi;
var nG = To;
var iG = Vu;
var UO = yF;
var xO = ns;
var rG = xO.set;
var zl = xO.getterFor("URL");
var oG = UO.URLSearchParams;
var sG = UO.getState;
var La = gf.URL;
var HE = gf.TypeError;
var Md = gf.parseInt;
var aG = Math.floor;
var $R = Math.pow;
var Ti = wi("".charAt);
var Li = wi(/./.exec);
var Ya = wi([].join);
var cG = wi(1 .toString);
var dG = wi([].pop);
var ms = wi([].push);
var Wp = wi("".replace);
var lG = wi([].shift);
var uG = wi("".split);
var qa = wi("".slice);
var Sl = wi("".toLowerCase);
var hG = wi([].unshift);
var Hp = "Invalid scheme";
var vo = "Invalid host";
var tC = "Invalid port";
var VO = /[a-z]/i;
var pG = /[\d+-.a-z]/i;
var Kp = /\d/;
var _G = /^0x/i;
var EG = /^[0-7]+$/;
var mG = /^\d+$/;
var eC = /^[\da-f]+$/i;
var fG = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
var gG = /[\0\t\n\r #/:<>?@[\\\]^|]/;
var TG = /^[\u0000-\u0020]+/;
var SG = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
var RG = /[\t\n\r]/g;
var Ma = function(t11) {
  var e, n, i, r;
  if (typeof t11 == "number") {
    for (e = [], n = 0; n < 4; n++) hG(e, t11 % 256), t11 = aG(t11 / 256);
    return Ya(e, ".");
  }
  if (typeof t11 == "object") {
    for (e = "", i = function(o) {
      for (var s = null, a = 1, c = null, d = 0, l = 0; l < 8; l++) o[l] !== 0 ? (d > a && (s = c, a = d), c = null, d = 0) : (c === null && (c = l), ++d);
      return d > a && (s = c, a = d), s;
    }(t11), n = 0; n < 8; n++) r && t11[n] === 0 || (r && (r = false), i === n ? (e += n ? ":" : "::", r = true) : (e += cG(t11[n], 16), n < 7 && (e += ":")));
    return "[" + e + "]";
  }
  return t11;
};
var Rl = {};
var FO = Tf({}, Rl, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 });
var BO = Tf({}, FO, { "#": 1, "?": 1, "{": 1, "}": 1 });
var Yp = Tf({}, BO, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 });
var Br = function(t11, e) {
  var n = tG(t11, 0);
  return n > 32 && n < 127 && !WE(e, t11) ? t11 : encodeURIComponent(t11);
};
var Ud = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 };
var za = function(t11, e) {
  var n;
  return t11.length == 2 && Li(VO, Ti(t11, 0)) && ((n = Ti(t11, 1)) == ":" || !e && n == "|");
};
var nC = function(t11) {
  var e;
  return t11.length > 1 && za(qa(t11, 0, 2)) && (t11.length == 2 || (e = Ti(t11, 2)) === "/" || e === "\\" || e === "?" || e === "#");
};
var CG = function(t11) {
  return t11 === "." || Sl(t11) === "%2e";
};
var qp = {};
var iC = {};
var zp = {};
var rC = {};
var oC = {};
var Jp = {};
var sC = {};
var aC = {};
var xd = {};
var Vd = {};
var Xp = {};
var Qp = {};
var Zp = {};
var $p = {};
var cC = {};
var t_ = {};
var fs = {};
var qi = {};
var dC = {};
var yo = {};
var Sr = {};
var Sf = function(t11, e, n) {
  var i, r, o, s = vr(t11);
  if (e) {
    if (r = this.parse(s)) throw HE(r);
    this.searchParams = null;
  } else {
    if (n !== void 0 && (i = new Sf(n, true)), r = this.parse(s, null, i)) throw HE(r);
    (o = sG(new oG())).bindURL(this), this.searchParams = o;
  }
};
Sf.prototype = { type: "URL", parse: function(t11, e, n) {
  var i, r, o, s, a, c = this, d = e || qp, l = 0, u = "", h = false, p = false, g = false;
  for (t11 = vr(t11), e || (c.scheme = "", c.username = "", c.password = "", c.host = null, c.port = null, c.path = [], c.query = null, c.fragment = null, c.cannotBeABaseURL = false, t11 = Wp(t11, TG, ""), t11 = Wp(t11, SG, "$1")), t11 = Wp(t11, RG, ""), i = Es(t11); l <= i.length; ) {
    switch (r = i[l], d) {
      case qp:
        if (!r || !Li(VO, r)) {
          if (e) return Hp;
          d = zp;
          continue;
        }
        u += Sl(r), d = iC;
        break;
      case iC:
        if (r && (Li(pG, r) || r == "+" || r == "-" || r == ".")) u += Sl(r);
        else {
          if (r != ":") {
            if (e) return Hp;
            u = "", d = zp, l = 0;
            continue;
          }
          if (e && (c.isSpecial() != WE(Ud, u) || u == "file" && (c.includesCredentials() || c.port !== null) || c.scheme == "file" && !c.host)) return;
          if (c.scheme = u, e) return void (c.isSpecial() && Ud[c.scheme] == c.port && (c.port = null));
          u = "", c.scheme == "file" ? d = $p : c.isSpecial() && n && n.scheme == c.scheme ? d = rC : c.isSpecial() ? d = aC : i[l + 1] == "/" ? (d = oC, l++) : (c.cannotBeABaseURL = true, ms(c.path, ""), d = dC);
        }
        break;
      case zp:
        if (!n || n.cannotBeABaseURL && r != "#") return Hp;
        if (n.cannotBeABaseURL && r == "#") {
          c.scheme = n.scheme, c.path = Di(n.path), c.query = n.query, c.fragment = "", c.cannotBeABaseURL = true, d = Sr;
          break;
        }
        d = n.scheme == "file" ? $p : Jp;
        continue;
      case rC:
        if (r != "/" || i[l + 1] != "/") {
          d = Jp;
          continue;
        }
        d = xd, l++;
        break;
      case oC:
        if (r == "/") {
          d = Vd;
          break;
        }
        d = qi;
        continue;
      case Jp:
        if (c.scheme = n.scheme, r == li) c.username = n.username, c.password = n.password, c.host = n.host, c.port = n.port, c.path = Di(n.path), c.query = n.query;
        else if (r == "/" || r == "\\" && c.isSpecial()) d = sC;
        else if (r == "?") c.username = n.username, c.password = n.password, c.host = n.host, c.port = n.port, c.path = Di(n.path), c.query = "", d = yo;
        else {
          if (r != "#") {
            c.username = n.username, c.password = n.password, c.host = n.host, c.port = n.port, c.path = Di(n.path), c.path.length--, d = qi;
            continue;
          }
          c.username = n.username, c.password = n.password, c.host = n.host, c.port = n.port, c.path = Di(n.path), c.query = n.query, c.fragment = "", d = Sr;
        }
        break;
      case sC:
        if (!c.isSpecial() || r != "/" && r != "\\") {
          if (r != "/") {
            c.username = n.username, c.password = n.password, c.host = n.host, c.port = n.port, d = qi;
            continue;
          }
          d = Vd;
        } else d = xd;
        break;
      case aC:
        if (d = xd, r != "/" || Ti(u, l + 1) != "/") continue;
        l++;
        break;
      case xd:
        if (r != "/" && r != "\\") {
          d = Vd;
          continue;
        }
        break;
      case Vd:
        if (r == "@") {
          h && (u = "%40" + u), h = true, o = Es(u);
          for (var E = 0; E < o.length; E++) {
            var f = o[E];
            if (f != ":" || g) {
              var S = Br(f, Yp);
              g ? c.password += S : c.username += S;
            } else g = true;
          }
          u = "";
        } else if (r == li || r == "/" || r == "?" || r == "#" || r == "\\" && c.isSpecial()) {
          if (h && u == "") return "Invalid authority";
          l -= Es(u).length + 1, u = "", d = Xp;
        } else u += r;
        break;
      case Xp:
      case Qp:
        if (e && c.scheme == "file") {
          d = t_;
          continue;
        }
        if (r != ":" || p) {
          if (r == li || r == "/" || r == "?" || r == "#" || r == "\\" && c.isSpecial()) {
            if (c.isSpecial() && u == "") return vo;
            if (e && u == "" && (c.includesCredentials() || c.port !== null)) return;
            if (s = c.parseHost(u)) return s;
            if (u = "", d = fs, e) return;
            continue;
          }
          r == "[" ? p = true : r == "]" && (p = false), u += r;
        } else {
          if (u == "") return vo;
          if (s = c.parseHost(u)) return s;
          if (u = "", d = Zp, e == Qp) return;
        }
        break;
      case Zp:
        if (!Li(Kp, r)) {
          if (r == li || r == "/" || r == "?" || r == "#" || r == "\\" && c.isSpecial() || e) {
            if (u != "") {
              var C = Md(u, 10);
              if (C > 65535) return tC;
              c.port = c.isSpecial() && C === Ud[c.scheme] ? null : C, u = "";
            }
            if (e) return;
            d = fs;
            continue;
          }
          return tC;
        }
        u += r;
        break;
      case $p:
        if (c.scheme = "file", r == "/" || r == "\\") d = cC;
        else {
          if (!n || n.scheme != "file") {
            d = qi;
            continue;
          }
          if (r == li) c.host = n.host, c.path = Di(n.path), c.query = n.query;
          else if (r == "?") c.host = n.host, c.path = Di(n.path), c.query = "", d = yo;
          else {
            if (r != "#") {
              nC(Ya(Di(i, l), "")) || (c.host = n.host, c.path = Di(n.path), c.shortenPath()), d = qi;
              continue;
            }
            c.host = n.host, c.path = Di(n.path), c.query = n.query, c.fragment = "", d = Sr;
          }
        }
        break;
      case cC:
        if (r == "/" || r == "\\") {
          d = t_;
          break;
        }
        n && n.scheme == "file" && !nC(Ya(Di(i, l), "")) && (za(n.path[0], true) ? ms(c.path, n.path[0]) : c.host = n.host), d = qi;
        continue;
      case t_:
        if (r == li || r == "/" || r == "\\" || r == "?" || r == "#") {
          if (!e && za(u)) d = qi;
          else if (u == "") {
            if (c.host = "", e) return;
            d = fs;
          } else {
            if (s = c.parseHost(u)) return s;
            if (c.host == "localhost" && (c.host = ""), e) return;
            u = "", d = fs;
          }
          continue;
        }
        u += r;
        break;
      case fs:
        if (c.isSpecial()) {
          if (d = qi, r != "/" && r != "\\") continue;
        } else if (e || r != "?") if (e || r != "#") {
          if (r != li && (d = qi, r != "/")) continue;
        } else c.fragment = "", d = Sr;
        else c.query = "", d = yo;
        break;
      case qi:
        if (r == li || r == "/" || r == "\\" && c.isSpecial() || !e && (r == "?" || r == "#")) {
          if ((a = Sl(a = u)) === ".." || a === "%2e." || a === ".%2e" || a === "%2e%2e" ? (c.shortenPath(), r == "/" || r == "\\" && c.isSpecial() || ms(c.path, "")) : CG(u) ? r == "/" || r == "\\" && c.isSpecial() || ms(c.path, "") : (c.scheme == "file" && !c.path.length && za(u) && (c.host && (c.host = ""), u = Ti(u, 0) + ":"), ms(c.path, u)), u = "", c.scheme == "file" && (r == li || r == "?" || r == "#")) for (; c.path.length > 1 && c.path[0] === ""; ) lG(c.path);
          r == "?" ? (c.query = "", d = yo) : r == "#" && (c.fragment = "", d = Sr);
        } else u += Br(r, BO);
        break;
      case dC:
        r == "?" ? (c.query = "", d = yo) : r == "#" ? (c.fragment = "", d = Sr) : r != li && (c.path[0] += Br(r, Rl));
        break;
      case yo:
        e || r != "#" ? r != li && (r == "'" && c.isSpecial() ? c.query += "%27" : c.query += r == "#" ? "%23" : Br(r, Rl)) : (c.fragment = "", d = Sr);
        break;
      case Sr:
        r != li && (c.fragment += Br(r, FO));
    }
    l++;
  }
}, parseHost: function(t11) {
  var e, n, i;
  if (Ti(t11, 0) == "[") {
    if (Ti(t11, t11.length - 1) != "]" || (e = function(r) {
      var o, s, a, c, d, l, u, h = [0, 0, 0, 0, 0, 0, 0, 0], p = 0, g = null, E = 0, f = function() {
        return Ti(r, E);
      };
      if (f() == ":") {
        if (Ti(r, 1) != ":") return;
        E += 2, g = ++p;
      }
      for (; f(); ) {
        if (p == 8) return;
        if (f() != ":") {
          for (o = s = 0; s < 4 && Li(eC, f()); ) o = 16 * o + Md(f(), 16), E++, s++;
          if (f() == ".") {
            if (s == 0 || (E -= s, p > 6)) return;
            for (a = 0; f(); ) {
              if (c = null, a > 0) {
                if (!(f() == "." && a < 4)) return;
                E++;
              }
              if (!Li(Kp, f())) return;
              for (; Li(Kp, f()); ) {
                if (d = Md(f(), 10), c === null) c = d;
                else {
                  if (c == 0) return;
                  c = 10 * c + d;
                }
                if (c > 255) return;
                E++;
              }
              h[p] = 256 * h[p] + c, ++a != 2 && a != 4 || p++;
            }
            if (a != 4) return;
            break;
          }
          if (f() == ":") {
            if (E++, !f()) return;
          } else if (f()) return;
          h[p++] = o;
        } else {
          if (g !== null) return;
          E++, g = ++p;
        }
      }
      if (g !== null) for (l = p - g, p = 7; p != 0 && l > 0; ) u = h[p], h[p--] = h[g + l - 1], h[g + --l] = u;
      else if (p != 8) return;
      return h;
    }(qa(t11, 1, -1)), !e)) return vo;
    this.host = e;
  } else if (this.isSpecial()) {
    if (t11 = eG(t11), Li(fG, t11) || (e = function(r) {
      var o, s, a, c, d, l, u, h = uG(r, ".");
      if (h.length && h[h.length - 1] == "" && h.length--, (o = h.length) > 4) return r;
      for (s = [], a = 0; a < o; a++) {
        if ((c = h[a]) == "") return r;
        if (d = 10, c.length > 1 && Ti(c, 0) == "0" && (d = Li(_G, c) ? 16 : 8, c = qa(c, d == 8 ? 1 : 2)), c === "") l = 0;
        else {
          if (!Li(d == 10 ? mG : d == 8 ? EG : eC, c)) return r;
          l = Md(c, d);
        }
        ms(s, l);
      }
      for (a = 0; a < o; a++) if (l = s[a], a == o - 1) {
        if (l >= $R(256, 5 - o)) return null;
      } else if (l > 255) return null;
      for (u = dG(s), a = 0; a < s.length; a++) u += s[a] * $R(256, 3 - a);
      return u;
    }(t11), e === null)) return vo;
    this.host = e;
  } else {
    if (Li(gG, t11)) return vo;
    for (e = "", n = Es(t11), i = 0; i < n.length; i++) e += Br(n[i], Rl);
    this.host = e;
  }
}, cannotHaveUsernamePasswordPort: function() {
  return !this.host || this.cannotBeABaseURL || this.scheme == "file";
}, includesCredentials: function() {
  return this.username != "" || this.password != "";
}, isSpecial: function() {
  return WE(Ud, this.scheme);
}, shortenPath: function() {
  var t11 = this.path, e = t11.length;
  !e || this.scheme == "file" && e == 1 && za(t11[0], true) || t11.length--;
}, serialize: function() {
  var t11 = this, e = t11.scheme, n = t11.username, i = t11.password, r = t11.host, o = t11.port, s = t11.path, a = t11.query, c = t11.fragment, d = e + ":";
  return r !== null ? (d += "//", t11.includesCredentials() && (d += n + (i ? ":" + i : "") + "@"), d += Ma(r), o !== null && (d += ":" + o)) : e == "file" && (d += "//"), d += t11.cannotBeABaseURL ? s[0] : s.length ? "/" + Ya(s, "/") : "", a !== null && (d += "?" + a), c !== null && (d += "#" + c), d;
}, setHref: function(t11) {
  var e = this.parse(t11);
  if (e) throw HE(e);
  this.searchParams.update();
}, getOrigin: function() {
  var t11 = this.scheme, e = this.port;
  if (t11 == "blob") try {
    return new ea(t11.path[0]).origin;
  } catch {
    return "null";
  }
  return t11 != "file" && this.isSpecial() ? t11 + "://" + Ma(this.host) + (e !== null ? ":" + e : "") : "null";
}, getProtocol: function() {
  return this.scheme + ":";
}, setProtocol: function(t11) {
  this.parse(vr(t11) + ":", qp);
}, getUsername: function() {
  return this.username;
}, setUsername: function(t11) {
  var e = Es(vr(t11));
  if (!this.cannotHaveUsernamePasswordPort()) {
    this.username = "";
    for (var n = 0; n < e.length; n++) this.username += Br(e[n], Yp);
  }
}, getPassword: function() {
  return this.password;
}, setPassword: function(t11) {
  var e = Es(vr(t11));
  if (!this.cannotHaveUsernamePasswordPort()) {
    this.password = "";
    for (var n = 0; n < e.length; n++) this.password += Br(e[n], Yp);
  }
}, getHost: function() {
  var t11 = this.host, e = this.port;
  return t11 === null ? "" : e === null ? Ma(t11) : Ma(t11) + ":" + e;
}, setHost: function(t11) {
  this.cannotBeABaseURL || this.parse(t11, Xp);
}, getHostname: function() {
  var t11 = this.host;
  return t11 === null ? "" : Ma(t11);
}, setHostname: function(t11) {
  this.cannotBeABaseURL || this.parse(t11, Qp);
}, getPort: function() {
  var t11 = this.port;
  return t11 === null ? "" : vr(t11);
}, setPort: function(t11) {
  this.cannotHaveUsernamePasswordPort() || ((t11 = vr(t11)) == "" ? this.port = null : this.parse(t11, Zp));
}, getPathname: function() {
  var t11 = this.path;
  return this.cannotBeABaseURL ? t11[0] : t11.length ? "/" + Ya(t11, "/") : "";
}, setPathname: function(t11) {
  this.cannotBeABaseURL || (this.path = [], this.parse(t11, fs));
}, getSearch: function() {
  var t11 = this.query;
  return t11 ? "?" + t11 : "";
}, setSearch: function(t11) {
  (t11 = vr(t11)) == "" ? this.query = null : (Ti(t11, 0) == "?" && (t11 = qa(t11, 1)), this.query = "", this.parse(t11, yo)), this.searchParams.update();
}, getSearchParams: function() {
  return this.searchParams.facade;
}, getHash: function() {
  var t11 = this.fragment;
  return t11 ? "#" + t11 : "";
}, setHash: function(t11) {
  (t11 = vr(t11)) != "" ? (Ti(t11, 0) == "#" && (t11 = qa(t11, 1)), this.fragment = "", this.parse(t11, Sr)) : this.fragment = null;
}, update: function() {
  this.query = this.searchParams.serialize() || null;
} };
var ea = function(t11) {
  var e = $j(this, yn), n = iG(arguments.length, 1) > 1 ? arguments[1] : void 0, i = rG(e, new Sf(t11, false, n));
  ff || (e.href = i.serialize(), e.origin = i.getOrigin(), e.protocol = i.getProtocol(), e.username = i.getUsername(), e.password = i.getPassword(), e.host = i.getHost(), e.hostname = i.getHostname(), e.port = i.getPort(), e.pathname = i.getPathname(), e.search = i.getSearch(), e.searchParams = i.getSearchParams(), e.hash = i.getHash());
};
var yn = ea.prototype;
var hi = function(t11, e) {
  return { get: function() {
    return zl(this)[t11]();
  }, set: e && function(n) {
    return zl(this)[e](n);
  }, configurable: true, enumerable: true };
};
ff && (ui(yn, "href", hi("serialize", "setHref")), ui(yn, "origin", hi("getOrigin")), ui(yn, "protocol", hi("getProtocol", "setProtocol")), ui(yn, "username", hi("getUsername", "setUsername")), ui(yn, "password", hi("getPassword", "setPassword")), ui(yn, "host", hi("getHost", "setHost")), ui(yn, "hostname", hi("getHostname", "setHostname")), ui(yn, "port", hi("getPort", "setPort")), ui(yn, "pathname", hi("getPathname", "setPathname")), ui(yn, "search", hi("getSearch", "setSearch")), ui(yn, "searchParams", hi("getSearchParams")), ui(yn, "hash", hi("getHash", "setHash"))), Ld(yn, "toJSON", function() {
  return zl(this).serialize();
}, { enumerable: true }), Ld(yn, "toString", function() {
  return zl(this).serialize();
}, { enumerable: true }), La && (e_ = La.createObjectURL, n_ = La.revokeObjectURL, e_ && Ld(ea, "createObjectURL", ZR(e_, La)), n_ && Ld(ea, "revokeObjectURL", ZR(n_, La)));
var e_;
var n_;
nG(ea, "URL"), Qj({ global: true, constructor: true, forced: !Zj, sham: !ff }, { URL: ea });
var IG = xt;
var vG = Se;
var yG = Vu;
var lC = oi;
var AG = rf;
var uC = Dn("URL");
IG({ target: "URL", stat: true, forced: !(AG && vG(function() {
  uC.canParse();
})) }, { canParse: function(t11) {
  var e = yG(arguments.length, 1), n = lC(t11), i = e < 2 || arguments[1] === void 0 ? void 0 : lC(arguments[1]);
  try {
    return !!new uC(n, i);
  } catch {
    return false;
  }
} });
var hC = ae(Gi.URL);
var Ne = { getDisplayMedia: false, getStreamFromExtension: false, supportUnifiedPlan: false, supportMinBitrate: false, supportSetRtpSenderParameters: false, supportDualStream: true, webAudioMediaStreamDest: false, supportReplaceTrack: false, supportWebGL: false, webAudioWithAEC: false, supportRequestFrame: false, supportShareAudio: false, supportDualStreamEncoding: false, supportDataChannel: false, supportPCSetConfiguration: false, supportWebRTCEncodedTransform: false, supportWebRTCInsertableStream: false, supportRequestVideoFrameCallback: false, supportWebCrypto: false };
function ft() {
  return Ne;
}
function jO() {
  return "setSinkId" in HTMLAudioElement.prototype && (!v("RESTRICTION_SET_PLAYBACK_DEVICE") || (oo() || _O()) && !lf());
}
function pC() {
  return !Ne.supportUnifiedPlan || v("CHROME_FORCE_PLAN_B") && ho();
}
var ke = function(t11) {
  return t11.IOS_15_16_INTERRUPTION_START = "ios15_16-interruption-start", t11.IOS_15_16_INTERRUPTION_END = "ios15_16-interruption-end", t11.IOS_INTERRUPTION_START = "ios-interruption-start", t11.IOS_INTERRUPTION_END = "ios-interruption-end", t11.STATE_CHANGE = "state-change", t11;
}({});
function gs(t11, e, n) {
  return { sampleRate: t11, stereo: e, bitrate: n };
}
function _t(t11, e, n, i, r) {
  return { width: t11, height: e, frameRate: n, bitrateMin: i, bitrateMax: r };
}
function pi(t11, e, n, i, r) {
  return { width: { max: t11 }, height: { max: e }, frameRate: n, bitrateMin: i, bitrateMax: r };
}
function i_(t11, e) {
  return { numSpatialLayers: t11, numTemporalLayers: e };
}
var bG = { "90p": _t(160, 90), "90p_1": _t(160, 90), "120p": _t(160, 120, 15, 30, 65), "120p_1": _t(160, 120, 15, 30, 65), "120p_3": _t(120, 120, 15, 30, 50), "120p_4": _t(212, 120), "180p": _t(320, 180, 15, 30, 140), "180p_1": _t(320, 180, 15, 30, 140), "180p_3": _t(180, 180, 15, 30, 100), "180p_4": _t(240, 180, 15, 30, 120), "240p": _t(320, 240, 15, 40, 200), "240p_1": _t(320, 240, 15, 40, 200), "240p_3": _t(240, 240, 15, 40, 140), "240p_4": _t(424, 240, 15, 40, 220), "360p": _t(640, 360, 15, 80, 400), "360p_1": _t(640, 360, 15, 80, 400), "360p_3": _t(360, 360, 15, 80, 260), "360p_4": _t(640, 360, 30, 80, 600), "360p_6": _t(360, 360, 30, 80, 400), "360p_7": _t(480, 360, 15, 80, 320), "360p_8": _t(480, 360, 30, 80, 490), "360p_9": _t(640, 360, 15, 80, 800), "360p_10": _t(640, 360, 24, 80, 800), "360p_11": _t(640, 360, 24, 80, 1e3), "480p": _t(640, 480, 15, 100, 500), "480p_1": _t(640, 480, 15, 100, 500), "480p_2": _t(640, 480, 30, 100, 1e3), "480p_3": _t(480, 480, 15, 100, 400), "480p_4": _t(640, 480, 30, 100, 750), "480p_6": _t(480, 480, 30, 100, 600), "480p_8": _t(848, 480, 15, 100, 610), "480p_9": _t(848, 480, 30, 100, 930), "480p_10": _t(640, 480, 10, 100, 400), "720p": _t(1280, 720, 15, 120, 1130), "720p_auto": _t(1280, 720, 30, 900, 3e3), "720p_1": _t(1280, 720, 15, 120, 1130), "720p_2": _t(1280, 720, 30, 120, 2e3), "720p_3": _t(1280, 720, 30, 120, 1710), "720p_5": _t(960, 720, 15, 120, 910), "720p_6": _t(960, 720, 30, 120, 1380), "1080p": _t(1920, 1080, 15, 120, 2080), "1080p_1": _t(1920, 1080, 15, 120, 2080), "1080p_2": _t(1920, 1080, 30, 120, 3e3), "1080p_3": _t(1920, 1080, 30, 120, 3150), "1080p_5": _t(1920, 1080, 60, 120, 4780), "1440p": _t(2560, 1440, 30, 120, 4850), "1440p_1": _t(2560, 1440, 30, 120, 4850), "1440p_2": _t(2560, 1440, 60, 120, 7350), "4k": _t(3840, 2160, 30, 120, 8910), "4k_1": _t(3840, 2160, 30, 120, 8910), "4k_3": _t(3840, 2160, 60, 120, 13500) };
var wG = { "480p": pi(640, 480, 5), "480p_1": pi(640, 480, 5), "480p_2": pi(640, 480, 30), "480p_3": pi(640, 480, 15), "720p": pi(1280, 720, 5), "720p_auto": _t(1280, 720, 30, 900, 3e3), "720p_1": pi(1280, 720, 5), "720p_2": pi(1280, 720, 30), "720p_3": pi(1280, 720, 15), "1080p": pi(1920, 1080, 5), "1080p_1": pi(1920, 1080, 5), "1080p_2": pi(1920, 1080, 30), "1080p_3": pi(1920, 1080, 15) };
var OG = { "1SL1TL": i_(1, 1), "3SL3TL": i_(3, 3), "2SL3TL": i_(2, 3) };
function cr(t11) {
  return t11 || (t11 = "480p_1"), typeof t11 == "string" ? Object.assign({}, bG[t11]) : t11;
}
function r_(t11) {
  return typeof t11 == "string" ? Object.assign({}, wG[t11]) : t11;
}
function Fd(t11) {
  return typeof t11 == "string" ? Object.assign({}, OG[t11]) : t11;
}
var NG = { speech_low_quality: gs(16e3, false), speech_standard: gs(32e3, false, 18), music_standard: gs(48e3, false), standard_stereo: gs(48e3, true, 56), high_quality: gs(48e3, false, 128), high_quality_stereo: gs(48e3, true, 192) };
function Jl(t11) {
  return typeof t11 == "string" ? Object.assign({}, NG[t11]) : t11;
}
var As = [];
function _C(t11) {
  return Ce(t11, "mediaSource", ["screen", "window", "application"]), true;
}
var H = function(t11) {
  return t11.NEED_RENEGOTIATE = "@need_renegotiate", t11.NEED_REPLACE_TRACK = "@need_replace_track", t11.NEED_REPLACE_MIXING_TRACK = "@need_replace_mixing_track", t11.NEED_CLOSE = "@need_close", t11.NEED_ENABLE_TRACK = "@need_enable_track", t11.NEED_DISABLE_TRACK = "@need_disable_track", t11.NEED_SESSION_ID = "@need_sid", t11.SET_OPTIMIZATION_MODE = "@set_optimization_mode", t11.GET_STATS = "@get_stats", t11.GET_RTC_STATS = "@get_rtc_stats", t11.GET_LOW_VIDEO_TRACK = "@get_low_video_track", t11.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", t11.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", t11.NEED_UPDATE_VIDEO_SEND_PARAMETERS = "@need_update_video_send_parameters", t11.NEED_MUTE_TRACK = "@need_mute_track", t11.NEED_UNMUTE_TRACK = "@need_unmute_track", t11;
}({});
var Gt = function(t11) {
  return t11.SCREEN_TRACK = "screen_track", t11.CUSTOM_TRACK = "custome_track", t11.LOW_STREAM = "low_stream", t11;
}({});
var na = function(t11) {
  return t11[t11.HIGH_STREAM = 0] = "HIGH_STREAM", t11[t11.LOW_STREAM = 1] = "LOW_STREAM", t11;
}({});
var DG = function(t11) {
  return t11[t11.HIGH_STREAM = 0] = "HIGH_STREAM", t11[t11.LOW_STREAM = 1] = "LOW_STREAM", t11;
}({});
var PG = function(t11) {
  return t11[t11.DISABLE = 0] = "DISABLE", t11[t11.LOW_STREAM = 1] = "LOW_STREAM", t11[t11.AUDIO_ONLY = 2] = "AUDIO_ONLY", t11;
}({});
var Ko = function(t11) {
  return t11.TRANSCEIVER_UPDATED = "transceiver-updated", t11.SEI_TO_SEND = "sei-to-send", t11.SEI_RECEIVED = "sei-received", t11.TRACK_UPDATED = "track-updated", t11;
}({});
var ma = function(t11) {
  return t11.SOURCE_STATE_CHANGE = "source-state-change", t11.TRACK_ENDED = "track-ended", t11.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", t11.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", t11.CLOSED = "closed", t11;
}({});
var Ws = function(t11) {
  return t11.FIRST_FRAME_DECODED = "first-frame-decoded", t11.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", t11.VIDEO_STATE_CHANGED = "video-state-changed", t11;
}({});
var fa = function(t11) {
  return t11.AUDIO = "audio", t11.VIDEO = "video", t11.DATA = "data", t11;
}({});
var jn = function(t11) {
  return t11.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", t11.RECEIVE_TRACK_BUFFER = "receive_track_buffer", t11.ON_AUDIO_BUFFER = "on_audio_buffer", t11.UPDATE_SOURCE = "update_source", t11;
}({});
(function(t11) {
  t11.UPDATE_TRACK_SOURCE = "update-track-source";
})({});
var KE = { sendVolumeLevel: 0, sendBitrate: 0, sendBytes: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, currentPacketLossRate: 0 };
var YE = { sendBytes: 0, sendBitrate: 0, sendPackets: 0, sendPacketsLost: 0, sendJitterMs: 0, sendRttMs: 0, sendResolutionHeight: 0, sendResolutionWidth: 0, captureResolutionHeight: 0, captureResolutionWidth: 0, targetSendBitrate: 0, totalDuration: 0, totalFreezeTime: 0, currentPacketLossRate: 0 };
var GO = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveLevel: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receivePacketsDiscarded: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
var kG = { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 };
var WO = { transportDelay: 0, end2EndDelay: 0, receiveBitrate: 0, receiveBytes: 0, receiveDelay: 0, receivePackets: 0, receivePacketsLost: 0, receiveResolutionHeight: 0, receiveResolutionWidth: 0, totalDuration: 0, totalFreezeTime: 0, freezeRate: 0, packetLossRate: 0, currentPacketLossRate: 0, publishDuration: -1 };
var un = function(t11) {
  return t11.ON_TRACK = "on_track", t11.ON_NODE = "on_node", t11;
}({});
var Wn = function(t11) {
  return t11.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", t11.REQUEST_CONSTRAINTS = "request_constraints", t11;
}({});
var Ua = function(t11) {
  return t11.IDLE = "IDLE", t11.INITING = "INITING", t11.INITEND = "INITEND", t11;
}({});
var Bo = function(t11) {
  return t11.STATE_CHANGE = "state_change", t11.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", t11.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", t11.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged", t11;
}({});
var nn = function(t11) {
  return t11.NONE = "none", t11.INIT = "init", t11.CANPLAY = "canplay", t11.PLAYING = "playing", t11.PAUSED = "paused", t11.SUSPEND = "suspend", t11.STALLED = "stalled", t11.WAITING = "waiting", t11.ERROR = "error", t11.DESTROYED = "destroyed", t11.ABORT = "abort", t11.ENDED = "ended", t11.EMPTIED = "emptied", t11.LOADEDDATA = "loadeddata", t11;
}({});
var zi = function(t11) {
  return t11[t11.VideoStateStopped = 0] = "VideoStateStopped", t11[t11.VideoStateStarting = 1] = "VideoStateStarting", t11[t11.VideoStateDecoding = 2] = "VideoStateDecoding", t11[t11.VideoStateFrozen = 3] = "VideoStateFrozen", t11;
}({});
var o_ = { uninit: 100, none: 110, init: 120, loadeddata: 130, canplay: 200, playing: 210, paused: 220, suspend: 300, stalled: 310, waiting: 320, error: 330, destroyed: 340, abort: 350, ended: 360, emptied: 370 };
var Cl = function(t11) {
  return t11.OPEN = "open", t11.MESSAGE = "message", t11.CLOSE = "close", t11.CLOSING = "closing", t11.ERROR = "error", t11;
}({});
function Et(t11, e, n, i, r) {
  var o, s, a = {};
  return Object.keys(i).forEach(function(c) {
    a[c] = i[c];
  }), a.enumerable = !!a.enumerable, a.configurable = !!a.configurable, ("value" in a || a.initializer) && (a.writable = true), a = ji(o = mj(s = n.slice()).call(s)).call(o, function(c, d) {
    return d(t11, e, c) || c;
  }, a), r && a.initializer !== void 0 && (a.value = a.initializer ? a.initializer.call(r) : void 0, a.initializer = void 0), a.initializer === void 0 && (Object.defineProperty(t11, e, a), a = null), a;
}
function P(t11, e, n) {
  return (e = function(i) {
    var r = function(o, s) {
      if (typeof o != "object" || !o) return o;
      var a = o[Symbol.toPrimitive];
      if (a !== void 0) {
        var c = a.call(o, "string");
        if (typeof c != "object") return c;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(o);
    }(i);
    return typeof r == "symbol" ? r : r + "";
  }(e)) in t11 ? Object.defineProperty(t11, e, { value: n, enumerable: true, configurable: true, writable: true }) : t11[e] = n, t11;
}
function EC(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Kt(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? EC(Object(n), true).forEach(function(i) {
      P(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : EC(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var Xl = class extends Xt {
  set _mediaStreamTrack(e) {
    e !== this.mediaStreamTrack && (this.safeEmit(Ko.TRACK_UPDATED, e), this.mediaStreamTrack = e);
  }
  get _mediaStreamTrack() {
    return this.mediaStreamTrack;
  }
  constructor(e, n) {
    super(), P(this, "trackMediaType", void 0), P(this, "_ID", void 0), P(this, "_rtpTransceiver", void 0), P(this, "_lowRtpTransceiver", void 0), P(this, "_hints", []), P(this, "_isClosed", false), P(this, "_originMediaStreamTrack", void 0), P(this, "mediaStreamTrack", void 0), P(this, "_external", {}), this._ID = n || Ut(8, "track-"), this._originMediaStreamTrack = e, this.mediaStreamTrack = e, function(i) {
      W(As).call(As, i) || As.push(i);
    }(this);
  }
  toString() {
    return this._ID;
  }
  getTrackId() {
    return this._ID;
  }
  getMediaStreamTrack(e) {
    return e || po(() => {
      var n;
      X.reportApiInvoke(null, { name: Te.GET_MEDIA_STREAM_TRACK, options: [], tag: Zt.TRACER }).onSuccess(((n = this._mediaStreamTrack) === null || n === void 0 ? void 0 : n.label) || "");
    }, this.mediaStreamTrack.id || this.getTrackId()), this._mediaStreamTrack;
  }
  getRTCRtpTransceiver(e) {
    return e === na.LOW_STREAM ? this._lowRtpTransceiver : this._rtpTransceiver;
  }
  getMediaStreamTrackSettings() {
    return this.getMediaStreamTrack(true).getSettings();
  }
  close() {
    this._isClosed = true, this._lowRtpTransceiver = void 0, this._rtpTransceiver = void 0, function(e) {
      let n = As.indexOf(e);
      n !== -1 && As.splice(n, 1);
    }(this), this.emit(ma.CLOSED), this.removeAllListeners(Ko.SEI_RECEIVED);
  }
  _updateRtpTransceiver(e, n) {
    if (n === na.LOW_STREAM) {
      if (this._lowRtpTransceiver === e) return;
      this._lowRtpTransceiver = e;
    } else {
      if (this._rtpTransceiver === e) return;
      this._rtpTransceiver = e;
    }
    this.emit(Ko.TRANSCEIVER_UPDATED, e, n);
  }
};
var no = class extends Xl {
  get isExternalTrack() {
    return this._isExternalTrack;
  }
  get muted() {
    return this._muted;
  }
  get enabled() {
    return this._enabled;
  }
  get processorContext() {
    return this._processorContext;
  }
  constructor(e, n) {
    super(e, n), P(this, "_enabled", true), P(this, "_muted", false), P(this, "_isExternalTrack", false), P(this, "_isClosed", false), P(this, "_enabledMutex", void 0), P(this, "processor", void 0), P(this, "_processorContext", void 0), P(this, "_handleTrackEnded", () => {
      this.onTrackEnded();
    }), this._enabledMutex = new ze("".concat(this.getTrackId())), e.addEventListener("ended", this._handleTrackEnded);
  }
  getTrackLabel() {
    var e, n;
    return (e = (n = this._originMediaStreamTrack) === null || n === void 0 ? void 0 : n.label) !== null && e !== void 0 ? e : "";
  }
  close() {
    this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, _.debug("[".concat(this.getTrackId(), "] close")), this.emit(H.NEED_CLOSE), super.close());
  }
  async _updateOriginMediaStreamTrack(e, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
    this._isExternalTrack = i, e !== this._originMediaStreamTrack && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), n && this._originMediaStreamTrack.stop()), e.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e, this._muted && (this._originMediaStreamTrack.enabled = false), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await kt(this, H.NEED_REPLACE_TRACK, this), this.processor && this._processorContext && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this._processorContext }));
  }
  _getDefaultPlayerConfig() {
    return {};
  }
  onTrackEnded() {
    _.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(ma.TRACK_ENDED);
  }
  stateCheck(e, n) {
    if (_.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e, ": ").concat(n, "]")), Nr(n, e), this._enabled && this._muted && e === "enabled" && n === false) throw new N(R.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print("error", _);
    if (!this._enabled && !this._muted && e === "muted" && n === true) throw new N(R.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print("error", _);
  }
  getProcessorStats() {
    return this._processorContext && this._processorContext.gatherStats() || [];
  }
  getProcessorUsage() {
    return this._processorContext ? this._processorContext.gatherUsage() : j.resolve([]);
  }
};
var mC = window.AudioContext || window.webkitAudioContext;
var Mn = null;
var wt = new class extends Xt {
  constructor() {
    super(...arguments), P(this, "prevState", void 0), P(this, "curState", void 0), P(this, "currentTime", void 0), P(this, "currentTimeStuckAt", void 0), P(this, "interruptDetectorTrack", void 0), P(this, "onLocalAudioTrackMute", () => {
      _.info("ios15-interruption-start"), this.emit(ke.IOS_15_16_INTERRUPTION_START);
    }), P(this, "onLocalAudioTrackUnmute", async () => {
      _.info("ios15-interruption-end"), this.curState !== "running" || this.duringInterruption ? _.info("ios15-interruption-end-canceled") : (Mn && await Mn.suspend(), this.emit(ke.IOS_15_16_INTERRUPTION_END));
    });
  }
  get duringInterruption() {
    return this.prevState === "running" && this.curState === "interrupted";
  }
  bindInterruptDetectorTrack(t11) {
    _.debug("webaudio bindInterruptDetectorTrack ".concat(t11.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = t11, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);
  }
  unbindInterruptDetectorTrack(t11) {
    _.debug("webaudio unbindInterruptDetectorTrack ".concat(t11.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === t11 && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);
  }
}();
function ga() {
  if (!Mn) {
    if (function() {
      if (!mC) return void _.error("your browser is not support web audio");
      _.info("create audio context");
      let t11 = Kt({}, v("WEBAUDIO_INIT_OPTIONS"));
      _.debug("audio context init option:", JSON.stringify(t11)), Mn = new mC(t11), wt.curState = Mn.state, Mn.onstatechange = () => {
        wt.prevState = wt.curState, wt.curState = Mn ? Mn.state : void 0;
        let { prevState: e, curState: n } = wt, i = n === "running", r = n === "interrupted", o = e === "running", s = e === "suspended", a = e === "interrupted", c = mt().osVersion;
        (ln() || vi()) && o && r && (_.info("ios".concat(c, "-interruption-start")), wt.emit(ke.IOS_INTERRUPTION_START)), (ln() || vi()) && (s || a) && i && (_.info("ios".concat(c, "-interruption-end")), wt.emit(ke.IOS_INTERRUPTION_END)), e !== n && wt.emit(ke.STATE_CHANGE, n, e);
      }, setInterval(() => {
        var e;
        let n = (e = Mn) === null || e === void 0 ? void 0 : e.currentTime;
        wt.currentTime !== n ? (wt.currentTimeStuckAt && (_.debug("AudioContext current time resume at ".concat(n)), wt.currentTimeStuckAt = void 0), wt.currentTime = n) : (n !== wt.currentTimeStuckAt && (X.reportApiInvoke(null, { name: "WEB_AUDIO_CURRENT_TIME_STUCK", options: { currentTime: n }, tag: Zt.TRACER }).onSuccess(), _.warning("AudioContext current time stuck at ".concat(n))), wt.currentTimeStuckAt = n);
      }, 5e3), async function(e) {
        let n = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"], i, r = false, o = false, s = false;
        function a(E) {
          e.state === "running" ? c(false) : ln() || vi() ? e.state === "suspended" && (c(true), E && e.resume().then(d, d)) : e.state !== "closed" && (c(true), E && e.resume().then(d, d));
        }
        function c(E) {
          if (r !== E) {
            r = E;
            for (let f = 0, S = n; f < S.length; f += 1) {
              let C = S[f];
              E ? window.addEventListener(C, l, { capture: true, passive: true }) : window.removeEventListener(C, l, { capture: true, passive: true });
            }
          }
        }
        function d() {
          a(false);
        }
        function l() {
          a(true);
        }
        function u(E) {
          if (!s) if (i.paused) if (E) {
            let f;
            h(false), s = true;
            try {
              f = i.play(), f ? f.then(p, p) : (i.addEventListener("playing", p), i.addEventListener("abort", p), i.addEventListener("error", p));
            } catch {
              p();
            }
          } else h(true);
          else h(false);
        }
        function h(E) {
          if (o !== E) {
            o = E;
            for (let f = 0, S = n; f < S.length; f++) {
              let C = S[f];
              E ? window.addEventListener(C, g, { capture: true, passive: true }) : window.removeEventListener(C, g, { capture: true, passive: true });
            }
          }
        }
        function p() {
          i.removeEventListener("playing", p), i.removeEventListener("abort", p), i.removeEventListener("error", p), s = false, u(false);
        }
        function g() {
          u(true);
        }
        if (ln()) {
          let E = e.createMediaStreamDestination(), f = document.createElement("div");
          f.innerHTML = "<audio x-webkit-airplay='deny'></audio>", i = f.children.item(0), i.controls = false, i.disableRemotePlayback = true, i.preload = "auto", i.srcObject = E.stream, u(true);
        }
        wt.on(ke.STATE_CHANGE, function() {
          a(true);
        }), a(false);
      }(Mn);
    }(), !Mn) throw new N(R.NOT_SUPPORTED, "can not create audio context");
    return Mn;
  }
  return Mn;
}
function No(t11) {
  if (function() {
    if (s_ !== null) return s_;
    let i = ga(), r = i.createBufferSource(), o = i.createGain(), s = i.createGain();
    r.connect(o), r.connect(s), r.disconnect(o);
    let a = false;
    try {
      r.disconnect(o);
    } catch {
      a = true;
    }
    return r.disconnect(), s_ = a, a;
  }()) return;
  let e = t11.connect, n = t11.disconnect;
  t11.connect = (i, r, o) => {
    var s;
    return t11._inputNodes || (t11._inputNodes = []), W(s = t11._inputNodes).call(s, i) || (i instanceof AudioNode ? (t11._inputNodes.push(i), e.call(t11, i, r, o)) : e.call(t11, i, r)), t11;
  }, t11.disconnect = (i, r, o) => {
    n.call(t11), i ? Wl(t11._inputNodes, i) : t11._inputNodes = [];
    for (let s of t11._inputNodes) e.call(t11, s);
  };
}
var s_ = null;
function Rf(t11, e) {
  let n = false, i = 1 / e;
  if (v("DISABLE_WEBAUDIO")) {
    let r = window.setInterval(() => {
      n ? window.clearInterval(r) : t11(performance.now() / 1e3);
    }, 1e3 * i);
  } else {
    let r = ga(), o = r.createGain();
    o.gain.value = 0, o.connect(r.destination);
    let s = () => {
      if (n) return void (o = null);
      let a = r.createOscillator();
      a.onended = s, a.connect(o), a.start(0), a.stop(r.currentTime + i), t11(r.currentTime);
    };
    s();
  }
  return () => {
    n = true;
  };
}
var Ql = class {
  constructor() {
    P(this, "context", void 0), P(this, "analyserNode", void 0), P(this, "sourceNode", void 0), this.context = ga(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4;
  }
  updateSource(e) {
    if (e !== this.sourceNode) {
      if (this.sourceNode) try {
        this.sourceNode.disconnect(this.analyserNode);
      } catch {
      }
      this.sourceNode = e, e == null ? void 0 : e.connect(this.analyserNode);
    }
  }
  getVolumeLevel() {
    if (!this.sourceNode || (!this.context || ln() || vi() || this.context.state !== "running" && this.context.resume(), !this.analyserNode)) return 0;
    let e = new Float32Array(this.analyserNode.fftSize);
    if (this.analyserNode.getFloatTimeDomainData) this.analyserNode.getFloatTimeDomainData(e);
    else {
      let i = new Uint8Array(this.analyserNode.fftSize);
      this.analyserNode.getByteTimeDomainData(i);
      for (let r = 0; r < e.length; ++r) e[r] = i[r] / 128 - 1;
    }
    let n = ji(e).call(e, (i, r) => i + r * r, 0) / e.length;
    return Math.max(10 * Math.log10(n) + 100, 0) / 100;
  }
  getAnalyserNode() {
    return this.analyserNode;
  }
  rebuildAnalyser() {
    try {
      var e, n;
      (e = this.sourceNode) === null || e === void 0 || e.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = 0.4, (n = this.sourceNode) === null || n === void 0 || n.connect(this.analyserNode);
    } catch {
      _.warning("rebuild analyser node failed.");
    }
  }
  destroy() {
    this.updateSource(void 0);
  }
};
var Zl = class extends Xt {
  get processSourceNode() {
    return this.sourceNode;
  }
  set processedNode(e) {
    var n;
    if (!this.isDestroyed && this._processedNode !== e) {
      try {
        var i;
        (i = this.sourceNode) === null || i === void 0 || i.disconnect(this.outputNode);
      } catch {
      }
      (n = this._processedNode) === null || n === void 0 || n.disconnect(), this._processedNode = e, this.connect();
    }
  }
  get processedNode() {
    return this._processedNode;
  }
  constructor() {
    super(), P(this, "outputNode", void 0), P(this, "outputTrack", void 0), P(this, "isPlayed", false), P(this, "sourceNode", void 0), P(this, "context", void 0), P(this, "audioBufferNode", void 0), P(this, "destNode", void 0), P(this, "audioOutputLevel", 0), P(this, "volumeLevelAnalyser", void 0), P(this, "_processedNode", void 0), P(this, "playNode", void 0), P(this, "isDestroyed", false), P(this, "onNoAudioInput", void 0), P(this, "isNoAudioInput", false), P(this, "_noAudioInputCount", 0), this.context = ga(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), No(this.outputNode), this.volumeLevelAnalyser = new Ql();
  }
  startGetAudioBuffer(e) {
    this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = (n) => {
      this.emit(jn.ON_AUDIO_BUFFER, function(i) {
        for (let r = 0; r < i.outputBuffer.numberOfChannels; r += 1) {
          let o = i.outputBuffer.getChannelData(r);
          for (let s = 0; s < o.length; s += 1) o[s] = 0;
        }
        return i.inputBuffer;
      }(n));
    });
  }
  stopGetAudioBuffer() {
    this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);
  }
  createOutputTrack() {
    if (!ft().webAudioMediaStreamDest) throw new N(R.NOT_SUPPORTED, "your browser is not support audio processor");
    return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;
  }
  play(e) {
    this.context.state !== "running" && qu(() => {
      wt.emit("autoplay-failed");
    }), this.isPlayed = true, this.playNode = e || this.context.destination, this.outputNode.connect(this.playNode);
  }
  stop() {
    if (this.isPlayed) try {
      this.outputNode.disconnect(this.playNode);
    } catch {
    }
    this.isPlayed = false;
  }
  getAccurateVolumeLevel() {
    return this.volumeLevelAnalyser.getVolumeLevel();
  }
  async checkHasAudioInput() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (e > 5) return this.isNoAudioInput = true, this.onNoAudioInput && this.onNoAudioInput(), false;
    ln() || vi() ? this.context.state === "suspended" && this.context.resume() : this.context.state !== "running" && this.context.resume();
    let n = this.volumeLevelAnalyser.getAnalyserNode(), i;
    n.getFloatTimeDomainData ? (i = new Float32Array(n.fftSize), n.getFloatTimeDomainData(i)) : (i = new Uint8Array(n.fftSize), n.getByteTimeDomainData(i));
    let r = false;
    for (let o = 0; o < i.length; o++) i[o] !== 0 && (r = true);
    return r ? (this.isNoAudioInput = false, true) : (await Me(200), await this.checkHasAudioInput(e ? e + 1 : 1) && r);
  }
  getAudioVolume() {
    return this.outputNode.gain.value;
  }
  setVolume(e) {
    this.outputNode.gain.setValueAtTime(e, this.context.currentTime);
  }
  destroy() {
    this.disconnect(), this.stop(), this.isDestroyed = true, this.onNoAudioInput = void 0;
  }
  disconnect() {
    var e, n;
    (e = this.processedNode) === null || e === void 0 || e.disconnect(), (n = this.sourceNode) === null || n === void 0 || n.disconnect(), this.outputNode && this.outputNode.disconnect();
  }
  connect() {
    var e;
    this.processedNode ? (e = this.processedNode) === null || e === void 0 || e.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode), this.volumeLevelAnalyser.updateSource(this.outputNode);
  }
};
var $l = class extends Zl {
  get isFreeze() {
    return false;
  }
  constructor(e, n, i) {
    var r;
    if (super(), P(this, "sourceNode", void 0), P(this, "track", void 0), P(this, "clonedTrack", void 0), P(this, "audioElement", void 0), P(this, "isCurrentTrackCloned", false), P(this, "isRemoteTrack", false), P(this, "originVolumeLevelAnalyser", void 0), P(this, "rebuildWebAudio", async () => {
      if (_.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed) return document.body.removeEventListener("click", this.rebuildWebAudio, true), void _.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel());
      this.context.resume().then(() => _.info("resume success")), _.debug("rebuild web audio because of ios 12 bugs"), this.disconnect();
      let a = this.track;
      this.track = this.track.clone(), this.isCurrentTrackCloned ? a.stop() : this.isCurrentTrackCloned = true;
      let c = new MediaStream([this.track]);
      this.sourceNode = this.context.createMediaStreamSource(c), No(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();
      let d = this.outputNode.gain.value;
      this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(d, this.context.currentTime), No(this.outputNode), this.emit(jn.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = c, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();
    }), e.kind !== "audio") throw new N(R.UNEXPECTED_ERROR);
    this.track = e;
    let o = new MediaStream([this.track]);
    if (this.isRemoteTrack = !!n, this.sourceNode = this.context.createMediaStreamSource(o), No(this.sourceNode), i) {
      let a = i.clone();
      a.enabled = true, this.clonedTrack = a, _.debug("create an unmuted track ".concat(a.id, " from the original track ").concat(i.id, " to get the volume"));
      let c = this.context.createMediaStreamSource(new MediaStream([a]));
      No(c), this.originVolumeLevelAnalyser = new Ql(), this.originVolumeLevelAnalyser.updateSource(c);
    }
    this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = o;
    let s = mt();
    n && s.os === ye.IOS && Number((r = s.osVersion) === null || r === void 0 ? void 0 : r.split(".")[0]) < 15 && (wt.on(ke.STATE_CHANGE, () => {
      this.context.state === "suspended" ? document.body.addEventListener("click", this.rebuildWebAudio, true) : this.context.state === "running" && this.rebuildWebAudio();
    }), this.checkHasAudioInput().then((a) => {
      a || document.body.addEventListener("click", this.rebuildWebAudio, true);
    }));
  }
  updateTrack(e) {
    this.sourceNode.disconnect(), this.track = e, this.isCurrentTrackCloned = false;
    let n = new MediaStream([e]);
    this.sourceNode = this.context.createMediaStreamSource(n), No(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(jn.UPDATE_SOURCE), this.audioElement.srcObject = n;
  }
  destroy() {
    var e;
    this.audioElement.srcObject = null, this.audioElement.remove(), wt.off("state-change", this.rebuildWebAudio), (e = this.originVolumeLevelAnalyser) === null || e === void 0 || e.destroy(), this.clonedTrack = void 0, super.destroy();
  }
  createMediaStreamSourceNode(e) {
    return this.context.createMediaStreamSource(new MediaStream([e]));
  }
  updateOriginTrack(e) {
    let n = e.clone();
    n.enabled = true, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = n), _.debug("create an unmuted track ".concat(n.id, " from the original track ").concat(e.id, " to get the volume"));
    let i = this.context.createMediaStreamSource(new MediaStream([n]));
    No(i), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i);
  }
  getOriginVolumeLevel() {
    return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();
  }
};
async function HO(t11, e, n) {
  let i = (o, s) => o ? typeof o != "number" ? o.max || o.exact || o.ideal || o.min || s : o : s, r = { audio: !!n && { mandatory: { chromeMediaSource: "desktop" } }, video: { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t11, maxHeight: i(e.height, 1080), maxWidth: i(e.width, 1920) } } };
  return e.frameRate && typeof e.frameRate != "number" ? (r.video.mandatory.maxFrameRate = e.frameRate.max, r.video.mandatory.minFrameRate = e.frameRate.min) : typeof e.frameRate == "number" && (r.video.mandatory.maxFrameRate = e.frameRate), await navigator.mediaDevices.getUserMedia(r);
}
async function LG(t11, e) {
  let n = await KO(t11.mediaSource), { sourceId: i, audio: r } = await function(o) {
    let s = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    return new j((a, c) => {
      let d = document.createElement("div");
      d.innerText = "share screen", d.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
      let l = document.createElement("div");
      l.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
      let u = document.createElement("div");
      u.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", u.setAttribute("style", "height: 12%;");
      let h = document.createElement("div");
      h.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
      let p = document.createElement("div");
      p.setAttribute("style", "display: flex; justify-content: space-between; padding: 16px 0;");
      let g = document.createElement("button");
      g.innerHTML = "cancel", g.setAttribute("style", "width: 85px;"), g.onclick = () => {
        document.body.removeChild(S);
        let C = new Error("NotAllowedError");
        C.name = "NotAllowedError", c(C);
      };
      let E = s, f = document.createElement("div");
      if (s) {
        let C = document.createElement("input");
        C.setAttribute("type", "checkbox");
        let A = document.createElement("span");
        C.setAttribute("style", "margin-right: 6px;"), A.innerText = "Share audio", C.checked = E, C.onchange = () => {
          E = C.checked;
        }, f.appendChild(C), f.appendChild(A);
      }
      p.appendChild(f), p.appendChild(g), l.appendChild(u), l.appendChild(h), l.appendChild(p);
      let S = document.createElement("div");
      S.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), S.appendChild(d), S.appendChild(l), document.body.appendChild(S), o.map((C) => {
        if (C.id) {
          let A = document.createElement("div");
          A.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
          let b = C.thumbnail;
          try {
            let { width: w } = b.getSize();
            w > 1920 && (b = b.resize({ width: 1920 }));
          } catch (w) {
            throw w && w.message.startsWith("Illegal invocation") && console.error("Operate thumbnail error, please try to set contextIsolation: false. (https://github.com/electron/electron/issues/34953)"), w;
          }
          A.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + b.toDataURL() + ' /></div><span style="	height: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + C.name.replace(/[\u00A0-\u9999<>\&]/g, function(w) {
            return "&#" + w.charCodeAt(0) + ";";
          }) + "</span>", A.onclick = () => {
            document.body.removeChild(S), a({ sourceId: C.id, audio: E });
          }, h.appendChild(A);
        }
      });
    });
  }(n, e);
  return await HO(i, t11, r);
}
async function KO(t11) {
  let e = ["window", "screen"];
  t11 !== "application" && t11 !== "window" || (e = ["window"]), t11 === "screen" && (e = ["screen"]);
  let n = IO();
  if (!n) throw console.error("failed to fetch electron, please mount it to window"), new N(R.ELECTRON_IS_NULL);
  let i = null;
  try {
    var r;
    i = ((r = n.desktopCapturer) === null || r === void 0 ? void 0 : r.getSources({ types: e })) || n.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", { types: e });
  } catch {
    i = null;
  }
  i && i.then || (i = new j((o, s) => {
    n.desktopCapturer.getSources({ types: e }, (a, c) => {
      a ? s(a) : o(c);
    });
  }));
  try {
    return await i;
  } catch (o) {
    throw new N(R.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, o.toString());
  }
}
var qE = new ze("safari");
var YO = false;
var qO = false;
async function Fn(t11, e) {
  let n = 0, i = null;
  for (; n < 2; ) try {
    i = await MG(t11, e, n > 0);
    break;
  } catch (r) {
    if (r instanceof N) throw _.error("[".concat(e, "] ").concat(r.toString())), r;
    let o = Il(r.name || r.code || r, r.message);
    if (o.code === R.MEDIA_OPTION_INVALID) {
      _.debug("[".concat(e, "] detect media option invalid, retry")), n += 1, await Me(500);
      continue;
    }
    throw _.error("[".concat(e, "] ").concat(o.toString())), o;
  }
  if (!i) throw new N(R.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
  return i;
}
async function MG(t11, e, n) {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new N(R.NOT_SUPPORTED, "can not find getUserMedia");
  n && (t11.video && (delete t11.video.width, delete t11.video.height), t11.screen && (delete t11.screen.width, delete t11.screen.height));
  let i = ft(), r = new MediaStream();
  if (t11.audioSource && r.addTrack(t11.audioSource), t11.videoSource && r.addTrack(t11.videoSource), !t11.audio && !t11.video && !t11.screen) return _.debug("Using Video Source/ Audio Source"), r;
  if (t11.screen) if (IO()) t11.screen.sourceId ? Ts(r, await HO(t11.screen.sourceId, t11.screen, t11.screenAudio)) : Ts(r, await LG(t11.screen, t11.screenAudio));
  else if (oo() && t11.screen.extensionId && t11.screen.mandatory) {
    if (!i.getStreamFromExtension) throw new N(R.NOT_SUPPORTED, "This browser does not support screen sharing");
    _.debug("[".concat(e, '] Screen access on chrome stable, looking for extension"'));
    let h = await (s = t11.screen.extensionId, a = e, new j((p, g) => {
      try {
        chrome.runtime.sendMessage(s, { getStream: true }, (E) => {
          if (!E || !E.streamId) return _.error("[".concat(a, "] No response from Chrome Plugin. Plugin not installed properly"), E), void g(new N(R.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
          p(E.streamId);
        });
      } catch (E) {
        _.error("[".concat(a, "] AgoraRTC screensharing plugin is not accessible(").concat(s, ")"), E.toString()), g(new N(R.CHROME_PLUGIN_NOT_INSTALL));
      }
    }));
    t11.screen.mandatory.chromeMediaSourceId = h, Ts(r, await navigator.mediaDevices.getUserMedia({ video: { mandatory: t11.screen.mandatory } }));
  } else if (i.getDisplayMedia) {
    var o;
    t11.screen.mediaSource && _C(t11.screen.mediaSource);
    let h = { width: t11.screen.width, height: t11.screen.height, frameRate: t11.screen.frameRate, displaySurface: (o = t11.screen.displaySurface) !== null && o !== void 0 ? o : t11.screen.mediaSource === "screen" ? "monitor" : t11.screen.mediaSource }, { selfBrowserSurface: p, surfaceSwitching: g, systemAudio: E } = t11.screen, f = { selfBrowserSurface: p, surfaceSwitching: g, systemAudio: E };
    !p && delete f.selfBrowserSurface, !g && delete f.surfaceSwitching, !E && delete f.systemAudio, _.debug("[".concat(e, "] getDisplayMedia:"), JSON.stringify({ video: h, audio: !!t11.screenAudio, controls: f })), Ts(r, await navigator.mediaDevices.getDisplayMedia(Kt({ video: h, audio: !!t11.screenAudio }, f)));
  } else {
    if (!$t()) throw _.error("[".concat(e, "] This browser does not support screenSharing")), new N(R.NOT_SUPPORTED, "This browser does not support screen sharing");
    {
      t11.screen.mediaSource && _C(t11.screen.mediaSource);
      let h = { video: { mediaSource: t11.screen.mediaSource, width: t11.screen.width, height: t11.screen.height, frameRate: t11.screen.frameRate } };
      _.debug("[".concat(e, "] getUserMedia: ").concat(JSON.stringify(h))), Ts(r, await navigator.mediaDevices.getUserMedia(h));
    }
  }
  var s, a;
  if (!t11.video && !t11.audio) return r;
  let c = { video: t11.video, audio: t11.audio }, d = v("MEDIA_DEVICE_CONSTRAINTS");
  if (d) try {
    typeof d == "string" && (d = JSON.parse(d)), c = kE(c, d);
  } catch {
  }
  _.debug("[".concat(e, "] GetUserMedia"), JSON.stringify(c)), mt();
  let l, u = null;
  (je() || ln() || Gl()) && (u = await qE.lock());
  try {
    l = await navigator.mediaDevices.getUserMedia(c);
  } catch (h) {
    throw u && u(), h;
  }
  return c.audio && (YO = true), c.video && (qO = true), Ts(r, l), u && u(), r;
}
function Il(t11, e) {
  switch (t11) {
    case "Starting video failed":
    case "OverconstrainedError":
    case "TrackStartError":
      return new N(R.MEDIA_OPTION_INVALID, "".concat(t11, ": ").concat(e));
    case "NotFoundError":
    case "DevicesNotFoundError":
      return new N(R.DEVICE_NOT_FOUND, "".concat(t11, ": ").concat(e));
    case "NotSupportedError":
      return new N(R.NOT_SUPPORTED, "".concat(t11, ": ").concat(e));
    case "NotReadableError":
      return new N(R.NOT_READABLE, "".concat(t11, ": ").concat(e));
    case "InvalidStateError":
    case "NotAllowedError":
    case "PERMISSION_DENIED":
    case "PermissionDeniedError":
      return new N(R.PERMISSION_DENIED, "".concat(t11, ": ").concat(e));
    case "ConstraintNotSatisfiedError":
      return new N(R.CONSTRAINT_NOT_SATISFIED, "".concat(t11, ": ").concat(e));
    default:
      return _.error("getUserMedia unexpected error", t11), new N(R.UNEXPECTED_ERROR, "".concat(t11, ": ").concat(e));
  }
}
function Ts(t11, e) {
  let n = t11.getVideoTracks()[0], i = t11.getAudioTracks()[0], r = e.getVideoTracks()[0], o = e.getAudioTracks()[0];
  o && (i && t11.removeTrack(i), t11.addTrack(o)), r && (n && t11.removeTrack(n), t11.addTrack(r));
}
var Gn = new class extends Xt {
  get state() {
    return this._state;
  }
  set state(t11) {
    t11 !== this._state && (this.emit(Bo.STATE_CHANGE, t11), this._state = t11);
  }
  constructor() {
    super(), P(this, "_state", Ua.IDLE), P(this, "isAccessMicrophonePermission", false), P(this, "isAccessCameraPermission", false), P(this, "lastAccessMicrophonePermission", false), P(this, "lastAccessCameraPermission", false), P(this, "checkdeviceMatched", false), P(this, "deviceInfoMap", /* @__PURE__ */ new Map()), this.init().then(() => {
      navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval(() => {
        (v("ENUMERATE_DEVICES_INTERVAL") || (Ku() || Hu() === ye.HARMONY_OS) && ho()) && this.updateDevicesInfo();
      }, v("ENUMERATE_DEVICES_INTERVAL_TIME"));
    }).catch((t11) => _.error(t11.toString()));
  }
  async enumerateDevices(t11, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return new N(R.NOT_SUPPORTED, "enumerateDevices() not supported.").throw();
    let i = await navigator.mediaDevices.enumerateDevices(), r = this.checkMediaDeviceInfoIsOk(i), o = !this.isAccessMicrophonePermission && t11, s = !this.isAccessCameraPermission && e;
    r.audio && (o = false), r.video && (s = false);
    let a = null, c = null, d = null;
    if (!n && (o || s)) {
      if (qE.isLocked && (_.debug("[device manager] wait GUM lock"), (await qE.lock())(), _.debug("[device manager] GUM unlock")), YO && (o = false, this.isAccessMicrophonePermission = true), qO && (s = false, this.isAccessCameraPermission = true), _.debug("[device manager] check media device permissions", t11, e, o, s), o && s) {
        try {
          d = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
        } catch (l) {
          let u = Il(l.name || l.code || l, l.message);
          if (u.code === R.PERMISSION_DENIED) throw u;
          _.warning("getUserMedia failed in getDevices", u);
        }
        this.isAccessCameraPermission = true, this.isAccessMicrophonePermission = true;
      } else if (o) {
        try {
          a = await navigator.mediaDevices.getUserMedia({ audio: t11 });
        } catch (l) {
          let u = Il(l.name || l.code || l, l.message);
          if (u.code === R.PERMISSION_DENIED) throw u;
          _.warning("getUserMedia failed in getDevices", u);
        }
        this.isAccessMicrophonePermission = true;
      } else if (s) {
        try {
          c = await navigator.mediaDevices.getUserMedia({ video: e });
        } catch (l) {
          let u = Il(l.name || l.code || l, l.message);
          if (u.code === R.PERMISSION_DENIED) throw u;
          _.warning("getUserMedia failed in getDevices", u);
        }
        this.isAccessCameraPermission = true;
      }
      _.debug("[device manager] mic permission", t11, "cam permission", e);
    }
    try {
      let l = await navigator.mediaDevices.enumerateDevices();
      return a && a.getTracks().forEach((u) => u.stop()), c && c.getTracks().forEach((u) => u.stop()), d && d.getTracks().forEach((u) => u.stop()), a = null, c = null, d = null, l;
    } catch (l) {
      return a && a.getTracks().forEach((u) => u.stop()), c && c.getTracks().forEach((u) => u.stop()), d && d.getTracks().forEach((u) => u.stop()), a = null, c = null, d = null, new N(R.ENUMERATE_DEVICES_FAILED, l.toString()).throw();
    }
  }
  async getRecordingDevices() {
    let t11 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
    return (await this.enumerateDevices(true, false, t11)).filter((e) => e.kind === "audioinput");
  }
  async getCamerasDevices() {
    let t11 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
    return (await this.enumerateDevices(false, true, t11)).filter((e) => e.kind === "videoinput");
  }
  async getSpeakers() {
    let t11 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
    return (await this.enumerateDevices(true, false, t11)).filter((e) => e.kind === "audiooutput");
  }
  searchDeviceIdByName(t11) {
    let e = null;
    return this.deviceInfoMap.forEach((n) => {
      n.device.label === t11 && (e = n.device.deviceId);
    }), e;
  }
  async getDeviceById(t11) {
    let e = (await this.enumerateDevices(true, true, true)).find((n) => n.deviceId === t11);
    if (!e) throw new N(R.DEVICE_NOT_FOUND, "deviceId: ".concat(t11));
    return e;
  }
  async init() {
    this.state = Ua.INITING;
    try {
      await this.updateDevicesInfo(), this.state = Ua.INITEND;
    } catch (t11) {
      throw _.warning("Device Detection functionality cannot start properly.", t11.toString()), this.state = Ua.IDLE, (typeof isSecureContext == "boolean" ? isSecureContext : location.protocol === "https:" || location.protocol === "file:" || location.hostname === "localhost" || location.hostname === "127.0.0.1" || location.hostname === "::1") || new N(R.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.").throw(), t11;
    }
  }
  async updateDevicesInfo() {
    let t11 = await this.enumerateDevices(true, true, true), e = Date.now(), n = [];
    if (t11[0] && t11[0].label && this.checkdeviceMatched === false) {
      this.checkdeviceMatched = true;
      let r = t11.find((s) => s.kind === "audioinput" && s.deviceId === "default"), o = t11.find((s) => s.kind === "audiooutput" && s.deviceId === "default");
      r && o ? o.groupId === r.groupId ? _.debug("[device-check] default input ".concat(r.label, " and output ").concat(o.label, " is the same group")) : _.warning("[device-check] default input ".concat(r.label, " and output ").concat(o.label, " is not the same group")) : _.debug("[device-check] default input or output not found");
    }
    let i = this.checkMediaDeviceInfoIsOk(t11);
    if (t11.forEach((r) => {
      if (!r.deviceId) return;
      let o = this.deviceInfoMap.get("".concat(r.kind, "_").concat(r.deviceId));
      if ((o ? o.state : "INACTIVE") !== "ACTIVE") {
        let s = { initAt: e, updateAt: e, device: r, state: "ACTIVE" };
        this.deviceInfoMap.set("".concat(r.kind, "_").concat(r.deviceId), s), n.push(s);
      }
      o && (o.updateAt = e);
    }), this.deviceInfoMap.forEach((r, o) => {
      r.state === "ACTIVE" && r.updateAt !== e && (r.state = "INACTIVE", n.push(r));
    }), this.state !== Ua.INITEND) return i.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), void (i.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true));
    n.forEach((r) => {
      switch (r.device.kind) {
        case "audioinput":
          this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(Bo.RECORDING_DEVICE_CHANGED, r);
          break;
        case "videoinput":
          this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(Bo.CAMERA_DEVICE_CHANGED, r);
          break;
        case "audiooutput":
          this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(Bo.PLAYOUT_DEVICE_CHANGED, r);
      }
    }), i.audio && (this.lastAccessMicrophonePermission = true, this.isAccessMicrophonePermission = true), i.video && (this.lastAccessCameraPermission = true, this.isAccessCameraPermission = true);
  }
  checkMediaDeviceInfoIsOk(t11) {
    let e = t11.filter((r) => r.kind === "audioinput"), n = t11.filter((r) => r.kind === "videoinput"), i = { audio: false, video: false };
    for (let r of e) if (r.label && r.deviceId) {
      i.audio = true;
      break;
    }
    for (let r of n) if (r.label && r.deviceId) {
      i.video = true;
      break;
    }
    return i;
  }
}();
var a_ = false;
var Un = new class extends Xt {
  constructor() {
    super(...arguments), P(this, "onAutoplayFailed", void 0), P(this, "onAudioAutoplayFailed", void 0);
  }
}();
function zO() {
  if (mt(), !a_) {
    let t11 = (e) => {
      e.preventDefault(), a_ = false, yc() ? document.body.removeEventListener("click", t11, true) : (document.body.removeEventListener("touchstart", t11, true), document.body.removeEventListener("mousedown", t11, true));
    };
    a_ = true, yc() ? document.body.addEventListener("click", t11, true) : (document.body.addEventListener("touchstart", t11, true), document.body.addEventListener("mousedown", t11, true)), _.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), Un.onAutoplayFailed ? Un.onAutoplayFailed() : Un.onAudioAutoplayFailed ? _.warning(`AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.

  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .`) : _.warning(`We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.

  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.

  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .`), Un.emit("autoplay-failed");
  }
}
function JO(t11, e, n, i) {
  if (!t11) return;
  let r = X.getBaseInfoBySessionId(t11);
  if (!r) return;
  let o = r.info, s = Date.now(), a = Kt(Kt({}, o), {}, { vid: o.vid === void 0 ? 0 : Number(o.vid), lts: s, elapse: s - r.startTime, cbRegistered: Un.onAutoplayFailed || Un.onAudioAutoplayFailed ? 1 : -1, errorMsg: n, mediaType: e, trackId: i, extend: void 0 });
  X.send({ type: Jt.AUTOPLAY_FAILED, data: a }, true);
}
var UG = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "error"];
var En = new class {
  constructor() {
    P(this, "onAutoplayFailed", void 0), P(this, "elementMap", /* @__PURE__ */ new Map()), P(this, "elementStateMap", /* @__PURE__ */ new Map()), P(this, "elementsNeedToResume", []), P(this, "sinkIdMap", /* @__PURE__ */ new Map()), P(this, "autoResumeAfterInterruption", (t11) => {
      Array.from(this.elementMap.entries()).forEach((e) => {
        let [n, i] = e, r = this.elementStateMap.get(n), o = i.srcObject.getAudioTracks()[0], s = o && o.readyState;
        if (_.debug("resume after interrupted, ele: ".concat(r, " audio: ").concat(s, " ").concat(t11)), s === "live") {
          if (t11) return i.pause(), void i.play();
          if (wt.curState === "running") return Zs() ? (i.pause(), void i.play()) : void (r && r === "paused" && i.play());
        }
      });
    }), P(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
      Array.from(this.elementMap.entries()).forEach((t11) => {
        let [e, n] = t11, i = n.srcObject.getAudioTracks()[0];
        i && i.readyState === "live" && (_.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), n.pause(), n.play());
      });
    }), this.autoResumeAudioElement(), wt.on(ke.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), wt.on(ke.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), wt.on(ke.STATE_CHANGE, () => {
      ln() && wt.prevState === "suspended" && wt.curState === "running" && this.autoResumeAfterInterruption();
    });
  }
  async setSinkID(t11, e) {
    let n = this.elementMap.get(t11);
    if (this.sinkIdMap.set(t11, e), n) try {
      await n.setSinkId(e);
    } catch (i) {
      throw new N(R.PERMISSION_DENIED, "can not set sink id: " + i.toString());
    }
  }
  play(t11, e, n, i) {
    if (this.elementMap.has(e)) return;
    let r = document.createElement("audio");
    r.autoplay = true, r.srcObject = new MediaStream([t11]), this.bindAudioElementEvents(e, r), this.elementMap.set(e, r), this.elementStateMap.set(e, nn.INIT), this.setVolume(e, n);
    let o = this.sinkIdMap.get(e);
    if (o) try {
      r.setSinkId(o).catch((a) => {
        _.warning("[".concat(e, "] set sink id failed"), a.toString());
      });
    } catch (a) {
      _.warning("[".concat(e, "] set sink id failed"), a.toString());
    }
    let s = r.play();
    s && s.then && s.catch((a) => {
      i && JO(i, "audio", a.message, e), _.warning("audio element play warning", a.toString()), this.elementMap.has(e) && a.name === "NotAllowedError" && (_.warning("detected audio element autoplay failed"), this.elementsNeedToResume.push(r), qu(() => {
        this.onAutoplayFailed && this.onAutoplayFailed(), zO();
      }));
    });
  }
  updateTrack(t11, e) {
    let n = this.elementMap.get(t11);
    n && (n.srcObject = new MediaStream([e]));
  }
  isPlaying(t11) {
    return this.elementMap.has(t11) && this.elementStateMap.get(t11) === "playing";
  }
  setVolume(t11, e) {
    let n = this.elementMap.get(t11);
    n && (e = Math.max(0, Math.min(100, e)), n.volume = e / 100);
  }
  stop(t11) {
    let e = this.elementMap.get(t11);
    if (this.sinkIdMap.delete(t11), !e) return;
    let n = this.elementsNeedToResume.indexOf(e);
    this.elementsNeedToResume.splice(n, 1), e.srcObject = null, e.remove(), this.elementMap.delete(t11), this.elementStateMap.delete(t11);
  }
  bindAudioElementEvents(t11, e) {
    UG.forEach((n) => {
      e.addEventListener(n, (i) => {
        let r = this.elementStateMap.get(t11), o = i.type === "pause" ? "paused" : i.type;
        if (_.debug("[".concat(t11, "] audio-element-status change ").concat(r, " => ").concat(o)), i.type === "error") {
          let s = e == null ? void 0 : e.error;
          s && _.error("[".concat(t11, "] media error, code: ").concat(s.code, ", message: ").concat(s.message));
        }
        this.elementStateMap.set(t11, o);
      });
    });
  }
  getPlayerState(t11) {
    return this.elementStateMap.get(t11) || "uninit";
  }
  autoResumeAudioElement() {
    let t11 = () => {
      this.elementsNeedToResume.forEach((e) => {
        e.play().then((n) => {
          _.debug("Auto resume audio element success");
        }).catch((n) => {
          _.warning("Auto resume audio element failed!", n);
        });
      }), this.elementsNeedToResume = [];
    };
    new j((e) => {
      document.body ? e() : window.addEventListener("load", () => e());
    }).then(() => {
      yc() ? document.body.addEventListener("click", t11, true) : (document.body.addEventListener("touchstart", t11, true), document.body.addEventListener("mousedown", t11, true));
    });
  }
}();
function se() {
  return function(t11, e, n) {
    let i = n.value;
    return typeof i == "function" && (n.value = function() {
      this._isClosed && new N(R.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning", _);
      for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];
      let a = i.apply(this, o);
      return a instanceof j ? new j((c, d) => {
        a.then(c).catch(d);
      }) : a;
    }), n;
  };
}
var tu = class extends Xt {
  constructor(e) {
    super(), P(this, "name", "VideoProcessorDestination"), P(this, "ID", "0"), P(this, "_source", void 0), P(this, "videoContext", void 0), P(this, "inputTrack", void 0), this.videoContext = e;
  }
  get kind() {
    return "video";
  }
  get enabled() {
    return true;
  }
  pipe() {
    throw new N(R.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor");
  }
  unpipe() {
    throw new N(R.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor");
  }
  enable() {
  }
  disable() {
  }
  updateInput(e) {
    if (e.context !== this.videoContext) throw new Error(`ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.
Probably you are making pipeline like this:
videoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).`);
    e.track && e.track !== this.inputTrack && (this.videoContext.chained = true, this.inputTrack = e.track, this.emit(un.ON_TRACK, e.track));
  }
  reset() {
    this.inputTrack = void 0, this.videoContext.chained = false, this.emit(un.ON_TRACK, void 0);
  }
};
var eu = class extends Xt {
  set chained(e) {
    this._chained = e;
  }
  get chained() {
    return this._chained;
  }
  constructor(e, n) {
    super(), P(this, "constraintsMap", /* @__PURE__ */ new Map()), P(this, "statsRegistry", []), P(this, "usageRegistry", []), P(this, "trackId", void 0), P(this, "direction", void 0), P(this, "_chained", false), this.trackId = e, this.direction = n;
  }
  async getConstraints() {
    return await Ge(this, Wn.REQUEST_CONSTRAINTS);
  }
  async requestApplyConstraints(e, n) {
    var i;
    return _.info("processor ".concat(n.name, " requestApplyConstraints for ").concat(this.trackId)), e && this.constraintsMap.set(n, e), kt(this, Wn.REQUEST_UPDATE_CONSTRAINTS, Array.from(Pr(i = this.constraintsMap).call(i)));
  }
  async requestRevertConstraints(e) {
    var n;
    if (this.constraintsMap.has(e)) return _.info("processor ".concat(e.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e), kt(this, Wn.REQUEST_UPDATE_CONSTRAINTS, Array.from(Pr(n = this.constraintsMap).call(n)));
  }
  registerStats(e, n, i) {
    this.statsRegistry.find((r) => r.processorID === e.ID && r.processorName === e.name && r.type === n) || this.statsRegistry.push({ processorName: e.name, processorID: e.ID, type: n, cb: i });
  }
  unregisterStats(e, n) {
    let i = this.statsRegistry.findIndex((r) => r.processorID === e.ID && r.processorName === e.name && r.type === n);
    i !== -1 && this.statsRegistry.splice(i, 1);
  }
  gatherStats() {
    let e = [];
    for (let { processorID: n, processorName: i, type: r, cb: o } of this.statsRegistry) try {
      let s = o();
      e.push({ processorID: n, processorName: i, type: r, stats: s });
    } catch (s) {
      _.error(new N(R.UNEXPECTED_ERROR, s.message));
    }
    return e;
  }
  registerUsage(e, n) {
    this.usageRegistry.find((i) => i.processorID === e.ID && i.processorName === e.name) || this.usageRegistry.push({ processorID: e.ID, processorName: e.name, cb: n });
  }
  unregisterUsage(e) {
    let n = this.usageRegistry.findIndex((i) => i.processorID === e.ID && i.processorName === e.name);
    n !== -1 && this.usageRegistry.splice(n, 1);
  }
  async gatherUsage() {
    let e = [];
    if (!this.chained) return [];
    for (let { cb: n } of this.usageRegistry) try {
      let i = n();
      i instanceof j && (i = await i), e.push(Kt(Kt({}, i), {}, { direction: this.direction }));
    } catch (i) {
      _.error("gather extension usage error", i);
    }
    return e;
  }
  getDirection() {
    return this.direction;
  }
};
var nu = class extends Xt {
  constructor(e) {
    super(), P(this, "name", "AudioProcessorDestination"), P(this, "ID", "0"), P(this, "inputTrack", void 0), P(this, "inputNode", void 0), P(this, "audioProcessorContext", void 0), P(this, "_source", void 0), this.audioProcessorContext = e;
  }
  get kind() {
    return "audio";
  }
  get enabled() {
    return true;
  }
  pipe() {
    throw new N(R.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor");
  }
  unpipe() {
    throw new N(R.NOT_SUPPORTED, "AudioProcessor cannot unpipe to any other Processor");
  }
  enable() {
  }
  disable() {
  }
  reset() {
    this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = false, this.emit(un.ON_TRACK, void 0), this.emit(un.ON_NODE, void 0);
  }
  updateInput(e) {
    if (e.context !== this.audioProcessorContext) throw new Error(`ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.
        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).`);
    e.track && this.inputTrack !== e.track && (this.audioProcessorContext.chained = true, this.inputTrack = e.track, this.emit(un.ON_TRACK, this.inputTrack)), e.node && this.inputNode !== e.node && (this.audioProcessorContext.chained = true, this.inputNode = e.node, this.emit(un.ON_NODE, this.inputNode));
  }
};
var iu = class extends Xt {
  set chained(e) {
    this._chained = e;
  }
  get chained() {
    return this._chained;
  }
  constructor(e, n, i) {
    super(), P(this, "constraintsMap", /* @__PURE__ */ new Map()), P(this, "statsRegistry", []), P(this, "audioContext", void 0), P(this, "trackId", void 0), P(this, "direction", void 0), P(this, "usageRegistry", []), P(this, "_chained", false), this.audioContext = e, this.trackId = n, this.direction = i;
  }
  async getConstraints() {
    return Ge(this, Wn.REQUEST_CONSTRAINTS);
  }
  getAudioContext() {
    return this.audioContext;
  }
  async requestApplyConstraints(e, n) {
    var i;
    return _.info("processor ".concat(n.name, " requestApplyConstraints for ").concat(this.trackId)), e && this.constraintsMap.set(n, e), kt(this, Wn.REQUEST_UPDATE_CONSTRAINTS, Array.from(Pr(i = this.constraintsMap).call(i)));
  }
  async requestRevertConstraints(e) {
    var n;
    if (this.constraintsMap.has(e)) return this.constraintsMap.delete(e), kt(this, Wn.REQUEST_UPDATE_CONSTRAINTS, Array.from(Pr(n = this.constraintsMap).call(n)));
  }
  registerStats(e, n, i) {
    this.statsRegistry.find((r) => r.processorID === e.ID && r.processorName === e.name && r.type === n) || this.statsRegistry.push({ processorName: e.name, processorID: e.ID, type: n, cb: i });
  }
  unregisterStats(e, n) {
    let i = this.statsRegistry.findIndex((r) => r.processorID === e.ID && r.processorName === e.name && r.type === n);
    i !== -1 && this.statsRegistry.splice(i, 1);
  }
  gatherStats() {
    let e = [];
    for (let { processorID: n, processorName: i, type: r, cb: o } of this.statsRegistry) try {
      let s = o();
      e.push({ processorID: n, processorName: i, type: r, stats: s });
    } catch (s) {
      _.error(new N(R.UNEXPECTED_ERROR, s.message));
    }
    return e;
  }
  registerUsage(e, n) {
    this.usageRegistry.find((i) => i.processorID === e.ID && i.processorName === e.name) || this.usageRegistry.push({ processorID: e.ID, processorName: e.name, cb: n });
  }
  unregisterUsage(e) {
    let n = this.usageRegistry.findIndex((i) => i.processorID === e.ID && i.processorName === e.name);
    n !== -1 && this.usageRegistry.splice(n, 1);
  }
  async gatherUsage() {
    let e = [];
    if (!this.chained) return [];
    for (let { cb: n } of this.usageRegistry) try {
      let i = n();
      i instanceof j && (i = await i), e.push(Kt(Kt({}, i), {}, { direction: this.direction }));
    } catch (i) {
      _.error("gather extension usage error", i);
    }
    return e;
  }
  getDirection() {
    return this.direction;
  }
};
var Pc = class extends Xt {
  get isPlayed() {
    return true;
  }
  get isFreeze() {
    return false;
  }
  constructor() {
    super(), P(this, "context", void 0), P(this, "processSourceNode", void 0), P(this, "outputTrack", void 0), P(this, "processedNode", void 0), P(this, "clonedTrack", void 0), P(this, "outputNode", void 0), this.outputNode = new zE();
  }
  setVolume() {
  }
  createOutputTrack() {
    throw new N(R.NOT_SUPPORTED, "can not create output MediaStreamTrack when WebAudio disabled");
  }
  getOriginVolumeLevel() {
    return 0;
  }
  getAccurateVolumeLevel() {
    return 0;
  }
  stopGetAudioBuffer() {
  }
  startGetAudioBuffer() {
  }
  play() {
  }
  stop() {
  }
  destroy() {
  }
  updateTrack() {
  }
  updateOriginTrack() {
  }
  createMediaStreamSourceNode() {
  }
};
var zE = class {
  disconnect() {
  }
  connect() {
  }
};
function XO(t11) {
  return new j((e, n) => {
    let i = false, r = document.createElement("video");
    r.setAttribute("autoplay", ""), r.setAttribute("muted", ""), r.muted = true, r.autoplay = true, r.setAttribute("playsinline", ""), r.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(r);
    let o = ln() ? "canplay" : "playing";
    r.addEventListener(o, () => {
      let s = r.videoWidth, a = r.videoHeight;
      !s && $t() || (i = true, r.srcObject = null, r.remove(), e([s, a]));
    }), r.srcObject = new MediaStream([t11]), r.play().catch(zu), setTimeout(() => {
      i || (r.srcObject = null, r.remove(), e([r.videoWidth, r.videoHeight]));
    }, 4e3);
  });
}
function ru(t11) {
  let e = {};
  t11.facingMode && (e.facingMode = t11.facingMode), t11.cameraId && (e.deviceId = { exact: t11.cameraId });
  let n = cr(t11.encoderConfig);
  return n.width != null && (e.width = n.width), n.height != null && (e.height = n.height), !SO() && n.frameRate && (e.frameRate = n.frameRate), _O() && typeof e.frameRate == "object" && (e.frameRate.max = 60), $t() && (e.frameRate = { ideal: 30, max: 30 }), e;
}
function fC(t11) {
  let e = {};
  if (SO() || (t11.AGC !== void 0 && (e.autoGainControl = t11.AGC), t11.AEC !== void 0 && (e.echoCancellation = t11.AEC), t11.ANS !== void 0 && (e.noiseSuppression = t11.ANS, oo() && t11.ANS && (e.googHighpassFilter = t11.ANS))), t11.encoderConfig) {
    let n = Jl(t11.encoderConfig);
    e.channelCount = n.stereo ? 2 : 1, e.sampleRate = n.sampleRate, e.sampleSize = n.sampleSize;
  }
  return t11.microphoneId && (e.deviceId = { exact: t11.microphoneId }), Ku() && (e.sampleRate = void 0), e;
}
var xG = (t11) => {
  let e = t11._encoderConfig;
  if (!e) return;
  let { frameRate: n, width: i, height: r } = t11.getMediaStreamTrackSettings(), { frameRate: o = n, width: s = i, height: a = r } = e;
  if (!o || !s || !a) return;
  s = wp(s), a = wp(a), o = wp(o);
  let { max: c, min: d } = function(p, g, E) {
    let f = 200 * Math.pow(E / 15, 0.6) * Math.pow(p * g / 640 / 360, 0.75);
    return { min: Math.floor(f), max: Math.floor(4 * f) };
  }(s, a, o), { bitrateMax: l, bitrateMin: u } = e || {};
  l || _.debug("calculate bitrate: [w: ".concat(s, ", h: ").concat(a, ", fps: ").concat(o, "] => [brMax: ").concat(l, ", brMin: ").concat(u, "]"));
  let { maxFramerate: h } = v("ENCODER_CONFIG_LIMIT");
  return h && typeof h == "number" && (o = Math.min(o, h)), { frameRate: o, bitrateMax: l || c, bitrateMin: u || d, scaleResolutionDownBy: 1, scale: 0 };
};
var QO = async (t11, e, n) => await (async (i, r, o) => {
  let s = function(d) {
    let l = [];
    for (let u = 0; u < d.length; u += 2) l.push(parseInt(d.slice(u, u + 2), 16));
    return Uint8Array.from(l);
  }(bO("" + r + o)).slice(0, 16), a = s.slice(0, 12), c = await window.crypto.subtle.importKey("raw", s, "AES-GCM", true, ["encrypt"]);
  return new Uint8Array(await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: a }, c, i));
})(t11.buffer, e, n);
var Cf = (t11) => {
  let e = document.createElement("canvas");
  return e.width = 2, e.height = 2, new j((n, i) => {
    e.toBlob(async (r) => {
      if (e.remove(), r) {
        let o = await ZO(r);
        n({ buffer: o, width: e.width, height: e.height });
      } else i(new N(R.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
    }, t11, 1);
  });
};
var ZO = async (t11) => {
  let e = await t11.arrayBuffer();
  return new Uint8Array(e);
};
var gC;
var TC;
var SC;
var RC;
var CC;
var IC;
var vC;
var yC;
var AC;
var bC;
var wC;
var OC;
var NC;
var DC;
var PC;
var kC;
var LC;
var MC;
var Yt;
var UC;
var xC;
var VC;
var FC;
var BC;
var jC;
var Ji;
var GC;
var WC;
var HC;
var KC;
var YC;
var qC;
var zC;
var JC;
var XC;
var QC;
var ZC;
var $C;
var tI;
var Ue;
var Qt = (gC = $({ argsMap: (t11, e) => [t11.getTrackId(), e], throttleTime: 300 }), TC = $({ argsMap: (t11, e) => [t11.getTrackId(), e] }), SC = se(), RC = $s("LocalAudioTrack", "_enabledMutex"), CC = $({ argsMap: (t11, e) => [t11.getTrackId(), e] }), IC = se(), vC = $s("LocalAudioTrack", "_enabledMutex"), yC = $({ argsMap: (t11, e) => [t11.getTrackId(), e] }), AC = se(), bC = se(), wC = se(), OC = $({ argsMap: (t11) => [t11.getTrackId()] }), NC = se(), DC = $({ argsMap: (t11) => [t11.getTrackId()] }), PC = se(), kC = $({ argsMap: (t11) => [t11.getTrackId()] }), LC = $({ argsMap: (t11, e) => [t11.getTrackId(), e.name] }), MC = $({ argsMap: (t11) => [t11.getTrackId()] }), Et((Yt = class extends no {
  get _source() {
    return this.initWebAudio();
  }
  set _source(t11) {
    this._trackSource = t11;
  }
  get processorContext() {
    return this._processorContext || (this._processorContext = this.initProcessor().processorContext), this._processorContext;
  }
  get processorDestination() {
    return this._processorDestination || (this._processorDestination = this.initProcessor().processorDestination), this._processorDestination;
  }
  get isPlaying() {
    return this._useAudioElement ? En.isPlaying(this.getTrackId()) : this._source.isPlayed;
  }
  get __className__() {
    return "LocalAudioTrack";
  }
  constructor(t11, e, n, i) {
    super(t11, n), P(this, "trackMediaType", fa.AUDIO), P(this, "_encoderConfig", void 0), P(this, "_trackSource", void 0), P(this, "_enabled", true), P(this, "_volume", 100), P(this, "_useAudioElement", true), P(this, "_bypassWebAudio", false), P(this, "processor", void 0), P(this, "_processorContext", void 0), P(this, "_processorDestination", void 0), P(this, "_getOriginVolumeLevel", void 0), this._encoderConfig = e, this._getOriginVolumeLevel = !!i, this._trackSource = new Pc(), v("DISABLE_WEBAUDIO") && (this._bypassWebAudio = true), v("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false), je() && !Mn ? setTimeout(() => this.initWebAudio()) : this.initWebAudio();
  }
  setVolume(t11) {
    Nt(t11, "volume", 0, 1e3), this._volume = t11, this._source.setVolume(t11 / 100), this._useAudioElement && En.setVolume(this.getTrackId(), t11);
    try {
      if (this._bypassWebAudio) return void _.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio."));
      let e = this._source.createOutputTrack();
      this._mediaStreamTrack !== e && (this._mediaStreamTrack = e, kt(this, H.NEED_REPLACE_TRACK, this).then(() => {
        _.debug("[".concat(this.getTrackId(), "] replace web audio track success"));
      }).catch((n) => {
        _.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), n);
      }));
    } catch {
    }
  }
  getVolumeLevel() {
    return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();
  }
  async setPlaybackDevice(t11) {
    if (!this._useAudioElement || !jO()) throw new N(R.NOT_SUPPORTED, "your browser does not support setting the audio output device");
    await En.setSinkID(this.getTrackId(), t11);
  }
  async setEnabled(t11, e, n) {
    return this._setEnabled(t11, e, n);
  }
  async _setEnabled(t11, e, n) {
    if (!n) {
      if (t11 === this._enabled) return;
      this.stateCheck("enabled", t11);
    }
    if (_.info("[".concat(this.getTrackId(), "] start setEnabled"), t11), t11) {
      this._originMediaStreamTrack.enabled = true;
      try {
        n || (this._enabled = true), await kt(this, H.NEED_ENABLE_TRACK, this), _.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(t11, " success"));
      } catch (i) {
        throw n || (this._enabled = false), _.error("[".concat(this.getTrackId(), "] setEnabled to true error"), i.toString()), i;
      }
    } else {
      this._originMediaStreamTrack.enabled = false, n || (this._enabled = false);
      try {
        await kt(this, H.NEED_DISABLE_TRACK, this);
      } catch (i) {
        throw n || (this._enabled = true), _.error("[".concat(this.getTrackId(), "] setEnabled to false error"), i.toString()), i;
      }
    }
  }
  async setMuted(t11) {
    t11 !== this._muted && (this.stateCheck("muted", t11), this._muted = t11, this._originMediaStreamTrack.enabled = !t11, _.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(t11)), t11 ? await kt(this, H.NEED_MUTE_TRACK, this) : await kt(this, H.NEED_UNMUTE_TRACK, this));
  }
  getStats() {
    return po(() => {
      _.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");
    }, "localAudioTrackGetStatsWarning"), ni(this, H.GET_STATS) || Kt({}, KE);
  }
  setAudioFrameCallback(t11) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4096;
    if (!t11) return this._source.removeAllListeners(jn.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
    this._source.startGetAudioBuffer(e), this._source.removeAllListeners(jn.ON_AUDIO_BUFFER), this._source.on(jn.ON_AUDIO_BUFFER, (n) => t11(n));
  }
  play() {
    _.debug("[".concat(this.getTrackId(), "] start audio playback")), this._useAudioElement ? (_.debug("[".concat(this.getTrackId(), "] start audio playback in element")), En.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();
  }
  stop() {
    _.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._useAudioElement ? En.stop(this.getTrackId()) : this._source.stop();
  }
  close() {
    super.close(), this._processorDestination && this.unbindProcessorDestinationEvents(this._processorDestination), this._processorContext && this.unbindProcessorContextEvents(this._processorContext), this.unpipe(), this._processorDestination && this._processorDestination._source && this._processorDestination._source.unpipe(), this._source.destroy();
  }
  _updatePlayerSource() {
    let t11 = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0];
    _.debug("[".concat(this.getTrackId(), "] update player source track")), t11 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && En.updateTrack(this.getTrackId(), this._mediaStreamTrack);
  }
  async _updateOriginMediaStreamTrack(t11, e) {
    this._originMediaStreamTrack !== t11 && (this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), e && this._originMediaStreamTrack.stop()), t11.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = t11, this._muted && (this._originMediaStreamTrack.enabled = false), this.processor && this._processorContext && this.processor.updateInput({ track: t11, context: this._processorContext }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await kt(this, H.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(t11));
  }
  renewMediaStreamTrack(t11) {
    return j.resolve(void 0);
  }
  pipe(t11) {
    if (this._bypassWebAudio) throw new N(R.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true.");
    if (this.processor === t11) return t11;
    if (t11._source) throw new N(R.INVALID_OPERATION, "Processor ".concat(t11.name, " already piped, please call unpipe beforehand."));
    return this.unpipe(), this.processor = t11, this.processor._source = this, t11.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), t11;
  }
  unpipe() {
    var t11;
    if (!this.processor) return;
    let e = this.processor;
    (t11 = this._source.processSourceNode) === null || t11 === void 0 || t11.disconnect(), this.processor._source = false, this.processor = void 0, e.reset();
  }
  bindProcessorDestinationEvents(t11) {
    t11.on(un.ON_TRACK, async (e) => {
      e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(e), await kt(this, H.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await kt(this, H.NEED_REPLACE_TRACK, this));
    }), t11.on(un.ON_NODE, (e) => {
      this._source.processedNode = e;
    });
  }
  unbindProcessorDestinationEvents(t11) {
    t11.removeAllListeners(un.ON_TRACK), t11.removeAllListeners(un.ON_NODE);
  }
  bindProcessorContextEvents(t11) {
    t11.on(Wn.REQUEST_CONSTRAINTS, async (e) => {
      e(this._originMediaStreamTrack.getSettings());
    });
  }
  unbindProcessorContextEvents(t11) {
    t11.removeAllListeners(Wn.REQUEST_CONSTRAINTS);
  }
  initWebAudio() {
    return this._trackSource instanceof Pc && (this._trackSource = new $l(this._mediaStreamTrack, false, this._getOriginVolumeLevel ? this._mediaStreamTrack : void 0)), this._trackSource;
  }
  initProcessor() {
    let t11 = new iu(this._source.context, this.getTrackId(), "local"), e = new nu(t11);
    return this._processorContext = t11, this._processorDestination = e, this.bindProcessorContextEvents(t11), this.bindProcessorDestinationEvents(e), this._source.on(jn.UPDATE_SOURCE, () => {
      this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: t11 });
    }), this._useAudioElement && (this._useAudioElement = false, this.isPlaying && (En.stop(this.getTrackId()), this._source.play()), kt(this, H.NEED_REPLACE_MIXING_TRACK, this).then(() => {
      _.debug("[".concat(this.getTrackId(), "] replace from origin track to web audio track success"));
    }).catch((n) => {
      _.warning("[".concat(this.getTrackId(), "] replace from origin track to web audio track failed"), n);
    })), { processorContext: t11, processorDestination: e };
  }
}).prototype, "setVolume", [gC], Object.getOwnPropertyDescriptor(Yt.prototype, "setVolume"), Yt.prototype), Et(Yt.prototype, "setPlaybackDevice", [TC, SC], Object.getOwnPropertyDescriptor(Yt.prototype, "setPlaybackDevice"), Yt.prototype), Et(Yt.prototype, "setEnabled", [RC, CC, IC], Object.getOwnPropertyDescriptor(Yt.prototype, "setEnabled"), Yt.prototype), Et(Yt.prototype, "setMuted", [vC, yC, AC], Object.getOwnPropertyDescriptor(Yt.prototype, "setMuted"), Yt.prototype), Et(Yt.prototype, "getStats", [bC], Object.getOwnPropertyDescriptor(Yt.prototype, "getStats"), Yt.prototype), Et(Yt.prototype, "setAudioFrameCallback", [wC], Object.getOwnPropertyDescriptor(Yt.prototype, "setAudioFrameCallback"), Yt.prototype), Et(Yt.prototype, "play", [OC, NC], Object.getOwnPropertyDescriptor(Yt.prototype, "play"), Yt.prototype), Et(Yt.prototype, "stop", [DC, PC], Object.getOwnPropertyDescriptor(Yt.prototype, "stop"), Yt.prototype), Et(Yt.prototype, "close", [kC], Object.getOwnPropertyDescriptor(Yt.prototype, "close"), Yt.prototype), Et(Yt.prototype, "pipe", [LC], Object.getOwnPropertyDescriptor(Yt.prototype, "pipe"), Yt.prototype), Et(Yt.prototype, "unpipe", [MC], Object.getOwnPropertyDescriptor(Yt.prototype, "unpipe"), Yt.prototype), Yt);
var ou = (UC = $({ argsMap: (t11, e) => [t11.getTrackId(), e] }), xC = se(), VC = $s("MicrophoneAudioTrack", "_enabledMutex"), FC = $({ argsMap: (t11, e, n) => [t11.getTrackId(), e, n] }), BC = se(), jC = $({ argsMap: (t11) => [t11.getTrackId()] }), Et((Ji = class extends Qt {
  get __className__() {
    return "MicrophoneAudioTrack";
  }
  constructor(t11, e, n, i) {
    super(t11, e.encoderConfig ? Jl(e.encoderConfig) : {}, i, v("GET_VOLUME_OF_MUTED_AUDIO_TRACK")), P(this, "_config", void 0), P(this, "_deviceName", "default"), P(this, "_constraints", void 0), P(this, "_originalConstraints", void 0), P(this, "_enabled", true), this._config = e, this._constraints = n, this._originalConstraints = n, this._deviceName = t11.label, typeof e.bypassWebAudio == "boolean" && (this._bypassWebAudio = e.bypassWebAudio), (Zs() || NE()) && wt.bindInterruptDetectorTrack(this);
  }
  async setDevice(t11) {
    if (_.info("[".concat(this.getTrackId(), "] start set device to ").concat(t11)), this._enabled) try {
      let e = await Gn.getDeviceById(t11), n = {};
      n.audio = Kt({}, this._constraints), n.audio.deviceId = { exact: t11 }, this._originMediaStreamTrack.stop();
      let i = null;
      try {
        i = await Fn(n, this.getTrackId());
      } catch (r) {
        throw _.error("[".concat(this.getTrackId(), "] setDevice failed"), r.toString()), i = await Fn({ audio: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(i.getAudioTracks()[0], false), r;
      }
      await this._updateOriginMediaStreamTrack(i.getAudioTracks()[0], false), this._deviceName = e.label, this._config.microphoneId = t11, this._constraints.deviceId = { exact: t11 };
    } catch (e) {
      throw _.error("[".concat(this.getTrackId(), "] setDevice error"), e.toString()), e;
    }
    else try {
      let e = await Gn.getDeviceById(t11);
      this._deviceName = e.label, this._config.microphoneId = t11, this._constraints.deviceId = { exact: t11 };
    } catch (e) {
      throw _.error("[".concat(this.getTrackId(), "] setDevice error"), e.toString()), e;
    }
    _.info("[".concat(this.getTrackId(), "] set device to ").concat(t11, " success"));
  }
  async setEnabled(t11, e, n) {
    if (e) return _.debug("[".concat(this.getTrackId(), "] setEnabled false (do not close microphone)")), await super._setEnabled(t11);
    if (!n) {
      if (t11 === this._enabled) return;
      this.stateCheck("enabled", t11);
    }
    if (_.info("[".concat(this.getTrackId(), "] start setEnabled"), t11), v("AUTO_RESET_AUDIO_ROUTE") && (ln() || vi())) {
      let s = navigator.audioSession;
      s && (t11 || (s.type = "playback"), s.type = "auto");
    }
    if (!t11) {
      var i;
      this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), (i = this._source.clonedTrack) === null || i === void 0 || i.stop(), n || (this._enabled = false);
      try {
        await kt(this, H.NEED_DISABLE_TRACK, this);
      } catch (s) {
        throw _.error("[".concat(this.getTrackId(), "] setEnabled false failed"), s.toString()), s;
      }
      return;
    }
    let r = Kt({}, this._constraints), o = Gn.searchDeviceIdByName(this._deviceName);
    o && !r.deviceId && (r.deviceId = o);
    try {
      n || (this._enabled = true);
      let s = await Fn({ audio: this._constraints }, this.getTrackId());
      await this._updateOriginMediaStreamTrack(s.getAudioTracks()[0], false), await kt(this, H.NEED_ENABLE_TRACK, this);
    } catch (s) {
      throw n || (this._enabled = false), _.error("[".concat(this.getTrackId(), "] setEnabled true failed"), s.toString()), s;
    }
    _.info("[".concat(this.getTrackId(), "] setEnabled success"));
  }
  close() {
    super.close(), (Zs() || NE()) && wt.unbindInterruptDetectorTrack(this);
  }
  onTrackEnded() {
    if ((ln() || vi()) && this._enabled && !this._isClosed && wt.duringInterruption) {
      let t11 = async () => {
        wt.off(ke.IOS_INTERRUPTION_END, t11), this._enabled && !this._isClosed && (_.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
      };
      wt.on(ke.IOS_INTERRUPTION_END, t11);
    } else _.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(ma.TRACK_ENDED);
  }
  async renewMediaStreamTrack(t11) {
    let e = t11 || this._constraints, n = Gn.searchDeviceIdByName(this._deviceName);
    if (n && !e.deviceId && (e.deviceId = n), this._constraints = e, this._enabled) {
      this._originMediaStreamTrack.stop();
      let i = await Fn({ audio: this._constraints }, this.getTrackId());
      await this._updateOriginMediaStreamTrack(i.getAudioTracks()[0], true);
    }
  }
  bindProcessorContextEvents(t11) {
    super.bindProcessorContextEvents(t11), t11.on(Wn.REQUEST_UPDATE_CONSTRAINTS, async (e, n, i) => {
      try {
        let r = Object.assign({}, this._originalConstraints, ...e);
        await this.renewMediaStreamTrack(r), n();
      } catch (r) {
        i(r);
      }
    });
  }
  unbindProcessorContextEvents(t11) {
    super.unbindProcessorContextEvents(t11), t11.removeAllListeners(Wn.REQUEST_UPDATE_CONSTRAINTS);
  }
}).prototype, "setDevice", [UC, xC], Object.getOwnPropertyDescriptor(Ji.prototype, "setDevice"), Ji.prototype), Et(Ji.prototype, "setEnabled", [VC, FC, BC], Object.getOwnPropertyDescriptor(Ji.prototype, "setEnabled"), Ji.prototype), Et(Ji.prototype, "close", [jC], Object.getOwnPropertyDescriptor(Ji.prototype, "close"), Ji.prototype), Ji);
var VG = (GC = $({ argsMap: (t11, e) => [t11.getTrackId(), e, t11.duration] }), WC = se(), HC = $({ argsMap: (t11) => [t11.getTrackId()] }), KC = se(), YC = $({ argsMap: (t11) => [t11.getTrackId()] }), qC = se(), zC = $({ argsMap: (t11) => [t11.getTrackId()] }), JC = se(), XC = $({ argsMap: (t11) => [t11.getTrackId()] }), QC = se(), ZC = $({ argsMap: (t11) => [t11.getTrackId()] }), $C = $({ argsMap: (t11) => [t11.getTrackId()] }), tI = se(), Et((Ue = class extends Qt {
  get __className__() {
    return "BufferSourceAudioTrack";
  }
  constructor(t11, e, n, i) {
    super(e.createOutputTrack(), n, i), P(this, "source", void 0), P(this, "_bufferSource", void 0), this._useAudioElement = false, this.source = t11, this._bufferSource = e, this._bufferSource.on(jn.AUDIO_SOURCE_STATE_CHANGE, (r) => {
      this.safeEmit(ma.SOURCE_STATE_CHANGE, r);
    });
    try {
      this._mediaStreamTrack = this._source.createOutputTrack();
    } catch {
    }
  }
  get currentState() {
    return this._bufferSource.currentState;
  }
  get duration() {
    return this._bufferSource.duration;
  }
  get playbackSpeed() {
    return this._bufferSource.playbackSpeed;
  }
  getCurrentTime() {
    return this._bufferSource.currentTime;
  }
  startProcessAudioBuffer(t11) {
    t11 && this._bufferSource.updateOptions(t11), this._bufferSource.startProcessAudioBuffer();
  }
  pauseProcessAudioBuffer() {
    this._bufferSource.pauseProcessAudioBuffer();
  }
  seekAudioBuffer(t11) {
    this._bufferSource.seekAudioBuffer(t11);
  }
  resumeProcessAudioBuffer() {
    this._bufferSource.resumeProcessAudioBuffer();
  }
  stopProcessAudioBuffer() {
    this._bufferSource.stopProcessAudioBuffer();
  }
  close() {
    this.source = null, this._bufferSource.destroy(), super.close();
  }
  setAudioBufferPlaybackSpeed(t11) {
    Nt(t11, "speed", 0), this._bufferSource.setAudioBufferPlaybackSpeed(t11);
  }
}).prototype, "startProcessAudioBuffer", [GC, WC], Object.getOwnPropertyDescriptor(Ue.prototype, "startProcessAudioBuffer"), Ue.prototype), Et(Ue.prototype, "pauseProcessAudioBuffer", [HC, KC], Object.getOwnPropertyDescriptor(Ue.prototype, "pauseProcessAudioBuffer"), Ue.prototype), Et(Ue.prototype, "seekAudioBuffer", [YC, qC], Object.getOwnPropertyDescriptor(Ue.prototype, "seekAudioBuffer"), Ue.prototype), Et(Ue.prototype, "resumeProcessAudioBuffer", [zC, JC], Object.getOwnPropertyDescriptor(Ue.prototype, "resumeProcessAudioBuffer"), Ue.prototype), Et(Ue.prototype, "stopProcessAudioBuffer", [XC, QC], Object.getOwnPropertyDescriptor(Ue.prototype, "stopProcessAudioBuffer"), Ue.prototype), Et(Ue.prototype, "close", [ZC], Object.getOwnPropertyDescriptor(Ue.prototype, "close"), Ue.prototype), Et(Ue.prototype, "setAudioBufferPlaybackSpeed", [$C, tI], Object.getOwnPropertyDescriptor(Ue.prototype, "setAudioBufferPlaybackSpeed"), Ue.prototype), Ue);
var ge = class t6 extends Qt {
  get __className__() {
    return "MixingAudioTrack";
  }
  get isActive() {
    for (let e of this.trackList) if (e._enabled && !e._isClosed && !e.muted) return true;
    return false;
  }
  constructor() {
    let e = ga().createMediaStreamDestination();
    super(e.stream.getAudioTracks()[0], void 0, Ut(8, "track-mix-")), P(this, "trackList", void 0), P(this, "destNode", void 0), this._useAudioElement = false;
    try {
      this._mediaStreamTrack = this._source.createOutputTrack();
    } catch {
    }
    this.destNode = e, this.trackList = [];
  }
  hasAudioTrack(e) {
    return this.trackList.indexOf(e) !== -1;
  }
  addAudioTrack(e) {
    this.trackList.indexOf(e) === -1 ? (_.debug("add ".concat(e.getTrackId(), " to mixing track")), e._source.outputNode.connect(this.destNode), this.trackList.push(e), this.updateEncoderConfig()) : _.debug("track ".concat(e.getTrackId(), " is already added"));
  }
  removeAudioTrack(e) {
    if (this.trackList.indexOf(e) !== -1) {
      _.debug("remove ".concat(e.getTrackId(), " from mixing track"));
      try {
        e._source.outputNode.disconnect(this.destNode);
      } catch {
      }
      Wl(this.trackList, e), this.updateEncoderConfig();
    }
  }
  updateEncoderConfig() {
    let e = {};
    this.trackList.forEach((n) => {
      n._encoderConfig && ((n._encoderConfig.bitrate || 0) > (e.bitrate || 0) && (e.bitrate = n._encoderConfig.bitrate), (n._encoderConfig.sampleRate || 0) > (e.sampleRate || 0) && (e.sampleRate = n._encoderConfig.sampleRate), (n._encoderConfig.sampleSize || 0) > (e.sampleSize || 0) && (e.sampleSize = n._encoderConfig.sampleSize), n._encoderConfig.stereo && (e.stereo = true));
    }), this._encoderConfig = e;
  }
  _updateRtpTransceiver(e) {
    this._rtpTransceiver !== e && (this._rtpTransceiver = e, this.trackList.forEach((n) => {
      n instanceof t6 ? n.emit(Ko.TRANSCEIVER_UPDATED, e) : n._updateRtpTransceiver(e);
    }));
  }
};
var JE = class extends Zl {
  set currentState(e) {
    e !== this._currentState && (this._currentState = e, this.safeEmit(jn.AUDIO_SOURCE_STATE_CHANGE, this._currentState));
  }
  get currentState() {
    return this._currentState;
  }
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), P(this, "audioBuffer", void 0), P(this, "sourceNode", void 0), P(this, "startPlayTime", 0), P(this, "startPlayOffset", 0), P(this, "pausePlayTime", 0), P(this, "options", void 0), P(this, "currentLoopCount", 0), P(this, "currentPlaybackSpeed", 100), P(this, "_currentState", "stopped"), this.audioBuffer = e, this.options = n, this.startPlayOffset = this.options.startPlayTime || 0;
  }
  createWebAudioDiagram() {
    return this.context.createGain();
  }
  get duration() {
    return this.audioBuffer ? this.audioBuffer.duration : 0;
  }
  get playbackSpeed() {
    return this.currentPlaybackSpeed;
  }
  get currentTime() {
    return this.audioBuffer ? this.currentState === "stopped" ? 0 : this.currentState === "paused" ? this.pausePlayTime : ((this.context.currentTime - this.startPlayTime) * (this.playbackSpeed / 100) + this.startPlayOffset) % this.audioBuffer.duration : 0;
  }
  updateOptions(e) {
    this.currentState === "stopped" ? (this.options = e, this.startPlayOffset = this.options.startPlayTime || 0) : _.warning("can not set audio source options");
  }
  startProcessAudioBuffer() {
    this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing";
  }
  pauseProcessAudioBuffer() {
    this.sourceNode && this.currentState === "playing" && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused");
  }
  seekAudioBuffer(e) {
    this.sourceNode && (this.sourceNode.onended = null, this.currentState === "playing" && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), this.currentState === "playing" ? (this.startPlayOffset = e, this.startSourceNode()) : this.currentState === "paused" && (this.pausePlayTime = e));
  }
  resumeProcessAudioBuffer() {
    this.currentState === "paused" && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing");
  }
  stopProcessAudioBuffer() {
    if (this.sourceNode) {
      this.sourceNode.onended = null;
      try {
        this.sourceNode.stop();
      } catch {
      }
      this.reset();
    }
  }
  destroy() {
    this.audioBuffer = null, super.destroy();
  }
  setAudioBufferPlaybackSpeed(e) {
    this.sourceNode && (this.currentState === "playing" && (this.startPlayOffset = this.currentTime, this.startPlayTime = this.context.currentTime), this.sourceNode.playbackRate.value = e / 100), this.currentPlaybackSpeed = e;
  }
  startSourceNode() {
    this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));
  }
  createSourceNode() {
    let e = this.context.createBufferSource();
    return e.buffer = this.audioBuffer, e.loop = !!this.options.loop, e.connect(this.outputNode), e.playbackRate.value = this.currentPlaybackSpeed / 100, e;
  }
  handleSourceNodeEnded() {
    if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount) return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();
    this.reset();
  }
  reset() {
    this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;
  }
};
var eI = /* @__PURE__ */ new Map();
var kc = class {
  get rendFrameRate() {
    if (this.renderStats && this.renderStats.curTs !== this.renderStats.lastTs) {
      let e = this.renderStats.curTs - this.renderStats.lastTs, n = (this.renderStats.renderNum - this.renderStats.lastRenderNum) / e;
      return this.renderStats.lastRenderNum = this.renderStats.renderNum, this.renderStats.lastTs = this.renderStats.curTs, n;
    }
    return 0;
  }
  get videoElementStatus() {
    return this._videoElementStatus;
  }
  set videoElementStatus(e) {
    e !== this._videoElementStatus && (_.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e)), this._videoElementStatus = e);
  }
  get videoState() {
    return this._videoState;
  }
  set videoState(e) {
    var n;
    e !== this._videoState && (this._videoState = e, (n = this.onVideoStateChanged) === null || n === void 0 || n.call(this, this.videoState));
  }
  constructor(e) {
    P(this, "trackId", void 0), P(this, "config", void 0), P(this, "onFirstVideoFrameDecoded", void 0), P(this, "onVideoStateChanged", void 0), P(this, "freezeTimeCounterList", []), P(this, "renderFreezeAccTime", 0), P(this, "isKeepLastFrame", false), P(this, "timeUpdatedCount", 0), P(this, "freezeTime", 0), P(this, "playbackTime", 0), P(this, "lastTimeUpdatedTime", 0), P(this, "autoplayFailed", false), P(this, "videoTrack", void 0), P(this, "videoElement", void 0), P(this, "cacheVideoElement", void 0), P(this, "renderStats", void 0), P(this, "_videoState", zi.VideoStateStopped), P(this, "videoElementCheckInterval", void 0), P(this, "videoElementFreezeTimeout", void 0), P(this, "_videoElementStatus", nn.NONE), P(this, "isGettingVideoDimensions", false), P(this, "startGetVideoDimensions", () => {
      let n = () => {
        if (this.isGettingVideoDimensions = true, this.videoElement.videoWidth * this.videoElement.videoHeight > 4) return _.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = false);
        setTimeout(n, 500);
      };
      !this.isGettingVideoDimensions && n();
    }), P(this, "autoResumeAfterInterruption", () => {
      this.videoTrack && this.videoTrack.readyState === "live" && wt.curState === "running" && (_.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(dR())), pR() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
    }), P(this, "handleVideoEvents", (n) => {
      switch (n.type) {
        case "play":
        case "playing":
          this.startGetVideoDimensions(), this.videoElementStatus = nn.PLAYING;
          break;
        case "loadeddata":
          if (this.videoState = zi.VideoStateStarting, this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded(), this.cacheVideoElement) {
            try {
              this.cacheVideoElement.srcObject = null, this.cacheVideoElement.remove();
            } catch {
            }
            this.cacheVideoElement = void 0;
          }
          break;
        case "canplay":
          this.videoElementStatus = nn.CANPLAY;
          break;
        case "stalled":
          this.videoElementStatus = nn.STALLED;
          break;
        case "suspend":
          this.videoElementStatus = nn.SUSPEND;
          break;
        case "pause":
          this.videoElementStatus = nn.PAUSED, ln() || vi() || je() && this.autoplayFailed || !this.videoTrack || this.videoTrack.readyState !== "live" || (_.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), this.videoElement.play());
          break;
        case "waiting":
          this.videoElementStatus = nn.WAITING;
          break;
        case "abort":
          this.videoElementStatus = nn.ABORT;
          break;
        case "ended":
          this.videoElementStatus = nn.ENDED;
          break;
        case "emptied":
          this.videoElementStatus = nn.EMPTIED;
          break;
        case "error": {
          let i = this.videoElement.error;
          i ? (this.videoElementStatus = nn.ERROR, _.error("[".concat(this.trackId, "] media error: ").concat(i.message, " (").concat(i.code, ")"))) : _.debug("[".concat(this.trackId, "] media not been an error."));
          break;
        }
        case "timeupdate": {
          let i = performance.now();
          if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10) return void (this.lastTimeUpdatedTime = i);
          let r = i - this.lastTimeUpdatedTime, o = this.lastTimeUpdatedTime;
          if (this.lastTimeUpdatedTime = i, yr.lastVisibleTime < yr.lastHiddenTime || o < yr.lastHiddenTime || o < yr.lastVisibleTime) return;
          for (r > v("VIDEO_FREEZE_DURATION") && (this.freezeTime += r), this.playbackTime += r; this.playbackTime >= 6e3; ) {
            this.playbackTime -= 6e3;
            let s = Math.min(6e3, this.freezeTime);
            this.freezeTimeCounterList.push(s), this.freezeTime = Math.max(0, this.freezeTime - 6e3);
          }
          break;
        }
      }
    }), P(this, "autoResumeAfterInterruptionOnIOS15_16", () => {
      this.videoTrack && this.videoTrack.readyState === "live" && (_.debug("[track-".concat(this.trackId, "] video element paused, auto resume for ").concat(dR())), pR() ? (this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : (this.videoElement.pause(), this.videoElement.play()));
    }), this.trackId = e.trackId, this.config = e, e.element instanceof HTMLVideoElement ? this.videoElement = e.element : this.videoElement = document.createElement("video"), wt.on(ke.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), wt.on(ke.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16);
  }
  getVideoElement() {
    return this.videoElement;
  }
  getContainerElement() {
    var e;
    return (e = this.videoElement.parentElement) !== null && e !== void 0 ? e : void 0;
  }
  updateConfig(e) {
    this.config = e, this.trackId = e.trackId, e.element !== this.videoElement && (this.destroy(), this.videoElement = e.element), this.videoTrack && this.initVideoElement();
  }
  updateVideoTrack(e) {
    this.videoTrack !== e && (this.videoTrack = e, this.initVideoElement());
  }
  play(e) {
    let n = this.videoElement.play();
    n && n.catch && n.catch((r) => {
      e && JO(e, "video", r.message, this.trackId), r.name === "NotAllowedError" ? (_.warning("detected video element autoplay failed", r), this.autoplayFailed = true, this.handleAutoPlayFailed()) : _.warning("[".concat(this.trackId, "] play warning: "), r);
    });
    let i = mt();
    if ((i.name === "Safari" && Number(i.version) === 15 || Zs()) && n && n.then) {
      let r = () => {
        this.config.mirror && (this.videoElement.style.transform = "rotateY(180deg)");
      };
      n.then(r).catch(r);
    }
  }
  getCurrentFrame() {
    let e = document.createElement("canvas");
    e.width = this.videoElement.videoWidth, e.height = this.videoElement.videoHeight;
    let n = e.getContext("2d");
    if (!n) return _.error("create canvas context failed!"), new ImageData(2, 2);
    n.drawImage(this.videoElement, 0, 0, e.width, e.height);
    let i = n.getImageData(0, 0, e.width, e.height);
    return e.remove(), i;
  }
  async getCurrentFrameToUint8Array(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, i = document.createElement("canvas");
    i.width = this.videoElement.videoWidth, i.height = this.videoElement.videoHeight;
    let r = i.getContext("2d");
    return r ? (r.drawImage(this.videoElement, 0, 0, i.width, i.height), new j((o, s) => {
      i.toBlob(async (a) => {
        if (i.remove(), a) {
          let c = await ZO(a);
          o({ buffer: c, width: i.width, height: i.height });
        } else s(new N(R.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));
      }, e, n < 0 ? 0.1 : n > 1 ? 1 : n);
    })) : await Cf(e);
  }
  destroy() {
    this.renderStats = void 0, wt.off(ke.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), wt.off(ke.IOS_15_16_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15_16), this.videoElement.srcObject = null, this.resetVideoElement(), this.freezeTimeCounterList = [], this.videoState = zi.VideoStateStopped;
  }
  initVideoElement() {
    if (this.videoElementStatus = nn.INIT, !this.videoElementCheckInterval && (nI.forEach((o) => {
      this.videoElement.addEventListener(o, this.handleVideoEvents);
    }), this.videoElementCheckInterval = window.setInterval(() => {
      (function(o) {
        return o !== document.body && document.body.contains(o);
      })(this.videoElement) || (this.videoElementStatus = nn.DESTROYED);
    }, 1e3), v("ENABLE_VIDEO_FRAME_CALLBACK"))) {
      var e, n;
      let o, s = () => {
        document.visibilityState === "visible" && (document.removeEventListener("visibilitychange", s), this.videoElementFreezeTimeout = window.setTimeout(a, v("VIDEO_FREEZE_DURATION")));
      }, a = () => {
        this.videoElementFreezeTimeout = void 0, this.videoState === zi.VideoStateDecoding && (document.visibilityState === "visible" ? this.videoState = zi.VideoStateFrozen : document.addEventListener("visibilitychange", s));
      }, c = (d, l) => {
        if (this.videoElementStatus === nn.PLAYING) {
          if (this.renderStats ? (this.renderStats.renderNum++, this.renderStats.curTs = l.mediaTime) : this.renderStats = { lastTs: l.mediaTime, curTs: l.mediaTime, lastRenderNum: 0, renderNum: 0 }, o) {
            let p = l.presentationTime - o.presentationTime;
            this.videoState === zi.VideoStateStarting && (this.videoState = zi.VideoStateDecoding), this.videoState === zi.VideoStateDecoding && this.onVideoStateChanged && (this.videoElementFreezeTimeout && window.clearTimeout(this.videoElementFreezeTimeout), this.videoElementFreezeTimeout = window.setTimeout(a, v("VIDEO_FREEZE_DURATION"))), p < v("VIDEO_FREEZE_DURATION") && this.videoState === zi.VideoStateFrozen && (this.videoState = zi.VideoStateDecoding), p > v("VIDEO_FREEZE_DURATION") && yr.lastVisibleTime >= yr.lastHiddenTime && o.timestamp > yr.lastVisibleTime && o.timestamp > yr.lastHiddenTime && (this.renderFreezeAccTime += p);
          }
          o = Kt(Kt({}, l), {}, { timestamp: d });
        }
        var u, h;
        v("ENABLE_VIDEO_FRAME_CALLBACK") && ((u = (h = this.videoElement).requestVideoFrameCallback) === null || u === void 0 || u.call(h, c));
      };
      (e = (n = this.videoElement).requestVideoFrameCallback) === null || e === void 0 || e.call(n, c);
    }
    this.videoElement.controls = false, this.videoElement.setAttribute("playsinline", ""), Ku() && !v("HIDE_NO_POSTER") && (this.videoElement.poster = "noposter");
    let i = mt();
    i.name === "Safari" && Number(i.version) === 15 || Zs() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", this.videoElement.setAttribute("muted", ""), this.videoElement.muted = true, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream ? this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, $t() && this.videoElement.load()) : (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, $t() && this.videoElement.load());
    let r = this.videoElement.play();
    r !== void 0 && r.catch((o) => {
      _.debug("[".concat(this.trackId, "] playback interrupted"), o.toString());
    });
  }
  resetVideoElement() {
    nI.forEach((e) => {
      this.videoElement && this.videoElement.removeEventListener(e, this.handleVideoEvents);
    }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0), this.videoElementStatus = nn.NONE;
  }
  handleAutoPlayFailed() {
    let e = (n) => {
      n.preventDefault(), this.videoElement.play().then(() => {
        _.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed."));
      }).catch((i) => {
        _.error(i);
      }), this.autoplayFailed = false, yc() ? document.body.removeEventListener("click", e, true) : (document.body.removeEventListener("touchstart", e, true), document.body.removeEventListener("mousedown", e, true));
    };
    yc() ? document.body.addEventListener("click", e, true) : (document.body.addEventListener("touchstart", e, true), document.body.addEventListener("mousedown", e, true)), zO();
  }
};
var nI = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate", "error"];
var su = class extends kc {
  constructor(e) {
    super(e), P(this, "container", void 0), P(this, "slot", void 0), this.slot = e.element, this.updateConfig(e);
  }
  updateConfig(e) {
    this.config = e, this.trackId = e.trackId;
    let n = e.element;
    n !== this.slot && (this.destroy(), this.slot = n), this.createElements();
  }
  updateVideoTrack(e) {
    this.videoTrack !== e && (this.videoTrack = e, this.createElements());
  }
  play(e) {
    var n;
    (n = this.container) !== null && n !== void 0 && n.contains(this.videoElement) && super.play(e);
  }
  getCurrentFrame() {
    var e;
    return (e = this.container) !== null && e !== void 0 && e.contains(this.videoElement) ? super.getCurrentFrame() : new ImageData(2, 2);
  }
  async getCurrentFrameToUint8Array(e) {
    var n;
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return (n = this.container) !== null && n !== void 0 && n.contains(this.videoElement) ? await super.getCurrentFrameToUint8Array(e, i) : await Cf(e);
  }
  destroy() {
    if (super.destroy(), this.videoElement.remove(), this.videoElement = document.createElement("video"), this.container) {
      try {
        this.container.remove(), this.slot.removeChild(this.container);
      } catch {
      }
      this.container = void 0;
    }
  }
  createElements() {
    this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", v("KEEP_LAST_FRAME") && this.isKeepLastFrame && this.videoElement.paused && this.resetVideoElement(), this.mountedVideoElement()) : this.unmountedVideoElement(), this.slot.appendChild(this.container);
  }
  mountedVideoElement() {
    var e;
    !this.container || (e = this.container) !== null && e !== void 0 && e.contains(this.videoElement) || this.container.appendChild(this.videoElement), super.initVideoElement(), this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.style.left = "0", this.videoElement.style.top = "0";
  }
  unmountedVideoElement() {
    var e;
    if ((e = this.container) !== null && e !== void 0 && e.contains(this.videoElement)) {
      super.resetVideoElement();
      try {
        this.container && this.container.removeChild(this.videoElement);
      } catch {
      }
      this.videoElement = document.createElement("video");
    }
  }
  resetVideoElement() {
    var e;
    (e = this.container) !== null && e !== void 0 && e.contains(this.videoElement) && (super.resetVideoElement(), this.cacheVideoElement = this.videoElement, this.videoElement = document.createElement("video"));
  }
  getContainerElement() {
    return this.container;
  }
};
var iI;
var rI;
var oI;
var sI;
var aI;
var cI;
var dI;
var lI;
var uI;
var hI;
var pI;
var _I;
var EI;
var mI;
var fI;
var gI;
var TI;
var SI;
var RI;
var CI;
var II;
var vI;
var yI;
var AI;
var ht;
var bI;
var wI;
var OI;
var NI;
var DI;
var PI;
var kI;
var LI;
var Ln;
var Ft = (iI = $({ argsMap: (t11, e, n) => [t11.getTrackId(), typeof e == "string" ? e : e instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", n] }), rI = se(), oI = $({ argsMap: (t11) => [t11.getTrackId()] }), sI = $s("LocalVideoTrack", "_enabledMutex"), aI = $({ argsMap: (t11, e) => [t11.getTrackId(), e] }), cI = se(), dI = $s("LocalVideoTrack", "_enabledMutex"), lI = $({ argsMap: (t11, e) => [t11.getTrackId(), e] }), uI = se(), hI = $({ argsMap: (t11, e) => [t11.getTrackId(), e] }), pI = se(), _I = se(), EI = $({ argsMap: (t11, e, n) => [t11.getTrackId(), e, n] }), mI = se(), fI = se(), gI = se(), TI = se(), SI = se(), RI = se(), CI = se(), II = $({ argsMap: (t11, e) => [t11.getTrackId(), e.name] }), vI = $({ argsMap: (t11) => [t11.getTrackId()] }), yI = $({ argsMap: (t11) => [t11.getTrackId()] }), AI = $({ argsMap: (t11, e, n) => [t11.getTrackId(), e.label, n] }), ht = class $O extends no {
  get videoHeight() {
    if (je()) {
      let { height: e } = this._mediaStreamTrack.getSettings();
      return this._videoHeight = e, this._videoHeight;
    }
    return this._videoHeight;
  }
  get videoWidth() {
    if (je()) {
      let { width: e } = this._mediaStreamTrack.getSettings();
      return this._videoWidth = e, this._videoWidth;
    }
    return this._videoWidth;
  }
  get isPlaying() {
    return !(!this._player || this._player.videoElementStatus !== nn.PLAYING);
  }
  get processorDestination() {
    return this._processorDestination;
  }
  get processorContext() {
    return this._processorContext;
  }
  set processorContext(e) {
    this._processorContext = e;
  }
  get __className__() {
    return "LocalVideoTrack";
  }
  constructor(e, n, i, r, o, s) {
    if (super(e, o), P(this, "trackMediaType", fa.VIDEO), P(this, "_player", void 0), P(this, "isUseScaleResolutionDownBy", false), P(this, "_videoVisibleTimer", null), P(this, "_previousVideoVisibleStatus", void 0), P(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), P(this, "_encoderConfig", void 0), P(this, "_scalabilityMode", { numSpatialLayers: 1, numTemporalLayers: 1 }), P(this, "_optimizationMode", void 0), P(this, "_videoHeight", void 0), P(this, "_videoWidth", void 0), P(this, "_forceBitrateLimit", void 0), P(this, "_enabled", true), P(this, "_processorDestination", void 0), P(this, "_processorContext", void 0), je()) {
      let { width: a, height: c } = e.getSettings();
      this._videoWidth = a, this._videoHeight = c;
    } else this.updateMediaStreamTrackResolution();
    if (this._encoderConfig = n, this._scalabilityMode = i, this._optimizationMode = r, this._hints = s || [], this._hints.indexOf(Gt.SCREEN_TRACK) === -1) this.updateBitrateFromProfile();
    else if (function(a, c, d) {
      let l = mt();
      return !(l.name !== a || !l.osVersion) && Number(l.version) === c;
    }(It.CHROME, 115) && Hu().indexOf("Windows") !== -1) {
      let a = function(c, d) {
        if ("VideoFrame" in window && "TransformStream" in window && ft().supportWebRTCInsertableStream) {
          let l = new MediaStreamTrackProcessor(c), u = new MediaStreamTrackGenerator({ kind: "video" }), h, p, g = Date.now(), E = () => {
            f && (clearInterval(f), f = void 0), h && (h.close(), h = void 0), c.stop(), p = void 0, u.removeEventListener("ended", E);
          }, f = window.setInterval(() => {
            if (p && h && Date.now() - g > 1e3) try {
              u.readyState === "live" ? p.enqueue(h.clone()) : E();
            } catch {
              E();
            }
          }, 1e3), S = new TransformStream({ transform: (C, A) => {
            u.readyState === "live" ? (p = A, g = Date.now(), h === void 0 ? (h = C, A.enqueue(C.clone())) : (A.enqueue(h), h = C)) : C.close();
          } });
          return u.addEventListener("ended", E), l.readable.pipeThrough(S).pipeTo(u.writable), u;
        }
      }(e);
      a && (_.info("local screen video track begin to inject frame"), this._mediaStreamTrack = a);
    }
    n && this._hints.indexOf(Gt.CUSTOM_TRACK) !== -1 && this.setEncoderConfiguration(n), this._processorContext = new eu(this.getTrackId(), "local"), this._processorDestination = new tu(this.processorContext), this.bindProcessorDestinationEvents();
  }
  play(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof e == "string") {
      let r = document.getElementById(e);
      r ? e = r : (_.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e, '" element, use document.body')), e = document.body);
    }
    _.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(e instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(n));
    let i = Kt(Kt(Kt({}, this._getDefaultPlayerConfig()), n), {}, { trackId: this.getTrackId(), element: e });
    this._player ? this._player.updateConfig(i) : (e instanceof HTMLVideoElement ? this._player = new kc(i) : this._player = new su(i), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
      try {
        let r = this.getVideoElementVisibleStatus();
        this.safeEmit(ma.VIDEO_ELEMENT_VISIBLE_STATUS, r);
      } catch {
      }
    }, v("CHECK_VIDEO_VISIBLE_INTERVAL"));
  }
  stop() {
    this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, _.debug("[".concat(this.getTrackId(), "] stop video playback")));
  }
  async setEnabled(e, n) {
    if (!n) {
      if (e === this._enabled) return;
      this.stateCheck("enabled", e);
    }
    if (_.info("[".concat(this.getTrackId(), "] start setEnabled"), e), !e) {
      this._originMediaStreamTrack.enabled = false;
      try {
        await kt(this, H.NEED_DISABLE_TRACK, this);
      } catch (i) {
        throw _.error("[".concat(this.getTrackId(), "] setEnabled to false error"), i.toString()), i;
      }
      return n || (this._enabled = false), void _.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
    }
    this._originMediaStreamTrack.enabled = true;
    try {
      await kt(this, H.NEED_ENABLE_TRACK, this);
    } catch (i) {
      throw _.error("[".concat(this.getTrackId(), "] setEnabled to true error"), i.toString()), i;
    }
    _.info("[".concat(this.getTrackId(), "] setEnabled to true success")), n || (this._enabled = true);
  }
  async setMuted(e) {
    e !== this._muted && (this.stateCheck("muted", e), this._muted = e, this._originMediaStreamTrack.enabled = !e, _.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e)), e ? await kt(this, H.NEED_MUTE_TRACK, this) : await kt(this, H.NEED_UNMUTE_TRACK, this));
  }
  async setEncoderConfiguration(e, n) {
    if (!this._enabled) throw new N(R.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
    if (e = cr(e), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e.bitrateMin), e.width || e.height || e.frameRate) {
      let i = ru({ encoderConfig: e });
      (je() || ln() || vi()) && (i.deviceId = void 0), _.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e), JSON.stringify(i));
      try {
        await this._originMediaStreamTrack.applyConstraints(i), this.updateMediaStreamTrackResolution();
      } catch (r) {
        let o = new N(R.UNEXPECTED_ERROR, r.toString());
        throw _.error("[".concat(this.getTrackId(), "] applyConstraints error"), o.toString()), o;
      }
    }
    this._encoderConfig = e, this._hints.indexOf(Gt.SCREEN_TRACK) === -1 && this.updateBitrateFromProfile();
    try {
      await kt(this, H.NEED_UPDATE_VIDEO_ENCODER, this);
    } catch (i) {
      return i.throw(_);
    }
  }
  getStats() {
    return po(() => {
      _.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");
    }, "localVideoTrackGetStatsWarning"), ni(this, H.GET_STATS) || Kt({}, YE);
  }
  async setBeautyEffect(e) {
    _.error("LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect");
  }
  getCurrentFrameData() {
    return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
  }
  async getCurrentFrameImage(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return this._player ? this._player.getCurrentFrameToUint8Array(e, n) : await Cf(e);
  }
  async setBitrateLimit(e) {
    if (_.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e))), e) {
      this._forceBitrateLimit = e, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e.max_bitrate ? this._encoderConfig.bitrateMax : e.max_bitrate : this._encoderConfig.bitrateMax = e.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e.min_bitrate);
      try {
        await kt(this, H.NEED_UPDATE_VIDEO_ENCODER, this);
      } catch (n) {
        return n.throw(_);
      }
    }
  }
  async setOptimizationMode(e) {
    if (e !== "motion" && e !== "detail" && e !== "balanced") return void _.error(R.INVALID_PARAMS, "optimization mode must be motion, detail or balanced");
    let n = this._optimizationMode;
    try {
      this._optimizationMode = e, await kt(this, H.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this);
    } catch (i) {
      throw this._optimizationMode = n, _.error("[".concat(this.getTrackId(), "] set optimization mode failed"), i.toString()), i;
    }
    _.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e, ")"));
  }
  setScalabiltyMode(e) {
    if (e.numSpatialLayers === 1 && e.numTemporalLayers !== 1) return _.error(R.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), void (this._scalabilityMode = { numSpatialLayers: 1, numTemporalLayers: 1 });
    this._scalabilityMode = e, _.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e, ")"));
  }
  updateMediaStreamTrackResolution() {
    XO(this._originMediaStreamTrack).then((e) => {
      let [n, i] = e;
      this._videoHeight = i, this._videoWidth = n;
    }).catch(zu);
  }
  _updatePlayerSource() {
    this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
  }
  _getDefaultPlayerConfig() {
    return { fit: "contain" };
  }
  async setSenderConfiguration(e) {
    if (!this._enabled) throw new N(R.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
    _.debug("[".concat(this.getTrackId(), "] setSenderConfiguration applyConstraints"), JSON.stringify(e)), e = cr(e), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e.bitrateMin), this._encoderConfig = e, this._hints.indexOf(Gt.SCREEN_TRACK) === -1 && this.updateBitrateFromProfile();
    try {
      await kt(this, H.NEED_UPDATE_VIDEO_ENCODER, this);
    } catch (n) {
      return n.throw(_);
    }
  }
  updateBitrateFromProfile() {
    if (!this._encoderConfig) return;
    let { width: e, height: n, frameRate: i } = this.getMediaStreamTrackSettings();
    if (!e || !n || !i) return;
    let { bitrateMax: r, bitrateMin: o } = this._encoderConfig;
    if (o == null || r == null) {
      let { max: s, min: a } = function(c, d, l, u, h) {
        let p = v("BITRATE_ADAPTER_TYPE");
        if (p === "DEFAULT_BITRATE") return { min: u, max: h };
        if (h === void 0) {
          var g;
          let f = Math.floor(200 * Math.pow(l / 15, 0.6) * Math.pow(c * d / 640 / 360, 0.75));
          h = p === "STANDARD_BITRATE" ? 4 * f : 2 * f, u = (g = u) !== null && g !== void 0 ? g : f;
        } else {
          var E;
          u = (E = u) !== null && E !== void 0 ? E : Math.floor(h / 10);
        }
        return { min: u, max: h };
      }(e, n, i, o, r);
      this._encoderConfig.bitrateMin = a, this._encoderConfig.bitrateMax = s, _.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e, ", h: ").concat(n, ", fps: ").concat(i, "] => [brMax: ").concat(s, ", brMin: ").concat(a, "]"));
    }
  }
  getVideoElementVisibleStatus() {
    try {
      var e, n;
      let i = this == null || (e = this._player) === null || e === void 0 ? void 0 : e.getContainerElement(), r = { track: this, element: this == null || (n = this._player) === null || n === void 0 ? void 0 : n.getVideoElement(), slot: i == null ? void 0 : i.parentElement }, { element: o, slot: s } = r;
      if (this.isPlaying && o instanceof HTMLVideoElement && s instanceof HTMLElement) {
        let a = CO.checkOneElementVisible(o), c = Object.assign({}, a);
        if (c.visible !== this._previousVideoVisibleStatus) {
          this._previousVideoVisibleStatus = c.visible;
          let d = X.reportApiInvoke(null, { tag: Zt.TRACER, name: Te.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
          c.visible ? d.onSuccess("Video is visible") : d.onSuccess("Invisible because of ".concat(c.reason));
        }
        return c;
      }
      return;
    } catch (i) {
      throw new N(R.GET_VIDEO_ELEMENT_VISIBLE_ERROR, i.message);
    }
  }
  async renewMediaStreamTrack(e) {
  }
  pipe(e) {
    if (this.processor === e) return e;
    if (e._source) throw new N(R.INVALID_OPERATION, "Processor ".concat(e.name, " already piped, please call unpipe beforehand."));
    return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), e;
  }
  unpipe() {
    if (!this.processor) return;
    let e = this.processor;
    this.processor._source = void 0, this.processor = void 0, e.reset();
  }
  close() {
    super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();
  }
  clone(e) {
    let n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = this._encoderConfig;
    e && (i = Kt(Kt({}, i), cr(e))), i = Vo(i);
    let r = Ut(8, "track-video-cloned-"), o = new $O(n ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, i, Vo(this._scalabilityMode), this._optimizationMode, r, Vo(this._hints));
    return e && i && o.setEncoderConfiguration(i), _.debug("clone video track from ".concat(this.getTrackId(), " to ").concat(r, ", clone ").concat(n)), o;
  }
  async replaceTrack(e, n) {
    if (!(e instanceof MediaStreamTrack)) throw new N(R.INVALID_PARAMS, "track should be an instance of MediaStreamTrack");
    if (e.kind !== "video") throw new N(R.INVALID_PARAMS, "track should be a video MediaStreamTrack");
    await this._updateOriginMediaStreamTrack(e, n, true), this.updateMediaStreamTrackResolution();
  }
  sendSeiData(e) {
    if (po(() => {
      X.reportApiInvoke(null, { name: Te.LOCAL_VIDEO_SEND_SEI_DATA, options: [], tag: Zt.TRACER }).onSuccess("");
    }, this._mediaStreamTrack.id || this.getTrackId()), !v("ENABLE_VIDEO_SEI") || !v("ENABLE_ENCODED_TRANSFORM")) return void _.warning('To send/receive SEI, please call AgoraRTC.setParameter("ENABLE_VIDEO_SEI", true) before instantiate IAgoraRtcClient');
    if (e instanceof Uint8Array == 0) return new N(R.INVALID_PARAMS, "Invalid argument type, ILocalVideoTrack.sendSeiData() only accept Uint8Array argument.").throw();
    let n = this.getRTCRtpTransceiver();
    if (!n) return void _.warning("Video track is not published, SEI can not be send");
    let i = n.sender.getParameters();
    if (i.codecs.length === 0) return;
    let r = i.codecs[0].mimeType.toLocaleLowerCase();
    r === "video/h264" ? this.safeEmit("sei-to-send", e) : _.warning("SEI is not supported by ".concat(r));
  }
  bindProcessorDestinationEvents() {
    this.processorDestination.on(un.ON_TRACK, async (e) => {
      e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(), await kt(this, H.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await kt(this, H.NEED_REPLACE_TRACK, this));
    });
  }
  unbindProcessorDestinationEvents() {
    this.processorDestination.removeAllListeners(un.ON_TRACK);
  }
  unbindProcessorContextEvents() {
    this.processorContext.removeAllListeners(Wn.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(Wn.REQUEST_CONSTRAINTS);
  }
}, Et(ht.prototype, "play", [iI, rI], Object.getOwnPropertyDescriptor(ht.prototype, "play"), ht.prototype), Et(ht.prototype, "stop", [oI], Object.getOwnPropertyDescriptor(ht.prototype, "stop"), ht.prototype), Et(ht.prototype, "setEnabled", [sI, aI, cI], Object.getOwnPropertyDescriptor(ht.prototype, "setEnabled"), ht.prototype), Et(ht.prototype, "setMuted", [dI, lI, uI], Object.getOwnPropertyDescriptor(ht.prototype, "setMuted"), ht.prototype), Et(ht.prototype, "setEncoderConfiguration", [hI, pI], Object.getOwnPropertyDescriptor(ht.prototype, "setEncoderConfiguration"), ht.prototype), Et(ht.prototype, "getStats", [_I], Object.getOwnPropertyDescriptor(ht.prototype, "getStats"), ht.prototype), Et(ht.prototype, "setBeautyEffect", [EI, mI], Object.getOwnPropertyDescriptor(ht.prototype, "setBeautyEffect"), ht.prototype), Et(ht.prototype, "getCurrentFrameData", [fI], Object.getOwnPropertyDescriptor(ht.prototype, "getCurrentFrameData"), ht.prototype), Et(ht.prototype, "getCurrentFrameImage", [gI], Object.getOwnPropertyDescriptor(ht.prototype, "getCurrentFrameImage"), ht.prototype), Et(ht.prototype, "setBitrateLimit", [TI], Object.getOwnPropertyDescriptor(ht.prototype, "setBitrateLimit"), ht.prototype), Et(ht.prototype, "setOptimizationMode", [SI], Object.getOwnPropertyDescriptor(ht.prototype, "setOptimizationMode"), ht.prototype), Et(ht.prototype, "setScalabiltyMode", [RI], Object.getOwnPropertyDescriptor(ht.prototype, "setScalabiltyMode"), ht.prototype), Et(ht.prototype, "updateMediaStreamTrackResolution", [CI], Object.getOwnPropertyDescriptor(ht.prototype, "updateMediaStreamTrackResolution"), ht.prototype), Et(ht.prototype, "pipe", [II], Object.getOwnPropertyDescriptor(ht.prototype, "pipe"), ht.prototype), Et(ht.prototype, "unpipe", [vI], Object.getOwnPropertyDescriptor(ht.prototype, "unpipe"), ht.prototype), Et(ht.prototype, "close", [yI], Object.getOwnPropertyDescriptor(ht.prototype, "close"), ht.prototype), Et(ht.prototype, "replaceTrack", [AI], Object.getOwnPropertyDescriptor(ht.prototype, "replaceTrack"), ht.prototype), ht);
var XE = (bI = $({ argsMap: (t11, e) => [t11.getTrackId(), e] }), wI = se(), OI = $s("CameraVideoTrack", "_enabledMutex"), NI = $({ argsMap: (t11, e) => [t11.getTrackId(), e] }), DI = se(), PI = $({ argsMap: (t11, e) => [t11.getTrackId(), e] }), kI = se(), LI = $({ argsMap: (t11) => [t11.getTrackId()] }), Ln = class t0 extends Ft {
  get __className__() {
    return "CameraVideoTrack";
  }
  constructor(e, n, i, r, o, s) {
    super(e, cr(n.encoderConfig), r, o, s), P(this, "_config", void 0), P(this, "_originalConstraints", void 0), P(this, "_constraints", void 0), P(this, "_enabled", true), P(this, "_deviceName", "default"), P(this, "tryResumeVideoForIOS15_16WeChat", async () => {
      (Zs() || NE()) && !function() {
        let a = mt();
        if (a.os !== ye.IOS || !a.osVersion) return false;
        let c = a.osVersion.split(".");
        return Number(c[0]) === 15 && Number(c[1]) >= 2;
      }() && TO() && this._enabled && !this._isClosed && (_.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack());
    }), this._config = n, this._originalConstraints = i, this._constraints = i, this._deviceName = e.label, this._encoderConfig = cr(this._config.encoderConfig), wt.on(ke.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), wt.on(ke.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), this.bindProcessorContextEvents();
  }
  async setDevice(e) {
    return typeof e == "string" ? this._setDeviceById(e) : e.deviceId ? this._setDeviceById(e.deviceId) : e.facingMode ? this._setDeviceByFacingModel(e.facingMode) : void 0;
  }
  async _setDeviceById(e) {
    if (_.info("[".concat(this.getTrackId(), "] set device to ").concat(e)), this._enabled) try {
      let n = await Gn.getDeviceById(e), i = {};
      i.video = Kt({}, this._constraints), i.video.deviceId = { exact: e }, i.video.facingMode = void 0, this._originMediaStreamTrack.stop();
      let r = null;
      try {
        r = await Fn(i, this.getTrackId());
      } catch (o) {
        throw _.error("[".concat(this.getTrackId(), "] setDevice failed"), o.toString()), r = await Fn({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(r.getVideoTracks()[0], false), o;
      }
      await this._updateOriginMediaStreamTrack(r.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution(), this._deviceName = n.label, this._config.cameraId = e, this._constraints.deviceId = { exact: e };
    } catch (n) {
      throw _.error("[".concat(this.getTrackId(), "] setDevice error"), n.toString()), n;
    }
    else try {
      let n = await Gn.getDeviceById(e);
      this._deviceName = n.label, this._config.cameraId = e, this._constraints.deviceId = { exact: e };
    } catch (n) {
      throw _.error("[".concat(this.getTrackId(), "] setDevice error"), n.toString()), n;
    }
    _.info("[".concat(this.getTrackId(), "] setDevice success"));
  }
  async _setDeviceByFacingModel(e) {
    _.info("[".concat(this.getTrackId(), "] set facingMode ").concat(e));
    let n = { video: Kt(Kt({}, this._constraints), {}, { deviceId: void 0, facingMode: { exact: e } }) };
    if (this._enabled) {
      this._originMediaStreamTrack.stop();
      let i = null;
      try {
        i = await Fn(n, this.getTrackId());
      } catch (r) {
        throw _.error("[".concat(this.getTrackId(), "] setDeviceByFacingModel failed"), r.toString()), i = await Fn({ video: this._constraints }, this.getTrackId()), await this._updateOriginMediaStreamTrack(i.getVideoTracks()[0], false), r;
      }
      await this._updateOriginMediaStreamTrack(i.getVideoTracks()[0], false), this.updateMediaStreamTrackResolution();
    }
    this._deviceName = "", this._config.facingMode = e, this._config.cameraId = void 0, this._constraints = Kt({}, n.video), _.info("[".concat(this.getTrackId(), "] setDeviceByFacingModel success"));
  }
  async setEnabled(e, n) {
    if (!n) {
      if (e === this._enabled) return;
      this.stateCheck("enabled", e);
    }
    if (_.info("[".concat(this.getTrackId(), "] start setEnabled"), e), e) {
      try {
        if (this.isExternalTrack) this._originMediaStreamTrack.enabled = true;
        else {
          let i = await Fn({ video: this._constraints }, this.getTrackId());
          await this._updateOriginMediaStreamTrack(i.getVideoTracks()[0], false);
        }
        await kt(this, H.NEED_ENABLE_TRACK, this);
      } catch (i) {
        throw _.error("[".concat(this.getTrackId(), "] setEnabled true error"), i.toString()), i;
      }
      this.updateMediaStreamTrackResolution(), _.info("[".concat(this.getTrackId(), "] setEnabled to true success")), n || (this._enabled = true);
    } else {
      this.isExternalTrack ? this._originMediaStreamTrack.enabled = false : (this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop()), n || (this._enabled = false);
      try {
        await kt(this, H.NEED_DISABLE_TRACK, this);
      } catch (i) {
        throw _.error("[".concat(this.getTrackId(), "] setEnabled to false error"), i.toString()), i;
      }
      _.info("[".concat(this.getTrackId(), "] setEnabled to false success"));
    }
  }
  async setEncoderConfiguration(e, n) {
    if (!this._enabled) throw new N(R.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
    e = cr(e), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate || e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate || e.bitrateMin);
    let i = le(this._config);
    i.encoderConfig = e;
    let r = ru(i);
    (je() || ln() || vi()) && (r.deviceId = void 0), _.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e), JSON.stringify(r));
    try {
      await this._originMediaStreamTrack.applyConstraints(r), this.updateMediaStreamTrackResolution();
    } catch (o) {
      let s = new N(R.UNEXPECTED_ERROR, o.toString());
      throw _.error("[".concat(this.getTrackId(), "] applyConstraints error"), s.toString()), s;
    }
    this._config = i, this._constraints = r, this._originalConstraints = r, this._encoderConfig = e, this._hints.indexOf(Gt.SCREEN_TRACK) === -1 && this.updateBitrateFromProfile();
    try {
      await kt(this, H.NEED_UPDATE_VIDEO_ENCODER, this);
    } catch (o) {
      return o.throw(_);
    }
  }
  _getDefaultPlayerConfig() {
    return { mirror: true, fit: "cover" };
  }
  onTrackEnded() {
    if ((ln() || vi()) && this._enabled && !this._isClosed && wt.duringInterruption) {
      let e = async () => {
        wt.off(ke.IOS_INTERRUPTION_END, e), this._enabled && !this._isClosed && (_.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), await this.setEnabled(false), await this.setEnabled(true));
      };
      wt.on(ke.IOS_INTERRUPTION_END, e);
    } else _.debug("[".concat(this.getTrackId(), "] track ended")), this.safeEmit(ma.TRACK_ENDED);
  }
  async renewMediaStreamTrack(e) {
    let n = e || this._constraints, i = Gn.searchDeviceIdByName(this._deviceName);
    if (i && !n.deviceId && (n.deviceId = { exact: i }), this._enabled) {
      let r = await Fn({ video: n }, this.getTrackId());
      this._constraints = n, await this._updateOriginMediaStreamTrack(r.getVideoTracks()[0], true), this.updateMediaStreamTrackResolution();
    }
  }
  close() {
    super.close(), wt.off(ke.IOS_15_16_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat), wt.off(ke.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15_16WeChat);
  }
  clone(e) {
    let n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], i = this._encoderConfig;
    e && (i = Kt(Kt({}, i), cr(e))), i = Vo(i);
    let r = Ut(8, "track-cam-cloned-"), o = new t0(n ? this._mediaStreamTrack.clone() : this._mediaStreamTrack, Vo(Kt(Kt({}, this._config), {}, { encoderConfig: i })), Vo(this._constraints), Vo(this._scalabilityMode), this._optimizationMode, r);
    return e && i && o.setEncoderConfiguration(i), _.debug("clone track from ".concat(this.getTrackId(), " to ").concat(r, ", clone ").concat(n)), o;
  }
  bindProcessorContextEvents() {
    this.processorContext.on(Wn.REQUEST_UPDATE_CONSTRAINTS, async (e, n, i) => {
      try {
        let r = Object.assign({}, this._originalConstraints, ...e);
        await this.renewMediaStreamTrack(r), n();
      } catch (r) {
        i(r);
      }
    }), this.processorContext.on(Wn.REQUEST_CONSTRAINTS, async (e) => {
      e(this._originMediaStreamTrack.getSettings());
    });
  }
}, Et(Ln.prototype, "setDevice", [bI, wI], Object.getOwnPropertyDescriptor(Ln.prototype, "setDevice"), Ln.prototype), Et(Ln.prototype, "setEnabled", [OI, NI, DI], Object.getOwnPropertyDescriptor(Ln.prototype, "setEnabled"), Ln.prototype), Et(Ln.prototype, "setEncoderConfiguration", [PI, kI], Object.getOwnPropertyDescriptor(Ln.prototype, "setEncoderConfiguration"), Ln.prototype), Et(Ln.prototype, "close", [LI], Object.getOwnPropertyDescriptor(Ln.prototype, "close"), Ln.prototype), Ln);
function c_(t11, e, n, i) {
  n.optimizationMode && (i && i.width && i.height ? (n.encoderConfig = Kt(Kt({}, i), {}, { bitrateMin: i.bitrateMin, bitrateMax: i.bitrateMax }), n.optimizationMode !== "motion" && n.optimizationMode !== "detail" || (e.contentHint = n.optimizationMode, e.contentHint === n.optimizationMode ? _.debug("[".concat(t11, "] set content hint to"), n.optimizationMode) : _.debug("[".concat(t11, "] set content hint failed")))) : _.warning("[".concat(t11, "] can not apply optimization mode bitrate config, no encoderConfig")));
}
var MI;
var UI;
var xI;
var VI;
var zn;
var FI;
var BI;
var jI;
var GI;
var WI;
var HI;
var $e;
var au = class extends Xl {
  getUserId() {
    return this._userId;
  }
  constructor(e, n, i, r) {
    super(e, "track-".concat(e.kind, "-").concat(n, "-").concat(r.clientId, "_").concat(Ut(5, ""))), P(this, "_userId", void 0), P(this, "_uintId", void 0), P(this, "_isDestroyed", false), P(this, "store", void 0), P(this, "processor", void 0), P(this, "processorContext", void 0), this._userId = n, this._uintId = i, this.store = r;
  }
  _updateOriginMediaStreamTrack(e) {
    this._originMediaStreamTrack = e, this._mediaStreamTrack = e, this._updatePlayerSource(), this.processor && this.processor.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext });
  }
  _destroy() {
    this._isDestroyed = true, _.info("[".concat(this.getTrackId(), "] is destroyed")), this.stop(), super.close();
  }
  getProcessorStats() {
    return this.processorContext.gatherStats();
  }
  getProcessorUsage() {
    return this.processorContext.gatherUsage();
  }
};
var Hs = (MI = $({ argsMap: (t11, e, n) => [t11.getTrackId(), typeof e == "string" ? e : e instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement", n] }), UI = $({ argsMap: (t11) => [t11.getTrackId()] }), xI = $({ argsMap: (t11, e) => [t11.getTrackId(), e.name] }), VI = $({ argsMap: (t11) => [t11.getTrackId()] }), Et((zn = class extends au {
  get isPlaying() {
    return !(!this._player || this._player.videoElementStatus !== nn.PLAYING);
  }
  get __className__() {
    return "RemoteVideoTrack";
  }
  constructor(t11, e, n, i) {
    super(t11, e, n, i), P(this, "_videoVisibleTimer", null), P(this, "_previousVideoVisibleStatus", void 0), P(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), P(this, "trackMediaType", fa.VIDEO), P(this, "_videoWidth", void 0), P(this, "_videoHeight", void 0), P(this, "_player", void 0), P(this, "processorDestination", void 0), P(this, "processorContext", void 0), this.updateMediaStreamTrackResolution(), this.processorContext = new eu(this.getTrackId(), "remote"), this.processorDestination = new tu(this.processorContext), this.bindProcessorDestinationEvents();
  }
  getStats() {
    return po(() => {
      _.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");
    }, "remoteVideoTrackGetStatsWarning"), ni(this, H.GET_STATS) || Kt({}, WO);
  }
  play(t11) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof t11 == "string") {
      let i = document.getElementById(t11);
      i ? t11 = i : (_.warning("[".concat(this.getTrackId(), '] can not find "#').concat(t11, '" element, use document.body')), t11 = document.body);
    }
    _.debug("[".concat(this.getTrackId(), "] start video playback in ").concat(t11 instanceof HTMLVideoElement ? "HTMLVideoElement" : "HTMLElement"), JSON.stringify(e));
    let n = Kt(Kt({ fit: "cover" }, e), {}, { trackId: this.getTrackId(), element: t11 });
    this._player ? this._player.updateConfig(n) : (t11 instanceof HTMLVideoElement ? this._player = new kc(n) : this._player = new su(n), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {
      this.store.subscribe(this.getUserId(), "video", void 0, void 0, Date.now()), this.safeEmit(Ws.FIRST_FRAME_DECODED);
    }, this._player.onVideoStateChanged = (i) => {
      this.safeEmit(Ws.VIDEO_STATE_CHANGED, i);
    }), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
      try {
        let i = this.getVideoElementVisibleStatus();
        this.safeEmit(Ws.VIDEO_ELEMENT_VISIBLE_STATUS, i);
      } catch {
      }
    }, v("CHECK_VIDEO_VISIBLE_INTERVAL"));
  }
  stop() {
    this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, _.debug("[".concat(this.getTrackId(), "] stop video playback")));
  }
  getCurrentFrameData() {
    return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);
  }
  updateMediaStreamTrackResolution() {
    XO(this._originMediaStreamTrack).then((t11) => {
      let [e, n] = t11;
      this._videoHeight = n, this._videoWidth = e;
    }).catch(zu);
  }
  _updatePlayerSource() {
    _.debug("[".concat(this.getTrackId(), "] update player source track")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);
  }
  getVideoElementVisibleStatus() {
    try {
      var t11, e;
      let n = this == null || (t11 = this._player) === null || t11 === void 0 ? void 0 : t11.getContainerElement(), i = { track: this, element: this == null || (e = this._player) === null || e === void 0 ? void 0 : e.getVideoElement(), slot: n == null ? void 0 : n.parentElement }, { element: r, slot: o } = i;
      if (this.isPlaying && r instanceof HTMLVideoElement && o instanceof HTMLElement) {
        let s = CO.checkOneElementVisible(r), a = Object.assign({}, s);
        if (a.visible !== this._previousVideoVisibleStatus) {
          this._previousVideoVisibleStatus = a.visible;
          let c = X.reportApiInvoke(null, { tag: Zt.TRACER, name: Te.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE, options: [this.getTrackId()] });
          a.visible ? c.onSuccess("Video is visible") : c.onSuccess("Invisible because of ".concat(a.reason));
        }
        return a;
      }
      return;
    } catch (n) {
      throw new N(R.GET_VIDEO_ELEMENT_VISIBLE_ERROR, n.message);
    }
  }
  pipe(t11) {
    if (this.processor === t11) return t11;
    if (t11._source) throw new N(R.INVALID_OPERATION, "Processor ".concat(t11.name, " already piped, please call unpipe beforehand."));
    return this.unpipe(), this.processor = t11, this.processor._source = this, t11.updateInput({ track: this._originMediaStreamTrack, context: this.processorContext }), t11;
  }
  unpipe() {
    if (!this.processor) return;
    let t11 = this.processor;
    this.processor._source = void 0, this.processor = void 0, t11.reset();
  }
  bindProcessorDestinationEvents() {
    this.processorDestination.on(un.ON_TRACK, async (t11) => {
      t11 ? t11 !== this._mediaStreamTrack && (this._mediaStreamTrack = t11, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
    });
  }
  unbindProcessorDestinationEvents() {
    this.processorDestination.removeAllListeners(un.ON_TRACK);
  }
  _destroy() {
    super._destroy(), this.unbindProcessorDestinationEvents();
  }
  _onSei(t11) {
    this.emit(Ko.SEI_RECEIVED, t11);
  }
}).prototype, "play", [MI], Object.getOwnPropertyDescriptor(zn.prototype, "play"), zn.prototype), Et(zn.prototype, "stop", [UI], Object.getOwnPropertyDescriptor(zn.prototype, "stop"), zn.prototype), Et(zn.prototype, "pipe", [xI], Object.getOwnPropertyDescriptor(zn.prototype, "pipe"), zn.prototype), Et(zn.prototype, "unpipe", [VI], Object.getOwnPropertyDescriptor(zn.prototype, "unpipe"), zn.prototype), zn);
var Ks = (FI = $({ argsMap: (t11, e) => [t11.getTrackId(), e], throttleTime: 300 }), BI = $({ argsMap: (t11, e) => [t11.getTrackId(), e] }), jI = $({ argsMap: (t11) => [t11.getTrackId()] }), GI = $({ argsMap: (t11) => [t11.getTrackId()] }), WI = $({ argsMap: (t11, e) => [t11.getTrackId(), e.name] }), HI = $({ argsMap: (t11) => [t11.getTrackId()] }), Et(($e = class extends au {
  get isPlaying() {
    return this._useAudioElement ? En.isPlaying(this.getTrackId()) : this._source.isPlayed;
  }
  get __className__() {
    return "RemoteAudioTrack";
  }
  constructor(t11, e, n, i) {
    super(t11, e, n, i), P(this, "trackMediaType", fa.AUDIO), P(this, "_source", void 0), P(this, "_useAudioElement", true), P(this, "_volume", 100), P(this, "processorContext", void 0), P(this, "processorDestination", void 0), P(this, "_played", false), P(this, "_bypassWebAudio", false), v("DISABLE_WEBAUDIO") ? (this._source = new Pc(), this._bypassWebAudio = true, this._useAudioElement = true) : (this._source = new $l(t11, true), v("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = false)), this._source.once(jn.RECEIVE_TRACK_BUFFER, () => {
      this.safeEmit(Ws.FIRST_FRAME_DECODED);
    }), this.processorContext = new iu(this._source.context, this.getTrackId(), "remote"), this.processorDestination = new nu(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(jn.UPDATE_SOURCE, () => {
      this.processor && this.processor.updateInput({ node: this._source.processSourceNode, context: this.processorContext });
    });
  }
  setAudioFrameCallback(t11) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4096;
    if (!t11) return this._source.removeAllListeners(jn.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
    this._source.startGetAudioBuffer(e), this._source.removeAllListeners(jn.ON_AUDIO_BUFFER), this._source.on(jn.ON_AUDIO_BUFFER, (n) => t11(n));
  }
  setVolume(t11) {
    this._volume = t11, this._useAudioElement ? En.setVolume(this.getTrackId(), t11) : this._source.setVolume(t11 / 100);
  }
  async setPlaybackDevice(t11) {
    if (!this._useAudioElement || !jO()) throw new N(R.NOT_SUPPORTED, "your browser does not support setting the audio output device");
    await En.setSinkID(this.getTrackId(), t11);
  }
  getVolumeLevel() {
    return this._source.getAccurateVolumeLevel();
  }
  getStats() {
    return po(() => {
      _.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");
    }, "remoteAudioTrackGetStatsWarning"), ni(this, H.GET_STATS) || Kt({}, GO);
  }
  play() {
    _.debug("[".concat(this.getTrackId(), "] start audio playback")), this._played = true, this._useAudioElement ? (_.debug("[".concat(this.getTrackId(), "] use audio element to play")), En.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play();
  }
  stop() {
    _.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._played = false, this._useAudioElement ? En.stop(this.getTrackId()) : this._source.stop();
  }
  _destroy() {
    super._destroy(), this._played = false, this.unbindProcessorDestinationEvents(), this._source.destroy();
  }
  _isFreeze() {
    return this._source.isFreeze;
  }
  _updatePlayerSource() {
    let t11 = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0];
    _.debug("[".concat(this.getTrackId(), "] update player source track")), t11 && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && En.updateTrack(this.getTrackId(), this._mediaStreamTrack);
  }
  pipe(t11) {
    if (this._bypassWebAudio) throw new N(R.NOT_SUPPORTED, "can not pipe extension when WebAudio disabled");
    if (this.processor === t11) return t11;
    if (t11._source) throw new N(R.INVALID_OPERATION, "Processor ".concat(t11.name, " already piped, please call unpipe beforehand."));
    return this.unpipe(), this.processor = t11, this.processor._source = this, t11.updateInput({ track: this._originMediaStreamTrack, node: this._source.processSourceNode, context: this.processorContext }), t11;
  }
  unpipe() {
    var t11;
    if (this._bypassWebAudio) throw new N(R.NOT_SUPPORTED, "can not unpipe extension when WebAudio disabled");
    if (!this.processor) return;
    let e = this.processor;
    (t11 = this._source.processSourceNode) === null || t11 === void 0 || t11.disconnect(), this.processor._source = false, this.processor = void 0, e.reset();
  }
  bindProcessorDestinationEvents() {
    this.processorDestination.on(un.ON_TRACK, async (t11) => {
      t11 ? t11 !== this._mediaStreamTrack && (this._mediaStreamTrack = t11, this._updatePlayerSource(false), this._source.processedNode = this._source.createMediaStreamSourceNode(t11)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());
    }), this.processorDestination.on(un.ON_NODE, (t11) => {
      this._source.processedNode = t11;
      let e = !t11;
      this._useAudioElement !== e && (this._played ? (this.stop(), this._useAudioElement = e, this.play()) : this._useAudioElement = e);
    });
  }
  unbindProcessorDestinationEvents() {
    this.processorDestination.removeAllListeners(un.ON_TRACK), this.processorDestination.removeAllListeners(un.ON_NODE);
  }
}).prototype, "setVolume", [FI], Object.getOwnPropertyDescriptor($e.prototype, "setVolume"), $e.prototype), Et($e.prototype, "setPlaybackDevice", [BI], Object.getOwnPropertyDescriptor($e.prototype, "setPlaybackDevice"), $e.prototype), Et($e.prototype, "play", [jI], Object.getOwnPropertyDescriptor($e.prototype, "play"), $e.prototype), Et($e.prototype, "stop", [GI], Object.getOwnPropertyDescriptor($e.prototype, "stop"), $e.prototype), Et($e.prototype, "pipe", [WI], Object.getOwnPropertyDescriptor($e.prototype, "pipe"), $e.prototype), Et($e.prototype, "unpipe", [HI], Object.getOwnPropertyDescriptor($e.prototype, "unpipe"), $e.prototype), $e);
var yr = new class extends Xt {
  get visibility() {
    return document.visibilityState;
  }
  get lastHiddenTime() {
    return this._lastHiddenTime;
  }
  get lastVisibleTime() {
    return this._lastVisibleTime;
  }
  constructor() {
    super(), P(this, "_lastHiddenTime", 0), P(this, "_lastVisibleTime", 0), document.addEventListener("visibilitychange", () => {
      document.visibilityState === "hidden" ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), _.debug("document visibility went ".concat(document.visibilityState)), this.emit("VISIBILITY_CHANGE", document.visibilityState);
    });
  }
}();
var cu = class extends Xt {
  constructor(e, n) {
    super(), P(this, "trackMediaType", fa.DATA), P(this, "_version", 1), P(this, "_type", 3), P(this, "_config", void 0), P(this, "_originDataChannel", void 0), P(this, "_dataStreamPacketHeader", new ArrayBuffer(4)), P(this, "_dataStreamPacketHandler", { serialize: (i) => i, deserialize: (i) => i }), P(this, "_datachannelEventMap", /* @__PURE__ */ new Map()), this._config = e, n && (this._originDataChannel = n, this._bandDataChannelEvents(n)), this._initPacketHeader();
  }
  useDataStream(e) {
    this._dataStreamPacketHandler = e;
  }
  get id() {
    return this._config.id;
  }
  get ordered() {
    return this._config.ordered;
  }
  get maxRetransmits() {
    return v("DATASTREAM_MAX_RETRANSMITS");
  }
  get metadata() {
    return this._config.metadata;
  }
  get readyState() {
    var e, n;
    return (e = (n = this._originDataChannel) === null || n === void 0 ? void 0 : n.readyState) !== null && e !== void 0 ? e : "connecting";
  }
  get _originDataChannelId() {
    var e, n;
    return (e = (n = this._originDataChannel) === null || n === void 0 ? void 0 : n.id) !== null && e !== void 0 ? e : null;
  }
  getChannelId() {
    return this.id;
  }
  getConfig() {
    return this._config;
  }
  _close() {
    this._originDataChannel && (this._unbindDataChannelEvents(this._originDataChannel), this._originDataChannel = void 0);
  }
  async _waitTillOpen() {
    return new j((e, n) => {
      if (this._originDataChannel) {
        this._originDataChannel.readyState === "open" && e();
        let i = setTimeout(() => {
          var r;
          n(new N(R.DATACHANNEL_CONNECTION_TIMEOUT, "Cannot create datachannel, id: ".concat((r = this._originDataChannel) === null || r === void 0 ? void 0 : r.id)));
        }, 1e4);
        this._originDataChannel.onopen = () => {
          clearTimeout(i), this._originDataChannel && this._bandDataChannelEvents(this._originDataChannel), e();
        }, this._originDataChannel.onerror = () => {
          throw clearTimeout(i), new N(R.DATACHANNEL_CONNECTION_TIMEOUT);
        };
      } else n(new N(R.DATACHANNEL_CONNECTION_TIMEOUT, "cannot find dataChannel"));
    });
  }
  _updateOriginDataChannel(e) {
    this._originDataChannel = e, this._bandDataChannelEvents(e);
  }
  _initPacketHeader() {
    let e = new DataView(this._dataStreamPacketHeader);
    e.setUint16(0, this._version), e.setUint8(2, this._type), e.setUint8(3, this._config.id);
  }
  _bandDataChannelEvents(e) {
    this._unbindDataChannelEvents(e), [Cl.OPEN, Cl.CLOSE, Cl.ERROR].forEach((n) => {
      let i = () => {
        this.emit(n);
      };
      this._datachannelEventMap.set(n, i), e.addEventListener(n, i);
    });
  }
  _unbindDataChannelEvents(e) {
    Array.from(this._datachannelEventMap.entries()).forEach((n) => {
      let [i, r] = n;
      e.removeEventListener(i, r);
    }), this._datachannelEventMap.clear();
  }
};
var QE = class extends cu {
  constructor(e) {
    super(e), P(this, "_messageListener", void 0), this._messageListener = (n) => {
      if (n.data.byteLength < this._dataStreamPacketHeader.byteLength) throw Error("invalid byteLength: the byte length must exceed " + this._dataStreamPacketHeader.byteLength);
      let i = n.data.slice(0, this._dataStreamPacketHeader.byteLength), r = new DataView(i).getUint8(3);
      if (r !== this.id) return void (v("SHOW_DATASTREAM2_LOG") && _.debug("invalid datachannel id: ".concat(r, " !== ").concat(this.id)));
      let o = n.data.slice(this._dataStreamPacketHeader.byteLength);
      o = this._dataStreamPacketHandler.deserialize(o), this.emit(Cl.MESSAGE, o);
    };
  }
  _updateOriginDataChannel(e) {
    super._updateOriginDataChannel(e), this._bandRemoteDataChannelEvents();
  }
  _close() {
    this._originDataChannel && (this._originDataChannel.removeEventListener("message", this._messageListener), super._close());
  }
  _bandRemoteDataChannelEvents() {
    this._originDataChannel && this._originDataChannel.addEventListener("message", this._messageListener);
  }
};
var ZE = class extends cu {
  send(e) {
    if (this._originDataChannel) {
      let n = e;
      n = this._dataStreamPacketHandler.serialize(e);
      let i = new Uint8Array(this._dataStreamPacketHeader.byteLength + n.byteLength);
      i.set(new Uint8Array(this._dataStreamPacketHeader), 0), i.set(new Uint8Array(n), this._dataStreamPacketHeader.byteLength), this._originDataChannel.send(i.buffer);
    }
  }
};
function vl() {
  let t11 = new Blob([atob("ZnVuY3Rpb24gZShlLHQsbil7bGV0IHI9bmV3IFVpbnQ4QXJyYXkoZSx0LG4pLGE9W10sbz0wO2Zvcig7YS5sZW5ndGg8bjspbyszPG4mJjA9PT1yW29dJiYwPT09cltvKzFdJiYzPT09cltvKzJdJiYoMD09PXJbbyszXXx8MT09PXJbbyszXXx8Mj09PXJbbyszXXx8Mz09PXJbbyszXSk/KGEucHVzaChyW29dLHJbbysxXSxyW28rM10pLG8rPTQpOihhLnB1c2gocltvXSksbysrKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSl9ZnVuY3Rpb24gdChlLHQpe2NvbnN0IG49ZnVuY3Rpb24oZSl7Y29uc3QgdD1lLmxlbmd0aDtsZXQgbj1bXSxyPTA7Zm9yKDtyPHQ7KXIrMjx0JiYwPT09ZVtyXSYmMD09PWVbcisxXSYmKDA9PT1lW3IrMl18fDE9PT1lW3IrMl18fDI9PT1lW3IrMl18fDM9PT1lW3IrMl0pPyhuLnB1c2goZVtyXSxlW3IrMV0sMyxlW3IrMl0pLHIrPTMpOihuLnB1c2goZVtyXSkscisrKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkobil9KHQpLHI9bi5sZW5ndGgsYT1NYXRoLmZsb29yKHIvMjU1KSxvPXIlMjU1LHM9bmV3IFVpbnQ4QXJyYXkoNithKzErcitlLmJ5dGVMZW5ndGgpO3NbMF09MCxzWzFdPTAsc1syXT0wLHNbM109MSxzWzRdPTYsc1s1XT0xMDE7bGV0IGk9MDtmb3IoO2k8YTspc1s2K2ldPTI1NSxpKys7cmV0dXJuIHNbNitpXT1vLGkrKyxzLnNldChuLDYraSkscy5zZXQobmV3IFVpbnQ4QXJyYXkoZSksNitpK3IpLHMuYnVmZmVyfW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZigiU2FmYXJpIik+LTEmJi0xPT09bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCJDaHJvbWUiKSYmKHNlbGYub25ydGN0cmFuc2Zvcm09bj0+e2NvbnN0IHI9bi50cmFuc2Zvcm1lcjtsZXQgYT1bXTtyLm9wdGlvbnMucG9ydC5vbm1lc3NhZ2U9ZT0+e2UuZGF0YS5zZWkmJmEucHVzaChlLmRhdGEuc2VpKX0sc2VsZi5wb3N0TWVzc2FnZSgic3RhcnRlZCIpO2NvbnN0IG89ci5yZWFkYWJsZS5nZXRSZWFkZXIoKSxzPXIud3JpdGFibGUuZ2V0V3JpdGVyKCk7InJ4Ij09PXIub3B0aW9ucy5uYW1lP2Z1bmN0aW9uIHQobil7by5yZWFkKCkudGhlbigocj0+e2lmKCFyLmRvbmUpe2lmKHIudmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkVmlkZW9GcmFtZSl7Y29uc3QgdD1mdW5jdGlvbih0KXtjb25zdCBuPW5ldyBEYXRhVmlldyh0LmRhdGEpO2xldCByPTA7Zm9yKDtyKzQ8dC5kYXRhLmJ5dGVMZW5ndGg7KXtpZigwPT09bi5nZXRVaW50OChyKzApJiYwPT09bi5nZXRVaW50OChyKzEpJiYwPT09bi5nZXRVaW50OChyKzIpJiYxPT09bi5nZXRVaW50OChyKzMpJiY2PT09bi5nZXRVaW50OChyKzQpKXtsZXQgYT1yKzYsbz0wLHM9MDtmb3IoOzI1NT09PShzPW4uZ2V0VWludDgoYSsrKSk7KW8rPTI1NTtvKz1zO2NvbnN0IGk9ZSh0LmRhdGEsYSxvKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaSl9cisrfXJldHVybiBudWxsfShyLnZhbHVlKTt0JiZuLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7c2VpOnR9KX1zLndyaXRlKHIudmFsdWUpLG4ub3B0aW9ucy5wb3J0LnBvc3RNZXNzYWdlKHt0cmFuc2Zvcm1lZDohMH0pLHQobil9fSkpfShyKToidHgiPT09ci5vcHRpb25zLm5hbWUmJmZ1bmN0aW9uIGUobil7by5yZWFkKCkudGhlbigocj0+e2lmKCFyLmRvbmUpe2lmKHIudmFsdWUgaW5zdGFuY2VvZiBSVENFbmNvZGVkVmlkZW9GcmFtZSl7Y29uc3QgZT1hLnNoaWZ0KCk7ZSYmKHIudmFsdWUuZGF0YT10KHIudmFsdWUuZGF0YSxlKSl9cy53cml0ZShyLnZhbHVlKSxuLm9wdGlvbnMucG9ydC5wb3N0TWVzc2FnZSh7dHJhbnNmb3JtZWQ6ITB9KSxlKG4pfX0pKX0ocil9LHNlbGYucG9zdE1lc3NhZ2UoInJlZ2lzdGVyZWQiKSk7Cg==")], { type: "text/javascript" });
  return setTimeout(() => hC.revokeObjectURL(t11), 0), new Worker(hC.createObjectURL(t11));
}
var Bd = /* @__PURE__ */ new Map();
var jd = /* @__PURE__ */ new Map();
function FG(t11, e, n) {
  let i = new Uint8Array(t11, e, n), r = [], o = 0;
  for (; r.length < n; ) o + 3 < n && i[o] === 0 && i[o + 1] === 0 && i[o + 2] === 3 && (i[o + 3] === 0 || i[o + 3] === 1 || i[o + 3] === 2 || i[o + 3] === 3) ? (r.push(i[o], i[o + 1], i[o + 3]), o += 4) : (r.push(i[o]), o++);
  return new Uint8Array(r);
}
var Gd = /* @__PURE__ */ new Map();
async function BG(t11, e) {
  if (!ft().supportWebRTCEncodedTransform) return void _.warning("browser not support video encoded transform");
  if (Gd.has(t11) || !t11.track) return;
  let n = { track: t11.track };
  if (oo()) {
    if (!t11.createEncodedStreams) return void _.warning("browser not support createEncodedStreams() API");
    let r = null;
    try {
      r = t11.createEncodedStreams();
    } catch (a) {
      return void _.error("create video-encoded-streams error", a && a.message);
    }
    let o = [];
    e.on("sei-to-send", (a) => {
      o.push(a);
    });
    let s = new TransformStream({ transform(a, c) {
      n.controller || (n.controller = c), t11.track && t11.track.id !== n.track.id && (_.debug("video track changed: ".concat(n.track.id, " => ").concat(t11.track.id)), n.track.removeEventListener("ended", i), n.track = t11.track, n.track.addEventListener("ended", i));
      let d = o.shift();
      d && (a.data = function(l, u) {
        let h = function(C) {
          let A = C.length, b = [], w = 0;
          for (; w < A; ) w + 2 < A && C[w] === 0 && C[w + 1] === 0 && (C[w + 2] === 0 || C[w + 2] === 1 || C[w + 2] === 2 || C[w + 2] === 3) ? (b.push(C[w], C[w + 1], 3, C[w + 2]), w += 3) : (b.push(C[w]), w++);
          return new Uint8Array(b);
        }(u), p = h.length, g = Math.floor(p / 255), E = p % 255, f = new Uint8Array(6 + g + 1 + p + l.byteLength);
        f[0] = 0, f[1] = 0, f[2] = 0, f[3] = 1, f[4] = 6, f[5] = 101;
        let S = 0;
        for (; S < g; ) f[6 + S] = 255, S++;
        return f[6 + S] = E, S++, f.set(h, 6 + S), f.set(new Uint8Array(l), 6 + S + p), f.buffer;
      }(a.data, d)), c.enqueue(a);
    } });
    r.readable.pipeThrough(s).pipeTo(r.writable);
  } else {
    if (!je()) return;
    {
      if (typeof RTCRtpScriptTransform > "u") return void _.warning("browser not support RTCRtpScriptTransform");
      let r = vl(), o = new MessageChannel();
      await new j((a) => r.onmessage = (c) => {
        c.data === "registered" && a(void 0);
      });
      let s = new RTCRtpScriptTransform(r, { name: "tx", port: o.port2 }, [o.port2]);
      t11.transform = s, await new j((a) => r.onmessage = (c) => {
        c.data === "started" && a(void 0);
      }), e.on("sei-to-send", (a) => {
        o.port1.postMessage({ sei: a });
      }), o.port1.onmessage = (a) => {
        var c;
        a.data.transformed && t11.track && ((c = t11.track) === null || c === void 0 ? void 0 : c.id) !== n.track.id && (_.debug("video track changed: ".concat(n.track.id, " => ").concat(t11.track.id)), n.track.removeEventListener("ended", i), n.track = t11.track, n.track.addEventListener("ended", i));
      }, n.worker = r;
    }
  }
  function i() {
    if (t11.track) {
      if (this.id !== t11.track.id) return;
      t11.track.removeEventListener("ended", i);
    }
    let r = Gd.get(t11);
    if (r) {
      Gd.delete(t11);
      try {
        var o, s;
        (o = r.controller) === null || o === void 0 || o.terminate(), (s = r.worker) === null || s === void 0 || s.terminate();
      } catch (a) {
        _.warning(a && a.message);
      }
    }
  }
  Gd.set(t11, n), t11.track.addEventListener("ended", i);
}
var xa = /* @__PURE__ */ new Map();
(function() {
  let t11 = mt();
  Ne.getDisplayMedia = !(!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia), Ne.getStreamFromExtension = t11.name === It.CHROME && Number(t11.version) > 34, Ne.supportUnifiedPlan = function() {
    if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype)) return false;
    let e = new RTCPeerConnection(), n = false;
    try {
      e.addTransceiver("audio"), n = true;
    } catch {
    }
    return e.close(), n;
  }(), Ne.supportMinBitrate = t11.name === It.CHROME || t11.name === It.EDGE, Ne.supportSetRtpSenderParameters = function() {
    let e = mt();
    return !!(window.RTCRtpSender && window.RTCRtpSender.prototype.setParameters && window.RTCRtpSender.prototype.getParameters) && (!!ho() || !(!je() && !Gl()) || e.name === It.FIREFOX && Number(e.version) >= 64);
  }(), t11.name === It.SAFARI && (Number(t11.version) >= 14 ? Ne.supportDualStream = true : Ne.supportDualStream = false), Ne.webAudioMediaStreamDest = function() {
    let e = mt();
    return !(e.name === It.SAFARI && Number(e.version) < 12);
  }(), Ne.supportReplaceTrack = !!window.RTCRtpSender && typeof RTCRtpSender.prototype.replaceTrack == "function", Ne.supportWebGL = typeof WebGLRenderingContext < "u", Ne.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, ho() || (Ne.webAudioWithAEC = true), Ne.supportShareAudio = function() {
    let e = mt();
    return (e.os === ye.WIN_10 || e.os === ye.WIN_81 || e.os === ye.WIN_7 || e.os === ye.LINUX || e.os === ye.MAC_OS || e.os === ye.CHROMIUM_OS) && e.name === It.CHROME && Number(e.version) >= 74;
  }(), Ne.supportDataChannel = !!(OE(76) || function(e) {
    let n = mt();
    return !(n.name !== It.FIREFOX || !n.osVersion) && Number(n.version) >= e;
  }(68) || mO(14)), Ne.supportPCSetConfiguration = function() {
    let e = window.RTCPeerConnection;
    return !$t() && !!e && e.prototype.setConfiguration instanceof Function;
  }(), Ne.supportWebRTCEncodedTransform = function() {
    let e = mt();
    return e.name === "Chrome" && Number(e.version) >= 86 || e.name === "Safari" && Number(e.version) >= 15;
  }(), Ne.supportWebRTCInsertableStream = function() {
    let e = mt();
    return (e.name === It.CHROME || e.name === It.EDGE) && Number(e.version) >= 94 && "MediaStreamTrackGenerator" in window && "MediaStreamTrackProcessor" in window;
  }(), Ne.supportRequestVideoFrameCallback = "requestVideoFrameCallback" in HTMLVideoElement.prototype, Ne.supportWebCrypto = typeof window < "u" && window.crypto !== void 0 && window.crypto.subtle !== void 0, qu(() => {
    Ne.supportDualStreamEncoding = function() {
      let e = mt();
      return !!v("DISABLE_WEBAUDIO") || e.name === "Safari" && Number(e.version) >= 14 || !!(e.name === "Chrome" && /Windows/i.test(e.os || "") && Number(e.version) >= 100 && v("CHROME_DUAL_STREAM_USE_ENCODING"));
    }(), _.info("browser compatibility", JSON.stringify(Ne), JSON.stringify(t11));
  });
})();
var ia = class t7 extends Xt {
  constructor(e, n) {
    super(), T(this, "signal", void 0), T(this, "token", void 0), T(this, "tokenTimeout", void 0), T(this, "tokenInterval", void 0), T(this, "_sequence", 0), T(this, "userMap", /* @__PURE__ */ new Map()), T(this, "encoder", new TextEncoder()), this.signal = e, this.token = n;
    let i = () => {
      this.signal.connectionState === Lt.CONNECTED && this.check(), this.userMap.size === 0 ? this.tokenInterval = window.setTimeout(i, 1e3) : this.tokenInterval = window.setTimeout(i, 3 * v("P2P_TOKEN_INTERVAL"));
    };
    i();
  }
  async send(e, n, i, r, o) {
    var s, a, c;
    if (this.userMap.size === 0) return;
    let d = Array.from(Pr(s = this.userMap).call(s))[0].token;
    typeof n != "string" && (n = JSON.stringify(n)), r = (a = r) !== null && a !== void 0 ? a : Ut(6, ""), o = (c = o) !== null && c !== void 0 ? c : this._sequence++;
    let l = { _id: r, _type: e, _seq: o, _message: n, token: "".concat(this.token, "_").concat(d) };
    v("SHOW_P2P_LOG") && _.debug("send message", l, "noNeedResponse : ".concat(i)), this.splitMessage(JSON.stringify(l)).forEach((h) => {
      this.signal.request(et.DATA_STREAM, { payload: so(this.encoder.encode(h)) });
    });
    let u = new j((h, p) => {
      let g = window.setTimeout(() => {
        this.off("res-@".concat(r, "_ack"), E), this.off("res-@".concat(r), S), this.off(ps.ABORT, f), _.debug("[external-signal] request timeout, type: ".concat(e, ", requestId: ").concat(r)), this.userMap.size === 0 ? p(new N(R.INVALID_REMOTE_USER)) : p(new N(R.TIMEOUT));
      }, v("EXTERNAL_SIGNAL_REQUEST_TIMEOUT")), E = () => {
        g && window.clearTimeout(g), this.off(ps.ABORT, f), i && h();
      }, f = () => {
        g && window.clearTimeout(g), this.off("res-@".concat(r, "_ack"), E), this.off("res-@".concat(r), S), p(new N(R.EXTERNAL_SIGNAL_ABORT, "type: ".concat(e, ", requestId: ").concat(r)));
      };
      this.once(ps.ABORT, f), this.once("res-@".concat(r, "_ack"), E);
      let S = (A, b) => {
        C = true, g && window.clearTimeout(g), this.off("res-@".concat(r, "_ack"), E), this.off(ps.ABORT, f), A === "success" ? h(b) : p(new N(R.P2P_MESSAGE_FAILED, "request ".concat(e, " failed, requestId: ").concat(r)));
      }, C = false;
      i || (this.once("res-@".concat(r), S), Me(v("SIGNAL_REQUEST_TIMEOUT")).then(() => {
        C || _.warning("external_signal request timeout, type: ".concat(e, ", requestId: ").concat(r, ", ").concat(l));
      }));
    });
    try {
      return await u;
    } catch (h) {
      if (h.code === R.TIMEOUT) return await this.send(e, n, i, r, o);
      throw h;
    }
  }
  onMessage(e) {
    var n;
    let { _uid: i } = e, r, o = this.userMap.get(i);
    if (o) r = o.splitMessageMap;
    else {
      if (this.userMap.size > 0 || !("_type" in e) || e._type !== ie.CHECK) return;
      let { token: d } = e;
      r = /* @__PURE__ */ new Map(), o = { uid: i, isStart: true, token: d, splitMessageMap: r, nextExpectedSequenceNumber: 0, receivedMessagesMap: /* @__PURE__ */ new Map() }, this.userMap.set(i, o), this.signal.emit(dt.ON_USER_ONLINE, { uid: i }), this.handleUserOnline();
    }
    if ("id" in e && "total" in e) {
      var s;
      let { id: d, total: l } = e, u = (s = r.get(d)) !== null && s !== void 0 ? s : [];
      if (u.push(e), r.has(d) || r.set(d, u), u.length !== l) return;
      {
        let h = ed(u).call(u, (p, g) => p.index - g.index).map((p) => p.payload).join("");
        r.delete(d), (e = JSON.parse(h))._uid = i;
      }
    }
    let { _type: a, token: c } = e;
    if (W(n = [ie.ACK, ie.CHECK]).call(n, a)) return a === ie.CHECK && this.handleCheckToken(o, c), void this.receiveMessage(e);
    c === "".concat(o.token, "_").concat(this.token) ? this.handleReceivedMessage(e) : _.debug('Receive unexpected message", '.concat(c, ", cur_token: ").concat(o.token, "_").concat(this.token), e);
  }
  check() {
    let e = { _id: Ut(6, ""), token: this.token, _type: ie.CHECK };
    v("SHOW_P2P_LOG") && _.debug("send message", e), this.signal.request(et.DATA_STREAM, { payload: so(this.encoder.encode(JSON.stringify(e))) });
  }
  ack(e) {
    let n = { _id: e, _type: ie.ACK, token: this.token };
    v("SHOW_P2P_LOG") && _.debug("send message", n), this.signal.request(et.DATA_STREAM, { payload: so(this.encoder.encode(JSON.stringify(n))) });
  }
  response(e, n, i) {
    this.send(ie.RESPONSE, JSON.stringify({ success: !i, message: n }), true, e);
  }
  handleReceivedMessage(e) {
    let n = () => {
      this.userMap.forEach((d) => {
        let { receivedMessagesMap: l, nextExpectedSequenceNumber: u } = d;
        for (; l.has(u); ) {
          let h = l.get(u);
          l.delete(u), this.receiveMessage(h), d.nextExpectedSequenceNumber++;
        }
      });
    };
    if (!e) return void n();
    let { _uid: i, _seq: r } = e, o = this.userMap.get(i), { receivedMessagesMap: s, isStart: a, nextExpectedSequenceNumber: c } = o;
    if (r < c) return this.ack(e._id), void _.debug("[external-signal] receive old message, seq: ".concat(r, ", ").concat(e._message));
    s.set(r, e), a && r === c && (this.receiveMessage(e), s.delete(c), o.nextExpectedSequenceNumber++, n());
  }
  receiveMessage(e) {
    let { _id: n, _type: i, _message: r, _uid: o } = e;
    if (v("SHOW_P2P_LOG") && _.debug("receive message", e), n) {
      let s;
      switch (e._type !== ie.ACK && (r && (s = JSON.parse(r)), this.ack(e._id)), e._type) {
        case ie.CANDIDATE:
        case ie.CONTROL:
          this.signal.emit(i, s, o);
          break;
        case ie.PUBLISH:
        case ie.UNPUBLISH:
        case ie.RESTART_ICE:
        case ie.CALL:
          s.uid = o, Ge(this.signal, i, s).then((a) => {
            this.response(e._id, a);
          }).catch(() => {
            this.response(e._id, void 0, true);
          });
          break;
        case ie.ACK:
          this.getListeners("res-@".concat(n, "_ack")).length > 0 && this.emit("res-@".concat(n, "_ack"));
          break;
        case ie.RESPONSE: {
          let { success: a, message: c } = s;
          this.emit("res-@".concat(n), a ? "success" : "failed", c);
          break;
        }
      }
    }
  }
  splitMessage(e) {
    if (e.length < t7.MAX_MESSAGE_SIZE) return [e];
    let n = [], { remoteToken: i } = JSON.parse(e), r = Ut(6, ""), o = 0, s = 800, a = Math.ceil(e.length / s);
    for (; e.length > 0; ) {
      o++;
      let c = { id: r, index: o, total: a, payload: e.slice(0, s), token: "".concat(this.token, "_").concat(i) };
      JSON.stringify(c).length > t7.MAX_MESSAGE_SIZE ? s -= 50 : (n.push(c), e = e.slice(s));
    }
    return n.map((c) => JSON.stringify(c));
  }
  handleCheckToken(e, n) {
    return e.token !== n ? (_.debug("token changed, from ".concat(e.token, " to ").concat(n)), this.reset(e.uid, n), false) : (this.tokenTimeout && (window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0), this.tokenTimeout = window.setTimeout(() => {
      _.debug("token timeout, ".concat(n)), this.reset(e.uid);
    }, v("MAX_P2P_TIMEOUT")), true);
  }
  async handleUserOnline() {
    let e = await Ge(this.signal, ie.CALL, void 0), n = await this.send(ie.CALL, e);
    this.signal.emit(nt.P2P_CONNECTION, n, true);
  }
  async reset(e, n) {
    let i = this.userMap.get(e);
    i && (this.emit(ps.ABORT), this.signal.emit(dt.ON_USER_OFFLINE, { uid: i.uid, reason: cj.P2P_TOKEN_CHANGED }), this._sequence = 0, this.userMap.clear(), n || (_.debug("change local token from ".concat(n, " to ").concat(n)), this.token = Ut(6, "")));
  }
  clear() {
    this._sequence = 0, this.userMap.clear(), this.tokenInterval && window.clearTimeout(this.tokenInterval), this.tokenInterval = void 0, this.tokenTimeout && window.clearTimeout(this.tokenTimeout), this.tokenTimeout = void 0, this.emit(ps.ABORT);
  }
};
T(ia, "MAX_SIZE", 1), T(ia, "MAX_MESSAGE_SIZE", 1024);
var du = class extends Xt {
  get connectionState() {
    return this._connectionState;
  }
  set connectionState(e) {
    e !== this._connectionState && (this._connectionState = e, e === Lt.CONNECTED ? this.emit(nt.WS_CONNECTED) : e === Lt.RECONNECTING ? this.emit(nt.WS_RECONNECTING, this._websocketReconnectReason) : e === Lt.CLOSED && this.emit(nt.WS_CLOSED, this._disconnectedReason));
  }
  get currentURLIndex() {
    return this.websocket.currentURLIndex;
  }
  get url() {
    return this.websocket && this.websocket.url || null;
  }
  get rtt() {
    return this.rttRolling.mean();
  }
  constructor(e, n) {
    super(), T(this, "_disconnectedReason", void 0), T(this, "_websocketReconnectReason", void 0), T(this, "_connectionState", Lt.CLOSED), T(this, "reconnectToken", void 0), T(this, "p2pToken", void 0), T(this, "websocket", void 0), T(this, "openConnectionTime", void 0), T(this, "clientId", void 0), T(this, "lastMsgTime", Date.now()), T(this, "uploadCache", []), T(this, "uploadCacheInterval", void 0), T(this, "rttRolling", new Hl(5)), T(this, "pingpongTimer", void 0), T(this, "pingpongTimeoutCount", 0), T(this, "joinResponse", void 0), T(this, "multiIpOption", void 0), T(this, "initError", void 0), T(this, "spec", void 0), T(this, "store", void 0), T(this, "_external_signal", void 0), T(this, "onWebsocketMessage", (i) => {
      if (i.data instanceof ArrayBuffer) return void this.emit(nt.ON_BINARY_DATA, i.data);
      let r = JSON.parse(i.data);
      if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(r, "_id")) {
        let o = "res-@".concat(r._id);
        this.emit(o, r._result, r._message);
      } else if (Object.prototype.hasOwnProperty.call(r, "_type")) {
        switch (r._type) {
          case dt.ON_DATA_STREAM:
            return void this.handleDataStream(r._message);
          case dt.MUTE_AUDIO:
          case dt.MUTE_VIDEO:
          case dt.ON_P2P_LOST:
          case dt.ON_USER_ONLINE:
            return;
          case dt.ON_USER_OFFLINE:
            let { uid: o } = r._message;
            return _.debug("[".concat(this.clientId, "] user-offline uid: ").concat(o)), void this._external_signal.reset(o);
        }
        if (this.emit(r._type, r._message), r._type === dt.ON_NOTIFICATION && this.handleNotification(r._message), r._type === dt.ON_USER_BANNED) switch (r._message.error_code) {
          case 14:
            this.close(At.UID_BANNED);
            break;
          case 15:
            this.close(At.IP_BANNED);
            break;
          case 16:
            this.close(At.CHANNEL_BANNED);
        }
        if (r._type === dt.ON_USER_LICENSE_BANNED) switch (r._message.error_code) {
          case Z.ERR_LICENSE_MISSING:
            this.close(At.LICENSE_MISSING);
            break;
          case Z.ERR_LICENSE_EXPIRED:
            this.close(At.LICENSE_EXPIRED);
            break;
          case Z.ERR_LICENSE_MINUTES_EXCEEDED:
            this.close(At.LICENSE_MINUTES_EXCEEDED);
            break;
          case Z.ERR_LICENSE_PERIOD_INVALID:
            this.close(At.LICENSE_PERIOD_INVALID);
            break;
          case Z.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
            this.close(At.LICENSE_MULTIPLE_SDK_SERVICE);
            break;
          case Z.ERR_LICENSE_ILLEGAL:
            this.close(At.LICENSE_ILLEGAL);
            break;
          default:
            this.close();
        }
      }
    }), this.clientId = e.clientId, this.spec = e, this.store = n, this.websocket = new Nc("gateway-".concat(this.clientId), this.spec.retryConfig, true, v("JOIN_GATEWAY_USE_DUAL_DOMAIN"), v("JOIN_GATEWAY_USE_443PORT_ONLY"), n), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
      this.connectionState === Lt.CONNECTED && this.reconnect("retry", Be.OFFLINE);
    }), this.p2pToken = Ut(6, ""), this._external_signal = new ia(this, this.p2pToken);
  }
  async request(e, n, i, r) {
    let o = Ut(6, ""), s = { _id: o, _type: e, _message: n }, a = this.websocket.connectionID, c = () => new j((g, E) => {
      if (this.connectionState === Lt.CONNECTED) return g();
      let f = () => {
        this.off(nt.WS_CLOSED, S), g();
      }, S = () => {
        this.off(nt.WS_CONNECTED, f), E(new N(R.WS_ABORT));
      };
      this.once(nt.WS_CONNECTED, f), this.once(nt.WS_CLOSED, S);
    });
    if (this.connectionState !== Lt.CONNECTING && this.connectionState !== Lt.RECONNECTING || e === et.JOIN || e === et.REJOIN || await c(), this.websocket.sendMessage(s, true), r) return;
    let d = new j((g, E) => {
      let f = false, S = (A, b) => {
        f = true, g({ isSuccess: A === "success", message: b || {} }), this.off(nt.WS_CLOSED, C), this.off(nt.WS_RECONNECTING, C), this.emit(nt.REQUEST_SUCCESS, e, n);
      };
      this.once("res-@".concat(o), S);
      let C = () => {
        E(new N(R.WS_ABORT, "type: ".concat(e))), this.off(nt.WS_CLOSED, C), this.off(nt.WS_RECONNECTING, C), this.off("res-@".concat(o), S);
      };
      this.once(nt.WS_CLOSED, C), this.once(nt.WS_RECONNECTING, C), Me(v("SIGNAL_REQUEST_TIMEOUT")).then(() => {
        this.websocket.connectionID !== a || f || (_.warning("[".concat(this.clientId, "] ws request timeout, type: ").concat(e)), this.emit(nt.REQUEST_TIMEOUT, e, n));
      });
    }), l = null;
    try {
      l = await d;
    } catch (g) {
      if (this.connectionState === Lt.CLOSED || e === et.LEAVE) throw new N(R.WS_ABORT);
      return !this.spec.forceWaitGatewayResponse || i ? g.throw() : e === et.JOIN || e === et.REJOIN ? null : (await c(), await this.request(e, n));
    }
    if (l.isSuccess) return l.message;
    let u = Number(l.message.error_code || l.message.code), h = Oc(u), p = new N(R.UNEXPECTED_RESPONSE, "".concat(h.desc, ": ").concat(l.message.error_str), { code: u, data: l.message, desc: h.desc });
    return h.action === "success" ? l.message : (_.warning("[".concat(this.clientId, "] [").concat(this.websocket.connectionID, "] unexpected response from type ").concat(e, ", error_code: ").concat(u, ", message: ").concat(h.desc, ", action: ").concat(h.action)), u === Z.ERR_TOO_MANY_BROADCASTERS ? ((e === et.JOIN || e === et.REJOIN) && (this.initError = p, this.close()), p.throw()) : h.action === "failed" ? p.throw() : h.action === "quit" ? (this.initError = p, this.close(), p.throw()) : (u === Z.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = l.message.option, _.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", Be.MULTI_IP)) : this.reconnect(h.action, Be.SERVER_ERROR), e === et.JOIN || e === et.REJOIN ? null : await this.request(e, n)));
  }
  waitMessage(e, n) {
    return new j((i) => {
      let r = (o) => {
        (!n || n(o)) && (this.off(e, r), i(o));
      };
      this.on(e, r);
    });
  }
  uploadWRTCStats(e) {
    if (!this.store.sessionId) return void _.warn("[".concat(this.clientId, "] no session id when upload wrtc stats"));
    let n = { lts: Date.now(), sid: this.store.sessionId, uid: this.store.intUid, stats: e };
    this.upload(wc.WRTC_STATS, n);
  }
  upload(e, n) {
    let i = { _type: e, _message: n };
    try {
      this.websocket.sendMessage(i);
    } catch {
      let o = v("MAX_UPLOAD_CACHE") || 50;
      this.uploadCache.push(i), this.uploadCache.length > o && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
        if (this.connectionState !== Lt.CONNECTED) return;
        let s = this.uploadCache.splice(0, 1)[0];
        this.uploadCache.length === 0 && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(s._type, s._message);
      }, v("UPLOAD_CACHE_INTERVAL") || 2e3));
    }
  }
  send(e, n) {
    let i = { _type: e, _message: n };
    this.websocket.sendMessage(i);
  }
  async sendExtensionMessage(e, n, i) {
    return await this._external_signal.send(e, n, i);
  }
  init(e) {
    return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new j((n, i) => {
      this.once(nt.WS_CONNECTED, () => n(this.joinResponse)), this.once(nt.WS_CLOSED, () => i(this.initError || new N(R.WS_ABORT))), this.connectionState = Lt.CONNECTING, this.websocket.init(e).catch(i);
    });
  }
  close(e) {
    this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._external_signal.clear(), this._disconnectedReason = e || At.LEAVE, this.connectionState = Lt.CLOSED, _.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), this.p2pToken = Ut(6, ""), this._external_signal.clear(), this._external_signal = new ia(this, this.p2pToken);
  }
  async join() {
    if (!this.joinResponse) {
      this.emit(nt.ABORT_P2P_EXECUTION);
      let e = await Ge(this, nt.REQUEST_JOIN_INFO), n = await this.request(et.JOIN, e);
      if (!n) return this.emit(nt.REPORT_JOIN_GATEWAY, R.TIMEOUT, this.url || ""), false;
      this.joinResponse = n, this.emit(nt.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;
    }
    return this.connectionState = Lt.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), true;
  }
  reconnect(e, n) {
    this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e, n);
  }
  handleDataStream(e) {
    try {
      var n;
      let i = Fo(e.payload), r = new TextDecoder().decode(i), o = JSON.parse(r);
      "total" in o && "id" in o || W(n = Object.values(ie)).call(n, o._type) ? (o._uid = e.uid, this._external_signal.onMessage(o)) : this.emit(dt.ON_DATA_STREAM, e);
    } catch {
      this.emit(dt.ON_DATA_STREAM, e);
    }
  }
  handleNotification(e) {
    _.debug("[".concat(this.clientId, "] receive notification: "), e);
    let n = Oc(e.code);
    if (n.action !== "success") {
      if (n.action !== "failed") return n.action === "quit" ? (n.desc === "ERR_REPEAT_JOIN_CHANNEL" && this.close(At.UID_BANNED), void this.close()) : void this.reconnect(n.action, Be.SERVER_ERROR);
      _.error("[".concat(this.clientId, "] ignore error: "), n.desc);
    }
  }
  handlePingPong() {
    if (!this.websocket || this.websocket.state !== "connected") return;
    this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
    let e = v("PING_PONG_TIME_OUT"), n = Date.now();
    this.pingpongTimeoutCount >= e && (_.warning("[".concat(this.clientId, "] PINGPONG Timeout. Last Socket Message: ").concat(n - this.lastMsgTime, "ms")), n - this.lastMsgTime > v("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", Be.TIMEOUT) : this.request(et.PING, void 0, true).then(() => {
      this.pingpongTimeoutCount = 0;
      let i = Date.now() - n;
      this.rttRolling.add(i), v("REPORT_STATS") && this.send(et.PING_BACK, { pingpongElapse: i });
    }).catch((i) => {
    });
  }
  handleWebsocketEvents() {
    this.websocket.on(it.RECONNECT_WAITTING_FINISH, (e) => {
      this.emit(nt.WS_RECONNECT_WAITTING_FINISH, e);
    }), this.websocket.on(it.RECONNECT_CREATE_CONNECTION, (e) => {
      this.emit(nt.WS_RECONNECT_CREATE_CONNECTION, e);
    }), this.websocket.on(it.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(it.CLOSED, () => {
      this.connectionState = Lt.CLOSED;
    }), this.websocket.on(it.FAILED, () => {
      this._disconnectedReason = At.NETWORK_ERROR, this.connectionState = Lt.CLOSED;
    }), this.websocket.on(it.RECONNECTING, (e) => {
      this._websocketReconnectReason = e, this.joinResponse = void 0, this.connectionState === Lt.CONNECTED ? this.connectionState = Lt.RECONNECTING : this.connectionState = Lt.CONNECTING;
    }), this.websocket.on(it.WILL_RECONNECT, (e, n, i) => {
      e !== "retry" ? (_.debug("".concat(this.clientId, " websocket will_connect event, renewSession reconnectMode is ").concat(e)), this.reconnectToken = void 0) : _.debug("".concat(this.clientId, " reconnect mode is retry, no need to renew session")), i(e);
    }), this.websocket.on(it.CONNECTED, () => {
      this.openConnectionTime = Date.now(), this.join().catch((e) => {
        if (this.emit(nt.REPORT_JOIN_GATEWAY, e, this.url || ""), e instanceof N && e.code === R.UNEXPECTED_RESPONSE && e.data.code === Z.ERR_NO_AUTHORIZED) return _.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", Be.SERVER_ERROR);
        _.error("[".concat(this.clientId, "] join gateway request failed"), e.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", Be.SERVER_ERROR) : (this.initError = e, this.close());
      });
    }), this.websocket.on(it.REQUEST_NEW_URLS, (e, n) => {
      Ge(this, nt.REQUEST_RECOVER, this.multiIpOption).then(e).catch(n);
    }), this.websocket.on(it.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
      this.emit(dt.ON_TOKEN_PRIVILEGE_DID_EXPIRE);
    });
  }
};
var e0 = { exports: {} };
e0.exports = (() => {
  var t11 = { 8: (i, r, o) => {
    o.r(r), o.d(r, { Parser: () => V, Printer: () => ce, parse: () => F, print: () => Y });
    let s = `
`, a = "".concat("\r").concat(s), c = " ", d;
    function l(M) {
      return M >= "0" && M <= "9";
    }
    function u(M) {
      return M >= "!" && M <= "~";
    }
    function h(M) {
      return u(M) || M >= "Â" && M <= "Ã¿";
    }
    function p(M) {
      return M === "!" || M >= "#" && M <= "'" || M >= "*" && M <= "+" || M >= "-" && M <= "." || M >= "0" && M <= "9" || M >= "A" && M <= "Z" || M >= "^" && M <= "~";
    }
    function g(M) {
      return M >= "1" && M <= "9";
    }
    function E(M) {
      return M >= "A" && M <= "Z" || M >= "a" && M <= "z";
    }
    function f(M) {
      return M === "d" || M === "h" || M === "m" || M === "s";
    }
    function S(M) {
      return M > "" && M < "	" || M > "\v" && M < "\f" || M > "" && M < "Ã¿";
    }
    function C(M) {
      return E(M) || l(M) || M === "+" || M === "/";
    }
    function A(M) {
      return l(M) || E(M) || M === "+" || M === "/" || M === "-" || M === "_";
    }
    function b(M) {
      return E(M) || l(M) || M === "+" || M === "/";
    }
    function w(M, m) {
      var I = Object.keys(M);
      if (Object.getOwnPropertySymbols) {
        var y = Object.getOwnPropertySymbols(M);
        m && (y = y.filter(function(x) {
          return Object.getOwnPropertyDescriptor(M, x).enumerable;
        })), I.push.apply(I, y);
      }
      return I;
    }
    function D(M) {
      for (var m = 1; m < arguments.length; m++) {
        var I = arguments[m] != null ? arguments[m] : {};
        m % 2 ? w(Object(I), true).forEach(function(y) {
          k(M, y, I[y]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(M, Object.getOwnPropertyDescriptors(I)) : w(Object(I)).forEach(function(y) {
          Object.defineProperty(M, y, Object.getOwnPropertyDescriptor(I, y));
        });
      }
      return M;
    }
    function k(M, m, I) {
      return m in M ? Object.defineProperty(M, m, { value: I, enumerable: true, configurable: true, writable: true }) : M[m] = I, M;
    }
    (function(M) {
      M.VERSION = "v", M.ORIGIN = "o", M.SESSION_NAME = "s", M.INFORMATION = "i", M.URI = "u", M.EMAIL = "e", M.PHONE = "p", M.CONNECTION = "c", M.BANDWIDTH = "b", M.TIME = "t", M.REPEAT = "r", M.ZONE_ADJUSTMENTS = "z", M.KEY = "k", M.ATTRIBUTE = "a", M.MEDIA = "m";
    })(d || (d = {}));
    class B {
      consumeText(m, I) {
        let y = I;
        for (; y < m.length; ) {
          let x = m[y];
          if (x === "\0" || x === "\r" || x === s) break;
          y += 1;
        }
        if (y - I == 0) throw new Error("Invalid text, at ".concat(m));
        return y;
      }
      consumeUnicastAddress(m, I, y) {
        return this.consumeTill(m, I, c);
      }
      consumeOneOrMore(m, I, y) {
        let x = I;
        for (; y(m[x]); ) x++;
        if (x - I == 0) throw new Error("Invalid rule at ".concat(I, "."));
        return x;
      }
      consumeSpace(m, I) {
        if (m[I] === c) return I + 1;
        throw new Error("Invalid space at ".concat(I, "."));
      }
      consumeIP4Address(m, I) {
        let y = I;
        for (let x = 0; x < 4; x++) if (y = this.consumeDecimalUChar(m, y), x !== 3) {
          if (m[y] !== ".") throw new Error("Invalid IP4 address.");
          y++;
        }
        return y;
      }
      consumeDecimalUChar(m, I) {
        let y = I;
        for (let rt = 0; rt < 3 && l(m[y]); rt++, y++) ;
        if (y - I == 0) throw new Error("Invalid decimal uchar.");
        let x = parseInt(m.slice(I, y));
        if (x >= 0 && x <= 255) return y;
        throw new Error("Invalid decimal uchar");
      }
      consumeIP6Address(m, I) {
        let y = this.consumeHexpart(m, I);
        return m[y] === ":" && (y += 1, y = this.consumeIP4Address(m, y)), y;
      }
      consumeHexpart(m, I) {
        let y = I;
        if (m[y] === ":" && m[y + 1] === ":") {
          y += 2;
          try {
            y = this.consumeHexseq(m, y);
          } catch {
          }
          return y;
        }
        if (y = this.consumeHexseq(m, y), m[y] === ":" && m[y + 1] === ":") {
          y += 2;
          try {
            y = this.consumeHexseq(m, y);
          } catch {
          }
          return y;
        }
        return y;
      }
      consumeHexseq(m, I) {
        let y = I;
        for (; y = this.consumeHex4(m, y), m[y] === ":" && m[y + 1] !== ":"; ) y += 1;
        return y;
      }
      consumeHex4(m, I) {
        let y = 0;
        for (; y < 4; y++) if (!((x = m[I + y]) >= "0" && x <= "9" || x >= "a" && x <= "f" || x >= "A" && x <= "F")) {
          if (y === 0) throw new Error("Invalid hex 4");
          break;
        }
        var x;
        return I + y;
      }
      consumeFQDN(m, I) {
        let y = I;
        for (; l(m[y]) || E(m[y]) || m[y] === "-" || m[y] === "."; ) y += 1;
        if (y - I < 4) throw new Error("Invalid FQDN");
        return y;
      }
      consumeExtnAddr(m, I) {
        return this.consumeOneOrMore(m, I, h);
      }
      consumeMulticastAddress(m, I, y) {
        switch (y) {
          case "IP4":
          case "ip4":
            return this.consumeIP4MulticastAddress(m, I);
          case "IP6":
          case "ip6":
            return this.consumeIP6MulticastAddress(m, I);
          default:
            try {
              return this.consumeFQDN(m, I);
            } catch {
              return this.consumeExtnAddr(m, I);
            }
        }
      }
      consumeIP6MulticastAddress(m, I) {
        let y = this.consumeHexpart(m, I);
        return m[y] === "/" ? this.consumeInteger(m, y + 1) : y;
      }
      consumeIP4MulticastAddress(m, I) {
        let y = I + 3, x = m.slice(I, y), rt = parseInt(x);
        if (rt < 224 || rt > 239) throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");
        for (let bt = 0; bt < 3; bt++) {
          if (m[y] !== ".") throw new Error("Invalid IP4 multicast address.");
          y += 1, y = this.consumeDecimalUChar(m, y);
        }
        return m[y] === "/" && (y += 1), y = this.consumeTTL(m, y), m[y] === "/" && (y = this.consumeInteger(m, y)), y;
      }
      consumeInteger(m, I) {
        if (!g(m[I])) throw new Error("Invalid integer.");
        for (I += 1; l(m[I]); ) I += 1;
        return I;
      }
      consumeTTL(m, I) {
        if (m[I] === "0") return I + 1;
        if (!g(m[I])) throw new Error("Invalid TTL.");
        I += 1;
        for (let y = 0; y < 2 && l(m[I]); y++) I += 1;
        return I;
      }
      consumeToken(m, I) {
        return this.consumeOneOrMore(m, I, p);
      }
      consumeTime(m, I) {
        let y = I;
        if (m[y] === "0") return y + 1;
        for (g(m[y]) && (y += 1); l(m[y]); ) y++;
        if (y - I < 10) throw new Error("Invalid time");
        return y;
      }
      consumeAddress(m, I) {
        return this.consumeTill(m, I, c);
      }
      consumeTypedTime(m, I) {
        let y = I;
        return y = this.consumeOneOrMore(m, y, l), f(m[y]) ? y + 1 : y;
      }
      consumeRepeatInterval(m, I) {
        if (!g(m[I])) throw new Error("Invalid repeat interval");
        for (I += 1; l(m[I]); ) I += 1;
        return f(m[I]) && (I += 1), I;
      }
      consumePort(m, I) {
        return this.consumeOneOrMore(m, I, l);
      }
      consume(m, I, y) {
        for (let x = 0; x < y.length; x++) {
          if (I + x >= m.length) throw new Error("consume exceeding value length");
          if (m[I + x] !== y[x]) throw new Error("consume ".concat(y, " failed at ").concat(x));
        }
        return I + y.length;
      }
      consumeTill(m, I, y) {
        let x = I;
        for (; x < m.length && (typeof y != "string" || m[x] !== y) && (typeof y != "function" || !y(m[x])); ) x++;
        return x;
      }
    }
    class V extends B {
      constructor() {
        super(), k(this, "records", []), k(this, "currentLine", 0);
      }
      parse(m) {
        let I = this.probeEOL(m);
        this.records = m.split(I).filter((_e) => !!rn(_e).call(_e)).map(this.parseLine), this.currentLine = 0;
        let y = this.parseVersion(), x = this.parseOrigin(), rt = this.parseSessionName(), bt = this.parseInformation(), Re = this.parseUri(), fn = this.parseEmail(), gr = this.parsePhone(), sd = this.parseConnection(), ad = this.parseBandWidth(), qn = this.parseTimeFields(), Mr = this.parseKey(), rs = this.parseSessionAttribute(), ee = this.parseMediaDescription();
        if (this.currentLine !== this.records.length) throw new Error("parsing failed, non exhaustive sdp lines.");
        return { version: y, origin: x, sessionName: rt, information: bt, uri: Re, emails: fn, phones: gr, connection: sd, bandwidths: ad, timeFields: qn, key: Mr, attributes: rs, mediaDescriptions: ee };
      }
      getCurrentRecord() {
        let m = this.records[this.currentLine];
        if (!m) throw new Error("Record doesn't exit.");
        return m;
      }
      probeEOL(m) {
        for (let I = 0; I < m.length; I++) if (m[I] === s) return m[I - 1] === "\r" ? a : s;
        throw new Error("Invalid newline character.");
      }
      parseLine(m, I) {
        if (m.length < 2) throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");
        let y = m[0];
        if (m[1] !== "=") throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');
        return { type: y, value: m.slice(2), line: I, cur: 0 };
      }
      parseSessionAttribute() {
        let m = new lt();
        for (; this.currentLine < this.records.length; ) {
          let I = this.getCurrentRecord();
          if (I.type !== d.ATTRIBUTE) break;
          let y = { attField: this.extractOneOrMore(I, (x) => p(x) && x !== ":"), _cur: 0 };
          I.value[I.cur] === ":" && (I.cur += 1, y.attValue = this.extractOneOrMore(I, S)), m.parse(y), this.currentLine++;
        }
        return m.digest();
      }
      parseMediaAttributes(m) {
        let I = new vt(m);
        for (; this.currentLine < this.records.length; ) {
          let y = this.getCurrentRecord();
          if (y.type !== d.ATTRIBUTE) break;
          let x = { attField: this.extractOneOrMore(y, (rt) => p(rt) && rt !== ":"), _cur: 0 };
          y.value[y.cur] === ":" && (y.cur += 1, x.attValue = this.extractOneOrMore(y, S)), I.parse(x), this.currentLine++;
        }
        return I.digest();
      }
      parseKey() {
        let m = this.getCurrentRecord();
        if (m.type === d.KEY) {
          if (m.value === "prompt" || m.value === "clear:" || m.value === "base64:" || m.value === "uri:") return m.value;
          throw this.currentLine++, new Error("Invalid key.");
        }
      }
      parseZone() {
        let m = this.getCurrentRecord();
        if (m.type === d.ZONE_ADJUSTMENTS) {
          let I = [];
          for (; ; ) try {
            let y = this.extract(m, this.consumeTime);
            this.consumeSpaceForRecord(m);
            let x = false;
            m.value[m.cur] === "-" && (x = true, m.cur += 1);
            let rt = this.extract(m, this.consumeTypedTime);
            I.push({ time: y, typedTime: rt, back: x });
          } catch {
            break;
          }
          if (I.length === 0) throw new Error("Invalid zone adjustments");
          return this.currentLine++, I;
        }
        return [];
      }
      parseRepeat() {
        let m = [];
        for (; ; ) {
          let I = this.getCurrentRecord();
          if (I.type !== d.REPEAT) break;
          {
            let y = this.extract(I, this.consumeRepeatInterval), x = this.parseTypedTime(I);
            m.push({ repeatInterval: y, typedTimes: x }), this.currentLine++;
          }
        }
        return m;
      }
      parseTypedTime(m) {
        let I = [];
        for (; ; ) try {
          this.consumeSpaceForRecord(m), I.push(this.extract(m, this.consumeTypedTime));
        } catch {
          break;
        }
        if (I.length === 0) throw new Error("Invalid typed time.");
        return I;
      }
      parseTime() {
        let m = this.getCurrentRecord(), I = this.extract(m, this.consumeTime);
        this.consumeSpaceForRecord(m);
        let y = this.extract(m, this.consumeTime);
        return this.currentLine++, { startTime: I, stopTime: y };
      }
      parseBandWidth() {
        let m = [];
        for (; this.currentLine < this.records.length; ) {
          let I = this.getCurrentRecord();
          if (I.type !== d.BANDWIDTH) break;
          {
            let y = this.extractOneOrMore(I, p);
            if (I.value[I.cur] !== ":") throw new Error("Invalid bandwidth field.");
            I.cur++;
            let x = this.extractOneOrMore(I, l);
            m.push({ bwtype: y, bandwidth: x }), this.currentLine++;
          }
        }
        return m;
      }
      parseVersion() {
        let m = this.getCurrentRecord();
        if (m.type !== d.VERSION) throw new Error("first sdp record must be version");
        let I = m.value.slice(0, this.consumeOneOrMore(m.value, 0, l));
        if (I.length !== m.value.length) throw new Error('invalid proto version, "v='.concat(m.value, '"'));
        return this.currentLine++, I;
      }
      parseOrigin() {
        let m = this.getCurrentRecord();
        if (m.type !== d.ORIGIN) throw new Error("second line of sdp must be origin");
        let I = this.extractOneOrMore(m, h);
        this.consumeSpaceForRecord(m);
        let y = this.extractOneOrMore(m, l);
        this.consumeSpaceForRecord(m);
        let x = this.extractOneOrMore(m, l);
        this.consumeSpaceForRecord(m);
        let rt = this.extractOneOrMore(m, p);
        this.consumeSpaceForRecord(m);
        let bt = this.extractOneOrMore(m, p);
        this.consumeSpaceForRecord(m);
        let Re = this.extract(m, this.consumeUnicastAddress);
        return this.currentLine++, { username: I, sessId: y, sessVersion: x, nettype: rt, addrtype: bt, unicastAddress: Re };
      }
      parseSessionName() {
        let m = this.getCurrentRecord();
        if (m.type === d.SESSION_NAME) {
          let I = this.extract(m, this.consumeText);
          return this.currentLine++, I;
        }
      }
      parseInformation() {
        let m = this.getCurrentRecord();
        if (m.type !== d.INFORMATION) return;
        let I = this.extract(m, this.consumeText);
        return this.currentLine++, I;
      }
      parseUri() {
        let m = this.getCurrentRecord();
        if (m.type === d.URI) return this.currentLine++, m.value;
      }
      parseEmail() {
        let m = [];
        for (; ; ) {
          let I = this.getCurrentRecord();
          if (I.type !== d.EMAIL) break;
          m.push(I.value), this.currentLine++;
        }
        return m;
      }
      parsePhone() {
        let m = [];
        for (; ; ) {
          let I = this.getCurrentRecord();
          if (I.type !== d.PHONE) break;
          m.push(I.value), this.currentLine++;
        }
        return m;
      }
      parseConnection() {
        let m = this.getCurrentRecord();
        if (m.type === d.CONNECTION) {
          let I = this.extractOneOrMore(m, p);
          this.consumeSpaceForRecord(m);
          let y = this.extractOneOrMore(m, p);
          this.consumeSpaceForRecord(m);
          let x = this.extract(m, this.consumeAddress);
          return this.currentLine++, { nettype: I, addrtype: y, address: x };
        }
      }
      parseMedia() {
        let m = this.getCurrentRecord(), I = this.extract(m, this.consumeToken);
        this.consumeSpaceForRecord(m);
        let y = this.extract(m, this.consumePort);
        m.value[m.cur] === "/" && (m.cur += 1, y += this.extract(m, this.consumeInteger)), this.consumeSpaceForRecord(m);
        let x = [];
        for (x.push(this.extract(m, this.consumeToken)); m.value[m.cur] === "/"; ) m.cur += 1, x.push(this.extract(m, this.consumeToken));
        if (x.length === 0) throw new Error("Invalid proto");
        let rt = this.parseFmt(m);
        return this.currentLine++, { mediaType: I, port: y, protos: x, fmts: rt };
      }
      parseTimeFields() {
        let m = [];
        for (; this.getCurrentRecord().type === d.TIME; ) {
          let I = this.parseTime(), y = this.parseRepeat(), x = this.parseZone();
          m.push({ time: I, repeats: y, zones: x });
        }
        return m;
      }
      parseMediaDescription() {
        let m = [];
        for (; this.currentLine < this.records.length && this.getCurrentRecord().type === d.MEDIA; ) {
          let I = this.parseMedia(), y = this.parseInformation(), x = this.parseConnections(), rt = this.parseBandWidth(), bt = this.parseKey(), Re = this.parseMediaAttributes(I);
          m.push({ media: I, information: y, connections: x, bandwidths: rt, key: bt, attributes: Re });
        }
        return m;
      }
      parseConnections() {
        let m = [];
        for (; this.currentLine < this.records.length && this.getCurrentRecord().type === d.CONNECTION; ) m.push(this.parseConnection());
        return m;
      }
      parseFmt(m) {
        let I = [];
        for (; ; ) try {
          this.consumeSpaceForRecord(m), I.push(this.extract(m, this.consumeToken));
        } catch {
          break;
        }
        if (I.length === 0) throw new Error("Invalid fmts");
        return I;
      }
      extract(m, I) {
        for (var y = arguments.length, x = new Array(y > 2 ? y - 2 : 0), rt = 2; rt < y; rt++) x[rt - 2] = arguments[rt];
        let bt = I.call(this, m.value, m.cur, ...x), Re = m.value.slice(m.cur, bt);
        return m.cur = bt, Re;
      }
      extractOneOrMore(m, I) {
        let y = this.consumeOneOrMore(m.value, m.cur, I), x = m.value.slice(m.cur, y);
        return m.cur = y, x;
      }
      consumeSpaceForRecord(m) {
        if (m.value[m.cur] !== c) throw new Error("Invalid space at ".concat(m.cur, "."));
        m.cur += 1;
      }
    }
    class z extends B {
      constructor() {
        super(...arguments), k(this, "attributes", void 0), k(this, "digested", false);
      }
      extractOneOrMore(m, I, y) {
        let x = this.consumeOneOrMore(m.attValue, m._cur, I), rt = m.attValue.slice(m._cur, x), [bt, Re] = y || [];
        if (typeof bt == "number" && rt.length < bt) throw new Error("error in length, should be more or equal than ".concat(bt, " characters."));
        if (typeof Re == "number" && rt.length > Re) throw new Error("error in length, should be less or equal than ".concat(Re, " characters."));
        return m._cur = x, rt;
      }
      consumeAttributeSpace(m) {
        if (m.attValue[m._cur] !== c) throw new Error("Invalid space at ".concat(m._cur, "."));
        m._cur += 1;
      }
      extract(m, I) {
        if (!m.attValue) throw new Error("Nothing to extract from attValue.");
        for (var y = arguments.length, x = new Array(y > 2 ? y - 2 : 0), rt = 2; rt < y; rt++) x[rt - 2] = arguments[rt];
        let bt = I.call(this, m.attValue, m._cur, ...x), Re = m.attValue.slice(m._cur, bt);
        return m._cur = bt, Re;
      }
      atEnd(m) {
        if (!m.attValue) throw new Error();
        return m._cur >= m.attValue.length;
      }
      peekChar(m) {
        if (!m.attValue) throw new Error();
        return m.attValue[m._cur];
      }
      peek(m, I) {
        if (!m.attValue) throw new Error();
        for (let y = 0; y < I.length; y++) if (I[y] !== m.attValue[m._cur + y]) return false;
        return true;
      }
      parseIceUfrag(m) {
        if (this.attributes.iceUfrag) throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");
        this.attributes.iceUfrag = this.extractOneOrMore(m, C, [4, 256]);
      }
      parseIcePwd(m) {
        if (this.attributes.icePwd) throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");
        this.attributes.icePwd = this.extractOneOrMore(m, C, [22, 256]);
      }
      parseIceOptions(m) {
        if (this.attributes.iceOptions) throw new Error("Invalid ice-options, should be only one 'ice-options' line");
        let I = [];
        for (; !this.atEnd(m); ) {
          I.push(this.extractOneOrMore(m, C));
          try {
            this.consumeAttributeSpace(m);
          } catch (y) {
            if (this.atEnd(m)) break;
            throw y;
          }
        }
        this.attributes.iceOptions = I;
      }
      parseFingerprint(m) {
        let I = this.extract(m, this.consumeToken);
        this.consumeAttributeSpace(m);
        let y = this.extract(m, this.consumeTill);
        this.attributes.fingerprints.push({ hashFunction: I, fingerprint: y });
      }
      parseExtmap(m) {
        let I = this.extractOneOrMore(m, l), y;
        this.peekChar(m) === "/" && (this.extract(m, this.consume, "/"), y = this.extract(m, this.consumeToken)), this.consumeAttributeSpace(m);
        let x = this.extract(m, this.consumeTill, c), rt = D(D({ entry: parseInt(I, 10) }, y && { direction: y }), {}, { extensionName: x });
        this.peekChar(m) === c && (this.consumeAttributeSpace(m), rt.extensionAttributes = this.extract(m, this.consumeTill)), this.attributes.extmaps.push(rt);
      }
      parseSetup(m) {
        if (this.attributes.setup) throw new Error("must only be one single 'a=setup' line.");
        let I = this.extract(m, this.consumeTill);
        if (I !== "active" && I !== "passive" && I !== "actpass" && I !== "holdconn") throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");
        this.attributes.setup = I;
      }
    }
    class lt extends z {
      constructor() {
        super(...arguments), k(this, "attributes", { unrecognized: [], groups: [], extmaps: [], fingerprints: [], identities: [] });
      }
      parse(m) {
        if (this.digested) throw new Error("already digested");
        try {
          switch (m.attField) {
            case "group":
              this.parseGroup(m);
              break;
            case "ice-lite":
              this.parseIceLite();
              break;
            case "ice-ufrag":
              this.parseIceUfrag(m);
              break;
            case "ice-pwd":
              this.parseIcePwd(m);
              break;
            case "ice-options":
              this.parseIceOptions(m);
              break;
            case "fingerprint":
              this.parseFingerprint(m);
              break;
            case "setup":
              this.parseSetup(m);
              break;
            case "tls-id":
              this.parseTlsId(m);
              break;
            case "identity":
              this.parseIdentity(m);
              break;
            case "extmap":
              this.parseExtmap(m);
              break;
            case "msid-semantic":
              this.parseMsidSemantic(m);
              break;
            default:
              m.ignored = true, this.attributes.unrecognized.push(m);
          }
        } catch (I) {
          throw console.error("parsing session attribute ".concat(m.attField, ' error, "a=').concat(m.attField, ":").concat(m.attValue, '"')), I;
        }
        if (!m.ignored && m.attValue && !this.atEnd(m)) throw new Error("attribute parsing error");
      }
      digest() {
        return this.digested = true, this.attributes;
      }
      parseGroup(m) {
        let I = this.extract(m, this.consumeToken), y = [];
        for (; !this.atEnd(m) && this.peekChar(m) === c; ) this.consumeAttributeSpace(m), y.push(this.extract(m, this.consumeToken));
        this.attributes.groups.push({ semantic: I, identificationTag: y });
      }
      parseIceLite() {
        if (this.attributes.iceLite) throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");
        this.attributes.iceLite = true;
      }
      parseTlsId(m) {
        if (this.attributes.tlsId) throw new Error("must be only one tld-id line");
        this.attributes.tlsId = this.extractOneOrMore(m, A);
      }
      parseIdentity(m) {
        let I = this.extractOneOrMore(m, b), y = [];
        for (; !this.atEnd(m) && this.peekChar(m) === c; ) {
          this.consumeAttributeSpace(m);
          let x = this.extract(m, this.consumeToken);
          this.extract(m, this.consume, "=");
          let rt = this.extractOneOrMore(m, (bt) => bt !== c && S(bt));
          y.push({ name: x, value: rt });
        }
        this.attributes.identities.push({ assertionValue: I, extensions: y });
      }
      parseMsidSemantic(m) {
        this.peekChar(m) === c && this.consumeAttributeSpace(m);
        let I = { semantic: this.extract(m, this.consumeToken), identifierList: [] };
        for (; ; ) {
          try {
            this.consumeAttributeSpace(m);
          } catch {
            break;
          }
          if (this.peekChar(m) === "*") {
            this.extract(m, this.consume, "*"), I.applyForAll = true;
            break;
          }
          {
            let y = this.extract(m, this.consumeTill, c);
            I.identifierList.push(y);
          }
        }
        this.attributes.msidSemantic = I;
      }
    }
    class vt extends z {
      constructor(m) {
        super(), k(this, "attributes", void 0), m.protos.indexOf("RTP") !== -1 || m.protos.indexOf("rtp"), this.attributes = { unrecognized: [], candidates: [], extmaps: [], fingerprints: [], imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [] };
      }
      parse(m) {
        if (this.digested) throw new Error("already digested");
        try {
          switch (m.attField) {
            case "extmap":
              this.parseExtmap(m);
              break;
            case "setup":
              this.parseSetup(m);
              break;
            case "ice-ufrag":
              this.parseIceUfrag(m);
              break;
            case "ice-pwd":
              this.parseIcePwd(m);
              break;
            case "ice-options":
              this.parseIceOptions(m);
              break;
            case "candidate":
              this.parseCandidate(m);
              break;
            case "remote-candidate":
              this.parseRemoteCandidate(m);
              break;
            case "end-of-candidates":
              this.parseEndOfCandidates();
              break;
            case "fingerprint":
              this.parseFingerprint(m);
              break;
            case "rtpmap":
              this.parseRtpmap(m);
              break;
            case "ptime":
              this.parsePtime(m);
              break;
            case "maxptime":
              this.parseMaxPtime(m);
              break;
            case "sendrecv":
            case "recvonly":
            case "sendonly":
            case "inactive":
              this.parseDirection(m);
              break;
            case "ssrc":
              this.parseSSRC(m);
              break;
            case "fmtp":
              this.parseFmtp(m);
              break;
            case "rtcp-fb":
              this.parseRtcpFb(m);
              break;
            case "rtcp-mux":
              this.parseRTCPMux();
              break;
            case "rtcp-mux-only":
              this.parseRTCPMuxOnly();
              break;
            case "rtcp-rsize":
              this.parseRTCPRsize();
              break;
            case "rtcp":
              this.parseRTCP(m);
              break;
            case "mid":
              this.parseMid(m);
              break;
            case "msid":
              this.parseMsid(m);
              break;
            case "imageattr":
              this.parseImageAttr(m);
              break;
            case "rid":
              this.parseRid(m);
              break;
            case "simulcast":
              this.parseSimulcast(m);
              break;
            case "sctp-port":
              this.parseSctpPort(m);
              break;
            case "max-message-size":
              this.parseMaxMessageSize(m);
              break;
            case "ssrc-group":
              this.parseSSRCGroup(m);
              break;
            default:
              m.ignored = true, this.attributes.unrecognized.push(m);
          }
        } catch (I) {
          throw console.error("parsing media attribute ".concat(m.attField, ' error, "a=').concat(m.attField, ":").concat(m.attValue, '"')), I;
        }
        if (!m.ignored && m.attValue && !this.atEnd(m)) throw new Error("attribute parsing error");
      }
      parseCandidate(m) {
        let I = this.extractOneOrMore(m, C, [1, 32]);
        this.consumeAttributeSpace(m);
        let y = this.extractOneOrMore(m, l, [1, 5]);
        this.consumeAttributeSpace(m);
        let x = this.extract(m, this.consumeToken);
        this.consumeAttributeSpace(m);
        let rt = this.extractOneOrMore(m, l, [1, 10]);
        this.consumeAttributeSpace(m);
        let bt = this.extract(m, this.consumeAddress);
        this.consumeAttributeSpace(m);
        let Re = this.extract(m, this.consumePort);
        this.consumeAttributeSpace(m), this.extract(m, this.consume, "typ"), this.consumeAttributeSpace(m);
        let fn = { foundation: I, componentId: y, transport: x, priority: rt, connectionAddress: bt, port: Re, type: this.extract(m, this.consumeToken), extension: {} };
        for (this.peek(m, " raddr") && (this.extract(m, this.consume, " raddr"), this.consumeAttributeSpace(m), fn.relAddr = this.extract(m, this.consumeAddress)), this.peek(m, " rport") && (this.extract(m, this.consume, " rport"), this.consumeAttributeSpace(m), fn.relPort = this.extract(m, this.consumePort)); this.peekChar(m) === c; ) {
          this.consumeAttributeSpace(m);
          let gr = this.extract(m, this.consumeToken);
          this.consumeAttributeSpace(m), fn.extension[gr] = this.extractOneOrMore(m, u);
        }
        this.attributes.candidates.push(fn);
      }
      parseRemoteCandidate(m) {
        let I = [];
        for (; ; ) {
          let y = this.extractOneOrMore(m, l, [1, 5]);
          this.consumeAttributeSpace(m);
          let x = this.extract(m, this.consumeAddress);
          this.consumeAttributeSpace(m);
          let rt = this.extract(m, this.consumePort);
          I.push({ componentId: y, connectionAddress: x, port: rt });
          try {
            this.consumeAttributeSpace(m);
          } catch {
            break;
          }
        }
        this.attributes.remoteCandidatesList.push(I);
      }
      parseEndOfCandidates() {
        if (this.attributes.endOfCandidates) throw new Error("must be only one line of end-of-candidates");
        this.attributes.endOfCandidates = true;
      }
      parseRtpmap(m) {
        let I = this.extract(m, this.consumeToken);
        this.consumeAttributeSpace(m);
        let y = this.extract(m, this.consumeTill, "/");
        this.extract(m, this.consume, "/");
        let x = { encodingName: y, clockRate: this.extractOneOrMore(m, l) };
        this.atEnd(m) || this.peekChar(m) !== "/" || (this.extract(m, this.consume, "/"), x.encodingParameters = parseInt(this.extract(m, this.consumeTill), 10));
        let rt = this.attributes.payloads.find((bt) => bt.payloadType === parseInt(I, 10));
        rt ? rt.rtpMap = x : this.attributes.payloads.push({ payloadType: parseInt(I, 10), rtpMap: x, rtcpFeedbacks: [] });
      }
      parsePtime(m) {
        if (this.attributes.ptime) throw new Error("must be only one line of ptime");
        this.attributes.ptime = this.extract(m, this.consumeTill);
      }
      parseMaxPtime(m) {
        if (this.attributes.maxPtime) throw new Error("must be only one line of ptime");
        this.attributes.maxPtime = this.extract(m, this.consumeTill);
      }
      parseDirection(m) {
        if (this.attributes.direction) throw new Error("must be only one line of direction info");
        this.attributes.direction = m.attField;
      }
      parseSSRC(m) {
        let I = this.extractOneOrMore(m, l);
        this.consumeAttributeSpace(m);
        let y = this.extract(m, this.consumeTill, ":"), x;
        this.peekChar(m) === ":" && (this.extract(m, this.consume, ":"), x = this.extract(m, this.consumeTill));
        let rt = this.attributes.ssrcs.find((bt) => bt.ssrcId === parseInt(I, 10));
        rt ? rt.attributes[y] = x : this.attributes.ssrcs.push({ ssrcId: parseInt(I, 10), attributes: { [y]: x } });
      }
      parseFmtp(m) {
        let I = this.extract(m, this.consumeTill, c);
        this.consumeAttributeSpace(m);
        let y = this.extract(m, this.consumeTill), x = {};
        y.split(";").forEach((bt) => {
          let [Re, fn] = bt.split("=");
          Re = rn(Re).call(Re);
          let gr = typeof fn == "string" ? rn(fn).call(fn) : null;
          typeof Re == "string" && Re.length > 0 && (x[Re] = gr);
        });
        let rt = this.attributes.payloads.find((bt) => bt.payloadType === parseInt(I, 10));
        rt ? rt.fmtp = { parameters: x } : this.attributes.payloads.push({ payloadType: parseInt(I, 10), rtcpFeedbacks: [], fmtp: { parameters: x } });
      }
      parseFmtParameters(m) {
        let I = {}, y = this.extract(m, this.consumeTill, "=");
        m._cur++;
        let x = this.extract(m, this.consumeTill, ";");
        for (I[y] = x; m.attValue[m._cur] === ";"; ) {
          let rt = this.extract(m, this.consumeTill, "=");
          m._cur++;
          let bt = this.extract(m, this.consumeTill, ";");
          I[rt] = bt;
        }
        return I;
      }
      parseRtcpFb(m) {
        let I = "";
        I = this.peekChar(m) === "*" ? this.extract(m, this.consume, "*") : this.extract(m, this.consumeTill, c), this.consumeAttributeSpace(m);
        let y = this.extract(m, this.consumeTill, c), x;
        if (y === "trr-int") x = { type: y, interval: this.extract(m, this.consumeTill) };
        else {
          let rt = { type: y };
          this.peekChar(m) === c && (this.consumeAttributeSpace(m), rt.parameter = this.extract(m, this.consumeToken), this.peekChar(m) === c && (rt.additional = this.extract(m, this.consumeTill))), x = rt;
        }
        if (I === "*") this.attributes.rtcpFeedbackWildcards.push(x);
        else {
          let rt = this.attributes.payloads.find((bt) => bt.payloadType === parseInt(I, 10));
          rt ? rt.rtcpFeedbacks.push(x) : this.attributes.payloads.push({ payloadType: parseInt(I, 10), rtcpFeedbacks: [x] });
        }
      }
      parseRTCPMux() {
        if (this.attributes.rtcpMux) throw new Error("must be single line of rtcp-mux");
        this.attributes.rtcpMux = true;
      }
      parseRTCPMuxOnly() {
        if (this.attributes.rtcpMuxOnly) throw new Error("must be single line of rtcp-only");
        this.attributes.rtcpMuxOnly = true;
      }
      parseRTCPRsize() {
        if (this.attributes.rtcpRsize) throw new Error("must be single line of rtcp-rsize");
        this.attributes.rtcpRsize = true;
      }
      parseRTCP(m) {
        if (this.attributes.rtcp) throw new Error("must be single line of rtcp");
        let I = { port: this.extract(m, this.consumePort) };
        this.peekChar(m) === c && (this.consumeAttributeSpace(m), I.netType = this.extractOneOrMore(m, p), this.consumeAttributeSpace(m), I.addressType = this.extractOneOrMore(m, p), this.consumeAttributeSpace(m), I.address = this.extract(m, this.consumeAddress)), this.attributes.rtcp = I;
      }
      parseMsid(m) {
        let I = { id: this.extractOneOrMore(m, p, [1, 64]) };
        this.peekChar(m) === c && (this.consumeAttributeSpace(m), I.appdata = this.extractOneOrMore(m, p, [1, 64])), this.attributes.msids.push(I);
      }
      parseImageAttr(m) {
        this.attributes.imageattr.push(m.attValue);
      }
      parseRid(m) {
        let I = this.extractOneOrMore(m, (x) => E(x) || l(x) || x === "_" || x === "-");
        this.consumeAttributeSpace(m);
        let y = { id: I, direction: this.extract(m, this.consumeToken), params: [] };
        if (this.peekChar(m) === c) {
          if (this.consumeAttributeSpace(m), this.peek(m, "pt=")) {
            this.extract(m, this.consume, "pt=");
            let x = [];
            for (; ; ) {
              let rt = this.extract(m, this.consumeToken);
              x.push(rt);
              try {
                this.extract(m, this.consume, ",");
              } catch {
                break;
              }
            }
            y.payloads = x, this.peekChar(m) === c && this.extract(m, this.consume, c);
          }
          for (; ; ) {
            let x = this.extract(m, this.consumeToken);
            switch (x) {
              case "depend": {
                let rt = { type: x, rids: this.extract(m, this.consume, "=").split(",") };
                y.params.push(rt);
                break;
              }
              default: {
                let rt = { type: x };
                this.peekChar(m) === "=" && (this.extract(m, this.consume, "="), rt.val = this.extract(m, this.consumeTill, ";")), y.params.push(rt);
              }
            }
            try {
              this.extract(m, this.consume, ";");
            } catch {
              break;
            }
          }
        }
        this.attributes.rids.push(y);
      }
      parseSimulcast(m) {
        if (this.attributes.simulcast) throw new Error("must be single line of simulcast");
        this.attributes.simulcast = m.attValue, this.extract(m, this.consumeTill);
      }
      parseSctpPort(m) {
        this.attributes.sctpPort = this.extractOneOrMore(m, l, [1, 5]);
      }
      parseMaxMessageSize(m) {
        this.attributes.maxMessageSize = this.extractOneOrMore(m, l, [1, void 0]);
      }
      digest() {
        return this.digested = true, this.attributes;
      }
      parseMid(m) {
        this.attributes.mid = this.extract(m, this.consumeToken);
      }
      parseSSRCGroup(m) {
        let I = this.extract(m, this.consumeToken), y = [];
        for (; ; ) try {
          this.consumeAttributeSpace(m);
          let x = this.extract(m, this.consumeInteger);
          y.push(parseInt(x, 10));
        } catch {
          break;
        }
        this.attributes.ssrcGroups.push({ semantic: I, ssrcIds: y });
      }
    }
    function Dt(M, m, I) {
      return m in M ? Object.defineProperty(M, m, { value: I, enumerable: true, configurable: true, writable: true }) : M[m] = I, M;
    }
    class ce {
      constructor() {
        Dt(this, "eol", a);
      }
      print(m, I) {
        let y = "";
        return I && (this.eol = I), y += this.printVersion(m.version), y += this.printOrigin(m.origin), y += this.printSessionName(m.sessionName), y += this.printInformation(m.information), y += this.printUri(m.uri), y += this.printEmail(m.emails), y += this.printPhone(m.phones), y += this.printConnection(m.connection), y += this.printBandwidth(m.bandwidths), y += this.printTimeFields(m.timeFields), y += this.printKey(m.key), y += this.printSessionAttributes(m.attributes), y += this.printMediaDescription(m.mediaDescriptions), y;
      }
      printVersion(m) {
        return "v=".concat(m).concat(this.eol);
      }
      printOrigin(m) {
        return "o=".concat(m.username, " ").concat(m.sessId, " ").concat(m.sessVersion, " ").concat(m.nettype, " ").concat(m.addrtype, " ").concat(m.unicastAddress).concat(this.eol);
      }
      printSessionName(m) {
        return m ? "s=".concat(m).concat(this.eol) : "";
      }
      printInformation(m) {
        return m ? "i=".concat(m).concat(this.eol) : "";
      }
      printUri(m) {
        return m ? "u=".concat(m).concat(this.eol) : "";
      }
      printEmail(m) {
        let I = "";
        for (let y of m) I += "e=".concat(y).concat(this.eol);
        return I;
      }
      printPhone(m) {
        let I = "";
        for (let y of m) I += "e=".concat(y).concat(this.eol);
        return I;
      }
      printConnection(m) {
        return m ? "c=".concat(m.nettype, " ").concat(m.addrtype, " ").concat(m.address).concat(this.eol) : "";
      }
      printBandwidth(m) {
        let I = "";
        for (let y of m) I += "b=".concat(y.bwtype, ":").concat(y.bandwidth).concat(this.eol);
        return I;
      }
      printTimeFields(m) {
        let I = "";
        for (let y of m) {
          I += "t=".concat(y.time.startTime, " ").concat(y.time.startTime).concat(this.eol);
          for (let x of y.repeats) I += "r=".concat(x.repeatInterval, " ").concat(x.typedTimes.join(" ")).concat(this.eol);
          y.zoneAdjustments && (I += "z=", I += "z=".concat(y.zoneAdjustments.map((x) => "".concat(x.time, " ").concat(x.back ? "-" : "", " ").concat(x.typedTime)).join(" ")).concat(this.eol), I += this.eol);
        }
        return I;
      }
      printKey(m) {
        return m ? "k=".concat(m).concat(this.eol) : "";
      }
      printAttributes(m) {
        let I = "";
        for (let y of m) I += "a=".concat(y.attField).concat(y.attValue ? ":".concat(y.attValue) : "").concat(this.eol);
        return I;
      }
      printMediaDescription(m) {
        let I = "";
        for (let y of m) I += this.printMedia(y.media), I += this.printInformation(y.information), I += this.printConnections(y.connections), I += this.printBandwidth(y.bandwidths), I += this.printKey(y.key), I += this.printMediaAttributes(y);
        return I;
      }
      printConnections(m) {
        let I = "";
        for (let y of m) I += this.printConnection(y);
        return I;
      }
      printMedia(m) {
        return "m=".concat(m.mediaType, " ").concat(m.port, " ").concat(m.protos.join("/"), " ").concat(m.fmts.join(" ")).concat(this.eol);
      }
      printSessionAttributes(m) {
        return new si(this.eol).print(m);
      }
      printMediaAttributes(m) {
        return new L(this.eol).print(m);
      }
    }
    class Wt {
      constructor(m) {
        Dt(this, "eol", void 0), this.eol = m;
      }
      printIceUfrag(m) {
        return m === void 0 ? "" : "a=ice-ufrag:".concat(m).concat(this.eol);
      }
      printIcePwd(m) {
        return m === void 0 ? "" : "a=ice-pwd:".concat(m).concat(this.eol);
      }
      printIceOptions(m) {
        return m === void 0 ? "" : "a=ice-options:".concat(m.join(c)).concat(this.eol);
      }
      printFingerprints(m) {
        return m.length > 0 ? m.map((I) => "a=fingerprint:".concat(I.hashFunction).concat(c).concat(I.fingerprint)).join(this.eol) + this.eol : "";
      }
      printExtmap(m) {
        return m.map((I) => "a=extmap:".concat(I.entry).concat(I.direction ? "/".concat(I.direction) : "").concat(c).concat(I.extensionName).concat(I.extensionAttributes ? "".concat(c).concat(I.extensionAttributes) : "").concat(this.eol)).join("");
      }
      printSetup(m) {
        return m === void 0 ? "" : "a=setup:".concat(m).concat(this.eol);
      }
      printUnrecognized(m) {
        return m.map((I) => "a=".concat(I.attField).concat(I.attValue ? ":".concat(I.attValue) : "").concat(this.eol)).join("");
      }
    }
    class si extends Wt {
      print(m) {
        let I = "";
        return I += this.printGroups(m.groups), I += this.printMsidSemantic(m.msidSemantic), I += this.printIceLite(m.iceLite), I += this.printIceUfrag(m.iceUfrag), I += this.printIcePwd(m.icePwd), I += this.printIceOptions(m.iceOptions), I += this.printFingerprints(m.fingerprints), I += this.printSetup(m.setup), I += this.printTlsId(m.tlsId), I += this.printIdentity(m.identities), I += this.printExtmap(m.extmaps), I += this.printUnrecognized(m.unrecognized), I;
      }
      printGroups(m) {
        let I = "";
        return m.length > 0 && (I += m.map((y) => "a=group:".concat(y.semantic).concat(y.identificationTag.map((x) => "".concat(c).concat(x)).join("")).concat(this.eol)).join("")), I;
      }
      printIceLite(m) {
        return m === void 0 ? "" : "a=ice-lite" + this.eol;
      }
      printTlsId(m) {
        return m ? "a=tls-id:".concat(m).concat(this.eol) : "";
      }
      printIdentity(m) {
        return m.length === 0 ? "" : m.map((I) => "a=identity:".concat(I.assertionValue).concat(I.extensions.map((y) => "".concat(c).concat(y.name).concat(y.value ? "=".concat(y.value) : "")))).join(this.eol) + this.eol;
      }
      printMsidSemantic(m) {
        if (!m) return "";
        let I = "a=msid-semantic:".concat(m.semantic);
        return m.applyForAll ? I += "".concat(c, "*") : m.identifierList.length > 0 && (I += m.identifierList.map((y) => "".concat(c).concat(y))), I + this.eol;
      }
    }
    class L extends Wt {
      print(m) {
        let I = m.attributes, y = "";
        return y += this.printRTCP(I.rtcp), y += this.printIceUfrag(I.iceUfrag), y += this.printIcePwd(I.icePwd), y += this.printIceOptions(I.iceOptions), y += this.printCandidates(I.candidates), y += this.printRemoteCandidatesList(I.remoteCandidatesList), y += this.printEndOfCandidates(I.endOfCandidates), y += this.printFingerprints(I.fingerprints), y += this.printSetup(I.setup), y += this.printMid(I.mid), y += this.printExtmap(I.extmaps), y += this.printRTPRelated(I), y += this.printPtime(I.ptime), y += this.printMaxPtime(I.maxPtime), y += this.printDirection(I.direction), y += this.printSSRCGroups(I.ssrcGroups), y += this.printSSRC(I.ssrcs), y += this.printRTCPMux(I.rtcpMux), y += this.printRTCPMuxOnly(I.rtcpMuxOnly), y += this.printRTCPRsize(I.rtcpRsize), y += this.printMSId(I.msids), y += this.printImageattr(I.imageattr), y += this.printRid(I.rids), y += this.printSimulcast(I.simulcast), y += this.printSCTPPort(I.sctpPort), y += this.printMaxMessageSize(I.maxMessageSize), y += this.printUnrecognized(I.unrecognized), y;
      }
      printCandidates(m) {
        return m.map((I) => "a=candidate:".concat(I.foundation).concat(c).concat(I.componentId).concat(c).concat(I.transport).concat(c).concat(I.priority).concat(c).concat(I.connectionAddress).concat(c).concat(I.port).concat(c, "typ").concat(c).concat(I.type).concat(I.relAddr ? "".concat(c, "raddr").concat(c).concat(I.relAddr) : "").concat(I.relPort ? "".concat(c, "rport").concat(c).concat(I.relPort) : "").concat(Object.keys(I.extension).map((y) => "".concat(c).concat(y).concat(c).concat(I.extension[y])).join("")).concat(this.eol)).join("");
      }
      printRemoteCandidatesList(m) {
        return m.map((I) => "a=remote-candidates:".concat(I.join(c)).concat(this.eol)).join("");
      }
      printEndOfCandidates(m) {
        return m === void 0 ? "" : "a=end-of-candidates" + this.eol;
      }
      printRTPRelated(m) {
        if (!m.payloads) return "";
        let I = m.payloads, y = "";
        y += m.rtcpFeedbackWildcards.map((x) => this.printRTCPFeedback("*", x)).join("");
        for (let x of I) y += this.printRtpMap(x.payloadType, x.rtpMap), y += this.printFmtp(x.payloadType, x.fmtp), y += x.rtcpFeedbacks.map((rt) => this.printRTCPFeedback(x.payloadType, rt)).join("");
        return y;
      }
      printFmtp(m, I) {
        if (!I) return "";
        let y = Object.keys(I.parameters);
        return y.length === 1 && I.parameters[y[0]] === null ? "a=fmtp:".concat(m).concat(c).concat(y[0]).concat(this.eol) : "a=fmtp:".concat(m).concat(c).concat(Object.keys(I.parameters).map((x) => "".concat(x, "=").concat(I.parameters[x])).join(";")).concat(this.eol);
      }
      printRtpMap(m, I) {
        return I ? "a=rtpmap:".concat(m).concat(c).concat(I.encodingName, "/").concat(I.clockRate).concat(I.encodingParameters ? "/".concat(I.encodingParameters) : "").concat(this.eol) : "";
      }
      printRTCPFeedback(m, I) {
        let y = "a=rtcp-fb:".concat(m).concat(c), x = I;
        return x.type === "trr-int" ? y += "ttr-int".concat(c).concat(x.interval) : (y += "".concat(x.type), x.parameter && (y += "".concat(c).concat(x.parameter), x.additional && (y += "".concat(c).concat(x.additional)))), y + this.eol;
      }
      printPtime(m) {
        return m === void 0 ? "" : "a=ptime:".concat(m).concat(this.eol);
      }
      printMaxPtime(m) {
        return m === void 0 ? "" : "a=maxptime:".concat(m).concat(this.eol);
      }
      printDirection(m) {
        return m === void 0 ? "" : "a=".concat(m).concat(this.eol);
      }
      printSSRC(m) {
        return m.map((I) => Object.keys(I.attributes).map((y) => "a=ssrc:".concat(I.ssrcId.toString(10)).concat(c).concat(y).concat(I.attributes[y] ? ":".concat(I.attributes[y]) : "").concat(this.eol)).join("")).join("");
      }
      printRTCPMux(m) {
        return m === void 0 ? "" : "a=rtcp-mux".concat(this.eol);
      }
      printRTCPMuxOnly(m) {
        return m === void 0 ? "" : "a=rtcp-mux-only".concat(this.eol);
      }
      printRTCPRsize(m) {
        return m === void 0 ? "" : "a=rtcp-rsize".concat(this.eol);
      }
      printRTCP(m) {
        if (m === void 0) return "";
        let I = "a=rtcp:".concat(m.port);
        return m.netType && (I += "".concat(c).concat(m.netType)), m.addressType && (I += "".concat(c).concat(m.addressType)), m.address && (I += "".concat(c).concat(m.address)), I + this.eol;
      }
      printMSId(m) {
        return m.map((I) => "a=msid:".concat(I.id).concat(I.appdata ? "".concat(c).concat(I.appdata) : "").concat(this.eol)).join("");
      }
      printImageattr(m) {
        return m.map((I) => "a=imageattr:".concat(I).concat(this.eol)).join("");
      }
      printRid(m) {
        return m.map((I) => {
          let y = "a=rid:".concat(I.id).concat(c).concat(I.direction);
          return I.payloads && (y += "".concat(c, "pt=").concat(I.payloads.join(","))), I.params.length > 0 && (y += "".concat(c).concat(I.params.map((x) => x.type === "depend" ? "depend=".concat(x.rids.join(",")) : "".concat(x.type, "=").concat(x.val)).join(";"))), y + this.eol;
        }).join("");
      }
      printSimulcast(m) {
        return m === void 0 ? "" : "a=simulcast:".concat(m).concat(this.eol);
      }
      printSCTPPort(m) {
        return m === void 0 ? "" : "a=sctp-port:".concat(m).concat(this.eol);
      }
      printMaxMessageSize(m) {
        return m === void 0 ? "" : "a=max-message-size:".concat(m).concat(this.eol);
      }
      printMid(m) {
        return m === void 0 ? "" : "a=mid:".concat(m).concat(this.eol);
      }
      printSSRCGroups(m) {
        return m.map((I) => "a=ssrc-group:".concat(I.semantic).concat(I.ssrcIds.map((y) => "".concat(c).concat(y.toString(10))).join("")).concat(this.eol)).join("");
      }
    }
    function F(M) {
      return new V().parse(M);
    }
    function Y(M, m) {
      return new ce().print(M, m);
    }
  } }, e = {};
  function n(i) {
    if (e[i]) return e[i].exports;
    var r = e[i] = { exports: {} };
    return t11[i](r, r.exports, n), r.exports;
  }
  return n.d = (i, r) => {
    for (var o in r) n.o(r, o) && !n.o(i, o) && Object.defineProperty(i, o, { enumerable: true, get: r[o] });
  }, n.o = (i, r) => Object.prototype.hasOwnProperty.call(i, r), n.r = (i) => {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(i, "__esModule", { value: true });
  }, n(8);
})();
var Le = e0.exports;
function $E() {
  let t11 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : v("SVC_MODE");
  if (v("ENABLE_SVC")) return function(e) {
    return e in xE;
  }(t11) ? t11 : xE.L1T3;
}
function KI(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function YI(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? KI(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : KI(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
function Lc(t11) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = arguments.length > 3 ? arguments[3] : void 0, { filterRTX: r, filterVideoFec: o, filterAudioFec: s, filterAudioCodec: a, filterVideoCodec: c } = e, { useXR: d } = n, l = [], u = [], h = [], p = [], g = false, E = false;
  if (Le.parse(t11).mediaDescriptions.forEach((S) => {
    i && i !== S.attributes.direction || (S.media.mediaType !== "video" || g || (u = S.attributes.payloads, p = S.attributes.extmaps, g = true), S.media.mediaType !== "audio" || E || (l = S.attributes.payloads, h = S.attributes.extmaps, E = true));
  }), !p || u.length === 0) throw new Error("Cannot get video capabilities from SDP.");
  if (!h || l.length === 0) throw new Error("Cannot get audio capabilities from SDP.");
  if (u.forEach((S) => {
    var C;
    (C = S.rtpMap) !== null && C !== void 0 && C.clockRate && (S.rtpMap.clockRate = parseInt(S.rtpMap.clockRate)), d && S.rtcpFeedbacks.push({ type: "rrtr" });
  }), l.forEach((S) => {
    var C;
    (C = S.rtpMap) !== null && C !== void 0 && C.clockRate && (S.rtpMap.clockRate = parseInt(S.rtpMap.clockRate)), d && S.rtcpFeedbacks.push({ type: "rrtr" });
  }), r && (l = l.filter((S) => {
    var C;
    return ((C = S.rtpMap) === null || C === void 0 ? void 0 : C.encodingName.toLowerCase()) !== "rtx";
  }), u = u.filter((S) => {
    var C;
    return ((C = S.rtpMap) === null || C === void 0 ? void 0 : C.encodingName.toLowerCase()) !== "rtx";
  })), o && (u = u.filter((S) => {
    var C;
    return !/(red)|(ulpfec)|(flexfec)/i.test(((C = S.rtpMap) === null || C === void 0 ? void 0 : C.encodingName) || "");
  })), s && (l = l.filter((S) => {
    var C;
    return !/(red)|(ulpfec)|(flexfec)/i.test(((C = S.rtpMap) === null || C === void 0 ? void 0 : C.encodingName) || "");
  })), a && (a == null ? void 0 : a.length) > 0 && (l = l.filter((S) => {
    var C;
    return W(a).call(a, ((C = S.rtpMap) === null || C === void 0 ? void 0 : C.encodingName.toLowerCase()) || "");
  })), c && (c == null ? void 0 : c.length) > 0) {
    let S = u.filter((C) => {
      var A;
      return W(c).call(c, ((A = C.rtpMap) === null || A === void 0 ? void 0 : A.encodingName.toLowerCase()) || "");
    });
    u = S.concat(r ? [] : yf(S, u));
  }
  let f = v("UNSUPPORTED_VIDEO_CODEC");
  return f && f.length > 0 && (u = u.filter((S) => !(S.rtpMap && W(f).call(f, S.rtpMap.encodingName.toLowerCase())))), { audioCodecs: l, videoCodecs: u, audioExtensions: h, videoExtensions: p };
}
function io(t11) {
  let e = Le.parse(t11), n, i;
  for (let r of e.mediaDescriptions) {
    if (!n) {
      let o = r.attributes.iceUfrag, s = r.attributes.icePwd;
      if (!o || !s) throw new Error("Cannot get iceUfrag or icePwd from SDP.");
      n = { iceUfrag: o, icePwd: s };
    }
    if (!i) {
      let o = r.attributes.fingerprints;
      o.length > 0 && (i = { fingerprints: o });
    }
  }
  if (!i && e.attributes.fingerprints.length > 0 && (i = { fingerprints: e.attributes.fingerprints }), !i || !n) throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
  return { iceParameters: n, dtlsParameters: i };
}
function n0(t11, e) {
  let n = [], i = t11.attributes.ssrcGroups.filter((s) => s.semantic === "FID"), r = t11.attributes.ssrcGroups.find((s) => s.semantic === "SIM"), o = t11.attributes.ssrcs;
  if (r) r.ssrcIds.forEach((s) => {
    var a;
    let c = (a = i.find((d) => d.ssrcIds[0] === s)) === null || a === void 0 ? void 0 : a.ssrcIds[1];
    n.push({ ssrcId: s, rtx: e ? c : void 0 });
  });
  else if (i.length > 0) {
    let s = i[0].ssrcIds[0], a = i[0].ssrcIds[1];
    n.push({ ssrcId: s, rtx: e ? a : void 0 });
  } else {
    if (o.length === 0) throw new Error("No ssrcs found on local media description.");
    n.push({ ssrcId: o[0].ssrcId });
  }
  return n;
}
function qI(t11, e, n) {
  let { cname: i } = t11, r;
  e ? r = i0(e) : (r = t11.iceParameters.candidates.map((l) => ({ foundation: l.foundation, componentId: "1", transport: l.protocol, priority: l.priority.toString(), connectionAddress: l.ip, port: l.port.toString(), type: l.type, extension: {} })), _.debug("Using candidates from gateway."));
  let o = { fingerprints: t11.dtlsParameters.fingerprints.map((l) => ({ hashFunction: l.algorithm, fingerprint: l.fingerprint })) }, s = { iceUfrag: t11.iceParameters.iceUfrag, icePwd: t11.iceParameters.icePwd }, a;
  switch (t11.dtlsParameters.role) {
    case "server":
      a = "passive";
      break;
    case "client":
      a = "active";
      break;
    case "auto":
      a = "actpass";
  }
  let c = uu(t11.rtpCapabilities), d = [];
  return Array.isArray(n) && n.length > 0 && n.forEach((l) => {
    d.push({ kind: Q.VIDEO, ssrcId: l.v, rtx: l.v_rtx, mslabel: "".concat(l.v, "_").concat(l.a) }, { kind: Q.AUDIO, ssrcId: l.a, mslabel: "".concat(l.v, "_").concat(l.a) });
  }), { dtlsParameters: o, iceParameters: s, candidates: r, rtpCapabilities: c, setup: a, cname: i, preSSRCs: d };
}
function i0(t11) {
  let e = [];
  return t11.ip && typeof t11.port == "number" && (e = [{ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t11.ip, port: t11.port.toString(), type: "host", extension: {} }], _.debug("Using remote candidate from AP ".concat(t11.ip, ":").concat(t11.port)), t11.ip6 && (e.push({ foundation: "udpcandidate", componentId: "1", transport: "udp", priority: "2103266323", connectionAddress: t11.ip6, port: t11.port.toString(), type: "host", extension: {} }), _.debug("Using IPV6 remote candidate from AP ".concat(t11.ip6, ":").concat(t11.port)))), e;
}
function Lo(t11, e, n) {
  let i = [], r = [];
  return t11.forEach((o) => {
    let { ssrcId: s, rtx: a } = o, c = Ut(8, "track-"), d = { ssrcId: s, attributes: YI({ label: c, mslabel: n = n || Ut(10, ""), msid: "".concat(n, " ").concat(c) }, e && { cname: e }) };
    if (i.push(d), a !== void 0) {
      let l = { ssrcId: a, attributes: YI({ label: c, mslabel: n, msid: "".concat(n, " ").concat(c) }, e && { cname: e }) };
      i.push(l), r.push({ semantic: "FID", ssrcIds: [s, a] });
    }
  }), t11.length > 1 && r.push({ semantic: "SIM", ssrcIds: t11.map((o) => {
    let { ssrcId: s } = o;
    return s;
  }) }), { ssrcs: i, ssrcGroups: r };
}
function ra(t11, e) {
  e instanceof Qt && t11.attributes.payloads.forEach((n) => {
    var i;
    let r = (i = n.rtpMap) === null || i === void 0 ? void 0 : i.encodingName.toLowerCase();
    if (!r || ["opus", "pcmu", "pcma", "g722"].indexOf(r) === -1) return;
    n.fmtp || (n.fmtp = { parameters: {} }), n.fmtp.parameters.minptime = "10", n.fmtp.parameters.useinbandfec = "1";
    let o = e._encoderConfig;
    o && r !== "pcmu" && r !== "pcma" && r !== "g722" && (o.bitrate && !$t() && (n.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * o.bitrate))), o.sampleRate && (n.fmtp.parameters.maxplaybackrate = "".concat(o.sampleRate), n.fmtp.parameters["sprop-maxcapturerate"] = "".concat(o.sampleRate)), o.stereo && (n.fmtp.parameters.stereo = "1", n.fmtp.parameters["sprop-stereo"] = "1"));
  });
}
function If(t11) {
  let e = t11.attributes.unrecognized.findIndex((n) => n.attField === "x-google-flag" && n.attValue === "conference");
  e !== -1 && t11.attributes.unrecognized.splice(e, 1);
}
function vf(t11, e) {
  var n;
  if (!(e instanceof Ft && e._encoderConfig && e._hints.indexOf(Gt.SCREEN_TRACK) === -1)) return;
  let i = e._encoderConfig;
  ft().supportMinBitrate && i.bitrateMin && t11.attributes.payloads.forEach((r) => {
    var o, s;
    W(o = ["h264", "h265", "vp8", "vp9", "av1"]).call(o, ((s = r.rtpMap) === null || s === void 0 ? void 0 : s.encodingName.toLowerCase()) || "") && (r.fmtp || (r.fmtp = { parameters: {} }), r.fmtp.parameters["x-google-min-bitrate"] = "".concat(i.bitrateMin));
  }), ft().supportMinBitrate && !W(n = e._hints).call(n, Gt.LOW_STREAM) && i.bitrateMax && t11.attributes.payloads.forEach((r) => {
    var o, s;
    W(o = ["h264", "h265", "vp8", "vp9", "av1"]).call(o, ((s = r.rtpMap) === null || s === void 0 ? void 0 : s.encodingName.toLowerCase()) || "") && (r.fmtp || (r.fmtp = { parameters: {} }), r.fmtp.parameters["x-google-start-bitrate"] = "".concat(v("X_GOOGLE_START_BITRATE") || Math.floor(i.bitrateMax)));
  });
}
function r0(t11) {
  if (t11.media.mediaType !== "video") return;
  let e = mt();
  if (e.name !== It.SAFARI && e.os !== ye.IOS) return;
  let n = t11.attributes.extmaps.findIndex((i) => /video-orientation/g.test(i.extensionName));
  n !== -1 && t11.attributes.extmaps.splice(n, 1);
}
function lu(t11, e, n) {
  if (!e) return;
  let i, r;
  if (t11.media.mediaType === "video" ? (i = n.videoExtensions, r = n.videoCodecs) : (i = n.audioExtensions, r = n.audioCodecs), e.twcc === true) {
    let o = i.find((s) => s.extensionName === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01");
    o && (t11.attributes.extmaps.find((a) => a.extensionName === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01") || t11.attributes.extmaps.push({ entry: o.entry, extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" }), function(a, c) {
      return c.filter((d) => !!a.find((l) => l.payloadType === d.payloadType && !!l.rtcpFeedbacks.find((u) => u.type === "transport-cc")));
    }(r, t11.attributes.payloads).forEach((a) => {
      a.rtcpFeedbacks.find((c) => c.type === "transport-cc") || a.rtcpFeedbacks.push({ type: "transport-cc" });
    }));
  } else if (e.twcc === false) {
    let o = t11.attributes.extmaps.findIndex((s) => s.extensionName === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01");
    o !== -1 && t11.attributes.extmaps.splice(o, 1), t11.attributes.payloads.forEach((s) => {
      let a = s.rtcpFeedbacks.findIndex((c) => c.type === "transport-cc");
      a !== -1 && s.rtcpFeedbacks.splice(a, 1);
    });
  }
  if (e.remb === true) {
    let o = i.find((s) => s.extensionName === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time");
    o && (t11.attributes.extmaps.find((a) => a.extensionName === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time") || t11.attributes.extmaps.push({ entry: o.entry, extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" }), function(a, c) {
      return c.filter((d) => !!a.find((l) => l.payloadType === d.payloadType && !!l.rtcpFeedbacks.find((u) => u.type === "goog-remb")));
    }(r, t11.attributes.payloads).forEach((a) => {
      a.rtcpFeedbacks.find((c) => c.type === "goog-remb") || a.rtcpFeedbacks.push({ type: "goog-remb" });
    }));
  } else if (e.remb === false) {
    let o = t11.attributes.extmaps.findIndex((s) => s.extensionName === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time");
    o !== -1 && t11.attributes.extmaps.splice(o, 1), t11.attributes.payloads.forEach((s) => {
      let a = s.rtcpFeedbacks.findIndex((c) => c.type === "goog-remb");
      a !== -1 && s.rtcpFeedbacks.splice(a, 1);
    });
  }
}
function o0(t11, e, n) {
  if ($t() || t11.media.mediaType !== "video" || !(e instanceof Ft) || n !== "vp9" && n !== "vp8" || n === "vp8" && !v("SIMULCAST") || n === "vp9" && v("ENABLE_SVC") || e._scalabilityMode === void 0 || e._scalabilityMode.numSpatialLayers <= 1) return;
  let i = n === "vp8" ? 2 : e._scalabilityMode.numSpatialLayers, r = t11.attributes.ssrcs[0], o = t11.attributes.ssrcGroups.find((a) => a.semantic === "FID" && a.ssrcIds[0] === r.ssrcId), s = { semantic: "SIM", ssrcIds: [r.ssrcId] };
  for (let a = 1; a < i; a++) t11.attributes.ssrcs.push({ ssrcId: r.ssrcId + a, attributes: le(r.attributes) }), s.ssrcIds.push(r.ssrcId + a), o && (t11.attributes.ssrcs.push({ ssrcId: o.ssrcIds[1] + a, attributes: le(r.attributes) }), t11.attributes.ssrcGroups.push({ semantic: "FID", ssrcIds: [r.ssrcId + a, o.ssrcIds[1] + a] }));
  t11.attributes.ssrcGroups.unshift(s);
}
async function s0() {
  let t11 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = new RTCPeerConnection();
  n.addTransceiver("video", { direction: "sendonly" }), n.addTransceiver("audio", { direction: "sendonly" }), n.addTransceiver("video", { direction: "recvonly" }), n.addTransceiver("audio", { direction: "recvonly" });
  let i = (await n.createOffer()).sdp, { send: r, recv: o, sendrecv: s } = function() {
    let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, d = arguments.length > 2 ? arguments[2] : void 0, l = Lc(d, a, c, "sendonly"), u = Lc(d, a, c, "recvonly"), h = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, p = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, g = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
    if (Ii(l, u, "videoExtensions", h, p, g), Ii(l, u, "videoCodecs", h, p, g), Ii(l, u, "audioExtensions", h, p, g), Ii(l, u, "audioCodecs", h, p, g), v("RAISE_H264_BASELINE_PRIORITY")) {
      let E = g.videoCodecs.findIndex((f) => {
        var S, C;
        return ((S = f.rtpMap) === null || S === void 0 ? void 0 : S.encodingName.toLocaleLowerCase()) === "h264" && ((C = f.fmtp) === null || C === void 0 ? void 0 : C.parameters["profile-level-id"]) === "42001f";
      });
      if (E !== -1) {
        let f = g.videoCodecs.findIndex((S) => {
          var C;
          return ((C = S.rtpMap) === null || C === void 0 ? void 0 : C.encodingName.toLocaleLowerCase()) === "h264";
        });
        if (f < E) {
          _.debug("raising H264 baseline profile priority");
          let S = g.videoCodecs[E];
          g.videoCodecs.splice(E, 1), g.videoCodecs.splice(f, 0, S);
        }
        f !== -1 && (p.videoCodecs = p.videoCodecs.filter((S) => {
          var C, A;
          return !(((C = S.rtpMap) === null || C === void 0 ? void 0 : C.encodingName.toLocaleLowerCase()) === "h264" && ((A = S.fmtp) === null || A === void 0 ? void 0 : A.parameters["profile-level-id"]) !== "42001f");
        })), f !== -1 && v("FILTER_SEND_H264_BASELINE") && (h.videoCodecs = h.videoCodecs.filter((S) => {
          var C, A;
          return !(((C = S.rtpMap) === null || C === void 0 ? void 0 : C.encodingName.toLocaleLowerCase()) === "h264" && ((A = S.fmtp) === null || A === void 0 ? void 0 : A.parameters["profile-level-id"]) !== "42001f");
        }));
      }
    }
    return { send: h, recv: p, sendrecv: g };
  }(t11, e, i);
  try {
    n.close();
  } catch {
  }
  return { send: r, recv: o, sendrecv: s };
}
function zI() {
  let t11 = { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, e = Lc(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, "recvonly"), n = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, i = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
  if (Ii(t11, e, "videoExtensions", n, i, r), Ii(t11, e, "videoCodecs", n, i, r), Ii(t11, e, "audioExtensions", n, i, r), Ii(t11, e, "audioCodecs", n, i, r), v("RAISE_H264_BASELINE_PRIORITY")) {
    let o = r.videoCodecs.findIndex((s) => s.rtpMap && s.rtpMap.encodingName.toLocaleLowerCase() === "h264" && s.fmtp && s.fmtp.parameters["profile-level-id"] === "42001f");
    if (o !== -1) {
      let s = r.videoCodecs.findIndex((a) => a.rtpMap && a.rtpMap.encodingName.toLocaleLowerCase() === "h264");
      if (s < o) {
        _.debug("raising H264 baseline profile priority");
        let a = r.videoCodecs[o];
        r.videoCodecs.splice(o, 1), r.videoCodecs.splice(s, 0, a);
      }
      s !== -1 && (i.videoCodecs = i.videoCodecs.filter((a) => !(a.rtpMap && a.rtpMap.encodingName.toLocaleLowerCase() === "h264" && a.fmtp && a.fmtp.parameters["profile-level-id"] !== "42001f")));
    }
  }
  return { send: n, recv: i, sendrecv: r };
}
function Ii(t11, e, n, i, r, o) {
  if (n === "videoExtensions" || n === "audioExtensions") {
    let s = [];
    return t11[n].forEach((a) => {
      e[n].some((c, d) => {
        if (a.entry === c.entry && a.extensionName === c.extensionName) return s.push(d), true;
      }) ? o[n].push(a) : i[n].push(a);
    }), void e[n].forEach((a, c) => {
      s.indexOf(c) === -1 && r[n].push(a);
    });
  }
  if (n === "videoCodecs" || n === "audioCodecs") {
    let s = [];
    return t11[n].forEach((a) => {
      e[n].some((c, d) => {
        if (a.payloadType === c.payloadType && JSON.stringify(a) === JSON.stringify(c)) return s.push(d), true;
      }) ? o[n].push(a) : i[n].push(a);
    }), void e[n].forEach((a, c) => {
      s.indexOf(c) === -1 && r[n].push(a);
    });
  }
}
function uu(t11) {
  let { send: e, recv: n, sendrecv: i } = t11;
  if (!i) {
    if (!e || !n) throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");
    return { send: e, recv: n };
  }
  let r, o;
  return e ? (r = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, r.audioCodecs = [...e.audioCodecs, ...i.audioCodecs], r.videoCodecs = [...e.videoCodecs, ...i.videoCodecs], r.audioExtensions = [...e.audioExtensions, ...i.audioExtensions], r.videoExtensions = [...e.videoExtensions, ...i.videoExtensions]) : r = i, n ? (o = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, o.audioCodecs = [...n.audioCodecs, ...i.audioCodecs], o.videoCodecs = [...n.videoCodecs, ...i.videoCodecs], o.audioExtensions = [...n.audioExtensions, ...i.audioExtensions], o.videoExtensions = [...n.videoExtensions, ...i.videoExtensions]) : o = i, { send: r, recv: o };
}
function oa(t11) {
  t11.media.mediaType === "audio" && t11.attributes.payloads.filter((e) => {
    var n;
    return ((n = e.rtpMap) === null || n === void 0 ? void 0 : n.encodingName.toLowerCase()) === "opus";
  }).forEach((e) => {
    e.fmtp || (e.fmtp = { parameters: {} }), e.fmtp.parameters.stereo = "1", e.fmtp.parameters["sprop-stereo"] = "1";
  });
}
function ac(t11, e, n, i) {
  let r = [];
  if (t11 === Q.VIDEO) {
    if (v("H264_PROFILE_LEVEL_ID") && i === "h264" && (r = e.videoCodecs.filter((o) => {
      var s;
      return W(s = o.rtpMap && o.rtpMap.encodingName.toLowerCase() || "").call(s, i) && o && o.fmtp && o.fmtp.parameters["profile-level-id"] === v("H264_PROFILE_LEVEL_ID");
    })), !Array.isArray(r) || r.length === 0) {
      let o = [], s = [], a = [], c = [];
      if (n.videoCodecs.forEach((d) => {
        let l = d.rtpMap && d.rtpMap.encodingName.toLowerCase() || "";
        W(l).call(l, i) ? o.push(d) : W(l).call(l, "vp9") ? s.push(d) : W(l).call(l, "vp8") ? a.push(d) : W(l).call(l, "h264") && c.push(d);
      }), o.length === 0) {
        let d = "";
        s.length !== 0 ? (o = s, d = "vp9") : a.length !== 0 ? (o = a, d = "vp8") : c.length !== 0 && (o = c, d = "h264"), _.warning("codec ".concat(i, " not included in rtpCapabilities, fallback to default payloads: ").concat(d));
      }
      o.length !== 0 && (r = e.videoCodecs.filter((d) => o.some((l) => l.payloadType === d.payloadType)));
    }
    if (r.length === 0 && (_.warning("codec ".concat(i, " not included in rtpCapabilities, fallback to default payloads: ").concat(e.videoCodecs[0].rtpMap && e.videoCodecs[0].rtpMap.encodingName)), r = e.videoCodecs), v("USE_PUB_RTX") || v("USE_SUB_RTX")) {
      let o = yf(r, e.videoCodecs);
      r = [...r, ...o];
    }
  } else r = e.audioCodecs.filter((o) => {
    var s;
    return W(s = o.rtpMap && o.rtpMap.encodingName.toLowerCase() || "").call(s, i);
  }), r.length === 0 && (_.warning("codec ".concat(i, " not included in rtpCapabilities, fallback to opus")), r = e.audioCodecs.filter((o) => {
    var s;
    return W(s = o.rtpMap && o.rtpMap.encodingName.toLowerCase() || "").call(s, "opus");
  }));
  return r;
}
function yf(t11, e) {
  let n = t11.map((i) => i.payloadType.toString());
  return e.filter((i) => i.rtpMap && i.rtpMap.encodingName === "rtx" && i.fmtp && i.fmtp.parameters.apt && W(n).call(n, i.fmtp && i.fmtp.parameters.apt));
}
async function Wd(t11, e, n) {
  let i = e.toString(), r = c0(i, "offer", "remote", "exchangeSDP");
  await t11.setRemoteDescription({ type: "offer", sdp: i });
  let o = await t11.createAnswer();
  if (!o.sdp) throw new Error("cannot get answer sdp");
  let s = o.sdp;
  s = a0(s, n || {}), r == null ? void 0 : r(s || ""), await t11.setLocalDescription({ type: "answer", sdp: s });
}
function a0(t11, e, n) {
  let i = Le.parse(t11), { useXR: r } = e;
  return i.mediaDescriptions.forEach((o) => {
    var s;
    o.attributes.mid && (Array.isArray(n) && !W(n).call(n, o.attributes.mid) || (o.media.mediaType === "audio" && oa(o), r && W(s = ["audio", "video"]).call(s, o.media.mediaType) && o.attributes.payloads.forEach((a) => {
      a.rtcpFeedbacks.findIndex((c) => c.type === "rrtr") === -1 && a.rtcpFeedbacks.push({ type: "rrtr" });
    })));
  }), Le.print(i);
}
function c0(t11, e, n, i) {
  if (v("SDP_LOGGING")) return _.upload("exchanging ".concat(n, " ").concat(e, " SDP during P2PConnection.").concat(i, `
`), t11), e === "offer" ? (r) => {
    c0(r, "answer", n === "local" ? "remote" : "local", i);
  } : void 0;
}
function Xi(t11, e) {
  return typeof v(t11) === e ? v(t11) : void 0;
}
function JI(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function jr(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? JI(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : JI(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var d_ = /* @__PURE__ */ new Map();
var tm = class extends Xt {
  get state() {
    return this._state;
  }
  set state(e) {
    if (e === this._state) return;
    let n = this._state;
    this._state = e, e === "DISCONNECTED" && this._disconnectedReason ? this.emit(xe.CONNECTION_STATE_CHANGE, e, n, this._disconnectedReason) : this.emit(xe.CONNECTION_STATE_CHANGE, e, n);
  }
  get joinGatewayStartTime() {
    return this._joinGatewayStartTime;
  }
  set joinGatewayStartTime(e) {
    _.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e)), this._joinGatewayStartTime = e;
  }
  constructor(e, n) {
    super(), T(this, "store", void 0), T(this, "joinInfo", void 0), T(this, "key", void 0), T(this, "ntpOffset", 0), T(this, "signal", void 0), T(this, "role", void 0), T(this, "inChannelInfo", { joinAt: null, duration: 0 }), T(this, "spec", void 0), T(this, "_state", "DISCONNECTED"), T(this, "_statsCollector", void 0), T(this, "_disconnectedReason", void 0), T(this, "isSignalRecover", false), T(this, "hasChangeBGPAddress", false), T(this, "trafficStatsInterval", void 0), T(this, "networkQualityInterval", void 0), T(this, "_joinGatewayStartTime", 0), T(this, "_signalTimeout", false), T(this, "_clientRoleOptions", void 0), T(this, "_isProactiveJoin", false), this.store = e, this.spec = n, this.signal = this.store.useP2P ? new du(jr(jr({}, n), {}, { retryConfig: n.websocketRetryConfig }), e) : new jE(jr(jr({}, n), {}, { retryConfig: n.websocketRetryConfig }), e), this._statsCollector = n.statsCollector, this.role = n.role || "audience", this._clientRoleOptions = n.clientRoleOptions, this.handleSignalEvents();
  }
  async join(e, n, i) {
    this.store.joinGatewayStart(), e.cloudProxyServer !== "disabled" && (this.hasChangeBGPAddress = true);
    let r = Date.now(), o = d_.get(e.cname);
    if (o || (o = /* @__PURE__ */ new Map(), d_.set(e.cname, o)), this._isProactiveJoin = true, o.has(e.uid)) {
      let d = new O(R.UID_CONFLICT);
      throw X.joinGateway(e.sid, { lts: r, succ: false, ec: d.code, addr: null, uid: e.uid, cid: e.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!e.proxyServer, signalChannel: "0", preload: e.preload }), this._isProactiveJoin = false, d;
    }
    o.set(e.uid, true), this.joinInfo = e, this.key = n;
    let s = 0;
    this.joinGatewayStartTime = r;
    let a = e.proxyServer;
    try {
      _.debug("[".concat(this.store.clientId, "] use websocket join uid ").concat(s));
      let d = e.gatewayAddrs.map((l) => {
        let { address: u } = l, [h, p] = u.split(":"), g = { host: h, port: p };
        return e.proxyServer && (g.proxy = e.proxyServer), g;
      });
      s = (await this.signal.init(d, i)).uid, _.debug("[".concat(this.store.clientId, "] websocket join uid ").concat(s, " cost ").concat(Date.now() - this.joinGatewayStartTime));
    } catch (d) {
      var c;
      throw _.error("[".concat(this.store.clientId, "] User join failed"), d.toString()), X.joinGateway(e.sid, { lts: r, succ: false, ec: ((c = d.data) === null || c === void 0 ? void 0 : c.desc) || d.code, errorMsg: d.message, addr: this.signal.url, uid: e.uid, cid: e.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!a, signalChannel: "0", preload: e.preload }), this._isProactiveJoin = false, o.delete(e.uid), this.signal.close(), d;
    }
    return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), _.debug("[".concat(this.store.clientId, "] Connected to gateway server")), this.trafficStatsInterval = window.setInterval(() => {
      this.updateTrafficStats().catch((d) => {
        _.warning("[".concat(this.store.clientId, "] get traffic stats error"), d.toString());
      });
    }, 3e3), this.networkQualityInterval = window.setInterval(() => {
      navigator && navigator.onLine !== void 0 && !navigator.onLine ? this.emit(xe.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 }) : this._signalTimeout ? this.emit(xe.NETWORK_QUALITY, { downlinkNetworkQuality: 5, uplinkNetworkQuality: 5 }) : this.state === "CONNECTED" && this._statsCollector.trafficStats ? this.emit(xe.NETWORK_QUALITY, { uplinkNetworkQuality: WR(this._statsCollector.trafficStats.B_unq), downlinkNetworkQuality: WR(this._statsCollector.trafficStats.B_dnq) }) : this.emit(xe.NETWORK_QUALITY, { uplinkNetworkQuality: 0, downlinkNetworkQuality: 0 });
    }, 2e3), this.store.joinGatewayEnd(), s;
  }
  async leave() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], n = arguments.length > 1 ? arguments[1] : void 0;
    if (this.state !== "DISCONNECTED") {
      n !== At.FALLBACK && (this.state = "DISCONNECTING");
      try {
        e || this.signal.connectionState !== Lt.CONNECTED || await function(i, r) {
          return r === 1 / 0 ? i : j.race([i, mB(r)]);
        }(this.signal.request(et.LEAVE, void 0, true), 3e3);
      } catch (i) {
        _.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), i);
      }
      this.signal.close(n), n !== At.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
    }
  }
  async publish(e, n, i) {
    if (this.state !== "CONNECTED" && this.state !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
    let r = { state: "offer", p2p_id: this.store.p2pId, ortc: n, mode: this.spec.mode, extend: v("PUB_EXTEND"), twcc: !!v("PUBLISH_TWCC"), rtx: !!v("USE_PUB_RTX") };
    try {
      return (await this.signal.request(et.PUBLISH, r, true))._message;
    } catch (o) {
      if (i && o.data && o.data.code === Z.ERR_PUBLISH_REQUEST_INVALID) return _.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), o.toString()), await this.tryUnpubBeforeRepub(e, n), this.publish(e, n, false);
      throw o;
    }
  }
  async publishDataChannel(e, n, i) {
    var r;
    if (this.state !== "CONNECTED" && this.state !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
    let o = { stream_id: n.streamId, ordered: n.ordered ? 1 : 0, max_retrans_times: (r = n.maxRetransmits) !== null && r !== void 0 ? r : 10, channel_id: n.channelId, metadata: n.metadata };
    try {
      await this.signal.request(et.PUBLISH_DATASTREAM, o, true);
    } catch (s) {
      if (i && s.data && s.data.code === Z.ERR_PUBLISH_REQUEST_INVALID) return _.warning("[".concat(this.store.clientId, "] receive publish datachannels error code, retry"), s.toString()), await this.tryUnpubDataChannelBeforeRepub(e, n), this.publishDataChannel(e, n, false);
      throw s;
    }
  }
  async unpublish(e, n) {
    try {
      if (this.state !== "CONNECTED" && this.state !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
      await this.signal.request(et.UNPUBLISH, { stream_id: n, ortc: e }, true);
    } catch (i) {
      _.warning("[".concat(this.store.clientId, "] unpublish warning: "), i);
    }
  }
  async unpublishDataChannel(e) {
    try {
      if (this.state !== "CONNECTED" && this.state !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
      await j.all(e.map((n) => this.signal.request(et.UNPUBLISH_DATASTREAM, { channel_id: n }, true)));
    } catch (n) {
      _.warning("unpublish datachannels warning: ", n);
    }
  }
  async presubscribe(e, n, i) {
    if (this.state !== "CONNECTED" && this.state !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can not presubscribe when connection state is ".concat(this.state));
    let r = { stream_id: e, stream_type: n, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!v("SUBSCRIBE_TWCC"), rtx: !!v("USE_SUB_RTX") || void 0, extend: v("SUB_EXTEND"), svc: Array.isArray(v("SVC")) && v("SVC").length !== 0 ? v("SVC") : void 0 };
    try {
      return await this.signal.request(et.PRE_SUBSCRIBE, r, true);
    } catch (o) {
      if (i && o.data && o.data.code === Z.ERR_SUBSCRIBE_REQUEST_INVALID) return _.warning("[".concat(this.store.clientId, "] pre-subscribe error, retry"), o.toString()), this.presubscribe(e, n, false);
      throw o;
    }
  }
  async subscribe(e, n, i) {
    if (this.state !== "CONNECTED" && this.state !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state));
    let r = { stream_id: e, stream_type: n.stream_type, mode: this.spec.mode, codec: this.spec.codec, p2p_id: this.store.p2pId, twcc: !!v("SUBSCRIBE_TWCC"), rtx: !!v("USE_SUB_RTX"), extend: v("SUB_EXTEND"), ssrcId: n.ssrcId, svc: Array.isArray(v("SVC")) && v("SVC").length !== 0 ? v("SVC") : void 0 };
    try {
      return (await this.signal.request(et.SUBSCRIBE, r, true))._message;
    } catch (o) {
      if (i && o.data && o.data.code === Z.ERR_SUBSCRIBE_REQUEST_INVALID) return _.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), o.toString()), await this.tryUnsubBeforeResub(e, n), await this.subscribe(e, n, false);
      throw o;
    }
  }
  async subscribeDataChannel(e, n, i) {
    if (this.state !== "CONNECTED" && this.state !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can not subscribe datachannel when connection state is ".concat(this.state));
    let r = { uid: e, stream_id: n.id, channel_id: n.datachannelId };
    try {
      return void await this.signal.request(et.SUBSCRIBE_DATASTREAM, r, true);
    } catch (o) {
      if (i && o.data && o.data.code === Z.ERR_SUBSCRIBE_REQUEST_INVALID) return _.warning("[".concat(this.store.clientId, "] receiver subscribe datachannel error code, retry"), o.toString()), await this.tryUnsubDataChannelBeforeResub(e, n), await this.subscribeDataChannel(e, n, false);
      throw o;
    }
  }
  async subscribeAll(e, n) {
    if (this.state !== "CONNECTED" && this.state !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state));
    let i = { p2p_id: this.store.p2pId, users: e, dtx: false, rtx: !!v("USE_SUB_RTX"), twcc: !!v("SUBSCRIBE_TWCC"), svc: Array.isArray(v("SVC")) && v("SVC").length !== 0 ? v("SVC") : void 0 };
    try {
      return await this.signal.request(et.SUBSCRIBE_STREAMS, i, true);
    } catch (r) {
      if (n && r.data && r.data.code === Z.ERR_SUBSCRIBE_REQUEST_INVALID) return _.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), r.toString()), await this.tryMassUnsubBeforeResub(e), await this.subscribeAll(e, false);
      throw r;
    }
  }
  async setVideoProfile(e) {
    let n = function(i) {
      if (!(i.bitrateMax && i.bitrateMin && i.frameRate && i.height && i.width)) return;
      let r = i.frameRate, o = i.width, s = i.height, a = true;
      return typeof r != "number" && (r = r.exact || r.ideal || r.max || r.min || 0, r || (a = false)), typeof o != "number" && (o = o.exact || o.ideal || o.max || o.min || 0, o || (a = false)), typeof s != "number" && (s = s.exact || s.ideal || s.max || s.min || 0, r || (a = false)), a ? { stream_type: 0, width: o, height: s, fps: r, start_bps: 1e3 * i.bitrateMax, min_bps: 1e3 * i.bitrateMin, target_bps: 1e3 * i.bitrateMax } : void 0;
    }(e);
    if (n) return this.signal.request(et.SET_VIDEO_PROFILE, n);
    _.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway"));
  }
  async unsubscribe(e, n) {
    try {
      await this.signal.request(et.UNSUBSCRIBE, { p2p_id: this.store.p2pId, ortc: e, stream_id: n }, true);
    } catch (i) {
      _.warning("[".concat(this.store.clientId, "] unsubscribe warning: "), i);
    }
  }
  async unsubscribeDataChannel(e, n) {
    try {
      if (this.state !== "CONNECTED" && this.state !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
      await j.all(e.map((i) => this.signal.request(et.UNSUBSCRIBE_DATASTREAM, { stream_id: i, uid: n }, true)));
    } catch (i) {
      _.warning("unsubscribeDataChannel warning: ", i);
    }
  }
  async massUnsubscribe(e) {
    try {
      await this.signal.request(et.UNSUBSCRIBE_STREAMS, e, true);
    } catch (n) {
      _.warning("[".concat(this.store.clientId, "] massUnsubscribeAll warning: "), n);
    }
  }
  async reconnectPC(e) {
    let { iceParameters: n, dtlsParameters: i, rtpCapabilities: r } = e;
    return { gatewayEstablishParams: await this.signal.request(et.CONNECT_PC, { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: { iceParameters: n, dtlsParameters: i, rtpCapabilities: r } }, true), gatewayAddress: this.getCurrentGatewayAddress() };
  }
  getGatewayInfo() {
    return this.signal.request(et.GATEWAY_INFO);
  }
  async renewToken(e) {
    await this.signal.request(et.RENEW_TOKEN, e), this.key = e.token;
  }
  async setClientRole(e, n) {
    if (n && (this._clientRoleOptions = Object.assign({}, n)), this.state !== "CONNECTED") return void (this.role = e);
    let i, r = 0;
    e === "audience" ? this._clientRoleOptions && this._clientRoleOptions.delay ? (i = this._clientRoleOptions.delay, r = 1) : r = this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : r = 0, await this.signal.request(et.SET_CLIENT_ROLE, { role: e, level: r, delay: i, client_ts: Date.now() }), this.role = e;
  }
  async setRemoteVideoStreamType(e, n) {
    await this.signal.request(et.SWITCH_VIDEO_STREAM, { stream_id: e, stream_type: n });
  }
  async setDefaultRemoteVideoStreamType(e) {
    await this.signal.request(et.DEFAULT_VIDEO_STREAM, { stream_type: e });
  }
  async setStreamFallbackOption(e, n) {
    await this.signal.request(et.SET_FALLBACK_OPTION, { stream_id: e, fallback_type: n });
  }
  async pickSVCLayer(e, n) {
    await this.signal.request(et.PICK_SVC_LAYER, { stream_id: e, spatial_layer: n.spatialLayer, temporal_layer: n.temporalLayer });
  }
  async setRTM2Flag(e) {
    await this.signal.request(et.SET_RTM2_FLAG, { rtm2_flag: e });
  }
  async sendExtensionMessage(e, n, i) {
    if (this.signal instanceof du) return this.signal.sendExtensionMessage(e, n, i);
  }
  getInChannelInfo() {
    return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), jr({}, this.inChannelInfo);
  }
  async getGatewayVersion() {
    return (await this.signal.request(et.GATEWAY_INFO)).version;
  }
  reset() {
    if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {
      let e = d_.get(this.joinInfo.cname);
      e && e.delete(this.joinInfo.uid);
    }
    this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);
  }
  updateTurnConfigFromSignal() {
    if (!this.joinInfo) return;
    let e = function(n) {
      let i;
      return i = n.startsWith("dc") ? n.match(/(dc\:\/\/)?([^:]+):(\d+)/) : n.match(/(wss\:\/\/)?([^:]+):(\d+)/), i ? { username: Ve.username, password: Ve.password, turnServerURL: i[2], tcpport: parseInt(i[3]) + 30, udpport: parseInt(i[3]) + 30, forceturn: false } : null;
    }((this.joinInfo.cloudProxyServer === "disabled" ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || "");
    this.joinInfo.turnServer.serversFromGateway = [], e && this.joinInfo.turnServer.mode !== "off" && this.joinInfo.cloudProxyServer === "disabled" && this.joinInfo.turnServer.serversFromGateway.push(jr(jr({}, Ve), {}, { turnServerURL: e.turnServerURL, tcpport: e.tcpport, udpport: e.udpport, username: this.joinInfo.uid.toString(), password: this.joinInfo.token }));
  }
  async updateTrafficStats() {
    if (this.state !== "CONNECTED") return;
    let e = await this.signal.request(et.TRAFFIC_STATS, void 0, true);
    e.timestamp = Date.now(), e.ntp_offset != null && (this.ntpOffset = e.ntp_offset), e.peer_delay.forEach((n) => {
      let i = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find((r) => r.peer_uid === n.peer_uid);
      i && i.B_st !== n.B_st && qu(() => {
        this.emit(xe.STREAM_TYPE_CHANGE, n.peer_uid, n.B_st);
      });
    }), this._statsCollector.updateTrafficStats(e);
  }
  getJoinMessage(e) {
    if (!this.joinInfo || !this.key) throw new O(R.UNEXPECTED_ERROR, "can not generate join message, no join info");
    let n = Object.assign({}, this.joinInfo.apResponse), i = v("REPORT_APP_SCENARIO");
    if (typeof i != "string") try {
      i = JSON.stringify(i);
    } catch {
      i = void 0;
    }
    i && i.length > 128 && (i = void 0);
    let r = !($t() || EO(87) || pC()) && typeof v("ENABLE_PRE_SUB") == "boolean" && v("ENABLE_PRE_SUB"), o = !pC() && Xi("ENABLE_PREALLOC_PC", "boolean"), s = jr({ license: this.joinInfo.license, p2p_id: this.store.p2pId, session_id: this.joinInfo.sid, app_id: this.joinInfo.appId, channel_key: this.key, channel_name: this.joinInfo.cname, sdk_version: ii, browser: navigator.userAgent, process_id: v("PROCESS_ID"), mode: this.store.useP2P ? "p2p" : this.spec.mode, codec: this.spec.codec, role: this.role, has_changed_gateway: this.hasChangeBGPAddress, ap_response: n, extend: v("JOIN_EXTEND"), details: { 6: this.joinInfo.stringUid, cservice_map: this.joinInfo.cloudProxyServer === "proxy3" ? "1" : this.joinInfo.cloudProxyServer === "proxy5" ? "2" : void 0 }, features: { rejoin: true }, optionalInfo: this.joinInfo.optionalInfo, appScenario: i, attributes: { userAttributes: { enablePublishedUserList: v("ENABLE_PUBLISHED_USER_LIST"), maxSubscription: v("MAX_SUBSCRIPTION"), subscribeAudioFilterTopN: typeof v("SUBSCRIBE_AUDIO_FILTER_TOPN") == "number" ? v("SUBSCRIBE_AUDIO_FILTER_TOPN") : void 0, enablePublishAudioFilter: typeof v("ENABLE_PUBLISH_AUDIO_FILTER") == "boolean" ? v("ENABLE_PUBLISH_AUDIO_FILTER") : void 0, enableUserLicenseCheck: typeof v("ENABLE_USER_LICENSE_CHECK") == "boolean" ? v("ENABLE_USER_LICENSE_CHECK") : void 0, enableRTX: v("USE_PUB_RTX") === true || v("USE_SUB_RTX") === true || void 0, disableFEC: v("DISABLE_FEC"), enableNTPReport: !!v("ENABLE_NTP_REPORT") || void 0, enableInstantVideo: !!v("ENABLE_INSTANT_VIDEO") || void 0, enableFulllinkAvSync: !!v("ENABLE_FULL_LINK_AV_SYNC") || void 0, enableDataStream2: Xi("ENABLE_DATASTREAM_2", "boolean"), enableAutFeedback: !!v("ENABLE_AUT_FEEDBACK") || void 0, rtm2Flag: typeof this.joinInfo.rtmFlag == "number" ? this.joinInfo.rtmFlag : void 0, enableUserAutoRebalanceCheck: !!v("ENABLE_USER_AUTO_REBALANCE_CHECK"), enableXR: Xi("USE_XR", "boolean"), enableLossbasedBwe: Xi("ENABLE_LOSSBASED_BWE", "boolean"), enableAutCC: !!v("ENABLE_AUT_CC") || void 0, enableCCFallback: Xi("ENABLE_CC_FALLBACK", "boolean"), enablePreallocPC: o, preSubNum: r ? Xi("PRE_SUB_NUM", "number") : void 0, enablePubTWCC: Xi("PUBLISH_TWCC", "boolean"), enableSubTWCC: Xi("SUBSCRIBE_TWCC", "boolean"), enablePubRTX: Xi("USE_PUB_RTX", "boolean"), enableSubRTX: Xi("USE_SUB_RTX", "boolean"), enableSubSVC: v("ENABLE_SVC") ? v("ENABLE_SVC_DEFAULT_CODECS") : Array.isArray(v("SVC")) && v("SVC").length !== 0 ? v("SVC") : void 0 } }, join_ts: this.joinGatewayStartTime }, e);
    return this.joinInfo.stringUid && (s.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (s.aes_mode = this.joinInfo.aesmode, v("ENCRYPT_AES") ? (s.aes_secret = this.joinInfo.aespassword, s.aes_encrypt = true) : s.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (s.aes_salt = this.joinInfo.aessalt)), n.addresses[this.signal.websocket.currentURLIndex] && (s.ap_response.ticket = n.addresses[this.signal.websocket.currentURLIndex].ticket, delete n.addresses), this.joinInfo.defaultVideoStream !== void 0 && (s.default_video_stream = this.joinInfo.defaultVideoStream), s;
  }
  getRejoinMessage() {
    if (!this.joinInfo) throw new O(R.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
    return { session_id: this.joinInfo.sid, channel_name: this.joinInfo.cname, cid: this.joinInfo.cid, uid: this.joinInfo.uid, vid: Number(this.joinInfo.vid) };
  }
  handleSignalEvents() {
    this.signal.on(nt.WS_RECONNECT_WAITTING_FINISH, (e) => {
      var n;
      W(n = ["tryNext", "recover"]).call(n, e) && this.joinInfo && X.adjustSessionStartTime(this.joinInfo.sid);
    }), this.signal.on(nt.WS_RECONNECT_CREATE_CONNECTION, (e) => {
      this.joinGatewayStartTime = Date.now();
    }), this.signal.on(nt.WS_RECONNECTING, (e) => {
      this.joinInfo && X.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: e || Be.NETWORK_ERROR }), this.joinInfo && (this.state = "RECONNECTING", X.sessionInit(this.joinInfo.sid, { lts: (/* @__PURE__ */ new Date()).getTime(), extend: this.isSignalRecover ? { recover: true } : { rejoin: true }, cname: this.joinInfo.cname, appid: this.joinInfo.appId, mode: this.spec.mode, stringUid: this.joinInfo.stringUid, channelProfile: this.spec.mode === "live" ? 1 : 0, channelMode: 0, lsid: this.joinInfo.sid, clientRole: this.role === "audience" ? 2 : 1, buildFormat: 2 }), this.isSignalRecover = false, this.joinGatewayStartTime = Date.now());
    }), this.signal.on(nt.WS_CLOSED, (e) => {
      let n;
      switch (e) {
        case At.LEAVE:
          n = Be.LEAVE;
          break;
        case At.UID_BANNED:
        case At.IP_BANNED:
        case At.CHANNEL_BANNED:
        case At.SERVER_ERROR:
          n = Be.SERVER_ERROR;
          break;
        case At.FALLBACK:
          n = Be.FALLBACK;
          break;
        case At.LICENSE_MISSING:
        case At.LICENSE_EXPIRED:
        case At.LICENSE_MINUTES_EXCEEDED:
        case At.LICENSE_PERIOD_INVALID:
        case At.LICENSE_MULTIPLE_SDK_SERVICE:
        case At.LICENSE_ILLEGAL:
        case At.TOKEN_EXPIRE:
          n = e;
          break;
        default:
          n = Be.NETWORK_ERROR;
      }
      _.debug("[".concat(this.store.clientId, "] [signal] websocket closed, reason: ").concat(n || "undefined -> " + Be.NETWORK_ERROR)), this.joinInfo && X.WebSocketQuit(this.joinInfo.sid, { lts: Date.now(), succ: e === At.LEAVE ? 1 : -1, cname: this.joinInfo.cname, uid: this.joinInfo.uid, cid: this.joinInfo.cid, errorCode: n }), this._disconnectedReason = e, e !== At.FALLBACK && (this.state = "DISCONNECTED"), this.reset();
    }), this.signal.on(nt.WS_CONNECTED, () => {
      if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo && (this.role === "audience" && this._clientRoleOptions && (this._clientRoleOptions.level || this._clientRoleOptions.delay) && (_.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(this._clientRoleOptions.level, ", delay: ").concat(this._clientRoleOptions.delay)), this.setClientRole(this.role, this._clientRoleOptions)), X.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: true, ec: null, vid: this.joinInfo.vid, addr: this.signal.url, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: "0", preload: this.joinInfo.preload }), this._isProactiveJoin = false, this.joinInfo.useLocalAccessPoint && this.joinInfo.setLocalAPVersion === 1)) {
        let e = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
        if (!e) return void _.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e));
        Ot("EVENT_REPORT_DOMAIN", e[1]), Ot("EVENT_REPORT_BACKUP_DOMAIN", e[1]), Ot("LOG_UPLOAD_SERVER", "".concat(e[1], ":6444"));
      }
    }), this.signal.on(dt.ON_UPLINK_STATS, (e) => {
      this._statsCollector.updateUplinkStats(e);
    }), this.signal.on(nt.REQUEST_RECOVER, (e, n, i) => {
      if (!this.joinInfo) return i(new O(R.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
      e && (this.joinInfo.multiIP = e, this.hasChangeBGPAddress = true), this.isSignalRecover = true, Ge(this, xe.REQUEST_NEW_GATEWAY_LIST).then(n).catch(i);
    }), this.signal.on(nt.REQUEST_JOIN_INFO, async (e) => {
      var n;
      if (this.updateTurnConfigFromSignal(), this.store.useP2P) return void e(this.getJoinMessage({ ortc: {} }));
      let { iceParameters: i, dtlsParameters: r, rtpCapabilities: o } = await Ge(this, xe.REQUEST_P2P_CONNECTION_PARAMS, { turnServer: (n = this.joinInfo) === null || n === void 0 ? void 0 : n.turnServer });
      e(this.getJoinMessage({ ortc: { iceParameters: i, dtlsParameters: r, rtpCapabilities: o, version: "2" } }));
    }), this.signal.on(nt.REQUEST_REJOIN_INFO, (e) => {
      e(this.getRejoinMessage());
    }), this.signal.on(nt.REPORT_JOIN_GATEWAY, (e, n) => {
      if (!this.joinInfo) return;
      let i, r = "";
      var o;
      e instanceof O ? (i = ((o = e.data) === null || o === void 0 ? void 0 : o.desc) || e.code, r = e.message) : i = e, X.joinGateway(this.joinInfo.sid, { lts: this.joinGatewayStartTime, succ: false, ec: i, errorMsg: r, addr: n, uid: this.joinInfo.uid, cid: this.joinInfo.cid, firstSuccess: this._isProactiveJoin, avoidJoinStartTime: this.store.avoidJoinStart, isProxy: !!this.joinInfo.proxyServer, signalChannel: "0", preload: this.joinInfo.preload }), this._isProactiveJoin = false;
    }), this.signal.on(nt.IS_P2P_DISCONNECTED, (e) => {
      e(Ac(this, xe.IS_P2P_DISCONNECTED));
    }), this.signal.on(nt.DISCONNECT_P2P, () => {
      this.emit(xe.DISCONNECT_P2P);
    }), this.signal.on(nt.REQUEST_SUCCESS, () => {
      this._signalTimeout = false;
    }), this.signal.on(nt.REQUEST_TIMEOUT, () => {
      this._signalTimeout = true;
    }), this.signal.on(nt.JOIN_RESPONSE, (e) => {
      let n = this.getCurrentGatewayAddress();
      this.emit(xe.JOIN_RESPONSE, e, n);
    }), this.signal.on(nt.PRE_CONNECT_PC, async () => {
      if (this.joinInfo) {
        this.updateTurnConfigFromSignal();
        let e = this.getCurrentGatewayAddress(), n = v("FINGERPRINT") || this.joinInfo.apResponse.addresses[this.signal.currentURLIndex].fingerprint;
        if (e && n) {
          let i = i0(e);
          this.emit(xe.PRE_CONNECT_PC, { candidates: i, fingerprint: n });
        }
      }
    });
  }
  async tryUnsubBeforeResub(e, n) {
    try {
      await this.signal.request(et.UNSUBSCRIBE, { p2p_id: this.store.p2pId, stream_id: e, ortc: [n] }, true);
    } catch (i) {
      throw _.warning("[".concat(this.store.clientId, "] tryUnsubBeforeResub warning"), i), i;
    }
  }
  async tryUnsubDataChannelBeforeResub(e, n) {
    try {
      await this.signal.request(et.UNSUBSCRIBE, { stream_id: n.id }, true);
    } catch (i) {
      throw _.warning("unsubscribe datachannel warning", i), i;
    }
  }
  async tryUnpubBeforeRepub(e, n) {
    try {
      await this.signal.request(et.UNPUBLISH, { stream_id: e, ortc: n }, true);
    } catch (i) {
      throw _.warning("[".concat(this.store.clientId, "] tryUnpubBeforeRepub warning: "), i), i;
    }
  }
  async tryUnpubDataChannelBeforeRepub(e, n) {
    try {
      await this.signal.request(et.UNPUBLISH_DATASTREAM, { channnel_id: n.channelId }, true);
    } catch (i) {
      throw _.warning("unpublish datastream warning: ", i), i;
    }
  }
  async tryMassUnsubBeforeResub(e) {
    let n = { users: e.map((i) => ({ stream_id: i.stream_id, stream_type: i.stream_type })) };
    try {
      await this.signal.request(et.UNSUBSCRIBE_STREAMS, n, true);
    } catch (i) {
      throw _.warning("[".concat(this.store.clientId, "] tryMassUnsubBeforeResub warning"), i), i;
    }
  }
  async muteLocal(e, n) {
    let i = { action: e.find((r) => r.stream_type === Ct.Audio) ? "mute_local_audio" : "mute_local_video", p2p_id: this.store.p2pId, ortc: e, stream_id: n };
    try {
      await this.signal.request(et.CONTROL, i, true, true);
    } catch (r) {
      throw _.warning("[".concat(this.store.clientId, "] gateway muteLocal warning: "), r), r;
    }
  }
  async unmuteLocal(e, n) {
    let i = { action: e.find((r) => r.stream_type === Ct.Audio) ? "unmute_local_audio" : "unmute_local_video", p2p_id: this.store.p2pId, ortc: e, stream_id: n };
    try {
      await this.signal.request(et.CONTROL, i, true, true);
    } catch (r) {
      throw _.warning("[".concat(this.store.clientId, "] gateway unmuteLocal warning: "), r), r;
    }
  }
  async muteRemote(e, n) {
    let i = { action: e === Q.AUDIO ? "mute_remote_audio" : "mute_remote_video", p2p_id: this.store.p2pId, stream_id: n };
    try {
      await this.signal.request(et.CONTROL, i, true, true);
    } catch (r) {
      throw _.warning("[".concat(this.store.clientId, "] gateway muteRemote warning: "), r), r;
    }
  }
  async unmuteRemote(e, n) {
    let i = { action: e === Q.AUDIO ? "unmute_remote_audio" : "unmute_remote_video", p2p_id: this.store.p2pId, stream_id: n };
    try {
      await this.signal.request(et.CONTROL, i, true, true);
    } catch (r) {
      throw _.warning("[".concat(this.store.clientId, "] gateway unmuteRemote warning: "), r), r;
    }
  }
  uploadWRTCStats(e) {
    this.signal.uploadWRTCStats(e);
  }
  upload(e, n) {
    this.signal.upload(e, n);
  }
  getSignalRTT() {
    return this.signal.rtt;
  }
  async restartICE(e) {
    let n = { p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e };
    try {
      return await this.signal.request(et.RESTART_ICE, n, true);
    } catch (i) {
      throw _.warning("[".concat(this.store.clientId, "] P2PChannel.restartICE warning: "), i), i;
    }
  }
  reconnect() {
    this.state === "CONNECTED" && this.signal.reconnect(void 0, Be.P2P_FAILED);
  }
  getCurrentGatewayAddress() {
    var e, n;
    if (!v("GATEWAY_WSS_ADDRESS")) return v("USE_CANDIDATE_FROM_AP_DETAIL") && (e = this.joinInfo) !== null && e !== void 0 && e.apGatewayAddress ? (_.debug("[".concat(this.store.clientId, "] use candidate from ap detail, ").concat(JSON.stringify(this.joinInfo.apGatewayAddress))), this.joinInfo.apGatewayAddress) : (n = this.joinInfo) !== null && n !== void 0 && n.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;
  }
  async setPublishAudioFilterEnabled(e) {
    await this.signal.request(et.SET_PARAMETER, { enablePublishAudioFilter: e });
  }
};
var Hd = 0;
var l_ = 0;
function Hi(t11, e, n, i) {
  return new j((r, o) => {
    e.timeout = e.timeout || v("HTTP_CONNECT_TIMEOUT"), e.responseType = e.responseType || "json", e.data && !n ? (e.data = JSON.stringify(e.data), Hd += ar(e.data)) : n && (e.data.size ? Hd += e.data.size : e.data instanceof FormData ? Hd += AO(e.data) : Hd += ar(JSON.stringify(e.data))), e.headers = e.headers || {}, e.headers["Content-Type"] = e.headers["Content-Type"] || "application/json", e.method = "POST", e.url = t11, mn.request(e).then((s) => {
      typeof s.data == "string" ? l_ += ar(s.data) : s.data instanceof ArrayBuffer || s.data instanceof Uint8Array ? l_ += s.data.byteLength : l_ += ar(JSON.stringify(s.data)), i && r({ data: s.data, headers: s.headers }), r(s.data);
    }).catch((s) => {
      mn.isCancel(s) ? o(new O(R.OPERATION_ABORTED, "cancel token canceled")) : s.code === "ECONNABORTED" ? o(new O(R.NETWORK_TIMEOUT, s.message)) : s.response ? o(new O(R.NETWORK_RESPONSE_ERROR, s.response.status)) : o(new O(R.NETWORK_ERROR, s.message));
    });
  });
}
(function() {
  var t11;
  function e(L) {
    var F = 0;
    return function() {
      return F < L.length ? { done: false, value: L[F++] } : { done: true };
    };
  }
  var n = typeof Object.defineProperties == "function" ? Object.defineProperty : function(L, F, Y) {
    return L == Array.prototype || L == Object.prototype || (L[F] = Y.value), L;
  }, i, r = function(L) {
    L = [typeof globalThis == "object" && globalThis, L, typeof window == "object" && window, typeof self == "object" && self, typeof Vs == "object" && Vs];
    for (var F = 0; F < L.length; ++F) {
      var Y = L[F];
      if (Y && Y.Math == Math) return Y;
    }
    throw Error("Cannot find global object");
  }(this);
  function o(L, F) {
    if (F) t: {
      var Y = r;
      L = L.split(".");
      for (var M = 0; M < L.length - 1; M++) {
        var m = L[M];
        if (!(m in Y)) break t;
        Y = Y[m];
      }
      (F = F(M = Y[L = L[L.length - 1]])) != M && F != null && n(Y, L, { configurable: true, writable: true, value: F });
    }
  }
  function s(L) {
    return (L = { next: L })[Symbol.iterator] = function() {
      return this;
    }, L;
  }
  function a(L) {
    var F = typeof Symbol < "u" && Symbol.iterator && L[Symbol.iterator];
    return F ? F.call(L) : { next: e(L) };
  }
  if (o("Symbol", function(L) {
    function F(m, I) {
      this.A = m, n(this, "description", { configurable: true, writable: true, value: I });
    }
    if (L) return L;
    F.prototype.toString = function() {
      return this.A;
    };
    var Y = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", M = 0;
    return function m(I) {
      if (this instanceof m) throw new TypeError("Symbol is not a constructor");
      return new F(Y + (I || "") + "_" + M++, I);
    };
  }), o("Symbol.iterator", function(L) {
    if (L) return L;
    L = Symbol("Symbol.iterator");
    for (var F = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), Y = 0; Y < F.length; Y++) {
      var M = r[F[Y]];
      typeof M == "function" && typeof M.prototype[L] != "function" && n(M.prototype, L, { configurable: true, writable: true, value: function() {
        return s(e(this));
      } });
    }
    return L;
  }), typeof Object.setPrototypeOf == "function") i = Object.setPrototypeOf;
  else {
    var c;
    t: {
      var d = {};
      try {
        d.__proto__ = { a: true }, c = d.a;
        break t;
      } catch {
      }
      c = false;
    }
    i = c ? function(L, F) {
      if (L.__proto__ = F, L.__proto__ !== F) throw new TypeError(L + " is not extensible");
      return L;
    } : null;
  }
  var l = i;
  function u() {
    this.m = false, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;
  }
  function h(L) {
    if (L.m) throw new TypeError("Generator is already running");
    L.m = true;
  }
  function p(L, F) {
    return L.h = 3, { value: F };
  }
  function g(L) {
    this.g = new u(), this.G = L;
  }
  function E(L, F, Y, M) {
    try {
      var m = F.call(L.g.j, Y);
      if (!(m instanceof Object)) throw new TypeError("Iterator result " + m + " is not an object");
      if (!m.done) return L.g.m = false, m;
      var I = m.value;
    } catch (y) {
      return L.g.j = null, L.g.s(y), f(L);
    }
    return L.g.j = null, M.call(L.g, I), f(L);
  }
  function f(L) {
    for (; L.g.h; ) try {
      var F = L.G(L.g);
      if (F) return L.g.m = false, { value: F.value, done: false };
    } catch (Y) {
      L.g.v = void 0, L.g.s(Y);
    }
    if (L.g.m = false, L.g.l) {
      if (F = L.g.l, L.g.l = null, F.F) throw F.D;
      return { value: F.return, done: true };
    }
    return { value: void 0, done: true };
  }
  function S(L) {
    this.next = function(F) {
      return L.o(F);
    }, this.throw = function(F) {
      return L.s(F);
    }, this.return = function(F) {
      return function(Y, M) {
        h(Y.g);
        var m = Y.g.j;
        return m ? E(Y, "return" in m ? m.return : function(I) {
          return { value: I, done: true };
        }, M, Y.g.return) : (Y.g.return(M), f(Y));
      }(L, F);
    }, this[Symbol.iterator] = function() {
      return this;
    };
  }
  function C(L, F) {
    return F = new S(new g(F)), l && L.prototype && l(F, L.prototype), F;
  }
  if (u.prototype.o = function(L) {
    this.v = L;
  }, u.prototype.s = function(L) {
    this.l = { D: L, F: true }, this.h = this.C || this.u;
  }, u.prototype.return = function(L) {
    this.l = { return: L }, this.h = this.u;
  }, g.prototype.o = function(L) {
    return h(this.g), this.g.j ? E(this, this.g.j.next, L, this.g.o) : (this.g.o(L), f(this));
  }, g.prototype.s = function(L) {
    return h(this.g), this.g.j ? E(this, this.g.j.throw, L, this.g.o) : (this.g.s(L), f(this));
  }, o("Array.prototype.entries", function(L) {
    return L || function() {
      return function(F, Y) {
        F instanceof String && (F += "");
        var M = 0, m = false, I = { next: function() {
          if (!m && M < F.length) {
            var y = M++;
            return { value: Y(y, F[y]), done: false };
          }
          return m = true, { done: true, value: void 0 };
        } };
        return I[Symbol.iterator] = function() {
          return I;
        }, I;
      }(this, function(F, Y) {
        return [F, Y];
      });
    };
  }), typeof Blob < "u" && (typeof FormData > "u" || !FormData.prototype.keys)) {
    var A = function(L, F) {
      for (var Y = 0; Y < L.length; Y++) F(L[Y]);
    }, b = function(L) {
      return L.replace(/\r?\n|\r/g, `\r
`);
    }, w = function(L, F, Y) {
      return F instanceof Blob ? (Y = Y !== void 0 ? Y + "" : typeof F.name == "string" ? F.name : "blob", F.name === Y && Object.prototype.toString.call(F) !== "[object Blob]" || (F = new File([F], Y)), [String(L), F]) : [String(L), String(F)];
    }, D = function(L, F) {
      if (L.length < F) throw new TypeError(F + " argument required, but only " + L.length + " present.");
    }, k = typeof globalThis == "object" ? globalThis : typeof window == "object" ? window : typeof self == "object" ? self : this, B = k.FormData, V = k.XMLHttpRequest && k.XMLHttpRequest.prototype.send, z = k.Request && k.fetch, lt = k.navigator && k.navigator.sendBeacon, vt = k.Element && k.Element.prototype, Dt = k.Symbol && Symbol.toStringTag;
    Dt && (Blob.prototype[Dt] || (Blob.prototype[Dt] = "Blob"), "File" in k && !File.prototype[Dt] && (File.prototype[Dt] = "File"));
    try {
      new File([], "");
    } catch {
      k.File = function(F, Y, M) {
        return F = new Blob(F, M || {}), Object.defineProperties(F, { name: { value: Y }, lastModified: { value: +(M && M.lastModified !== void 0 ? new Date(M.lastModified) : /* @__PURE__ */ new Date()) }, toString: { value: function() {
          return "[object File]";
        } } }), Dt && Object.defineProperty(F, Dt, { value: "File" }), F;
      };
    }
    var ce = function(L) {
      return L.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    }, Wt = function(L) {
      this.i = [];
      var F = this;
      L && A(L.elements, function(Y) {
        if (Y.name && !Y.disabled && Y.type !== "submit" && Y.type !== "button" && !Y.matches("form fieldset[disabled] *")) if (Y.type === "file") {
          var M = Y.files && Y.files.length ? Y.files : [new File([], "", { type: "application/octet-stream" })];
          A(M, function(m) {
            F.append(Y.name, m);
          });
        } else Y.type === "select-multiple" || Y.type === "select-one" ? A(Y.options, function(m) {
          !m.disabled && m.selected && F.append(Y.name, m.value);
        }) : Y.type === "checkbox" || Y.type === "radio" ? Y.checked && F.append(Y.name, Y.value) : (M = Y.type === "textarea" ? b(Y.value) : Y.value, F.append(Y.name, M));
      });
    };
    if ((t11 = Wt.prototype).append = function(L, F, Y) {
      D(arguments, 2), this.i.push(w(L, F, Y));
    }, t11.delete = function(L) {
      D(arguments, 1);
      var F = [];
      L = String(L), A(this.i, function(Y) {
        Y[0] !== L && F.push(Y);
      }), this.i = F;
    }, t11.entries = function L() {
      var F, Y = this;
      return C(L, function(M) {
        if (M.h == 1 && (F = 0), M.h != 3) return F < Y.i.length ? M = p(M, Y.i[F]) : (M.h = 0, M = void 0), M;
        F++, M.h = 2;
      });
    }, t11.forEach = function(L, F) {
      D(arguments, 1);
      for (var Y = a(this), M = Y.next(); !M.done; M = Y.next()) {
        var m = a(M.value);
        M = m.next().value, m = m.next().value, L.call(F, m, M, this);
      }
    }, t11.get = function(L) {
      D(arguments, 1);
      var F = this.i;
      L = String(L);
      for (var Y = 0; Y < F.length; Y++) if (F[Y][0] === L) return F[Y][1];
      return null;
    }, t11.getAll = function(L) {
      D(arguments, 1);
      var F = [];
      return L = String(L), A(this.i, function(Y) {
        Y[0] === L && F.push(Y[1]);
      }), F;
    }, t11.has = function(L) {
      D(arguments, 1), L = String(L);
      for (var F = 0; F < this.i.length; F++) if (this.i[F][0] === L) return true;
      return false;
    }, t11.keys = function L() {
      var F, Y, M, m, I = this;
      return C(L, function(y) {
        if (y.h == 1 && (F = a(I), Y = F.next()), y.h != 3) return Y.done ? void (y.h = 0) : (M = Y.value, m = a(M), p(y, m.next().value));
        Y = F.next(), y.h = 2;
      });
    }, t11.set = function(L, F, Y) {
      D(arguments, 2), L = String(L);
      var M = [], m = w(L, F, Y), I = true;
      A(this.i, function(y) {
        y[0] === L ? I && (I = !M.push(m)) : M.push(y);
      }), I && M.push(m), this.i = M;
    }, t11.values = function L() {
      var F, Y, M, m, I = this;
      return C(L, function(y) {
        if (y.h == 1 && (F = a(I), Y = F.next()), y.h != 3) return Y.done ? void (y.h = 0) : (M = Y.value, (m = a(M)).next(), p(y, m.next().value));
        Y = F.next(), y.h = 2;
      });
    }, Wt.prototype._asNative = function() {
      for (var L = new B(), F = a(this), Y = F.next(); !Y.done; Y = F.next()) {
        var M = a(Y.value);
        Y = M.next().value, M = M.next().value, L.append(Y, M);
      }
      return L;
    }, Wt.prototype._blob = function() {
      var L = "----formdata-polyfill-" + Math.random(), F = [], Y = "--" + L + `\r
Content-Disposition: form-data; name="`;
      return this.forEach(function(M, m) {
        return typeof M == "string" ? F.push(Y + ce(b(m)) + `"\r
\r
` + b(M) + `\r
`) : F.push(Y + ce(b(m)) + '"; filename="' + ce(M.name) + `"\r
Content-Type: ` + (M.type || "application/octet-stream") + `\r
\r
`, M, `\r
`);
      }), F.push("--" + L + "--"), new Blob(F, { type: "multipart/form-data; boundary=" + L });
    }, Wt.prototype[Symbol.iterator] = function() {
      return this.entries();
    }, Wt.prototype.toString = function() {
      return "[object FormData]";
    }, vt && !vt.matches && (vt.matches = vt.matchesSelector || vt.mozMatchesSelector || vt.msMatchesSelector || vt.oMatchesSelector || vt.webkitMatchesSelector || function(L) {
      for (var F = (L = (this.document || this.ownerDocument).querySelectorAll(L)).length; 0 <= --F && L.item(F) !== this; ) ;
      return -1 < F;
    }), Dt && (Wt.prototype[Dt] = "FormData"), V) {
      var si = k.XMLHttpRequest.prototype.setRequestHeader;
      k.XMLHttpRequest.prototype.setRequestHeader = function(L, F) {
        si.call(this, L, F), L.toLowerCase() === "content-type" && (this.B = true);
      }, k.XMLHttpRequest.prototype.send = function(L) {
        L instanceof Wt ? (L = L._blob(), this.B || this.setRequestHeader("Content-Type", L.type), V.call(this, L)) : V.call(this, L);
      };
    }
    z && (k.fetch = function(L, F) {
      return F && F.body && F.body instanceof Wt && (F.body = F.body._blob()), z.call(this, L, F);
    }), lt && (k.navigator.sendBeacon = function(L, F) {
      return F instanceof Wt && (F = F._asNative()), lt.call(this, L, F);
    }), k.FormData = Wt;
  }
})();
var Mc = () => {
  let t11 = v("AREAS");
  return t11.length === 0 && t11.push(St.GLOBAL), ji(t11).call(t11, (e, n, i) => {
    let r = d0(n);
    return r ? i === 0 ? r : "".concat(e, ",").concat(r) : e;
  }, "");
};
var d0 = (t11) => t11 === St.OVERSEA ? "".concat(Ye.ASIA, ",").concat(Ye.EUROPE, ",").concat(Ye.AFRICA, ",").concat(Ye.NORTH_AMERICA, ",").concat(Ye.SOUTH_AMERICA, ",").concat(Ye.OCEANIA) : Ye[t11];
var jG = (t11) => {
  let e = { CODE: "", WEBCS_DOMAIN: [], WEBCS_DOMAIN_BACKUP_LIST: [], PROXY_CS: [], CDS_AP: [], ACCOUNT_REGISTER: [], UAP_AP: [], EVENT_REPORT_DOMAIN: [], EVENT_REPORT_BACKUP_DOMAIN: [], LOG_UPLOAD_SERVER: [], PROXY_SERVER_TYPE3: [] };
  return t11.map((n) => {
    let i = Zu[n], r = Object.keys(i);
    r && r.map((o) => {
      o !== "CODE" && (e[o] = e[o].concat(i[o]));
    });
  }), e;
};
var yl = { GLOBAL: { ASIA: [St.CHINA, St.JAPAN, St.INDIA, St.KOREA, St.HKMC], EUROPE: [], NORTH_AMERICA: [St.US], SOUTH_AMERICA: [], OCEANIA: [], AFRICA: [] } };
var Kd = Object.keys(yl[St.GLOBAL]);
var u_ = [St.CHINA, St.NORTH_AMERICA, St.EUROPE, St.ASIA, St.JAPAN, St.INDIA, St.OCEANIA, St.SOUTH_AMERICA, St.AFRICA, St.KOREA, St.HKMC, St.US];
var GG = function(t11, e) {
  let n = [];
  if (W(t11).call(t11, St.GLOBAL)) {
    let o = [St.GLOBAL, St.OVERSEA], s = Object.keys(Zu);
    if (e === St.GLOBAL) throw new O(R.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value");
    if (e === St.CHINA) n = [St.OVERSEA];
    else if (r = e, W(Kd).call(Kd, r)) {
      let a = (i = e, yl[St.GLOBAL][i] || []), c = [...o, e, ...a];
      n = s.filter((d) => !W(c).call(c, d));
    } else if (function(a) {
      let c = false;
      return Kd.forEach((d) => {
        var l;
        W(l = yl[St.GLOBAL][d]).call(l, a) && (c = true);
      }), c;
    }(e)) {
      let a = function(d) {
        let l;
        return Kd.forEach((u) => {
          var h;
          W(h = yl[St.GLOBAL][u]).call(h, d) && (l = u);
        }), l;
      }(e), c = [...o, a, e];
      n = s.filter((d) => !W(c).call(c, d));
    } else n = t11;
    n = function(a) {
      let c = [];
      return u_.forEach((d) => {
        W(a).call(a, d) && c.push(d);
      }), c.concat(a.filter((d) => !W(u_).call(u_, d)));
    }(n);
  } else n = t11;
  var i, r;
  return n;
};
function XI(t11) {
  var e, n;
  if (!t11 && W(e = v("AREAS")).call(e, St.EXTENSIONS)) return _.debug("update area from ap : reset"), void Af(vB, true);
  if (!W(n = v("AREAS")).call(n, St.GLOBAL) || !t11) return;
  let i = Zu.EXTENSIONS;
  i && (i = { CODE: d0(St.EXTENSIONS), WEBCS_DOMAIN: ["ap-web-1-".concat(t11, ".agora.io")], WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-".concat(t11, ".ap.sd-rtn.com")], PROXY_CS: ["proxy-ap-web-".concat(t11, ".agora.io")], CDS_AP: ["cds-ap-web-1-".concat(t11, ".agora.io"), "cds-ap-web-2-".concat(t11, ".ap.sd-rtn.com")], ACCOUNT_REGISTER: ["sua-ap-web-1-".concat(t11, ".agora.io"), "sua-ap-web-2-".concat(t11, ".ap.sd-rtn.com")], UAP_AP: ["uap-ap-web-1-".concat(t11, ".agora.io"), "uap-ap-web-2-".concat(t11, ".ap.sd-rtn.com")], EVENT_REPORT_DOMAIN: ["statscollector-1-".concat(t11, ".agora.io")], EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-".concat(t11, ".agora.io")], LOG_UPLOAD_SERVER: ["logservice-".concat(t11, ".agora.io")], PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy-".concat(t11, ".agora.io")] }, _.debug("update area from ap success: ".concat(t11, ",config is "), i), Ot("AREAS", [St.EXTENSIONS], true), Object.keys(i).map((r) => {
    r === "LOG_UPLOAD_SERVER" || r === "EVENT_REPORT_DOMAIN" || r === "EVENT_REPORT_BACKUP_DOMAIN" || r === "PROXY_SERVER_TYPE3" ? Ot(r, i[r][0]) : Ot(r, i[r]);
  }));
}
function Af(t11) {
  let e = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], n = X.reportApiInvoke(null, { name: Te.SET_AREA, options: t11, tag: Zt.TRACER });
  try {
    let i = [];
    if (typeof t11 == "string" && (i = [t11]), Array.isArray(t11) && (t11.forEach((o) => {
      if (!W(UR).call(UR, o)) throw new O(R.INVALID_PARAMS, "invalid area code");
    }), i = t11), Object.prototype.toString.call(t11) === "[object Object]") {
      let { areaCode: o, excludedArea: s } = t11;
      if (!o) throw new O(R.INVALID_PARAMS, "area code is needed");
      let a = o;
      typeof o == "string" && (a = [o]), i = s ? GG(a, s) : a;
    }
    if (!e) {
      if ($r.AREAS) {
        let o = new O(R.PROHIBITED_OPERATION, "setArea is prohibited because of config-distribute");
        return n.onError(o), void _.warning("setArea is prohibited because of config-distribute");
      }
      if (W(i).call(i, St.GLOBAL) && v("AREAS") === St.EXTENSIONS) {
        let o = new O(R.PROHIBITED_OPERATION, "setArea is prohibited because of ap extensions");
        return n.onError(o), void _.warning("setArea is prohibited because of ap extensions");
      }
    }
    Ot("AREAS", i, e);
    let r = jG(i);
    Object.keys(r).map((o) => {
      o === "LOG_UPLOAD_SERVER" || o === "EVENT_REPORT_DOMAIN" || o === "EVENT_REPORT_BACKUP_DOMAIN" || o === "PROXY_SERVER_TYPE3" ? Ot(o, r[o][0]) : Ot(o, r[o]);
    }), _.debug("set area success:", i.join(","));
  } catch (i) {
    throw n.onError(i), i;
  }
  n.onSuccess();
}
function QI(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function em(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? QI(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : QI(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var h_ = 1;
function WG(t11, e, n, i, r) {
  h_ += 1;
  let o = { sid: n.sid, command: "convergeAllocateEdge", uid: "666", appId: n.appId, ts: Math.floor(Date.now() / 1e3), seq: h_, requestId: h_, version: ii, cname: n.cname }, s = { service_name: e, json_body: JSON.stringify(o) }, a, c, d = t11[0];
  return Wi(async () => {
    a = Date.now();
    let l = await Hi(d, { data: s, cancelToken: i, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" } });
    if (c = Date.now() - a, l.code !== 0) {
      let p = new O(R.UNEXPECTED_RESPONSE, "live streaming ap error, code" + l.code, { retry: true, responseTime: c });
      throw _.error(p.toString()), p;
    }
    let u = JSON.parse(l.json_body);
    if (u.code !== 200) {
      let p = new O(R.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(u.code, ", reason: ").concat(u.reason), { code: u.code, responseTime: c });
      throw _.error(p.toString()), p;
    }
    if (!u.servers || u.servers.length === 0) {
      let p = new O(R.UNEXPECTED_RESPONSE, "live streaming app center empty server", { code: u.code, responseTime: c });
      throw _.error(p.toString()), p;
    }
    let h = function(p, g) {
      return { addressList: p.servers.map((E) => "wss://".concat(E.address.replace(/\./g, "-"), ".").concat(v("WORKER_DOMAIN"), ":").concat(E.wss, "?serviceName=").concat(encodeURIComponent(g))), workerToken: p.workerToken, vid: p.vid };
    }(u, e);
    return v("LIVE_STREAMING_ADDRESS") && (h.addressList = v("LIVE_STREAMING_ADDRESS") instanceof Array ? v("LIVE_STREAMING_ADDRESS") : [v("LIVE_STREAMING_ADDRESS")]), em(em({}, h), {}, { responseTime: c });
  }, (l, u) => (X.apworkerEvent(n.sid, { success: true, sc: 200, serviceName: e, responseDetail: JSON.stringify(l.addressList), firstSuccess: u === 0, responseTime: c, serverIp: t11[u % t11.length] }), false), (l, u) => (X.apworkerEvent(n.sid, { success: false, sc: l.data && l.data.code || 200, serviceName: e, responseTime: c, serverIp: t11[u % t11.length] }), !!(l.code !== R.OPERATION_ABORTED && l.code !== R.UNEXPECTED_RESPONSE || l.data && l.data.retry) && (d = t11[(u + 1) % t11.length], true)), r);
}
var p_ = 1;
function ZI(t11, e, n, i) {
  let { url: r, areaCode: o } = t11, { clientId: s, sid: a } = e, c = Date.now(), d, [l, u] = wf(e, o, [ue.CHOOSE_SERVER]), h = he.networkState;
  return Wi(async () => {
    h && he.networkState === wn.OFFLINE && he.onlineWaiter && await j.race([he.onlineWaiter, Me(i && i.maxRetryTimeout || Ee.maxRetryTimeout)]), h = he.networkState;
    let { data: p, headers: g } = await Hi(r, { data: l, cancelToken: n, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
    d = g.http3 === "1" ? 1 : -1, X.reportResourceTiming(r, a), l0(p, r, e, c, [ue.CHOOSE_SERVER], d);
    let E = Dc(p, ue.CHOOSE_SERVER);
    return bf(E), mf(E, r);
  }, (p) => (p && X.joinChooseServer(a, { lts: c, succ: true, csAddr: r, opid: u, serverList: p.gatewayAddrs.map((g) => g.address), ec: null, cid: p.cid.toString(), uid: p.uid.toString(), csIp: p.csIp, unilbsServerIds: [ue.CHOOSE_SERVER].toString(), isHttp3: d }), false), (p) => p.code !== R.OPERATION_ABORTED && (p.code === R.CAN_NOT_GET_GATEWAY_SERVER ? p.data.retry : (X.joinChooseServer(a, { lts: c, succ: false, csAddr: r, serverList: null, opid: u, ec: p.code, csIp: p.data && p.data.csIp, unilbsServerIds: [ue.CHOOSE_SERVER].toString(), extend: JSON.stringify({ networkState: h }), isHttp3: d }), _.warning("[".concat(s || "sid-".concat(a.slice(0, 6)), "] Choose server network error, retry"), p), true)), i);
}
function $I(t11, e, n, i) {
  let r, { url: o, areaCode: s, serviceIds: a } = t11, c = Date.now(), [d, l] = wf(e, s, a), u;
  return Wi(async () => {
    u && he.networkState === wn.OFFLINE && he.onlineWaiter && await j.race([he.onlineWaiter, Me(i && i.maxRetryTimeout || Ee.maxRetryTimeout)]), u = he.networkState;
    let { data: h, headers: p } = await Hi(o, { data: d, cancelToken: n, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
    r = p.http3 === "1" ? 1 : -1, X.reportResourceTiming(o, e.sid), l0(h, o, e, c, a, r);
    let g = Dc(h, ue.CHOOSE_SERVER), E = Dc(h, e.cloudProxyServer === "proxy5" ? ue.CLOUD_PROXY_5 : e.cloudProxyServer === "proxy3" || e.cloudProxyServer === "proxy4" ? ue.CLOUD_PROXY : ue.CLOUD_PROXY_FALLBACK);
    return bf(g), { gatewayInfo: mf(g, o), proxyInfo: E, url: o };
  }, (h) => (h.gatewayInfo && X.joinChooseServer(e.sid, { lts: c, succ: true, csAddr: o, serverList: h.gatewayInfo.gatewayAddrs.map((p) => p.address), ec: null, opid: l, cid: h.gatewayInfo.cid.toString(), uid: h.gatewayInfo.uid.toString(), csIp: h.gatewayInfo.csIp, unilbsServerIds: a.toString(), isHttp3: r }), h.proxyInfo && X.joinWebProxyAP(e.sid, { lts: c, sucess: 1, apServerAddr: o, turnServerAddrList: h.proxyInfo.addresses.map((p) => p.ip).join(","), errorCode: null, eventType: e.cloudProxyServer, unilbsServerIds: a.toString() }), false), (h) => h.code !== R.OPERATION_ABORTED && (h.code === R.CAN_NOT_GET_GATEWAY_SERVER ? h.data.retry : (X.joinWebProxyAP(e.sid, { lts: c, sucess: 0, apServerAddr: o, turnServerAddrList: null, errorCode: h.code, eventType: e.cloudProxyServer, unilbsServerIds: a.toString(), extend: JSON.stringify({ networkState: u }) }), _.warning("[".concat(e.clientId, "] multi unilbs network error, retry"), h), true)), i);
}
var l0 = (t11, e, n, i, r, o) => {
  let { sid: s, clientId: a, cloudProxyServer: c } = n, d = [], l = (u) => {
    u.flag === 4096 ? X.joinChooseServer(s, { lts: i, succ: false, csAddr: e, opid: t11.opid, serverList: null, ec: u.error.message, csIp: u.error.data && u.error.data.csIp, unilbsServerIds: r.toString(), isHttp3: o }) : u.flag !== 1048576 && u.flag !== 4194304 && u.flag !== 4194310 || X.joinWebProxyAP(s, { lts: i, sucess: 0, apServerAddr: e, turnServerAddrList: null, errorCode: u.error.code, eventType: c, unilbsServerIds: r.toString() });
  };
  if (t11.response_body.forEach((u) => {
    let h = u.buffer.code;
    if (u.uri === 23 && h === 0 && !u.buffer.edges_services) if (u.buffer.flag === 4194310) _.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), u.buffer.edges_services = [];
    else {
      let p = { error: new O(R.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: t11.detail[502] }), flag: u.buffer.flag };
      d.push(p), l(p);
    }
    if (h !== 0) {
      let p = ta(h), g = { error: new O(R.CAN_NOT_GET_GATEWAY_SERVER, p.desc, { desc: p.desc, retry: p.retry, csIp: t11.detail[502] }), flag: u.buffer.flag };
      u.buffer.flag === 4194310 ? _.warning(g.error.toString()) : d.push(g), l(g);
    }
  }), d.length) throw _.warning("[".concat(a || "sid-".concat(s.slice(0, 6)), "] multi unilbs ").concat(e, " failed, ").concat(d.map((u) => "flag: ".concat(u.flag, ", message: ").concat(u.error.message, ", retry: ").concat(u.error.data.retry)).join(" | "))), new O(R.CAN_NOT_GET_GATEWAY_SERVER, d.map((u) => "flag: ".concat(u.flag, ", message: ").concat(u.error.message)).join(" | "), { retry: !!d.find((u) => u.error.data.retry), csIp: t11.detail[502], desc: [...new Set(d.map((u) => {
    var h;
    return u == null || (h = u.error) === null || h === void 0 || (h = h.data) === null || h === void 0 ? void 0 : h.desc;
  }).filter((u) => !!u))] });
};
var bf = (t11) => {
  var e, n, i, r;
  if (t11.addresses && t11.addresses.length === 0 && t11.code === 0) throw new O(R.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", { retry: true, csIp: t11.detail && t11.detail[502] });
  if (v("AP_AREA") && ((i = t11.detail) !== null && i !== void 0 && i[23] && typeof ((r = t11.detail) === null || r === void 0 ? void 0 : r[23]) == "string" ? XI(t11.detail[23].toLowerCase()) : XI()), (e = t11.detail) !== null && e !== void 0 && e[19] && typeof ((n = t11.detail) === null || n === void 0 ? void 0 : n[19]) == "string") {
    let s = t11.detail[19], a = s == null ? void 0 : s.split(";");
    for (let c = 0; c < a.length; c++) {
      var o;
      let d = rn(o = a[c]).call(o);
      t11.addresses[c] && a && (t11.addresses[c].fingerprint = d);
    }
  }
  if (v("GATEWAY_ADDRESS") && v("GATEWAY_ADDRESS").length > 0) {
    _.debug("assign gateway address to", v("GATEWAY_ADDRESS"));
    let s = v("GATEWAY_ADDRESS").map((a) => {
      var c, d;
      let l = (c = (d = t11.addresses.find((u) => u.ip === a.ip && u.port === a.port)) === null || d === void 0 ? void 0 : d.fingerprint) !== null && c !== void 0 ? c : "";
      return { ip: a.ip, port: a.port, ticket: t11.addresses[0] && t11.addresses[0].ticket, fingerprint: l };
    });
    t11.addresses = s;
  }
};
var HG = (t11, e) => {
  if (t11.response_body && t11.response_body.length) {
    let n = t11.response_body[0];
    if (n.buffer.code !== 0) {
      let i = ta(n.buffer.code);
      throw new O(R.UPDATE_TICKET_FAILED, "[".concat(n.buffer.code, "]: ").concat(i.desc), { retry: i.retry });
    }
    return n.buffer.ticket;
  }
  throw _.debug("update ticket request received ap response without response body:", e), new O(R.UPDATE_TICKET_FAILED, "cannot find response body from ap response", { retry: false });
};
var wf = (t11, e, n) => {
  let i = Math.floor(Math.random() * 1e12), r = { appid: t11.appId, client_ts: Date.now(), opid: i, sid: t11.sid, request_bodies: [{ uri: 22, buffer: { cname: t11.cname, detail: em({ 6: t11.stringUid, 11: e, 12: v("USE_NEW_TOKEN") ? "1" : void 0, 22: e }, t11.apRTM ? { 26: "RTM2" } : {}), key: t11.token, service_ids: n, uid: t11.uid || 0 } }] };
  r.request_bodies.forEach((s) => {
    t11.multiIP && t11.multiIP.gateway_ip && (s.buffer.detail[5] = JSON.stringify({ vocs_ip: [t11.multiIP.uni_lbs_ip], vos_ip: [t11.multiIP.gateway_ip] }));
  });
  let o = new FormData();
  return o.append("request", JSON.stringify(r)), [o, i];
};
var KG = (t11, e) => {
  let n = Math.floor(Math.random() * 1e12), i = { appid: t11.appId, client_ts: Date.now(), opid: n, sid: t11.sid, request_bodies: [{ uri: 28, buffer: { cname: t11.cname, detail: { 1: "", 6: t11.stringUid, 12: "1" }, token: t11.token, service_ids: e, uid: t11.uid || 0, edges_services: t11.apResponse.addresses.map((o) => ({ ip: o.ip, port: o.port })) } }] }, r = new FormData();
  return r.append("request", JSON.stringify(i)), [r, n];
};
var Ys = 0;
function Ta(t11) {
  return j.all(t11.map((e) => e.then((n) => {
    throw n;
  }, (n) => n))).then((e) => {
    throw e;
  }, (e) => e);
}
var Uc = async (t11) => {
  let { fragementLength: e, referenceList: n, asyncMapHandler: i, allFailedhandler: r, promisesCollector: o } = t11, s = 0, a = e, c, d = 0, l = async () => {
    let u = (() => {
      let h = s * a, p = h + a;
      return n.slice(h, p).map(i);
    })();
    o && o.push(...u);
    try {
      c = await Ta(u);
    } catch (h) {
      if (d += a, s++, !(d >= n.length)) return void await l();
      r(h);
    }
    u.forEach((h) => h.cancel());
  };
  return await l(), c;
};
var u0 = async (t11) => {
  let { referenceList: e, asyncMapHandler: n, closeFn: i } = t11, r = e.length, o = 0, s = async () => {
    let a = n(e.shift());
    try {
      return await a;
    } catch (c) {
      if (o++, o >= r || i != null && i(c)) throw c;
      return s();
    }
  };
  return s();
};
async function nm(t11, e, n, i) {
  return { gatewayInfo: await async function(o, s, a, c) {
    let d = null, l = [], u = async () => {
      let p = v("WEBCS_DOMAIN").slice(0, v("AJAX_REQUEST_CONCURRENT")).map((f) => ({ url: o.proxyServer ? "https://".concat(o.proxyServer, "/ap/?url=").concat(f + "/api/v2/transpond/webrtc?v=2") : "https://".concat(f, "/api/v2/transpond/webrtc?v=2"), areaCode: Mc() })), g = c.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: p.map((f) => f.url) }), E = await Uc({ fragementLength: v("FRAGEMENT_LENGTH"), referenceList: p, asyncMapHandler: (f) => (_.debug("[".concat(o.clientId, "] Connect to choose_server:"), f.url), ZI(f, o, s, a)), allFailedhandler: (f) => {
        throw c.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: f }, g), f[0];
      }, promisesCollector: l });
      return c.recordJoinChannelService({ endTs: Date.now(), status: "success" }, g), E;
    }, h = async () => {
      if (await Me(1e3), d !== null) return d;
      let p = v("WEBCS_DOMAIN_BACKUP_LIST").map((f) => ({ url: o.proxyServer ? "https://".concat(o.proxyServer, "/ap/?url=").concat(f + "/api/v2/transpond/webrtc?v=2") : "https://".concat(f, "/api/v2/transpond/webrtc?v=2"), areaCode: Mc() })), g = c.recordJoinChannelService({ endTs: void 0, startTs: Date.now(), status: "pending", service: "chooseServer", urls: p.map((f) => f.url) }), E = await Uc({ fragementLength: v("FRAGEMENT_LENGTH"), referenceList: p, asyncMapHandler: (f) => (_.debug("[".concat(o.clientId, "] Connect to backup choose_server:"), f.url), ZI(f, o, s, a)), allFailedhandler: (f) => {
        throw c.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: f }, g), f[0];
      }, promisesCollector: l });
      return c.recordJoinChannelService({ endTs: Date.now(), status: "success" }, g), E;
    };
    try {
      return d = await Ta([u(), h()]), l.length && l.forEach((p) => p.cancel && typeof p.cancel == "function" && p.cancel()), d;
    } catch (p) {
      throw p[0];
    }
  }(t11, e, n, i) };
}
async function tv(t11, e, n, i, r) {
  let o = t11.cloudProxyServer;
  if (o === "disabled") {
    if (t11.useLocalAccessPoint) return await nm(t11, e, n, r);
    if (v("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
      let { gatewayInfo: h, proxyInfo: p } = await nv(t11, e, n, r);
      if (t11.turnServer && t11.turnServer.mode !== "auto") return { gatewayInfo: h };
      let g = p.map((E) => ({ turnServerURL: E.address, tcpport: E.tcpport || Ve.tcpport, udpport: E.udpport || Ve.udpport, username: E.username || Ve.username, password: E.password || Ve.password, forceturn: false, security: true }));
      if (r.useP2P) {
        var s;
        let E = (s = t11.uid) !== null && s !== void 0 ? s : h.uid, f = "glb:".concat(E.toString()), S = await PE(f), C = p.map((A) => ({ turnServerURL: A.address, tcpport: A.tcpport || Ve.tcpport, udpport: A.udpport || Ve.udpport, username: f, password: S, forceturn: false, security: true }));
        g.push(...C);
      }
      return t11.turnServer = { mode: "manual", servers: g }, { gatewayInfo: h };
    }
    return await nm(t11, e, n, r);
  }
  let { proxyInfo: a, gatewayInfo: c } = await nv(t11, e, n, r), d = { gatewayInfo: c }, l = a.map((h) => ({ turnServerURL: h.address, tcpport: o === "proxy3" ? void 0 : h.tcpport ? h.tcpport : Ve.tcpport, udpport: o === "proxy4" ? void 0 : h.udpport ? h.udpport : Ve.udpport, username: h.username || Ve.username, password: h.password || Ve.password, forceturn: o !== "proxy4", security: o === "proxy5" }));
  if (r.useP2P) {
    var u;
    let h = (u = t11.uid) !== null && u !== void 0 ? u : c.uid, p = "glb:".concat(h.toString()), g = await PE(p), E = a.map((f) => ({ turnServerURL: f.address, tcpport: o === "proxy3" ? void 0 : f.tcpport || Ve.tcpport, udpport: o === "proxy4" ? void 0 : f.udpport || Ve.udpport, username: p, password: g, forceturn: o !== "proxy4", security: o === "proxy5" }));
    l.push(...E);
  }
  return t11.turnServer = { mode: "manual", servers: l }, _.debug("[".concat(t11.clientId, "] set proxy server: ").concat(t11.proxyServer, ", mode: ").concat(o)), d;
}
async function h0(t11, e, n, i, r) {
  let o = v("ACCOUNT_REGISTER").slice(0, v("AJAX_REQUEST_CONCURRENT")), s = [];
  s = e.proxyServer ? o.map((c) => "https://".concat(e.proxyServer, "/ap/?url=").concat(c + "/api/v1")) : o.map((c) => "https://".concat(c, "/api/v1"));
  let a = r == null ? void 0 : r.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "stringUID", urls: s });
  try {
    let c = await async function(d, l, u, h, p) {
      let g = Date.now(), E = { sid: u.sid, opid: 10, appid: u.appId, string_uid: l }, f = d[0], S = await Wi(() => Hi(f + "".concat(f.indexOf("?") === -1 ? "?" : "&", "action=stringuid"), { data: E, cancelToken: h, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } }), (C, A) => {
        if (C.code === 0) {
          if (C.uid <= 0 || C.uid >= Math.pow(2, 32)) throw _.error("Invalid Uint Uid ".concat(l, " => ").concat(C.uid), C), X.reqUserAccount(E.sid, { lts: g, success: false, serverAddr: f, stringUid: E.string_uid, uid: C.uid, errorCode: R.INVALID_UINT_UID_FROM_STRING_UID, extend: E }), new O(R.INVALID_UINT_UID_FROM_STRING_UID);
          return X.reqUserAccount(E.sid, { lts: g, success: true, serverAddr: f, stringUid: E.string_uid, uid: C.uid, errorCode: null, extend: E }), false;
        }
        let b = ta(C.code);
        return b.retry && (f = d[(A + 1) % d.length]), X.reqUserAccount(E.sid, { lts: g, success: false, serverAddr: f, stringUid: E.string_uid, uid: C.uid, errorCode: b.desc, extend: E }), b.retry;
      }, (C, A) => C.code !== R.OPERATION_ABORTED && (X.reqUserAccount(E.sid, { lts: g, success: false, serverAddr: f, stringUid: E.string_uid, uid: null, errorCode: C.code, extend: E }), f = d[(A + 1) % d.length], true), p);
      if (S.code !== 0) {
        let C = ta(S.code);
        throw new O(R.UNEXPECTED_RESPONSE, C.desc);
      }
      return S;
    }(s, t11, e, n, i);
    return r == null ? void 0 : r.recordJoinChannelService({ status: "success", endTs: Date.now() }, a), c.uid;
  } catch (c) {
    throw r == null ? void 0 : r.recordJoinChannelService({ status: "error", endTs: Date.now(), errors: [c] }, a), c;
  }
}
async function YG(t11, e, n) {
  let i = v("ACCOUNT_REGISTER"), r = [];
  r = e.proxyServer ? i.map((o) => "https://".concat(e.proxyServer, "/ap/?url=").concat(o + "/api/v1")) : i.map((o) => "https://".concat(o, "/api/v1"));
  try {
    return await u0({ referenceList: r, asyncMapHandler: (s) => async function(a, c, d, l) {
      let u = Date.now(), h = { sid: d.sid, opid: 10, appid: d.appId, string_uid: c };
      try {
        let p = await Hi(a + "".concat(a.indexOf("?") === -1 ? "?" : "&", "action=stringuid"), { data: h, cancelToken: l, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 72 } });
        if (p.code !== 0) {
          let g = ta(p.code);
          throw new O(R.UNEXPECTED_RESPONSE, "preload sua error:".concat(g.desc), g);
        }
        if (p.uid <= 0 || p.uid >= Math.pow(2, 32)) throw new O(R.INVALID_UINT_UID_FROM_STRING_UID);
        return { requestTime: u, url: a, req: h, uid: p.uid, elapse: Date.now() - u };
      } catch (p) {
        throw p;
      }
    }(s, t11, e, n), closeFn: (s) => s.code === R.OPERATION_ABORTED || s.code === R.UNEXPECTED_RESPONSE && !s.data.retry });
  } catch (o) {
    throw o;
  }
}
async function qG(t11, e, n) {
  let i = v("CDS_AP").slice(0, v("AJAX_REQUEST_CONCURRENT")).map((c) => t11.proxyServer ? "https://".concat(t11.proxyServer, "/ap/?url=").concat(c + "/api/v1") : "https://".concat(c, "/api/v1?action=config")), r = i.map((c) => function(d, l, u, h) {
    let p = mt(), g = { flag: 64, cipher_method: 0, features: { device: p.name, system: p.os, system_general: navigator.userAgent, vendor: l.appId, version: ii, cname: l.cname, sid: l.sid, session_id: l.sid, detail: "", proxyServer: l.proxyServer } };
    return Wi(() => Hi(d, { data: g, timeout: 1e3, cancelToken: u, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 54 } }), void 0, (E) => E.code !== R.OPERATION_ABORTED, h);
  }(c, t11, e, n)), o = null, s = null, a = {};
  try {
    o = await Ta(r);
  } catch (c) {
    if (c.code === R.OPERATION_ABORTED) throw c;
    s = c;
  }
  if (r.forEach((c) => c.cancel()), X.reportApiInvoke(t11.sid, { name: Te.REQUEST_CONFIG_DISTRIBUTE, options: { error: s, res: o } }).onSuccess(), o && o.test_tags) try {
    a = function(c) {
      if (!c.test_tags) return {};
      let d = c.test_tags, l = Object.keys(d), u = {};
      return l.forEach((h) => {
        var p;
        let g = rn(p = h.slice(4)).call(p), E = JSON.parse(d[h])[1];
        u[g] = E;
      }), u;
    }(o);
  } catch {
  }
  return a;
}
async function ev(t11, e) {
  let n = v("WEBCS_DOMAIN").concat(v("WEBCS_DOMAIN_BACKUP_LIST")).map((i) => ({ url: "https://".concat(i, "/api/v2/transpond/webrtc?v=2"), areaCode: Mc(), serviceIds: [ue.CHOOSE_SERVER, ue.CLOUD_PROXY_FALLBACK] }));
  try {
    return await u0({ referenceList: n, asyncMapHandler: (r) => async function(o, s, a) {
      let c, { url: d, areaCode: l, serviceIds: u } = o, h = Date.now(), [p, g] = wf(s, l, u), E = he.networkState;
      try {
        E && he.networkState === wn.OFFLINE && he.onlineWaiter && await j.race([he.onlineWaiter, Me(Ee.maxRetryTimeout)]), E = he.networkState;
        let { data: f, headers: S } = await Hi(d, { data: p, cancelToken: a, headers: { "Content-Type": "multipart/form-data;" } }, true, true);
        c = S.http3 === "1" ? 1 : -1, ((w) => {
          let D = [];
          if (w.response_body.forEach((k) => {
            let B = k.buffer.code;
            if (k.uri === 23 && B === 0 && !k.buffer.edges_services) if (k.buffer.flag === 4194310) k.buffer.edges_services = [];
            else {
              let V = { error: new O(R.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", { retry: true, csIp: w.detail[502] }), flag: k.buffer.flag };
              D.push(V);
            }
            if (B !== 0) {
              let V = ta(B), z = { error: new O(R.CAN_NOT_GET_GATEWAY_SERVER, V.desc, { desc: V.desc, retry: V.retry, csIp: w.detail[502] }), flag: k.buffer.flag };
              k.buffer.flag === 4194310 ? _.warning(z.error.toString()) : D.push(z);
            }
          }), D.length) throw new O(R.CAN_NOT_GET_GATEWAY_SERVER, D.map((k) => "flag: ".concat(k.flag, ", message: ").concat(k.error.message)).join(" | "), { retry: !!D.find((k) => k.error.data.retry), csIp: w.detail[502], desc: [...new Set(D.map((k) => {
            var B;
            return k == null || (B = k.error) === null || B === void 0 || (B = B.data) === null || B === void 0 ? void 0 : B.desc;
          }).filter((k) => !!k))] });
        })(f);
        let A = Dc(f, ue.CHOOSE_SERVER), b = Dc(f, ue.CLOUD_PROXY_FALLBACK);
        return bf(A), { gatewayInfo: mf(A, d), proxyInfo: b, opid: g, requestTime: h, url: d, isHttp3: c, elapse: Date.now() - h };
      } catch (f) {
        throw f;
      }
    }(r, t11, e), closeFn: (r) => r.code === R.OPERATION_ABORTED || r.code === R.CAN_NOT_GET_GATEWAY_SERVER && !r.data.retry });
  } catch (i) {
    throw i;
  }
}
async function nv(t11, e, n, i) {
  let r = v("PROXY_SERVER_TYPE3"), o = (p, g, E) => {
    let f = E || r;
    return Array.isArray(f) && (f = g % 2 == 0 ? r[1] : r[0]), "https://".concat(f, "/ap/?url=").concat(p);
  }, s = null, a = [], c = async () => {
    let p = v("WEBCS_DOMAIN").slice(0, v("AJAX_REQUEST_CONCURRENT")).map((f, S) => {
      let C;
      return C = t11.cloudProxyServer === "disabled" && t11.proxyServer ? o("".concat(f, "/api/v2/transpond/webrtc?v=2"), S, t11.proxyServer) : t11.cloudProxyServer === "disabled" || t11.cloudProxyServer === "fallback" ? "https://".concat(f, "/api/v2/transpond/webrtc?v=2") : o("".concat(f, "/api/v2/transpond/webrtc?v=2"), S), { url: C, areaCode: Mc(), serviceIds: [ue.CHOOSE_SERVER, t11.cloudProxyServer === "proxy5" ? ue.CLOUD_PROXY_5 : t11.cloudProxyServer === "proxy3" || t11.cloudProxyServer === "proxy4" ? ue.CLOUD_PROXY : ue.CLOUD_PROXY_FALLBACK] };
    }), g = i.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: p.map((f) => f.url) }), E = await Uc({ fragementLength: v("FRAGEMENT_LENGTH"), referenceList: p, asyncMapHandler: (f) => (_.debug("[".concat(t11.clientId, "] Connect to choose_server:"), f.url), $I(f, t11, e, n)), allFailedhandler: (f) => {
      throw i.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: f }, g), f[0];
    }, promisesCollector: a });
    return i.recordJoinChannelService({ endTs: Date.now(), status: "success" }, g), E;
  }, d = async () => {
    if (await Me(1e3), s !== null) return s;
    let p = v("WEBCS_DOMAIN_BACKUP_LIST").map((f, S) => {
      let C;
      return C = t11.cloudProxyServer === "disabled" && t11.proxyServer ? o("".concat(f, "/api/v2/transpond/webrtc?v=2"), S, t11.proxyServer) : t11.cloudProxyServer === "disabled" || t11.cloudProxyServer === "fallback" ? "https://".concat(f, "/api/v2/transpond/webrtc?v=2") : o("".concat(f, "/api/v2/transpond/webrtc?v=2"), S), { url: C, areaCode: Mc(), serviceIds: [ue.CHOOSE_SERVER, t11.cloudProxyServer === "proxy5" ? ue.CLOUD_PROXY_5 : t11.cloudProxyServer === "proxy3" || t11.cloudProxyServer === "proxy4" ? ue.CLOUD_PROXY : ue.CLOUD_PROXY_FALLBACK] };
    }), g = i.recordJoinChannelService({ startTs: Date.now(), status: "pending", service: "chooseServer", urls: p.map((f) => f.url) }), E = await Uc({ fragementLength: v("FRAGEMENT_LENGTH"), referenceList: p, asyncMapHandler: (f) => (_.debug("[".concat(t11.clientId, "] Connect to backup choose_server:"), f.url), $I(f, t11, e, n)), allFailedhandler: (f) => {
      throw i.recordJoinChannelService({ endTs: Date.now(), status: "error", errors: f }, g), f[0];
    }, promisesCollector: a });
    return i.recordJoinChannelService({ endTs: Date.now(), status: "success" }, g), E;
  }, l, u, h;
  try {
    ({ gatewayInfo: l, proxyInfo: u, url: h } = await Ta([c(), d()]));
  } catch (p) {
    throw p[0];
  }
  if (a.length && a.forEach((p) => p.cancel && typeof p.cancel == "function" && p.cancel()), !l || !u) throw new O(R.UNEXPECTED_ERROR, "missing gateway or proxy response").print();
  if (t11.apUrl = h, t11.cloudProxyServer !== "disabled" && Array.isArray(r) && h) {
    let p = /^https?:\/\/(.+?)(\/.*)?$/.exec(h)[1];
    W(r).call(r, p) && (t11.proxyServer = p, _.setProxyServer(p), X.setProxyServer(p));
  }
  return s = { gatewayInfo: l, proxyInfo: await kO(u, l.uid) }, s;
}
async function zG(t11, e, n) {
  let i = v("UAP_AP").slice(0, v("AJAX_REQUEST_CONCURRENT")).map((o) => t11.proxyServer ? "https://".concat(t11.proxyServer, "/ap/?url=").concat(o + "/api/v1?action=uap") : "https://".concat(o, "/api/v1?action=uap")), r = i.map((o) => function(s, a, c, d) {
    let l = { command: "convergeAllocateEdge", sid: a.sid, appId: a.appId, token: a.token, ts: Date.now(), version: ii, cname: a.cname, uid: a.uid.toString(), requestId: p_, seq: p_ };
    p_ += 1;
    let u = { service_name: "tele_channel", json_body: JSON.stringify(l) };
    return Wi(async () => {
      let h = await Hi(s, { data: u, cancelToken: c, headers: { "X-Packet-Service-Type": 0, "X-Packet-URI": 61 } });
      if (h.code !== 0) {
        let g = new O(R.UNEXPECTED_RESPONSE, "cross channel ap error, code" + h.code, { retry: true });
        throw _.error(g.toString()), g;
      }
      let p = JSON.parse(h.json_body);
      if (p.code !== 200) {
        let g = new O(R.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(p.code, ", reason: ").concat(p.reason));
        throw _.error(g.toString()), g;
      }
      if (!p.servers || p.servers.length === 0) {
        let g = new O(R.UNEXPECTED_RESPONSE, "cross channel app center empty server");
        throw _.error(g.toString()), g;
      }
      return { vid: p.vid, workerToken: p.workerToken, addressList: (v("CHANNEL_MEDIA_RELAY_SERVERS") || p.servers).map((g) => "wss://".concat(g.address.replace(/\./g, "-"), ".").concat(v("WORKER_DOMAIN"), ":").concat(g.wss)) };
    }, void 0, (h) => !!(h.code !== R.OPERATION_ABORTED && h.code !== R.UNEXPECTED_RESPONSE || h.data && h.data.retry), d);
  }(o, t11, e, n));
  try {
    let o = await Ta(r);
    return r.forEach((s) => s.cancel()), o;
  } catch (o) {
    throw o[0];
  }
}
async function JG(t11, e, n) {
  let i = null, r = [], o = async (s) => {
    let a = v(s ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map((c) => t11.proxyServer ? "https://".concat(t11.proxyServer, "/ap/?url=").concat(c + "/api/v2/transpond/webrtc?v=2") : "https://".concat(c, "/api/v2/transpond/webrtc?v=2"));
    return s && (await Me(1e3), i !== null) ? i : await Uc({ fragementLength: v("FRAGEMENT_LENGTH"), referenceList: a, asyncMapHandler: (c) => (_.debug("[".concat(t11.clientId, "] update ticket, Connect to ").concat(s ? "backup" : "", " choose_server:"), c), function(d, l, u, h) {
      let [p] = KG(l, [ue.CHOOSE_SERVER]), g = he.networkState;
      return Wi(async () => {
        g && he.networkState === wn.OFFLINE && he.onlineWaiter && await j.race([he.onlineWaiter, Me(h && h.maxRetryTimeout || Ee.maxRetryTimeout)]), g = he.networkState;
        let E = await Hi(d, { data: p, cancelToken: u, headers: { "Content-Type": "multipart/form-data;" } }, true);
        return HG(E, d);
      }, () => false, (E) => E.code !== R.OPERATION_ABORTED && (E.code === R.UPDATE_TICKET_FAILED ? E.data.retry : (_.warning("[".concat(l.clientId, "] update ticket network error, retry"), E), true)), h);
    }(c, t11, e, n)), allFailedhandler: (c) => {
      throw c[0];
    }, promisesCollector: r });
  };
  try {
    return i = await Ta([o(false), o(true)]), r.length && r.forEach((s) => s.cancel && typeof s.cancel == "function" && s.cancel()), i;
  } catch (s) {
    throw s[0];
  }
}
function iv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function rv(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? iv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : iv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var im = class extends Xt {
  get isSuccess() {
    return !!this.configs;
  }
  constructor() {
    super(), T(this, "configs", void 0), T(this, "joinInfo", void 0), T(this, "cancelToken", void 0), T(this, "retryConfig", { timeout: 3e3, timeoutFactor: 1.5, maxRetryCount: 1, maxRetryTimeout: 1e4 }), T(this, "interval", void 0), T(this, "mutex", new ze("config-distribute")), T(this, "mutableParamsRead", false);
  }
  startGetConfigDistribute(e, n) {
    this.joinInfo = e, this.cancelToken = n, this.interval && this.stopGetConfigDistribute(), v("ENABLE_CONFIG_DISTRIBUTE") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {
      this.updateConfigDistribute();
    }, v("CONFIG_DISTRIBUTE_INTERVAL")));
  }
  stopGetConfigDistribute() {
    this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0;
  }
  async awaitConfigDistributeComplete() {
    this.mutex.isLocked && (await this.mutex.lock())();
  }
  async updateConfigDistribute() {
    if (this.mutableParamsRead || (this.mutableParamsRead = true, X.reportApiInvoke(null, { options: void 0, name: Te.LOAD_CONFIG_FROM_LOCALSTORAGE, tag: Zt.TRACER }).onSuccess(JSON.stringify($r))), !this.joinInfo || !this.cancelToken || !this.retryConfig) return void _.debug("[config-distribute] get config distribute interrupted have no joininfo");
    let e, n = await this.mutex.lock();
    try {
      e = await qG(this.joinInfo, this.cancelToken, this.retryConfig), _.debug("[config-distribute] get config distribute", JSON.stringify(e)), e.limit_bitrate && this.handleBitrateLimit(e.limit_bitrate), this.cacheGlobalParameterConfig(e), this.configs = e;
    } catch (i) {
      let r = new O(R.NETWORK_RESPONSE_ERROR, i);
      _.warning("[config-distribute] ".concat(r.toString()));
    } finally {
      n();
    }
  }
  getBitrateLimit() {
    return this.configs ? this.configs.limit_bitrate : void 0;
  }
  handleBitrateLimit(e) {
    var n;
    (n = e) && n.uplink && n.id && n.uplink.max_bitrate !== void 0 && n.uplink.min_bitrate !== void 0 && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e.id && this.emit(FE.UPDATE_BITRATE_LIMIT, e) : this.emit(FE.UPDATE_BITRATE_LIMIT, e));
  }
  getLowStreamConfigDistribute() {
    return this.configs && this.configs.limit_bitrate && rv({}, this.configs.limit_bitrate.low_stream_uplink);
  }
  cacheGlobalParameterConfig(e) {
    var n;
    let i = ed(n = Object.keys(e).filter((o) => /^webrtc_ng_global_parameter/.test(o))).call(n);
    for (let o = 0; o < i.length; o++) for (let s = i.length - 1; s > o; s--) {
      let a = i[s];
      if (typeof e[a].__priority == "number") {
        let c = e[a].__priority, d = i[s - 1];
        if (typeof e[d].__priority == "number") {
          if (!(c > e[d].__priority)) continue;
          {
            let l = a;
            i[s] = i[s - 1], i[s - 1] = l;
          }
        } else {
          let l = a;
          i[s] = i[s - 1], i[s - 1] = l;
        }
      }
    }
    let r = {};
    i.forEach((o) => {
      let s = e[o], a = s.__expires;
      Object.keys(s).forEach((c) => {
        c === "__priority" || c === "__expires" || Object.prototype.hasOwnProperty.call(r, c) || (r[c] = rv({ value: s[c] }, a && { expires: a }));
      });
    });
    try {
      (function(a) {
        try {
          let c = Date.now();
          Object.keys(a).forEach((d) => {
            switch (d) {
              case "ENABLE_EVENT_REPORT":
              case "UPLOAD_LOG":
              case "ENABLE_AG_ADAPTATION":
              case "FORCE_AG_HIGH_FRAMERATE":
              case "FORCE_SUPPORT_AG_ADAPTATION":
              case "ENCODER_CONFIG_LIMIT":
              case "CAMERA_CAPTURE_CONFIG":
              case "ENABLE_PRELOAD":
                if (Object.prototype.hasOwnProperty.call(oe, d)) {
                  let { value: l, expires: u } = a[d];
                  if (u && u <= c) return;
                  $r[d] = l, oe[d] = l, _.debug("Update global parameters from config distribute", d, l);
                }
            }
          });
        } catch (c) {
          _.error("Error update config immediately: ".concat(a), c.message);
        }
      })(r);
      let o = JSON.stringify(r), s = window.btoa(o);
      window.localStorage.setItem("websdk_ng_global_parameter", s), _.debug("Caching global parameters ".concat(o));
    } catch (o) {
      _.error("Error caching global parameters:", o.message);
    }
  }
};
var rm = class extends Xt {
  constructor() {
    super(...arguments), T(this, "resultStorage", /* @__PURE__ */ new Map());
  }
  setLocalAudioStats(e, n, i) {
    this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e, this.checkAudioInputLevel(i, n)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e, this.checkSendAudioBitrate(i, n));
  }
  setLocalVideoStats(e, n, i) {
    this.record("SEND_VIDEO_BITRATE_TOO_LOW", e, this.checkSendVideoBitrate(i, n)), this.record("FRAMERATE_INPUT_TOO_LOW", e, this.checkFramerateInput(i, n)), this.record("FRAMERATE_SENT_TOO_LOW", e, this.checkFramerateSent(i));
  }
  setRemoteAudioStats(e, n) {
    let i = e.getUserId();
    this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", i, this.checkAudioOutputLevel(n));
  }
  setRemoteVideoStats(e, n) {
    let i = e.getUserId();
    this.record("RECV_VIDEO_DECODE_FAILED", i, this.checkVideoDecode(n));
  }
  record(e, n, i) {
    if (v("STATS_UPDATE_INTERVAL") > 500) return;
    this.resultStorage.has(e) || this.resultStorage.set(e, { result: [], isPrevNormal: true });
    let r = this.resultStorage.get(e);
    if (r && (r.result.push(i), r.result.length >= 5)) {
      var o;
      let s = W(o = r.result).call(o, true);
      r.isPrevNormal && !s && this.emit("exception", ov[e], e, n), !r.isPrevNormal && s && this.emit("exception", ov[e] + 2e3, e + "_RECOVER", n), r.isPrevNormal = s, r.result = [];
    }
  }
  checkAudioOutputLevel(e) {
    return !(e.receiveBitrate > 0 && e.receiveLevel === 0);
  }
  checkAudioInputLevel(e, n) {
    return n instanceof ge && !n.isActive || !!n.muted || e.sendVolumeLevel !== 0;
  }
  checkFramerateInput(e, n) {
    let i = null;
    n._encoderConfig && n._encoderConfig.frameRate && (i = Nn(n._encoderConfig.frameRate));
    let r = e.captureFrameRate;
    return !i || !r || !(i > 10 && r < 5 || i < 10 && i >= 5 && r <= 1);
  }
  checkFramerateSent(e) {
    return !(e.captureFrameRate && e.sendFrameRate && e.captureFrameRate > 5 && e.sendFrameRate <= 1);
  }
  checkSendVideoBitrate(e, n) {
    return !!n.muted || e.sendBitrate !== 0;
  }
  checkSendAudioBitrate(e, n) {
    return n instanceof ge && !n.isActive || !!n.muted || e.sendBitrate !== 0;
  }
  checkVideoDecode(e) {
    return e.receiveBitrate === 0 || e.decodeFrameRate !== 0;
  }
};
var ov = { FRAMERATE_INPUT_TOO_LOW: 1001, FRAMERATE_SENT_TOO_LOW: 1002, SEND_VIDEO_BITRATE_TOO_LOW: 1003, RECV_VIDEO_DECODE_FAILED: 1005, AUDIO_INPUT_LEVEL_TOO_LOW: 2001, AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002, SEND_AUDIO_BITRATE_TOO_LOW: 2003 };
var qe = new class {
  markSubscribeStart(t11, e) {
    performance.mark("agora-web-sdk/".concat(t11, "/subscribe-").concat(e));
  }
  markPublishStart(t11, e) {
    performance.mark("agora-web-sdk/".concat(t11, "/publish-").concat(e));
  }
  measureFromSubscribeStart(t11, e) {
    let n = performance.getEntriesByName("agora-web-sdk/".concat(t11, "/subscribe-").concat(e));
    if (n.length > 0) {
      let i = n[n.length - 1];
      return Math.round(performance.now() - i.startTime);
    }
    return 0;
  }
  measureFromPublishStart(t11, e) {
    let n = performance.getEntriesByName("agora-web-sdk/".concat(t11, "/publish-").concat(e));
    if (n.length > 0) {
      let i = n[n.length - 1];
      return Math.round(performance.now() - i.startTime);
    }
    return 0;
  }
}();
function Of(t11, e) {
  this.v = t11, this.k = e;
}
function Tt(t11) {
  return new Of(t11, 0);
}
var XG = Lb;
var QG = mr;
xt({ target: "Promise", stat: true, forced: true }, { withResolvers: function() {
  var t11 = QG.f(this);
  return { promise: t11.promise, resolve: t11.resolve, reject: t11.reject };
} });
var ZG = mr;
var $G = _a;
xt({ target: "Promise", stat: true, forced: true }, { try: function(t11) {
  var e = ZG.f(this), n = $G(t11);
  return (n.error ? e.reject : e.resolve)(n.value), e.promise;
} });
var om = ae(XG);
var p0 = Ea.f("asyncIterator");
var tW = ae(p0);
function Ja(t11) {
  var e, n;
  function i(o, s) {
    try {
      var a = t11[o](s), c = a.value, d = c instanceof Of;
      om.resolve(d ? c.v : c).then(function(l) {
        if (d) {
          var u = o === "return" ? "return" : "next";
          if (!c.k || l.done) return i(u, l);
          l = t11[u](l).value;
        }
        r(a.done ? "return" : "normal", l);
      }, function(l) {
        i("throw", l);
      });
    } catch (l) {
      r("throw", l);
    }
  }
  function r(o, s) {
    switch (o) {
      case "return":
        e.resolve({ value: s, done: true });
        break;
      case "throw":
        e.reject(s);
        break;
      default:
        e.resolve({ value: s, done: false });
    }
    (e = e.next) ? i(e.key, e.arg) : n = null;
  }
  this._invoke = function(o, s) {
    return new om(function(a, c) {
      var d = { key: o, arg: s, resolve: a, reject: c, next: null };
      n ? n = n.next = d : (e = n = d, i(o, s));
    });
  }, typeof t11.return != "function" && (this.return = void 0);
}
function Bi(t11) {
  return function() {
    return new Ja(t11.apply(this, arguments));
  };
}
Ja.prototype[typeof Ds == "function" && tW || "@@asyncIterator"] = function() {
  return this;
}, Ja.prototype.next = function(t11) {
  return this._invoke("next", t11);
}, Ja.prototype.throw = function(t11) {
  return this._invoke("throw", t11);
}, Ja.prototype.return = function(t11) {
  return this._invoke("return", t11);
};
var sv = ae(Gi.Object.getOwnPropertySymbols);
var eW = xt;
var nW = Nm.indexOf;
var iW = Nu;
var sm = gc([].indexOf);
var av = !!sm && 1 / sm([1], 1, -0) < 0;
eW({ target: "Array", proto: true, forced: av || !iW("indexOf") }, { indexOf: function(t11) {
  var e = arguments.length > 1 ? arguments[1] : void 0;
  return av ? sm(this, t11, e) || 0 : nW(this, t11, e);
} });
var rW = bi("Array").indexOf;
var oW = hn;
var sW = rW;
var __ = Array.prototype;
var aW = function(t11) {
  var e = t11.indexOf;
  return t11 === __ || oW(__, t11) && e === __.indexOf ? sW : e;
};
var cv = ae(aW);
function cW(t11, e) {
  if (t11 == null) return {};
  var n, i, r = function(s, a) {
    if (s == null) return {};
    var c, d, l = {}, u = NO(s);
    for (d = 0; d < u.length; d++) c = u[d], cv(a).call(a, c) >= 0 || (l[c] = s[c]);
    return l;
  }(t11, e);
  if (sv) {
    var o = sv(t11);
    for (i = 0; i < o.length; i++) n = o[i], cv(e).call(e, n) >= 0 || Object.prototype.propertyIsEnumerable.call(t11, n) && (r[n] = t11[n]);
  }
  return r;
}
function Si(t11) {
  if (Array.isArray(t11)) return t11.map((n) => n);
  if (!dv(t11)) return t11;
  let e = {};
  for (let n in t11) {
    let i = t11[n];
    dv(i) || Array.isArray(i) ? e[n] = Si(i) : e[n] = i;
  }
  return e;
}
function dv(t11) {
  return !(typeof t11 != "object" || Array.isArray(t11) || !t11);
}
var cc = class {
  constructor(e) {
    T(this, "input", []), T(this, "size", void 0), this.size = e;
  }
  add(e) {
    this.input.push(e), this.input.length > this.size && this.input.splice(0, 1);
  }
  diffMean() {
    return this.input.length === 0 ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;
  }
};
var hr = { address: "unknown", candidateType: "unknown", id: "unknown", port: 0, priority: 0, protocol: "unknown", type: "unknown" };
var xc = { timestamp: 0, bitrate: { actualEncoded: 0, transmit: 0 }, sendPacketLossRate: 0, recvPacketLossRate: 0, videoRecv: [], videoSend: [], audioRecv: [], audioSend: [], selectedCandidatePair: { id: "unknown", localCandidate: hr, remoteCandidate: hr } };
var _0 = { firsCount: 0, nacksCount: 0, plisCount: 0, framesDecodeCount: 0, framesDecodeInterval: 0, framesDecodeFreezeTime: 0, decodeFrameRate: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packets: 0, ssrc: 0, qpSumPerFrame: 0, framesDroppedCount: 0, outputFrameRate: 0 };
var E0 = { firsCount: 0, nacksCount: 0, plisCount: 0, frameCount: 0, bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0, qpSumPerFrame: 0 };
var m0 = { bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0, jitterMs: 0 };
var f0 = { jitterBufferMs: 0, jitterMs: 0, bytes: 0, packetsLost: 0, packetLostRate: 0, packetsDiscarded: 0, packets: 0, ssrc: 0, receivedFrames: 0, droppedFrames: 0, concealedSamples: 0 };
function lv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function uv(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? lv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : lv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var Vc = class {
  constructor(e, n) {
    T(this, "onFirstVideoReceived", void 0), T(this, "onFirstVideoDecoded", void 0), T(this, "onFirstAudioReceived", void 0), T(this, "onFirstVideoDecodedTimeout", void 0), T(this, "onFirstAudioDecoded", void 0), T(this, "onSelectedLocalCandidateChanged", void 0), T(this, "onSelectedRemoteCandidateChanged", void 0), T(this, "videoIsReady", false), T(this, "videoIsReady2", {}), T(this, "pc", void 0), T(this, "options", void 0), T(this, "intervalTimer", void 0), T(this, "stats", Si(xc)), T(this, "isFirstVideoReceived", {}), T(this, "isFirstVideoDecoded", {}), T(this, "isFirstAudioReceived", {}), T(this, "isFirstAudioDecoded", {}), T(this, "isFirstVideoDecodedTimeout", {}), T(this, "lossRateWindowStats", []), this.pc = e, this.options = n, this.intervalTimer = window.setInterval(async () => {
      this.updateStats();
    }, this.options.updateInterval);
  }
  getStats() {
    return this.stats;
  }
  getSelectedCandidatePair() {
    return new j((e) => {
      e({ local: uv({}, hr), remote: uv({}, hr) });
    });
  }
  setVideoIsReady(e) {
    this.videoIsReady = e;
  }
  setVideoIsReady2(e, n) {
    this.videoIsReady2[e] = n;
  }
  getVideoIsReady(e) {
    return this.videoIsReady2[e] || false;
  }
  setIsFirstAudioDecoded(e) {
  }
  destroy() {
    window.clearInterval(this.intervalTimer), this.pc = void 0;
  }
  calcLossRate(e) {
    this.lossRateWindowStats.push(e), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);
    let n = this.lossRateWindowStats.length, i = ["videoSend", "audioSend", "videoRecv", "audioRecv"], r = 0, o = 0, s = 0, a = 0;
    for (let c of i) e[c].forEach((d, l) => {
      if (!this.lossRateWindowStats[n - 1][c][l] || !this.lossRateWindowStats[0][c][l]) return;
      let u = this.lossRateWindowStats[n - 1][c][l].packets - this.lossRateWindowStats[0][c][l].packets, h = this.lossRateWindowStats[n - 1][c][l].packetsLost - this.lossRateWindowStats[0][c][l].packetsLost;
      c === "videoSend" || c === "audioSend" ? (r += u, s += h) : (o += u, a += h), Number.isNaN(u) || Number.isNaN(u) ? d.packetLostRate = 0 : d.packetLostRate = u <= 0 || h <= 0 ? 0 : h / (u + h);
    });
    e.sendPacketLossRate = r <= 0 || s <= 0 ? 0 : s / (r + s), e.recvPacketLossRate = o <= 0 || a <= 0 ? 0 : a / (o + a);
  }
};
function hv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function dW(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? hv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : hv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var am = class extends Vc {
  constructor() {
    super(...arguments), T(this, "_stats", xc), T(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map());
  }
  async updateStats() {
    let e = await this._getStats(), n = this.statsResponsesToObjects(e);
    this._stats = Si(xc);
    let i = n.filter((o) => o.type === "ssrc");
    this.processSSRCStats(i);
    let r = n.find((o) => o.type === "VideoBwe");
    r && this.processBandwidthStats(r), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
  }
  processBandwidthStats(e) {
    this._stats.bitrate = { actualEncoded: Number(e.googActualEncBitrate), targetEncoded: Number(e.googTargetEncBitrate), retransmit: Number(e.googRetransmitBitrate), transmit: Number(e.googTransmitBitrate) }, this._stats.sendBandwidth = Number(e.googAvailableSendBandwidth);
  }
  processSSRCStats(e) {
    e.forEach((n) => {
      var i;
      let r = W(i = n.id).call(i, "send");
      switch ("".concat(n.mediaType, "_").concat(r ? "send" : "recv")) {
        case "video_send": {
          let o = Si(E0);
          o.codec = n.googCodecName, o.adaptionChangeReason = "none", n.googCpuLimitedResolution && (o.adaptionChangeReason = "cpu"), n.googBandwidthLimitedResolution && (o.adaptionChangeReason = "bandwidth"), o.avgEncodeMs = Number(n.googAvgEncodeMs), o.inputFrame = { width: Number(n.googFrameWidthInput) || Number(n.googFrameWidthSent), height: Number(n.googFrameHeightInput) || Number(n.googFrameHeightSent), frameRate: Number(n.googFrameRateInput) }, o.sentFrame = { width: Number(n.googFrameWidthSent), height: Number(n.googFrameHeightSent), frameRate: Number(n.googFrameRateInput) }, o.firsCount = Number(n.googFirReceived), o.nacksCount = Number(n.googNacksReceived), o.plisCount = Number(n.googPlisReceived), o.frameCount = Number(n.framesEncoded), o.bytes = Number(n.bytesSent), o.packets = Number(n.packetsSent), o.packetsLost = Number(n.packetsLost), o.ssrc = Number(n.ssrc), o.rttMs = Number(n.googRtt || 0), this._stats.videoSend.push(o), this._stats.rtt = o.rttMs;
          break;
        }
        case "video_recv": {
          let o = Si(_0), s = this.lastDecodeVideoReceiverStats.get(Number(n.ssrc));
          if (o.codec = n.googCodecName, o.targetDelayMs = Number(n.googTargetDelayMs), o.renderDelayMs = Number(n.googRenderDelayMs), o.currentDelayMs = Number(n.googCurrentDelayMs), o.minPlayoutDelayMs = Number(n.googMinPlayoutDelayMs), o.decodeMs = Number(n.googDecodeMs), o.maxDecodeMs = Number(n.googMaxDecodeMs), o.receivedFrame = { width: Number(n.googFrameWidthReceived), height: Number(n.googFrameHeightReceived), frameRate: Number(n.googFrameRateReceived) }, o.decodedFrame = { width: Number(n.googFrameWidthReceived), height: Number(n.googFrameHeightReceived), frameRate: Number(n.googFrameRateDecoded) }, o.decodeFrameRate = Number(n.googFrameRateDecoded), o.outputFrame = { width: Number(n.googFrameWidthReceived), height: Number(n.googFrameHeightReceived), frameRate: Number(n.googFrameRateOutput) }, o.jitterBufferMs = Number(n.googJitterBufferMs), o.firsCount = Number(n.googFirsSent), o.nacksCount = Number(n.googNacksSent), o.plisCount = Number(n.googPlisSent), o.framesDecodeCount = Number(n.framesDecoded), o.bytes = Number(n.bytesReceived), o.packets = Number(n.packetsReceived), o.packetsLost = Number(n.packetsLost), o.ssrc = Number(n.ssrc), o.packets > 0 && !this.isFirstVideoReceived[o.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(o.ssrc), this.isFirstVideoReceived[o.ssrc] = true), o.framesDecodeCount > 0 && !this.isFirstVideoDecoded[o.ssrc] && (this.onFirstVideoDecoded && this.onFirstVideoDecoded(o.ssrc, o.decodedFrame.width, o.decodedFrame.height), this.isFirstVideoDecoded[o.ssrc] = true), s) {
            let a = s.stats, c = Date.now() - s.lts;
            o.framesDecodeFreezeTime = a.framesDecodeFreezeTime, o.framesDecodeInterval = a.framesDecodeInterval, o.framesDecodeCount > a.framesDecodeCount && this.isFirstVideoDecoded[o.ssrc] ? (s.lts = Date.now(), o.framesDecodeInterval = c, o.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(n.ssrc, 10)) ? o.framesDecodeFreezeTime += o.framesDecodeInterval : this.setVideoIsReady2(parseInt(n.ssrc, 10), true))) : o.framesDecodeCount < s.stats.framesDecodeCount && (o.framesDecodeInterval = 0);
          }
          this.lastDecodeVideoReceiverStats.set(o.ssrc, { stats: dW({}, o), lts: Date.now() }), this._stats.videoRecv.push(o);
          break;
        }
        case "audio_recv": {
          let o = Si(f0);
          o.codec = n.googCodecName, o.outputLevel = Math.abs(Number(n.audioOutputLevel)) / 32767, o.decodingCNG = Number(n.googDecodingCNG), o.decodingCTN = Number(n.googDecodingCTN), o.decodingCTSG = Number(n.googDecodingCTSG), o.decodingNormal = Number(n.googDecodingNormal), o.decodingPLC = Number(n.googDecodingPLC), o.decodingPLCCNG = Number(n.googDecodingPLCCNG), o.expandRate = Number(n.googExpandRate), o.accelerateRate = Number(n.googAccelerateRate), o.preemptiveExpandRate = Number(n.googPreemptiveExpandRate), o.secondaryDecodedRate = Number(n.googSecondaryDecodedRate), o.speechExpandRate = Number(n.googSpeechExpandRate), o.preferredJitterBufferMs = Number(n.googPreferredJitterBufferMs), o.jitterBufferMs = Number(n.googJitterBufferMs), o.jitterMs = Number(n.googJitterReceived), o.bytes = Number(n.bytesReceived), o.packets = Number(n.packetsReceived), o.packetsLost = Number(n.packetsLost), o.ssrc = Number(n.ssrc), o.receivedFrames = Number(n.googDecodingCTN) || Number(n.packetsReceived), o.droppedFrames = Number(n.googDecodingPLC) + Number(n.googDecodingPLCCNG) || Number(n.packetsLost), o.receivedFrames > 0 && !this.isFirstAudioReceived[o.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(o.ssrc), this.isFirstAudioReceived[o.ssrc] = true), o.decodingNormal > 0 && !this.isFirstAudioDecoded[o.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(o.ssrc), this.isFirstAudioDecoded[o.ssrc] = true), this._stats.audioRecv.push(o);
          break;
        }
        case "audio_send": {
          let o = Si(m0);
          o.codec = n.googCodecName, o.inputLevel = Math.abs(Number(n.audioInputLevel)) / 32767, o.aecReturnLoss = Number(n.googEchoCancellationReturnLoss || 0), o.aecReturnLossEnhancement = Number(n.googEchoCancellationReturnLossEnhancement || 0), o.residualEchoLikelihood = Number(n.googResidualEchoLikelihood || 0), o.residualEchoLikelihoodRecentMax = Number(n.googResidualEchoLikelihoodRecentMax || 0), o.bytes = Number(n.bytesSent), o.packets = Number(n.packetsSent), o.packetsLost = Number(n.packetsLost), o.ssrc = Number(n.ssrc), o.rttMs = Number(n.googRtt || 0), this._stats.rtt = o.rttMs, this._stats.audioSend.push(o);
          break;
        }
      }
    });
  }
  _getStats() {
    return new j((e, n) => {
      this.pc.getStats(e, n);
    });
  }
  statsResponsesToObjects(e) {
    let n = [];
    return e.result().forEach((i) => {
      let r = { id: i.id, timestamp: i.timestamp.valueOf().toString(), type: i.type };
      i.names().forEach((o) => {
        r[o] = i.stat(o);
      }), n.push(r);
    }), n;
  }
};
function pv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Ao(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? pv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : pv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var hu = class extends Vc {
  constructor() {
    super(...arguments), T(this, "_stats", xc), T(this, "report", void 0), T(this, "lastDecodeVideoReceiverStats", /* @__PURE__ */ new Map()), T(this, "lastVideoFramesRecv", /* @__PURE__ */ new Map()), T(this, "lastVideoFramesSent", /* @__PURE__ */ new Map()), T(this, "lastVideoFramesDecode", /* @__PURE__ */ new Map()), T(this, "lastVideoFramesOutput", /* @__PURE__ */ new Map()), T(this, "lastVideoJBDelay", /* @__PURE__ */ new Map()), T(this, "lastAudioJBDelay", /* @__PURE__ */ new Map()), T(this, "mediaBytesSent", /* @__PURE__ */ new Map()), T(this, "mediaBytesRetransmit", /* @__PURE__ */ new Map()), T(this, "mediaBytesTargetEncode", /* @__PURE__ */ new Map()), T(this, "lastEncoderMs", /* @__PURE__ */ new Map());
  }
  async updateStats() {
    this.report = await this.pc.getStats(), this._stats = Si(xc), this.report.forEach((e) => {
      switch (e.type) {
        case kn.OUTBOUND:
        case kn.INBOUND: {
          let n = e.mediaType || e.kind, i = !n && "frameWidth" in e, r = !n && !("frameWidth" in e);
          e.type === kn.OUTBOUND ? n === "audio" || r ? this.processAudioOutboundStats(e) : (n === "video" || i) && this.processVideoOutboundStats(e) : e.type === kn.INBOUND && (n === "audio" || r ? this.processAudioInboundStats(e) : (n === "video" || i) && this.processVideoInboundStats(e));
          break;
        }
        case kn.TRANSPORT: {
          let n = this.report.get(e.selectedCandidatePairId);
          n && this.processCandidatePairStats(n);
          break;
        }
        case kn.CANDIDATE_PAIR:
          e.selected && this.processCandidatePairStats(e);
      }
    }), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats;
  }
  async getSelectedCandidatePair() {
    let e = await this.pc.getStats(), n = { local: Ao({}, hr), remote: Ao({}, hr) };
    return e.forEach((i) => {
      let r;
      if (i.type === kn.TRANSPORT && (r = e.get(i.selectedCandidatePairId)), i.type === kn.CANDIDATE_PAIR && i.selected && (r = i), r) {
        let o = (s, a) => {
          s.type = a.type, s.id = a.id, a.address && (s.address = a.address), a.candidateType && (s.candidateType = a.candidateType), a.port && (s.port = a.port), a.priority && (s.priority = a.priority), a.protocol && (s.protocol = a.protocol), a.relayProtocol && (s.relayProtocol = a.relayProtocol);
        };
        if (r.localCandidateId) {
          let s = e.get(r.localCandidateId);
          s && o(n.local, s);
        }
        if (r.remoteCandidateId) {
          let s = e.get(r.remoteCandidateId);
          s && o(n.remote, s);
        }
      }
    }), n;
  }
  processCandidatePairStats(e) {
    if (this._stats.sendBandwidth = e.availableOutgoingBitrate || 0, e.currentRoundTripTime && (this._stats.rtt = 1e3 * e.currentRoundTripTime), this._stats.videoSend.forEach((n) => {
      e.currentRoundTripTime && (n.rttMs = 1e3 * e.currentRoundTripTime);
    }), this._stats.audioSend.forEach((n) => {
      e.currentRoundTripTime && (n.rttMs = 1e3 * e.currentRoundTripTime);
    }), this._stats.selectedCandidatePair.id = e.id, e.localCandidateId) {
      let n = this.report.get(e.localCandidateId);
      n && this.processCandidateStats(n);
    }
    if (e.remoteCandidateId) {
      let n = this.report.get(e.remoteCandidateId);
      n && this.processCandidateStats(n);
    }
  }
  processCandidateStats(e) {
    let n;
    e.type === kn.LOCAL_CANDIDATE && (n = this._stats.selectedCandidatePair.localCandidate), e.type === kn.REMOTE_CANDIDATE && (n = this._stats.selectedCandidatePair.remoteCandidate), n && (n.type = e.type, n.id = e.id, e.address && (n.address = e.address), e.candidateType && (n.candidateType = e.candidateType), e.port && (n.port = e.port), e.priority && (n.priority = e.priority), e.protocol && (n.protocol = e.protocol), e.relayProtocol && (n.relayProtocol = e.relayProtocol), e.type === kn.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== n.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(Ao({}, n), Ao({}, this.stats.selectedCandidatePair.localCandidate)), e.type === kn.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== n.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(Ao({}, n), Ao({}, this.stats.selectedCandidatePair.remoteCandidate)));
  }
  processAudioInboundStats(e) {
    let n = this._stats.audioRecv.find((i) => i.ssrc === e.ssrc);
    n || (n = Si(f0), this._stats.audioRecv.push(n)), n.ssrc = e.ssrc, n.packets = e.packetsReceived, n.packetsLost = e.packetsLost, n.packetsDiscarded = e.packetsDiscarded, n.bytes = e.bytesReceived, n.jitterMs = 1e3 * e.jitter, this.processAudioTrackReceiverStats(e, e.trackId, n), e.codecId && (n.codec = this.getCodecFromCodecStats(e.codecId)), n.receivedFrames || (n.receivedFrames = e.packetsReceived), n.droppedFrames || (n.droppedFrames = e.packetsLost), n.receivedFrames > 0 && !this.isFirstAudioReceived[n.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(n.ssrc), this.isFirstAudioReceived[n.ssrc] = true), n.outputLevel && n.outputLevel > 0 && !this.isFirstAudioDecoded[n.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(n.ssrc), this.isFirstAudioDecoded[n.ssrc] = true), typeof e.concealedSamples == "number" && (n.concealedSamples = e.concealedSamples);
  }
  processVideoInboundStats(e) {
    let n = this._stats.videoRecv.find((a) => a.ssrc === e.ssrc);
    n || (n = Si(_0), this._stats.videoRecv.push(n)), n.ssrc = e.ssrc, n.packets = e.packetsReceived, n.packetsLost = e.packetsLost, n.bytes = e.bytesReceived, n.firsCount = e.firCount, n.nacksCount = e.nackCount, n.plisCount = e.pliCount, n.framesDecodeCount = e.framesDecoded, n.framesDroppedCount = e.framesDropped, n.totalInterFrameDelay = e.totalInterFrameDelay, n.totalSquaredInterFrameDelay = e.totalSquaredInterFrameDelay, n.totalFreezesDuration = e.totalFreezesDuration;
    let i = this.lastDecodeVideoReceiverStats.get(n.ssrc), r = this.lastVideoFramesDecode.get(n.ssrc), o = this.lastVideoFramesOutput.get(n.ssrc), s = Date.now();
    if (n.framesDecodeCount > 0 && !this.isFirstVideoDecoded[n.ssrc]) {
      let a = n.decodedFrame ? n.decodedFrame.width : 0, c = n.decodedFrame ? n.decodedFrame.height : 0;
      this.onFirstVideoDecoded && this.onFirstVideoDecoded(n.ssrc, a, c), this.isFirstVideoDecoded[n.ssrc] = true;
    }
    if (i) {
      let a = i.stats, c = s - i.lts;
      n.framesDecodeFreezeTime = a.framesDecodeFreezeTime, n.framesDecodeInterval = a.framesDecodeInterval, !this.isFirstVideoDecoded[n.ssrc] && c > this.options.firstVideoDecodedTimeout && !this.isFirstVideoDecodedTimeout[n.ssrc] && (this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(n.ssrc), this.isFirstVideoDecodedTimeout[n.ssrc] = true), n.framesDecodeCount > a.framesDecodeCount && this.isFirstVideoDecoded[n.ssrc] ? (i.lts = Date.now(), n.framesDecodeInterval = c, n.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e.ssrc)) ? n.framesDecodeFreezeTime += n.framesDecodeInterval : this.setVideoIsReady2(parseInt(e.ssrc, 10), true))) : n.framesDecodeCount < a.framesDecodeCount && (n.framesDecodeInterval = 0), e.framesDecoded && e.qpSum && (i.stats.framesDecodeCount > e.framesDecoded ? n.qpSumPerFrame = e.qpSum / e.framesDecoded : n.qpSumPerFrame = (e.qpSum - i.qpSum) / (e.framesDecoded - i.stats.framesDecodeCount));
    }
    r && s - r.lts >= 800 ? (n.decodeFrameRate = Math.round((n.framesDecodeCount - r.count) / ((s - r.lts) / 1e3)), this.lastVideoFramesDecode.set(n.ssrc, { count: n.framesDecodeCount, lts: s, rate: n.decodeFrameRate })) : r ? n.decodeFrameRate = r.rate : this.lastVideoFramesDecode.set(n.ssrc, { count: n.framesDecodeCount, lts: s, rate: 0 }), n.framesDroppedCount && e.framesReceived && (o && s - o.lts >= 800 ? (n.outputFrameRate = Math.round((e.framesReceived - n.framesDroppedCount - o.count) / ((s - o.lts) / 1e3)), this.lastVideoFramesOutput.set(n.ssrc, { count: e.framesReceived - n.framesDroppedCount, lts: s, rate: Math.max(n.outputFrameRate, 0) })) : o ? n.outputFrameRate = o.rate : this.lastVideoFramesOutput.set(n.ssrc, { count: e.framesReceived - n.framesDroppedCount, lts: s, rate: 0 })), e.totalDecodeTime && (n.decodeMs = 1e3 * e.totalDecodeTime), this.processVideoTrackReceiverStats(e, e.trackId, n), e.codecId && (n.codec = this.getCodecFromCodecStats(e.codecId)), e.framerateMean && (n.framesRateFirefox = e.framerateMean), n.packets > 0 && !this.isFirstVideoReceived[n.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(n.ssrc), this.isFirstVideoReceived[n.ssrc] = true), this.lastDecodeVideoReceiverStats.set(n.ssrc, { stats: Ao({}, n), lts: i ? i.lts : Date.now(), qpSum: e.qpSum });
  }
  processVideoOutboundStats(e) {
    let n = this._stats.videoSend.find((r) => r.ssrc === e.ssrc);
    n || (n = Si(E0), this._stats.videoSend.push(n));
    let i = this.mediaBytesSent.get(e.ssrc);
    if (i) i.add(e.bytesSent);
    else {
      let r = new cc(10);
      r.add(e.bytesSent), this.mediaBytesSent.set(e.ssrc, r);
    }
    if (e.retransmittedBytesSent !== void 0) {
      let r = this.mediaBytesRetransmit.get(e.ssrc);
      if (r) r.add(e.retransmittedBytesSent);
      else {
        let o = new cc(10);
        o.add(e.retransmittedBytesSent), this.mediaBytesRetransmit.set(e.ssrc, o);
      }
    }
    if (e.totalEncodedBytesTarget) {
      let r = this.mediaBytesTargetEncode.get(e.ssrc);
      if (r) r.add(e.totalEncodedBytesTarget);
      else {
        let o = new cc(10);
        o.add(e.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e.ssrc, o);
      }
    }
    if (n.ssrc = e.ssrc, n.bytes = e.bytesSent, n.packets = e.packetsSent, n.firsCount = e.firCount, n.nacksCount = e.nackCount, n.plisCount = e.pliCount, n.frameCount = e.framesEncoded, n.adaptionChangeReason = e.qualityLimitationReason, n.scalabilityMode = e.scalabilityMode, e.totalEncodeTime && e.framesEncoded) {
      let r = this.lastEncoderMs.get(e.ssrc);
      if (!r || r.lastFrameCount > e.framesEncoded) n.avgEncodeMs = 1e3 * e.totalEncodeTime / e.framesEncoded;
      else {
        let o = e.framesEncoded - r.lastFrameCount, s = e.totalEncodeTime - r.lastEncoderTime;
        n.avgEncodeMs = 1e3 * s / o;
      }
    }
    if (e.framesEncoded && e.qpSum) {
      let r = this.lastEncoderMs.get(e.ssrc);
      !r || r.lastFrameCount > e.framesEncoded ? n.qpSumPerFrame = e.qpSum / e.framesEncoded : n.qpSumPerFrame = (e.qpSum - r.lastQpSum) / (e.framesEncoded - r.lastFrameCount);
    }
    if (this.lastEncoderMs.set(e.ssrc, { lastFrameCount: e.framesEncoded, lastEncoderTime: e.totalEncodeTime, lastQpSum: e.qpSum, lts: Date.now() }), e.codecId && (n.codec = this.getCodecFromCodecStats(e.codecId)), e.mediaSourceId && this.processVideoMediaSource(e.mediaSourceId, n), this.processVideoTrackSenderStats(e, e.trackId, n), e.remoteId) this.processRemoteInboundStats(e.remoteId, n);
    else {
      let r = this.findRemoteStatsId(e.ssrc, kn.REMOTE_INBOUND);
      r && this.processRemoteInboundStats(r, n);
    }
  }
  processAudioOutboundStats(e) {
    let n = this._stats.audioSend.find((i) => i.ssrc === e.ssrc);
    if (n || (n = Si(m0), this._stats.audioSend.push(n)), n.ssrc = e.ssrc, n.packets = e.packetsSent, n.bytes = e.bytesSent, e.mediaSourceId && this.processAudioMediaSource(e.mediaSourceId, n), e.codecId && (n.codec = this.getCodecFromCodecStats(e.codecId)), this.processAudioTrackSenderStats(e, e.trackId, n), e.remoteId) this.processRemoteInboundStats(e.remoteId, n);
    else {
      let i = this.findRemoteStatsId(e.ssrc, kn.REMOTE_INBOUND);
      i && this.processRemoteInboundStats(i, n);
    }
  }
  findRemoteStatsId(e, n) {
    var i;
    let r = Array.from(Pr(i = this.report).call(i)).find((o) => o.type === n && o.ssrc === e);
    return r ? r.id : null;
  }
  processVideoMediaSource(e, n) {
    let i = this.report.get(e);
    i && i.width && i.height && i.framesPerSecond && (n.inputFrame = { width: i.width, height: i.height, frameRate: i.framesPerSecond });
  }
  processAudioMediaSource(e, n) {
    let i = this.report.get(e);
    i && (n.inputLevel = i.audioLevel);
  }
  processVideoTrackSenderStats(e, n, i) {
    var r, o, s, a;
    let c = n ? this.report.get(n) : void 0, d = (r = c == null ? void 0 : c.framesSent) !== null && r !== void 0 ? r : e.framesSent;
    if (typeof d != "number") return;
    let l = (o = c == null ? void 0 : c.frameWidth) !== null && o !== void 0 ? o : e.frameWidth, u = (s = c == null ? void 0 : c.frameHeight) !== null && s !== void 0 ? s : e.frameHeight, h = (a = c == null ? void 0 : c.framesPerSecond) !== null && a !== void 0 ? a : e.framesPerSecond;
    if (typeof l == "number" && typeof u == "number" || (l = 0, u = 0), h == null) {
      let p = Date.now(), g = this.lastVideoFramesSent.get(i.ssrc);
      g && p - g.lts >= 800 ? (h = Math.round((d - g.count) / ((p - g.lts) / 1e3)), this.lastVideoFramesSent.set(i.ssrc, { count: d, lts: p, rate: h })) : g ? h = g.rate : this.lastVideoFramesSent.set(i.ssrc, { count: d, lts: p, rate: 0 });
    }
    i.sentFrame = { width: l, height: u, frameRate: Math.max(0, h) };
  }
  processVideoTrackReceiverStats(e, n, i) {
    var r, o, s, a, c;
    let d = n ? this.report.get(n) : void 0, l = (r = d == null ? void 0 : d.framesReceived) !== null && r !== void 0 ? r : e.framesReceived, u = (o = d == null ? void 0 : d.frameWidth) !== null && o !== void 0 ? o : e.frameWidth, h = (s = d == null ? void 0 : d.frameHeight) !== null && s !== void 0 ? s : e.frameHeight, p = (a = d == null ? void 0 : d.jitterBufferDelay) !== null && a !== void 0 ? a : e.jitterBufferDelay, g = (c = d == null ? void 0 : d.jitterBufferEmittedCount) !== null && c !== void 0 ? c : e.jitterBufferEmittedCount;
    if (typeof l == "number") {
      let E = this.lastVideoFramesRecv.get(i.ssrc), f = Date.now();
      i.framesReceivedCount = l;
      let S = 0;
      E && f - E.lts >= 800 ? (S = Math.round((l - E.count) / ((f - E.lts) / 1e3)), this.lastVideoFramesRecv.set(i.ssrc, { count: l, lts: f, rate: S })) : E ? S = E.rate : this.lastVideoFramesRecv.set(i.ssrc, { count: l, lts: f, rate: 0 }), i.receivedFrame = { width: u || 0, height: h || 0, frameRate: S || 0 }, i.decodedFrame = { width: u || 0, height: h || 0, frameRate: i.decodeFrameRate || 0 }, i.outputFrame = { width: u || 0, height: h || 0, frameRate: i.outputFrameRate || i.decodeFrameRate || 0 };
    }
    if (p && g) {
      let E = this.lastVideoJBDelay.get(i.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 }, f = E.jitterBufferMs, S = g - E.jitterBufferEmittedCount;
      S > 0 && (f = 1e3 * (p - E.jitterBufferDelay) / S), i.jitterBufferMs = f, i.currentDelayMs = Math.round(f), this.lastVideoJBDelay.set(i.ssrc, { jitterBufferDelay: p, jitterBufferEmittedCount: g, jitterBufferMs: i.currentDelayMs });
    }
  }
  processAudioTrackSenderStats(e, n, i) {
    var r, o, s, a;
    let c = n ? this.report.get(n) : void 0, d = (r = (o = c == null ? void 0 : c.echoReturnLoss) !== null && o !== void 0 ? o : e.echoReturnLoss) !== null && r !== void 0 ? r : 0, l = (s = (a = c == null ? void 0 : c.echoReturnLossEnhancement) !== null && a !== void 0 ? a : e.echoReturnLossEnhancement) !== null && s !== void 0 ? s : 0;
    i.aecReturnLoss = d, i.aecReturnLossEnhancement = l;
  }
  processAudioTrackReceiverStats(e, n, i) {
    var r, o, s, a, c, d, l;
    let u = n ? this.report.get(n) : void 0, h = (r = u == null ? void 0 : u.removedSamplesForAcceleration) !== null && r !== void 0 ? r : e.removedSamplesForAcceleration, p = (o = u == null ? void 0 : u.totalSamplesReceived) !== null && o !== void 0 ? o : e.totalSamplesReceived, g = (s = u == null ? void 0 : u.jitterBufferDelay) !== null && s !== void 0 ? s : e.jitterBufferDelay, E = (a = u == null ? void 0 : u.jitterBufferEmittedCount) !== null && a !== void 0 ? a : e.jitterBufferEmittedCount, f = (c = u == null ? void 0 : u.audioLevel) !== null && c !== void 0 ? c : e == null ? void 0 : e.audioLevel, S = (d = u == null ? void 0 : u.totalSamplesDuration) !== null && d !== void 0 ? d : e == null ? void 0 : e.totalSamplesDuration, C = (l = u == null ? void 0 : u.concealedSamples) !== null && l !== void 0 ? l : e.concealedSamples;
    if (h && p && (i.accelerateRate = h / p), g && E) {
      let b = this.lastAudioJBDelay.get(i.ssrc) || { jitterBufferDelay: 0, jitterBufferEmittedCount: 0, jitterBufferMs: 0 }, w = b.jitterBufferMs, D = E - b.jitterBufferEmittedCount;
      D > 0 && (w = 1e3 * (g - b.jitterBufferDelay) / D), i.jitterBufferMs = Math.round(w), this.lastAudioJBDelay.set(i.ssrc, { jitterBufferDelay: g, jitterBufferEmittedCount: E, jitterBufferMs: i.jitterBufferMs });
    }
    i.outputLevel = f;
    let A = 1920;
    S && p && (A = p / S / 50, i.receivedFrames = Math.round(p / A)), C && (i.droppedFrames = Math.round(C / A));
  }
  processRemoteInboundStats(e, n) {
    let i = this.report.get(e);
    i && (n.packetsLost = i.packetsLost, i.roundTripTime && (n.rttMs = 1e3 * i.roundTripTime), i.jitter && (n.jitterMs = 1e3 * i.jitter), i.timestamp && (n.timestamp = i.timestamp));
  }
  getCodecFromCodecStats(e) {
    let n = this.report.get(e);
    if (!n) return "";
    let i = n.mimeType.match(/\/(.*)$/);
    return i && i[1] ? i[1] : "";
  }
  updateSendBitrate() {
    let e = 0, n = null, i = null;
    this.mediaBytesSent.forEach((o) => {
      e += o.diffMean();
    }), this.mediaBytesRetransmit.forEach((o) => {
      n = n === null ? o.diffMean() : n + o.diffMean();
    }), this.mediaBytesTargetEncode.forEach((o) => {
      i = i === null ? o.diffMean() : i + o.diffMean();
    });
    let r = n !== null ? e - n : e;
    this._stats.bitrate = { actualEncoded: 8 * r / (this.options.updateInterval / 1e3), transmit: 8 * e / (this.options.updateInterval / 1e3) }, n !== null && (this._stats.bitrate.retransmit = 8 * n / (this.options.updateInterval / 1e3)), i !== null && (this._stats.bitrate.targetEncoded = 8 * i / (this.options.updateInterval / 1e3));
  }
};
var cm = class extends Vc {
  updateStats() {
    return j.resolve();
  }
};
function Nf(t11) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 250, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 8, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 500, r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1e4, o = function() {
    let s = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i);
    return s && s[0] ? Number(s[0].split("/")[1]) : null;
  }();
  return o ? o < 76 ? new am(t11, { updateInterval: e, lossRateInterval: n, freezeRateLimit: i, firstVideoDecodedTimeout: r }) : new hu(t11, { updateInterval: e, lossRateInterval: n, freezeRateLimit: i, firstVideoDecodedTimeout: r }) : function(s) {
    if (!window.RTCStatsReport) return false;
    let a = s.getStats();
    return !!(a instanceof j || function(c) {
      return !!c && (typeof c == "object" || typeof c == "function") && typeof c.then == "function";
    }(a));
  }(t11) ? new hu(t11, { updateInterval: e, lossRateInterval: n, freezeRateLimit: i, firstVideoDecodedTimeout: r }) : new cm(t11, { updateInterval: e, lossRateInterval: n, freezeRateLimit: i, firstVideoDecodedTimeout: r });
}
var _v = class {
  get localCapabilities() {
    return le(this._localCapabilities);
  }
  get rtpCapabilities() {
    return le(this._rtpCapabilities);
  }
  get candidates() {
    return le(this._candidates);
  }
  get iceParameters() {
    return le(this._iceParameters);
  }
  get dtlsParameters() {
    return le(this._dtlsParameters);
  }
  constructor(t11) {
    T(this, "sessionDesc", void 0), T(this, "_localCapabilities", void 0), T(this, "_rtpCapabilities", void 0), T(this, "_candidates", void 0), T(this, "_iceParameters", void 0), T(this, "_dtlsParameters", void 0), T(this, "setup", void 0), T(this, "currentMidIndex", void 0), T(this, "cname", "o/i14u9pJrxRKAsu"), T(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), t11 = le(t11);
    let { remoteIceParameters: e, remoteDtlsParameters: n, candidates: i, remoteRTPCapabilities: r, localCapabilities: o, direction: s, setup: a, videoCodec: c, audioCodec: d } = t11, l;
    this.setup = a, l = s === cn.RECEIVE_ONLY ? Le.parse(`v=0
o=- 0 0 IN IP4 127.0.0.1
s=AgoraGateway
t=0 0
a=group:BUNDLE 0 1
a=msid-semantic: WMS
a=extmap-allow-mixed
m=video 9 UDP/TLS/RTP/SAVPF 0
c=IN IP4 127.0.0.1
a=rtcp:9 IN IP4 0.0.0.0
a=sendonly
a=rtcp-mux
a=rtcp-rsize
a=mid:0
m=audio 9 UDP/TLS/RTP/SAVPF 0
c=IN IP4 127.0.0.1
a=rtcp:9 IN IP4 0.0.0.0
a=sendonly
a=rtcp-mux
a=rtcp-rsize
a=mid:1
`) : Le.parse(`v=0
o=- 0 0 IN IP4 127.0.0.1
s=AgoraGateway
t=0 0
a=group:BUNDLE 0 1
a=msid-semantic: WMS
a=extmap-allow-mixed
m=video 9 UDP/TLS/RTP/SAVPF 0
c=IN IP4 127.0.0.1
a=rtcp:9 IN IP4 0.0.0.0
a=recvonly
a=rtcp-mux
a=rtcp-rsize
a=mid:0
m=audio 9 UDP/TLS/RTP/SAVPF 0
c=IN IP4 127.0.0.1
a=rtcp:9 IN IP4 0.0.0.0
a=recvonly
a=rtcp-mux
a=rtcp-rsize
a=mid:1
`), this._rtpCapabilities = r, this._candidates = i, this._iceParameters = e, this._dtlsParameters = n, this._localCapabilities = o;
    let u = s === cn.RECEIVE_ONLY ? this.rtpCapabilities.send : this.rtpCapabilities.recv, h = s === cn.RECEIVE_ONLY ? this._localCapabilities.recv : this._localCapabilities.send, p = s === cn.RECEIVE_ONLY ? r.send.videoCodecs : ac(Q.VIDEO, u, h, c), g = s === cn.RECEIVE_ONLY ? r.send.audioCodecs : ac(Q.AUDIO, u, h, d);
    for (let E of l.mediaDescriptions) E.attributes.iceUfrag = e.iceUfrag, E.attributes.icePwd = e.icePwd, E.attributes.fingerprints = n.fingerprints, E.attributes.candidates = i, E.attributes.setup = this.setup, E.media.mediaType === "application" && (E.attributes.sctpPort = "5000"), E.media.mediaType === "video" && (E.media.fmts = p.map((f) => f.payloadType.toString(10)), E.attributes.payloads = p, E.attributes.extmaps = u.videoExtensions), E.media.mediaType === "audio" && (E.media.fmts = g.map((f) => f.payloadType.toString(10)), E.attributes.payloads = g, E.attributes.extmaps = u.audioExtensions, oa(E));
    this.sessionDesc = l, this.currentMidIndex = l.mediaDescriptions.length - 1;
  }
  toString() {
    return Le.print(this.sessionDesc);
  }
  hasMid(t11) {
    return Array.isArray(t11) ? t11.every((e) => this.hasMid(e)) : this.sessionDesc.mediaDescriptions.some((e) => e.attributes.mid === t11);
  }
  send(t11, e, n, i, r) {
    n = n.replace(/ /g, "-");
    let { ssrcs: o, ssrcGroups: s } = Lo(e, this.cname, v("SYNC_GROUP") ? n : void 0), a = this.findPreloadMediaDesc(o);
    if (a) {
      if ($t() && this.firefoxSsrcMidMap.set(o[0].ssrcId, a.attributes.mid), r && (r.twcc || r.remb)) {
        let c = this.sessionDesc.mediaDescriptions.indexOf(a);
        return this.sessionDesc.mediaDescriptions[c] = this.mungSendMediaDesc(a, r), { mid: a.attributes.mid, needExchangeSDP: true };
      }
      return { mid: a.attributes.mid, needExchangeSDP: false };
    }
    {
      let c = this.findAvailableMediaIndex(t11, o, i), d;
      return c === -1 ? (d = this.createOrRecycleSendMedia(t11, o, s, "sendonly", i, r), this.updateBundleMids()) : (d = le(this.sessionDesc.mediaDescriptions[c]), d.attributes.direction = "sendonly", d.attributes.ssrcs = o, d.attributes.ssrcGroups = s, this.sessionDesc.mediaDescriptions[c] = this.mungSendMediaDesc(d, r)), $t() && this.firefoxSsrcMidMap.set(o[0].ssrcId, d.attributes.mid), { needExchangeSDP: true, mid: d.attributes.mid };
    }
  }
  stopSending(t11) {
    let e = this.sessionDesc.mediaDescriptions.filter((n) => n.attributes.mid && t11.indexOf(n.attributes.mid) !== -1);
    if (e.length !== t11.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
    e.forEach((n) => {
      n.attributes.ssrcs = [];
    }), this.updateBundleMids();
  }
  receive(t11, e, n) {
    let i = [];
    return t11.forEach((r) => {
      let o = r._mediaStreamTrack.kind, s = this.findAvailableRecvMediaIndex(o), a, c = false;
      s === -1 ? (c = true, a = this.createOrRecycleRecvMedia(r, [], "recvonly", e, n), this.updateBundleMids()) : (a = le(this.sessionDesc.mediaDescriptions[s]), a.attributes.direction = "recvonly"), i.push({ mid: a.attributes.mid, needCreateTransceiver: c });
    }), i;
  }
  stopReceiving(t11) {
    let e = this.sessionDesc.mediaDescriptions.filter((n) => t11.indexOf(n.attributes.mid) !== -1);
    if (e.length !== t11.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
    e.forEach((n) => {
      n.media.port = "0", n.attributes.direction = "inactive";
    }), this.updateBundleMids();
  }
  addRemoteCandidate(t11) {
    let { foundation: e, protocol: n, address: i, port: r, type: o, relatedAddress: s, relatedPort: a, priority: c } = new RTCIceCandidate(t11), d = { foundation: e ?? "", componentId: "1", transport: n ?? "", priority: c ? c + "" : "", connectionAddress: i ?? "", port: r ? r + "" : "", type: o ? o + "" : "", relAddr: s ?? "", relPort: a ? a + "" : "", extension: {} };
    this.candidates.some((l) => l.priority === d.priority && l.connectionAddress === d.connectionAddress && l.port === d.port) || (this._candidates.push(d), this.sessionDesc.mediaDescriptions.forEach((l) => {
      l.attributes.candidates = this.candidates;
    }));
  }
  clearRemoteCandidate() {
    this._candidates = [], this.sessionDesc.mediaDescriptions[0].attributes.candidates = this._candidates;
  }
  createOrRecycleRecvMedia(t11, e, n, i, r) {
    let o = t11._mediaStreamTrack.kind, s = this.rtpCapabilities.recv, a = ac(o, s, this.localCapabilities.send, o === Q.AUDIO ? r : i), c = o === Q.VIDEO ? s.videoExtensions : s.audioExtensions, d = "".concat(++this.currentMidIndex), l = { media: { mediaType: o, port: "9", protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a.map((h) => h.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: [], extmaps: c, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: e, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: a, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: n, rtcpMux: true, rtcpRsize: true, mid: "".concat(d) } };
    l = this.mungRecvMediaDsec(l, t11);
    let u = this.findFirstClosedMedia(o);
    if (u) {
      let h = this.sessionDesc.mediaDescriptions.indexOf(u);
      this.sessionDesc.mediaDescriptions[h] = l;
    } else this.sessionDesc.mediaDescriptions.push(l);
    return l;
  }
  muteRemote(t11) {
    let e = this.sessionDesc.mediaDescriptions.filter((n) => W(t11).call(t11, n.attributes.mid || ""));
    if (e.length !== t11.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
    e.forEach((n) => {
      n.attributes.direction = "inactive";
    });
  }
  unmuteRemote(t11) {
    let e = this.sessionDesc.mediaDescriptions.filter((n) => W(t11).call(t11, n.attributes.mid || ""));
    if (e.length !== t11.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
    e.forEach((n) => {
      n.attributes.direction = "recvonly";
    });
  }
  findAvailableMediaIndex(t11, e, n) {
    return this.sessionDesc.mediaDescriptions.findIndex((i) => {
      let r = i.media.mediaType === t11 && i.media.port !== "0" && (i.attributes.direction === "sendonly" || i.attributes.direction === "sendrecv") && i.attributes.ssrcs.length === 0;
      if ($t()) {
        if (r) {
          let o = this.firefoxSsrcMidMap.get(e[0].ssrcId);
          return !(o || i.attributes.mid !== "0" && i.attributes.mid !== "1") || !(!o || o !== i.attributes.mid);
        }
        return false;
      }
      return r && i.attributes.mid === n;
    });
  }
  findAvailableRecvMediaIndex(t11) {
    return this.sessionDesc.mediaDescriptions.findIndex((e) => {
      let n = e.media.mediaType === t11 && e.media.port !== "0" && (e.attributes.direction === "recvonly" || e.attributes.direction === "sendrecv");
      return e.attributes.mid !== "0" && e.attributes.mid !== "1" && n;
    });
  }
  predictReceivingMids(t11) {
    let e = [];
    for (let n = 0; n < t11; n++) e.push((this.currentMidIndex + n + 1).toString(10));
    return e;
  }
  restartICE(t11) {
    t11 = le(t11), this._iceParameters = t11, this.sessionDesc.mediaDescriptions.forEach((e) => {
      e.attributes.iceUfrag = t11.iceUfrag, e.attributes.icePwd = t11.icePwd;
    });
  }
  createOrRecycleSendMedia(t11, e, n, i, r, o) {
    let s = this.rtpCapabilities.send, a = t11 === Q.VIDEO ? s.videoCodecs : s.audioCodecs, c = t11 === Q.VIDEO ? s.videoExtensions : s.audioExtensions;
    $t() && (r = "".concat(++this.currentMidIndex));
    let d = { media: { mediaType: t11, port: "9", protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a.map((u) => u.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: [], extmaps: c, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: e, ssrcGroups: n, rtcpFeedbackWildcards: [], payloads: a, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i, rtcpMux: true, rtcpRsize: true, mid: r } };
    d = this.mungSendMediaDesc(d, o);
    let l = this.findFirstClosedMedia(t11);
    if (l) {
      let u = this.sessionDesc.mediaDescriptions.indexOf(l);
      this.sessionDesc.mediaDescriptions[u] = d;
    } else this.sessionDesc.mediaDescriptions.push(d);
    return d;
  }
  mungRecvMediaDsec(t11, e, n) {
    let i = le(t11);
    return If(i), ra(i, e), vf(i, e), r0(i), lu(i, n, this.localCapabilities.send), i;
  }
  mungSendMediaDesc(t11, e) {
    let n = le(t11);
    return lu(n, e, this.localCapabilities.recv), oa(n), n;
  }
  updateRecvMedia(t11, e) {
    let n = this.sessionDesc.mediaDescriptions.findIndex((i) => i.attributes.mid === t11);
    if (n !== -1) {
      let i = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n], e);
      this.sessionDesc.mediaDescriptions[n] = i;
    }
  }
  updateBundleMids() {
    this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((t11) => t11.media.port !== "0").map((t11) => t11.attributes.mid);
  }
  findPreloadMediaDesc(t11) {
    return this.sessionDesc.mediaDescriptions.find((e) => {
      var n;
      return ((n = e.attributes) === null || n === void 0 || (n = n.ssrcs[0]) === null || n === void 0 ? void 0 : n.ssrcId) === t11[0].ssrcId;
    });
  }
  findFirstClosedMedia(t11) {
    return this.sessionDesc.mediaDescriptions.find((e) => $t() ? e.media.port === "0" && e.media.mediaType === t11 : e.media.port === "0");
  }
};
var lW = ["sdp"];
var Vt;
function Ev(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Gr(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Ev(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : Ev(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var mv = (Vt = class bs extends Kl {
  get currentLocalDescription() {
    return this.peerConnection.currentLocalDescription;
  }
  get currentRemoteDescription() {
    return this.peerConnection.currentRemoteDescription;
  }
  get peerConnectionState() {
    return this.peerConnection.connectionState;
  }
  get iceConnectionState() {
    return this.peerConnection.iceConnectionState;
  }
  get dtlsTransportState() {
    var e, n;
    return (e = (n = this.peerConnection.getReceivers()[0]) === null || n === void 0 || (n = n.transport) === null || n === void 0 ? void 0 : n.state) !== null && e !== void 0 ? e : null;
  }
  get localCodecs() {
    return [];
  }
  set isInRestartIce(e) {
    this._isInRestartIce = e;
  }
  get isInRestartIce() {
    return this._isInRestartIce;
  }
  constructor(e, n, i) {
    super(e, n), T(this, "direction", void 0), T(this, "name", void 0), T(this, "store", void 0), T(this, "spec", void 0), T(this, "peerConnection", void 0), T(this, "initialOffer", void 0), T(this, "transport", void 0), T(this, "statsFilter", void 0), T(this, "localCandidateCount", 0), T(this, "_isInRestartIce", false), T(this, "mutex", new ze("P2PConnection-mutex")), T(this, "onLocalCandidate", void 0), T(this, "remoteSDP", void 0), T(this, "pendingCandidates", []), T(this, "localCapabilities", void 0), T(this, "isReady", false), T(this, "restartCnt", 0), T(this, "curTurnServerIndex", 0), this.store = n, this.spec = e, this.peerConnection = new RTCPeerConnection(bs.resolvePCConfiguration(e, n.p2pTransport), { optional: [{ googDscp: true }] }), this.direction = i ?? cn.SEND_ONLY, this.name = this.direction === cn.SEND_ONLY ? "sendP2PConnection" : "recvP2PConnection", this.statsFilter = Nf(this.peerConnection, v("STATS_UPDATE_INTERVAL"), void 0, $t() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;
  }
  async establish(e) {
    try {
      let n = await s0();
      if (this.localCapabilities = uu(n), e) {
        let { sdp: i } = e, r = cW(e, lW), o = function() {
          let l = { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, u = Lc(arguments.length > 2 ? arguments[2] : void 0, arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, "sendonly"), h = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, p = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, g = { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] };
          if (Ii(u, l, "videoExtensions", h, p, g), Ii(u, l, "videoCodecs", h, p, g), Ii(u, l, "audioExtensions", h, p, g), Ii(u, l, "audioCodecs", h, p, g), v("RAISE_H264_BASELINE_PRIORITY")) {
            let E = g.videoCodecs.findIndex((f) => f.rtpMap && f.rtpMap.encodingName.toLocaleLowerCase() === "h264" && f.fmtp && f.fmtp.parameters["profile-level-id"] === "42001f");
            if (E !== -1) {
              let f = g.videoCodecs.findIndex((S) => S.rtpMap && S.rtpMap.encodingName.toLocaleLowerCase() === "h264");
              if (f < E) {
                _.debug("raising H264 baseline profile priority");
                let S = g.videoCodecs[E];
                g.videoCodecs.splice(E, 1), g.videoCodecs.splice(f, 0, S);
              }
              f !== -1 && v("FILTER_SEND_H264_BASELINE") && (h.videoCodecs = h.videoCodecs.filter((S) => !(S.rtpMap && S.rtpMap.encodingName.toLocaleLowerCase() === "h264" && S.fmtp && S.fmtp.parameters["profile-level-id"] !== "42001f")));
            }
          }
          return { send: h, recv: p, sendrecv: g };
        }({}, {}, i);
        this.remoteSDP = new _v({ remoteIceParameters: r.iceParameters, remoteDtlsParameters: r.dtlsParameters, candidates: [], remoteRTPCapabilities: o, localCapabilities: this.localCapabilities, direction: this.direction, setup: "actpass", videoCodec: this.store.codec, audioCodec: this.store.audioCodec }), await this.setRemoteDescription({ type: "offer", sdp: this.remoteSDP.toString() }), this.isReady = true;
        let s = await this.peerConnection.createAnswer();
        if (!s.sdp) throw new Error("Cannot get answer sdp when trying to establish PeerConnection.");
        let a = io(s.sdp);
        await this.peerConnection.setLocalDescription(s);
        let c = await zI({}, {}, s.sdp);
        this.localCapabilities = uu(c);
        let d = this.peerConnection.getTransceivers()[0];
        return d != null && d.receiver && d.receiver.transport && this.tryBindTransportEvents(d.receiver.transport), Gr(Gr({}, a), {}, { sdp: s.sdp });
      }
      {
        this.peerConnection.addTransceiver("video", { direction: "sendonly" }), this.peerConnection.addTransceiver("audio", { direction: "sendonly" });
        let i = await this.peerConnection.createOffer();
        if (!i.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
        let r = io(i.sdp);
        return this.initialOffer = i, Gr(Gr({}, r), {}, { sdp: i.sdp });
      }
    } catch (n) {
      throw new N(R.GET_LOCAL_CONNECTION_PARAMS_FAILED, n.toString());
    }
  }
  async connect(e) {
    try {
      if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
      await this.peerConnection.setLocalDescription(this.initialOffer);
      let { sdp: n, iceParameters: i, dtlsParameters: r } = e, o = await zI({}, {}, n);
      this.remoteSDP = new _v({ remoteIceParameters: i, remoteDtlsParameters: r, candidates: [], remoteRTPCapabilities: o, localCapabilities: this.localCapabilities, direction: this.direction, setup: "active", videoCodec: this.store.codec, audioCodec: this.store.audioCodec }), await this.setRemoteDescription({ type: "answer", sdp: this.remoteSDP.toString() });
      let s = this.peerConnection.getTransceivers()[0];
      s != null && s.sender && s.sender.transport && this.tryBindTransportEvents(s.sender.transport);
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(n.toString()));
    }
  }
  async addRemoteCandidate(e) {
    try {
      e && this.pendingCandidates.push(e), this.peerConnection.remoteDescription && this.isReady && (this.pendingCandidates.forEach((n) => {
        this.peerConnection.addIceCandidate(n);
      }), this.pendingCandidates = []);
    } catch (n) {
      throw new N(R.ADD_CANDIDATE_FAILED, "P2PConnection.addRemoteCandidate failed; ".concat(n.toString()));
    }
  }
  send(e, n, i) {
    var r = this;
    return Bi(function* () {
      let o = yield Tt(r.mutex.lock("From P2PConnection.send"));
      try {
        if (!r.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
        let s = [], a = r.remoteSDP.receive(e, n, i);
        e.forEach((f, S) => {
          if (a[S].needCreateTransceiver) {
            let C = r.peerConnection.addTransceiver(f._mediaStreamTrack, { direction: "sendonly" });
            s.push(C), f._updateRtpTransceiver(C);
          } else {
            let C = r.peerConnection.getTransceivers().find((A) => A.mid === a[S].mid);
            if (!C) throw new Error("cannot find transceiver when sendPeerconnection send, mid is ".concat(a[S].mid));
            s.push(C), f._updateRtpTransceiver(C);
          }
        }), $t() && v("SIMULCAST") === true && (yield Tt(r.applySimulcastForFirefox(s, e)));
        let c = a.map((f) => f.mid), d = yield Tt(r.peerConnection.createOffer()), l = r.mungSendOfferSDP(d.sdp, e, c), u = Le.parse(l), h = c.map((f) => {
          let S = u.mediaDescriptions.find((C) => C.attributes.mid === f);
          if (!S) throw new Error("Cannot extract ssrc from mediaDescription.");
          return n0(S, v("USE_PUB_RTX"));
        }), p = s.map((f, S) => {
          let C = c[S];
          return { localSSRC: h[S], id: C };
        });
        yield Tt(r.peerConnection.setLocalDescription({ type: "offer", sdp: l }));
        try {
          yield p;
        } catch (f) {
          let S = r.remoteSDP.toString();
          throw yield Tt(r.peerConnection.setLocalDescription({ type: "offer", sdp: l })), yield Tt(r.peerConnection.setRemoteDescription({ type: "answer", sdp: S })), yield Tt(r.stopSending(c, true)), f;
        }
        yield Tt(r.applySimulcastEncodings(s, e)), yield Tt(r.applySendEncodings(s, e));
        let g = r.remoteSDP.toString(), E = r.logSDPExchange(l, "offer", "local", "send");
        return E == null ? void 0 : E(g), yield Tt(r.setRemoteDescription({ type: "answer", sdp: g })), s.map((f, S) => {
          let C = c[S];
          return { localSSRC: h[S], id: C };
        });
      } catch (s) {
        throw s instanceof N ? s : new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(s.toString()));
      } finally {
        o();
      }
    })();
  }
  async stopSending(e, n) {
    let i = n ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
      let r = this.peerConnection.getTransceivers().filter((c) => e.indexOf(c.mid) !== -1);
      if (r.length !== e.length) throw new Error("Transceivers' length (".concat(r.length, ") doesn't match mids' length (").concat(e.length, ") when trying to call P2PConnection.stopSending."));
      r.map((c) => {
        var d;
        c.direction = "inactive", (d = c.stop) === null || d === void 0 || d.call(c);
      });
      let o = await this.peerConnection.createOffer(), s = this.logSDPExchange(o.sdp || "", "offer", "local", "stopSending");
      await this.peerConnection.setLocalDescription(o), this.remoteSDP.stopReceiving(e);
      let a = this.remoteSDP.toString();
      s == null ? void 0 : s(a), await this.setRemoteDescription({ type: "answer", sdp: a });
    } catch (r) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(r.toString()));
    } finally {
      i && i();
    }
  }
  async receive(e, n, i, r) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e, " before remoteSDP created."));
      let { mid: o, needExchangeSDP: s } = this.remoteSDP.send(e, n, i, r);
      if (s) {
        let c = this.remoteSDP.toString(), d = this.logSDPExchange(c, "offer", "remote", "receive");
        await this.setRemoteDescription({ type: "offer", sdp: c });
        let l = await this.peerConnection.createAnswer(), u = this.mungReceiveAnswerSDP(l.sdp, o, e);
        d == null ? void 0 : d(u || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: u }), _.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e, " by exchanging SDP."));
      } else _.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e, " no need to exchange SDP."));
      let a = this.peerConnection.getTransceivers().find((c) => c.mid === o);
      if (!a || a.mid === null) throw new Error("Cannot get transceiver after setLocalDescription.");
      return { track: a.receiver.track, mid: a.mid, transceiver: a };
    } catch (o) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(o.toString()));
    }
  }
  async mockReceive(e, n, i, r) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e, " before remoteSDP created."));
      let { mid: o, needExchangeSDP: s } = this.remoteSDP.send(e, n, i, r);
      if (s) {
        let a = this.remoteSDP.toString(), c = this.logSDPExchange(a, "offer", "remote", "receive");
        await this.setRemoteDescription({ type: "offer", sdp: a });
        let d = await this.peerConnection.createAnswer(), l = this.mungReceiveAnswerSDP(d.sdp, o, e);
        c == null ? void 0 : c(l || ""), await this.peerConnection.setLocalDescription({ type: "answer", sdp: l }), _.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e, " by exchanging SDP."));
      } else _.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e, " no need to exchange SDP."));
    } catch (o) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(o.toString()));
    }
  }
  async stopReceiving(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
      this.remoteSDP.stopSending(e);
      let n = this.remoteSDP.toString(), i = this.logSDPExchange(n, "offer", "remote", "stopReceiving");
      await this.setRemoteDescription({ type: "offer", sdp: n });
      let r = await this.peerConnection.createAnswer();
      i == null ? void 0 : i(r.sdp || ""), await this.peerConnection.setLocalDescription(r);
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(n.toString()));
    }
  }
  async restartICE(e) {
    try {
      if (this.store.p2pTransport === Oo.Auto && (this.store.p2pTransport = Oo.SdRtn, ft().supportPCSetConfiguration && this.peerConnection.setConfiguration(bs.resolvePCConfiguration(this.spec, this.store.p2pTransport))), this.restartCnt > 3 && (this.restartCnt = 0, ft().supportPCSetConfiguration && this.peerConnection.setConfiguration(bs.resolvePCConfiguration(this.spec, this.store.p2pTransport, ++this.curTurnServerIndex))), !e) {
        this.restartCnt++, this.isReady = false;
        let n = await this.peerConnection.createOffer({ iceRestart: true });
        if (!n.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
        let { iceParameters: i } = io(n.sdp);
        return this.store.descriptionStart(), this.direction === cn.SEND_ONLY && await this.peerConnection.setLocalDescription(n), i;
      }
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
      if (this.remoteSDP.restartICE(e), this.store.descriptionStart(), this.direction === cn.RECEIVE_ONLY) {
        this.restartCnt++, await this.setRemoteDescription({ type: "offer", sdp: this.remoteSDP.toString() });
        let n = await this.peerConnection.createAnswer();
        if (!n.sdp) throw new Error("Cannot get answer sdp when trying to iceRestart.");
        let { iceParameters: i } = io(n.sdp);
        return await this.peerConnection.setLocalDescription(n), i;
      }
      await this.setRemoteDescription({ type: "answer", sdp: this.remoteSDP.toString() }), this.isReady = true;
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(n.toString()));
    }
  }
  close() {
    var e;
    this.peerConnection.close(), this.peerConnection.onicecandidate = null, (e = this.onConnectionStateChange) === null || e === void 0 || e.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.transport = void 0, this.statsFilter.destroy();
  }
  getStats() {
    return this.statsFilter.getStats();
  }
  getRemoteVideoIsReady(e) {
    return this.statsFilter.getVideoIsReady(e);
  }
  async updateEncoderConfig(e, n) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
      let i = await this.peerConnection.createOffer(), r = this.mungSendOfferSDP(i.sdp, [n], [e]);
      this.remoteSDP.updateRecvMedia(e, n);
      let o = this.remoteSDP.toString(), s = this.logSDPExchange(r, "offer", "local", "updateEncoderConfig");
      await this.peerConnection.setLocalDescription({ type: "offer", sdp: r }), s == null ? void 0 : s(o), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o });
    } catch (i) {
      throw new N(R.EXCHANGE_SDP_FAILED, i.toString());
    }
  }
  async updateSendParameters(e, n) {
    let i = this.peerConnection.getTransceivers().filter((r) => r.mid === e);
    i.length === 1 && (this.isVP8Simulcast(n) ? $t() || await this.applySimulcastEncodings(i, [n]) : await this.applySendEncodings(i, [n]));
  }
  setStatsRemoteVideoIsReady(e, n) {
    this.statsFilter.setVideoIsReady2(e, n);
  }
  async replaceTrack(e, n) {
    let i = this.peerConnection.getTransceivers().find((r) => r.mid === n);
    i && await i.sender.replaceTrack(e._mediaStreamTrack);
  }
  async getSelectedCandidatePair() {
    let e = this.peerConnection.getReceivers();
    if (e.length > 0 && e[0].transport && e[0].transport.iceTransport && e[0].transport.iceTransport.getSelectedCandidatePair && e[0].transport.iceTransport.getSelectedCandidatePair()) {
      let n = e[0].transport.iceTransport, { local: i, remote: r } = n.getSelectedCandidatePair();
      return { local: Gr(Gr({}, hr), {}, { candidateType: i.type, protocol: i.protocol, address: i.address, port: i.port }), remote: Gr(Gr({}, hr), {}, { candidateType: r.type, protocol: r.protocol, address: r.address, port: r.port }) };
    }
    return this.statsFilter.getSelectedCandidatePair();
  }
  bindPCEvents() {
    this.peerConnection.oniceconnectionstatechange = () => {
      var e, n;
      W(e = ["connected", "completed"]).call(e, this.peerConnection.iceConnectionState) && (this.isReady = false), (n = this.onICEConnectionStateChange) === null || n === void 0 || n.call(this, this.peerConnection.iceConnectionState);
    }, this.peerConnection.onconnectionstatechange = () => {
      var e;
      this.peerConnection.connectionState === "connected" && (this.restartCnt = 0), (e = this.onConnectionStateChange) === null || e === void 0 || e.call(this, this.peerConnection.connectionState);
    }, this.startICECandidate();
  }
  startICECandidate() {
    this.peerConnection.onicecandidate || (this.localCandidateCount = 0, this.peerConnection.onicecandidate = (e) => {
      if (e.candidate) {
        var n;
        e.candidate.candidate && ((n = this.onLocalCandidate) === null || n === void 0 || n.call(this, e.candidate.toJSON())), this.localCandidateCount += 1;
      } else _.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount);
    });
  }
  unbindPCEvents() {
    this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
  }
  static resolvePCConfiguration(e, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = { iceServers: [] };
    var o;
    return e.iceServers ? r.iceServers = e.iceServers : e.turnServer && e.turnServer.mode !== "off" && (Yu(e.turnServer.servers) ? r.iceServers = e.turnServer.servers : (r.iceServers && r.iceServers.push(...bs.turnServerConfigToIceServers(e.turnServer.servers, n, i)), v("USE_TURN_SERVER_OF_GATEWAY") && r.iceServers && e.turnServer.serversFromGateway && r.iceServers.push(...bs.turnServerConfigToIceServers(e.turnServer.serversFromGateway, n, i)), W(o = [Oo.Relay, Oo.SdRtn]).call(o, n) && (r.iceTransportPolicy = "relay"), v("FORCE_TURN_TCP") ? r.iceTransportPolicy = "relay" : e.turnServer.servers.concat(e.turnServer.serversFromGateway || []).forEach((s) => {
      s.forceturn && (r.iceTransportPolicy = "relay");
    }))), v("ENABLE_ENCODED_TRANSFORM") && ft().supportWebRTCEncodedTransform && (r.encodedInsertableStreams = true), _.debug("P2PConnection p2pTransport is ".concat(n)), r;
  }
  static turnServerConfigToIceServers(e, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = [], o = e.filter((a) => a.tcpport);
    _.debug("P2PConnection turnServers is ".concat(o, ", current index is ").concat(i));
    let s = o.length > i ? o[i] : o[0];
    switch (n) {
      case Oo.SdRtn:
        let a = e.filter((d) => {
          var l;
          return W(l = d.username).call(l, "glb:") && d.turnServerURL == d.turnServerURL;
        }), c = a.length > i ? a[i] : a[0];
        c && (r.push({ username: c.username, credential: c.password, credentialType: "password", urls: "turn:".concat(Us(c.turnServerURL), ":").concat(c.tcpport, "?transport=udp") }), r.push({ username: c.username, credential: c.password, credentialType: "password", urls: "turns:".concat(Us(c.turnServerURL), ":").concat(c.tcpport, "?transport=tcp") }));
        break;
      case Oo.Relay:
        s && (r.push({ username: s.username, credential: s.password, credentialType: "password", urls: "turn:".concat(s.turnServerURL, ":").concat(s.tcpport, "?transport=udp") }), r.push({ username: s.username, credential: s.password, credentialType: "password", urls: "turns:".concat(Us(s.turnServerURL), ":").concat(s.tcpport, "?transport=tcp") }));
        break;
      default:
        s && (r.push({ username: s.username, credential: s.password, credentialType: "password", urls: "turn:".concat(s.turnServerURL, ":").concat(s.tcpport, "?transport=udp") }), r.push({ username: s.username, credential: s.password, credentialType: "password", urls: "turns:".concat(Us(s.turnServerURL), ":").concat(s.tcpport, "?transport=tcp") }), r.push({ username: s.username, credential: s.password, credentialType: "password", urls: "stun:".concat(s.turnServerURL, ":").concat(s.tcpport) }));
    }
    return r;
  }
  tryBindTransportEvents(e) {
    if (e) {
      this.transport = e, e.onstatechange = () => {
        var i;
        e != null && e.state && ((i = this.onDTLSTransportStateChange) === null || i === void 0 || i.call(this, e.state));
      }, e.onerror = (i) => {
        var r;
        (r = this.onDTLSTransportError) === null || r === void 0 || r.call(this, "error" in i ? i.error : i);
      };
      let n = e.iceTransport;
      n && (n.onstatechange = () => {
        let i = e == null ? void 0 : e.iceTransport.state;
        var r;
        i && ((r = this.onICETransportStateChange) === null || r === void 0 || r.call(this, i));
      }, n.getSelectedCandidatePair && (n.onselectedcandidatepairchange = () => {
        if (n.getSelectedCandidatePair()) {
          let { local: i, remote: r } = n.getSelectedCandidatePair();
          _.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: i.type, protocol: i.protocol }), ", remote ").concat(JSON.stringify({ candidateType: r.type, protocol: r.protocol, address: r.address, port: r.port }), " )"));
        }
      }));
    }
  }
  tryUnbindTransportEvents() {
    this.transport && (this.transport.onstatechange = null, this.transport.onerror = null, this.transport.iceTransport && (this.transport.iceTransport.onstatechange = null));
  }
  async updateRtpSenderEncodings(e, n) {
    var i;
    if (n || (n = this.peerConnection.getSenders().find((l) => l.track === e._mediaStreamTrack)), !n) return _.warn("[".concat(e.getTrackId(), "] no rtpSender found}"));
    if (this.isVP8Simulcast(e)) return _.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
    if (!ft().supportSetRtpSenderParameters) return _.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
    let r = {}, o = {};
    switch (e._optimizationMode) {
      case "motion":
        r.degradationPreference = "maintain-framerate";
        break;
      case "detail":
        r.degradationPreference = "maintain-resolution";
        break;
      default:
        r.degradationPreference = "balanced";
    }
    if (e._encoderConfig) {
      var s;
      let { bitrateMax: l, frameRate: u, scaleResolutionDownBy: h } = e._encoderConfig;
      l && (o.maxBitrate = 1e3 * l), W(s = e._hints).call(s, Gt.LOW_STREAM) && (u && (o.maxFramerate = Nn(u)), h && h >= 1 && (o.scaleResolutionDownBy = h));
    }
    if (v("DSCP_TYPE") && ho()) {
      var a;
      let l = v("DSCP_TYPE");
      W(a = ["very-low", "low", "medium", "high"]).call(a, l) && (o.networkPriority = l);
    }
    let c = n.getParameters(), d = (i = c.encodings) === null || i === void 0 ? void 0 : i[0];
    $t() && !d && (r.encodings = [o]), d && Object.assign(d, o), Object.assign(c, r), _.debug("[".concat(e.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(c.encodings))), await n.setParameters(c);
  }
  async applySendEncodings(e, n) {
    try {
      if (!ft().supportSetRtpSenderParameters || e.length !== n.length) return;
      for (let i = 0; i < e.length; i++) {
        let r = e[i], o = n[i];
        o instanceof Ft && !this.isVP8Simulcast(o) && await this.updateRtpSenderEncodings(o, r.sender);
      }
    } catch {
      _.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
    }
  }
  mungSendOfferSDP(e, n, i) {
    let r = Le.parse(e);
    return n.forEach((o, s) => {
      let a = i[s], c = r.mediaDescriptions.find((d) => d.attributes.mid === a);
      c && (ra(c, o), o0(c, o, this.store.codec));
    }), Le.print(r);
  }
  bindStatsEvents() {
    this.statsFilter.onFirstAudioReceived = (e) => {
      var n;
      (n = this.onFirstAudioReceived) === null || n === void 0 || n.call(this, e);
    }, this.statsFilter.onFirstVideoReceived = (e) => {
      var n;
      (n = this.onFirstVideoReceived) === null || n === void 0 || n.call(this, e);
    }, this.statsFilter.onFirstAudioDecoded = (e) => {
      var n;
      (n = this.onFirstAudioDecoded) === null || n === void 0 || n.call(this, e);
    }, this.statsFilter.onFirstVideoDecoded = (e, n, i) => {
      var r;
      (r = this.onFirstVideoDecoded) === null || r === void 0 || r.call(this, e, n, i);
    }, this.statsFilter.onSelectedLocalCandidateChanged = (e, n) => {
      var i;
      (i = this.onSelectedLocalCandidateChanged) === null || i === void 0 || i.call(this, e, n);
    }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, n) => {
      var i;
      (i = this.onSelectedRemoteCandidateChanged) === null || i === void 0 || i.call(this, e, n);
    }, this.statsFilter.onFirstVideoDecodedTimeout = (e) => {
      var n;
      (n = this.onFirstVideoDecodedTimeout) === null || n === void 0 || n.call(this, e);
    };
  }
  unbindStatsEvents() {
    this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
  }
  async applySimulcastForFirefox(e, n) {
    if (e.length === n.length) for (let c = 0; c < e.length; c++) {
      var i, r, o, s, a;
      let d = e[c], l = n[c];
      if (l instanceof Ft && !W(i = l._hints).call(i, Gt.LOW_STREAM) && (r = l._encoderConfig) !== null && r !== void 0 && r.bitrateMax && ((o = l._encoderConfig) === null || o === void 0 ? void 0 : o.bitrateMax) > 200 && (s = l._scalabilityMode) !== null && s !== void 0 && s.numSpatialLayers && ((a = l._scalabilityMode) === null || a === void 0 ? void 0 : a.numSpatialLayers) > 1 && this.store.codec === "vp8") {
        let u = {}, h = { high: 1e3 * (l._encoderConfig.bitrateMax - 50), medium: 5e4 };
        u.encodings = [{ rid: "m", active: true, maxBitrate: h.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: h.high }];
        let p = d.sender.getParameters();
        await d.sender.setParameters(Object.assign(p, u));
      }
    }
  }
  async applySimulcastEncodings(e, n) {
    if (!$t() && e.length === n.length) for (let i = 0; i < e.length; i++) {
      let r = n[i];
      if (r instanceof Ft && this.isVP8Simulcast(r)) {
        let o = e[i], s = {}, a = { high: 1e3 * (r._encoderConfig.bitrateMax - 50), medium: 5e4 };
        s.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: a.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: a.medium, scaleResolutionDownBy: 4 }];
        let c = o.sender.getParameters();
        await o.sender.setParameters(Object.assign(c, s));
      }
    }
  }
  isVP8Simulcast(e) {
    var n, i, r, o, s;
    return !!(e instanceof Ft && v("SIMULCAST") && this.store.codec === "vp8" && !W(n = e._hints).call(n, Gt.LOW_STREAM) && (i = e._encoderConfig) !== null && i !== void 0 && i.bitrateMax && ((r = e._encoderConfig) === null || r === void 0 ? void 0 : r.bitrateMax) > 200 && (o = e._scalabilityMode) !== null && o !== void 0 && o.numSpatialLayers && ((s = e._scalabilityMode) === null || s === void 0 ? void 0 : s.numSpatialLayers) > 1);
  }
  logSDPExchange(e, n, i, r) {
    if (v("SDP_LOGGING")) return _.upload("[".concat(this.store.clientId, "] exchanging ").concat(i, " ").concat(n, " SDP during P2PConnection.").concat(r, `
`), e), n === "offer" ? (o) => {
      this.logSDPExchange(o, "answer", i === "local" ? "remote" : "local", r);
    } : void 0;
  }
  async muteLocal(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
      let n = this.peerConnection.getTransceivers().filter((s) => s.mid && e.indexOf(s.mid) !== -1);
      if (n.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length.");
      n.map((s) => {
        s.direction = "inactive";
      });
      let i = await this.peerConnection.createOffer(), r = this.logSDPExchange(i.sdp || "", "offer", "local", "muteLocal");
      await this.peerConnection.setLocalDescription(i), this.remoteSDP.muteRemote(e);
      let o = this.remoteSDP.toString();
      r == null ? void 0 : r(o), await this.setRemoteDescription({ type: "answer", sdp: o });
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(n.toString()));
    }
  }
  async unmuteLocal(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
      let n = this.peerConnection.getTransceivers().filter((s) => s.mid && e.indexOf(s.mid) !== -1);
      if (n.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length.");
      n.map(async (s) => {
        s.direction = "sendonly";
      });
      let i = await this.peerConnection.createOffer(), r = this.logSDPExchange(i.sdp || "", "offer", "local", "unmuteLocal");
      await this.peerConnection.setLocalDescription(i), this.remoteSDP.unmuteRemote(e);
      let o = this.remoteSDP.toString();
      r == null ? void 0 : r(o), await this.setRemoteDescription({ type: "answer", sdp: o });
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(n.toString()));
    }
  }
  async getRemoteSSRC(e, n) {
    var i, r;
    if (n = (i = n) !== null && i !== void 0 ? i : (r = this.currentRemoteDescription) === null || r === void 0 ? void 0 : r.sdp) {
      var o;
      let s = (o = Le.parse(n).mediaDescriptions.find((a) => a.attributes.mid === e)) === null || o === void 0 ? void 0 : o.attributes.ssrcs;
      return s == null ? void 0 : s[0].ssrcId;
    }
  }
  async setRemoteDescription(e) {
    var n;
    await this.peerConnection.setRemoteDescription(e), W(n = ["connected", "completed"]).call(n, this.peerConnection.iceConnectionState) || (this.isReady = true, this.addRemoteCandidate());
  }
  mungReceiveAnswerSDP(e, n, i) {
    let r = Le.parse(e), o = r.mediaDescriptions.find((s) => s.attributes.mid === n);
    return o && i === Q.AUDIO && o.media.mediaType === "audio" && oa(o), Le.print(r);
  }
}, q(Vt.prototype, "establish", [_i], Object.getOwnPropertyDescriptor(Vt.prototype, "establish"), Vt.prototype), q(Vt.prototype, "connect", [_i], Object.getOwnPropertyDescriptor(Vt.prototype, "connect"), Vt.prototype), q(Vt.prototype, "receive", [_i], Object.getOwnPropertyDescriptor(Vt.prototype, "receive"), Vt.prototype), q(Vt.prototype, "mockReceive", [_i], Object.getOwnPropertyDescriptor(Vt.prototype, "mockReceive"), Vt.prototype), q(Vt.prototype, "stopReceiving", [_i], Object.getOwnPropertyDescriptor(Vt.prototype, "stopReceiving"), Vt.prototype), q(Vt.prototype, "restartICE", [_i], Object.getOwnPropertyDescriptor(Vt.prototype, "restartICE"), Vt.prototype), q(Vt.prototype, "close", [_i], Object.getOwnPropertyDescriptor(Vt.prototype, "close"), Vt.prototype), q(Vt.prototype, "updateEncoderConfig", [_i], Object.getOwnPropertyDescriptor(Vt.prototype, "updateEncoderConfig"), Vt.prototype), q(Vt.prototype, "updateSendParameters", [_i], Object.getOwnPropertyDescriptor(Vt.prototype, "updateSendParameters"), Vt.prototype), q(Vt.prototype, "replaceTrack", [_i], Object.getOwnPropertyDescriptor(Vt.prototype, "replaceTrack"), Vt.prototype), q(Vt.prototype, "muteLocal", [_i], Object.getOwnPropertyDescriptor(Vt.prototype, "muteLocal"), Vt.prototype), q(Vt.prototype, "unmuteLocal", [_i], Object.getOwnPropertyDescriptor(Vt.prototype, "unmuteLocal"), Vt.prototype), Vt);
function _i(t11, e, n) {
  let i = t11[e];
  if (typeof i != "function") throw new Error("Cannot use mutex on object property.");
  return n.value = async function() {
    let r = this.mutex, o = await r.lock("From P2PConnection.".concat(e));
    try {
      for (var s = arguments.length, a = new Array(s), c = 0; c < s; c++) a[c] = arguments[c];
      return await i.apply(this, a);
    } finally {
      o();
    }
  }, n;
}
function dm(t11, e) {
  let n = document.createElement("video"), i = document.createElement("canvas");
  n.setAttribute("style", "display:none"), i.setAttribute("style", "display:none"), n.setAttribute("muted", ""), n.muted = true, n.setAttribute("autoplay", ""), n.autoplay = true, n.setAttribute("playsinline", ""), i.width = Nn(e.width), i.height = Nn(e.height);
  let r = Nn(e.framerate || 15);
  document.body.append(n), document.body.append(i);
  let o = t11._mediaStreamTrack;
  n.srcObject = new MediaStream([o]), n.play();
  let s = i.getContext("2d");
  if (!s) throw new O(R.UNEXPECTED_ERROR, "can not get canvas context");
  let a = ft(), c = i.captureStream(a.supportRequestFrame ? 0 : r).getVideoTracks()[0];
  c.canvas || (c.canvas = i), i.startCapture = () => {
    if (!n) return i.stopCapture && i.stopCapture();
    if (n.paused && n.play(), n.videoHeight > 2 && n.videoWidth > 2) {
      let l = n.videoWidth, u = n.videoHeight / l, h = i.width * u;
      Math.abs(h - i.height) >= 2 && (_.debug("adjust low stream resolution", "".concat(i.width, "x").concat(i.height, " -> ").concat(i.width, "x").concat(h)), i.height = h);
    }
    s.drawImage(n, 0, 0, i.width, i.height), c.requestFrame && c.requestFrame(), o !== t11._mediaStreamTrack && (o = t11._mediaStreamTrack, n.srcObject = new MediaStream([o]));
  }, i.stopCapture = Rf(() => i.startCapture && i.startCapture(), r);
  let d = c.stop;
  return c.stop = () => {
    d.call(c), n && (n.remove(), n.srcObject = null, n = null), i && (i.width = 0, i.remove(), i.stopCapture && i.stopCapture(), i.startCapture = void 0, i.stopCapture = void 0, i = null), _.debug("clean low stream renderer");
  }, c;
}
var Al = function(t11) {
  return t11[t11.HEIGHT = 2033] = "HEIGHT", t11[t11.FRAME_RATE = 2034] = "FRAME_RATE", t11[t11.WIDTH = 2035] = "WIDTH", t11;
}(Al || {});
var Ie = function(t11) {
  return t11[t11.FRAME_RATE = 2002] = "FRAME_RATE", t11[t11.WIDTH = 2003] = "WIDTH", t11[t11.HEIGHT = 2004] = "HEIGHT", t11[t11.PACKAGE_LOST = 2005] = "PACKAGE_LOST", t11[t11.AVG_ENCODE = 2007] = "AVG_ENCODE", t11[t11.NACKS = 2009] = "NACKS", t11[t11.PLIS = 2010] = "PLIS", t11[t11.FIRS = 2011] = "FIRS", t11[t11.BITRATE = 2012] = "BITRATE", t11[t11.PACKAGE_RATE = 2031] = "PACKAGE_RATE", t11[t11.ADAPTATION = 2032] = "ADAPTATION", t11[t11.ACTUAL_ENCODED = 2060] = "ACTUAL_ENCODED", t11[t11.BANDWIDTH = 2061] = "BANDWIDTH", t11[t11.RETRANSMIT = 2062] = "RETRANSMIT", t11[t11.TARGET_ENCODED = 2064] = "TARGET_ENCODED", t11[t11.TRANSMIT = 2066] = "TRANSMIT", t11[t11.FREEZE = 2082] = "FREEZE", t11[t11.DISABLED = 2095] = "DISABLED", t11[t11.PLAYER_STATUS = 2128] = "PLAYER_STATUS", t11[t11.QP_SUM = 2143] = "QP_SUM", t11;
}(Ie || {});
var Do = function(t11) {
  return t11[t11.BITRATE = 2069] = "BITRATE", t11[t11.PACKAGE_LOST = 2070] = "PACKAGE_LOST", t11[t11.PACKAGE_RATE = 2071] = "PACKAGE_RATE", t11[t11.HEIGHT = 2073] = "HEIGHT", t11[t11.FRAME_RATE = 2075] = "FRAME_RATE", t11[t11.WIDTH = 2077] = "WIDTH", t11;
}(Do || {});
var Qe = function(t11) {
  return t11[t11.JITTER = -1] = "JITTER", t11[t11.PACKAGE_LOST = 2014] = "PACKAGE_LOST", t11[t11.WIDTH = 2018] = "WIDTH", t11[t11.HEIGHT = 2019] = "HEIGHT", t11[t11.FRAME_RATE = 2020] = "FRAME_RATE", t11[t11.JITTER_BUFFER = 2023] = "JITTER_BUFFER", t11[t11.CURRENT_DELAY = 2024] = "CURRENT_DELAY", t11[t11.NACKS = 2026] = "NACKS", t11[t11.PLIS = 2027] = "PLIS", t11[t11.FIRS = 2028] = "FIRS", t11[t11.BITRATE = 2029] = "BITRATE", t11[t11.PACKAGE_RATE = 2078] = "PACKAGE_RATE", t11[t11.FREEZE = 2084] = "FREEZE", t11[t11.DISABLED = 2101] = "DISABLED", t11[t11.PLAYER_STATUS = 2129] = "PLAYER_STATUS", t11[t11.QP_SUM = 2144] = "QP_SUM", t11[t11.I_FRAME_DELAY = 2149] = "I_FRAME_DELAY", t11;
}(Qe || {});
var Po = function(t11) {
  return t11[t11.FRAME_RATE_DECODE = 2021] = "FRAME_RATE_DECODE", t11[t11.FRAME_RATE_RENDER = 2022] = "FRAME_RATE_RENDER", t11[t11.FRAME_RATE_OUTPUT = 2155] = "FRAME_RATE_OUTPUT", t11[t11.FREEZE_TIME = 2109] = "FREEZE_TIME", t11[t11.FREEZE_TIME_RENDER = 2147] = "FREEZE_TIME_RENDER", t11[t11.FREEZE_DURATION = 2156] = "FREEZE_DURATION", t11;
}(Po || {});
var g0 = function(t11) {
  return t11[t11.PCM_LEVEL = 2104] = "PCM_LEVEL", t11;
}(g0 || {});
var zr = function(t11) {
  return t11[t11.PACKAGE_LOST = -1] = "PACKAGE_LOST", t11[t11.LEVEL = 2038] = "LEVEL", t11[t11.BITRATE = 2039] = "BITRATE", t11[t11.PACKAGE_RATE = 2040] = "PACKAGE_RATE", t11[t11.AEC_RETURN_LOSS = 2041] = "AEC_RETURN_LOSS", t11[t11.AEC_RETURN_LOSS_ENH = 2042] = "AEC_RETURN_LOSS_ENH", t11[t11.FREEZE = 2081] = "FREEZE", t11[t11.DISABLED = 2096] = "DISABLED", t11;
}(zr || {});
var mi = function(t11) {
  return t11[t11.BITRATE = 2044] = "BITRATE", t11[t11.PACKAGE_LOST = 2045] = "PACKAGE_LOST", t11[t11.PACKAGE_RATE = 2046] = "PACKAGE_RATE", t11[t11.CURRENT_DELAY = 2047] = "CURRENT_DELAY", t11[t11.JITTER_BUFFER = 2054] = "JITTER_BUFFER", t11[t11.JITTER = 2055] = "JITTER", t11[t11.FREEZE = 2083] = "FREEZE", t11[t11.DISABLED = 2102] = "DISABLED", t11[t11.PCM_LEVEL = 2105] = "PCM_LEVEL", t11[t11.PLAYER_STATUS = 2130] = "PLAYER_STATUS", t11[t11.CONCEALED_SAMPLES = 2148] = "CONCEALED_SAMPLES", t11;
}(mi || {});
var T0 = function(t11) {
  return t11[t11.FREEZE_TIME = -1] = "FREEZE_TIME", t11[t11.LEVEL = 2043] = "LEVEL", t11;
}(T0 || {});
var $n = function(t11) {
  return t11[t11.RTT = 2006] = "RTT", t11[t11.CONN_TYPE = 801] = "CONN_TYPE", t11;
}($n || {});
var Rr = 1e3;
var bo = 3;
function st(t11, e, n) {
  n != null && Number.isFinite(n) && (t11[e] = Math.round(Math.max(0, n)));
}
function fv(t11) {
  let e = { [$n.CONN_TYPE]: 0, [$n.RTT]: t11.rtt };
  switch (t11.selectedCandidatePair.localCandidate.candidateType) {
    case "relay": {
      let n = t11.selectedCandidatePair.localCandidate.relayProtocol;
      n === "udp" && (e[$n.CONN_TYPE] = 1), n === "tcp" && (e[$n.CONN_TYPE] = 3), n === "tls" && (e[$n.CONN_TYPE] = 4);
      break;
    }
    case "srflx":
      e[$n.CONN_TYPE] = 2;
  }
  return e;
}
function gv(t11) {
  let e = 0;
  switch (t11) {
    case "none":
      e = 0;
      break;
    case "cpu":
      e = 1;
      break;
    case "bandwidth":
      e = 2;
      break;
    case "other":
      e = 3;
  }
  return e;
}
var pu = class extends Xt {
  constructor(e) {
    super(), T(this, "store", void 0), T(this, "uploadWRTCStatsTimer", void 0), T(this, "uploadOutboundDenoiserStatsTimer", void 0), T(this, "uploadExtStatsTimer", void 0), T(this, "uploadExtUsageStatsTimer", void 0), T(this, "uploadInboundExtStatsTimer", void 0), T(this, "requestStats", void 0), T(this, "requestTransportStats", void 0), T(this, "requestLocalMedia", void 0), T(this, "requestRemoteMedia", void 0), T(this, "requestAllTracks", void 0), T(this, "requestVideoIsReady", void 0), T(this, "requestUploadStats", void 0), T(this, "requestUpload", void 0), T(this, "uploadOutboundStarted", false), T(this, "uploadInboundStarted", false), T(this, "uploadTransportStarted", false), T(this, "uploadExtensionUsageStarted", false), T(this, "lastRecvStats", void 0), T(this, "lastSendStats", void 0), T(this, "lastFullRecvStats", void 0), T(this, "lastFullSendStats", void 0), T(this, "needUploadRenderFreezeTime", true), this.store = e;
  }
  uploadWRTCStats(e) {
    if (!this.requestStats || !this.requestUploadStats) return;
    let n, i;
    if (this.uploadTransportStarted && (n = this.requestStats(), this.store.useP2P && (i = this.requestStats(true))), !n && this.uploadOutboundStarted && (n = this.requestStats()), !i && this.uploadInboundStarted && (i = this.requestStats(true)), n || i) {
      let r = {};
      if (this.uploadTransportStarted && n) {
        let o = this.getTransportStats(n, i, e);
        o && (r.misc = [o]);
      }
      if (this.uploadOutboundStarted && n) {
        let o = this.getOutboundStats(n, e ? this.lastSendStats : this.lastFullSendStats, e);
        o && (r.outbound = [o]);
      }
      if (this.uploadInboundStarted && i) {
        let o = this.getInboundStats(i, e ? this.lastRecvStats : this.lastFullRecvStats, e);
        o && (r.inbound = o);
      }
      this.requestUploadStats(r);
    }
    this.lastRecvStats = i, this.lastSendStats = n, e || (this.lastFullRecvStats = i, this.lastFullSendStats = n);
  }
  startUploadWRTCStats() {
    if (this.uploadWRTCStatsTimer) return;
    let e = 1;
    this.uploadWRTCStatsTimer = window.setInterval(() => {
      if (!this.uploadTransportStarted && !this.uploadInboundStarted && !this.uploadOutboundStarted) return this.stopUploadWRTCStats();
      this.uploadWRTCStats(e !== bo), ++e === bo + 1 && (e = 1);
    }, Rr);
  }
  stopUploadWRTCStats() {
    window.clearInterval(this.uploadWRTCStatsTimer), this.uploadWRTCStatsTimer = void 0, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0);
  }
  getTransportStats(e, n, i) {
    if (!this.requestStats) return;
    if (i) return e.rtt == null ? void 0 : { addition: { [$n.RTT]: e.rtt, [$n.CONN_TYPE]: void 0 } };
    let r = fv(e);
    if (this.store.useP2P) {
      if (n) {
        let o = fv(n);
        r[$n.CONN_TYPE] += o[$n.CONN_TYPE] << 3;
      }
      r[$n.CONN_TYPE] += 110;
    } else r[$n.CONN_TYPE] += 100;
    return { addition: r };
  }
  getOutboundStats(e, n, i) {
    if (!this.requestUploadStats || !this.requestLocalMedia) return;
    let r = this.requestLocalMedia();
    if (!r || r.length === 0) return;
    let o, s, a;
    return r.forEach((c) => {
      let [d, { track: l, ssrcs: u }] = c;
      switch (d) {
        case U.LocalVideoLowTrack:
        case U.LocalVideoTrack:
          if (d === U.LocalVideoTrack) {
            let h = function(E, f, S, C, A) {
              let b = f.videoSend.find((z) => z.ssrc === E);
              if (!b) return;
              let w = {}, { sentFrame: D, inputFrame: k } = b;
              if (k && D) {
                let z = k.frameRate, lt = D.frameRate;
                w[Ie.FREEZE] = function(vt, Dt) {
                  let ce = true;
                  return ce = !(vt <= 5) && (vt <= 10 ? Dt < 3 : vt <= 20 ? Dt < 4 : Dt < 5), ce;
                }(z, lt) ? 1 : 0;
              }
              if (st(w, Ie.QP_SUM, b.qpSumPerFrame), A) return w;
              switch (D && (st(w, Ie.HEIGHT, D.height), st(w, Ie.WIDTH, D.width), st(w, Ie.FRAME_RATE, D.frameRate)), w[Ie.DISABLED] = C._originMediaStreamTrack && !C._originMediaStreamTrack.enabled || C._mediaStreamTrack && !C._mediaStreamTrack.enabled ? 1 : 0, b.adaptionChangeReason) {
                case "none":
                  w[Ie.ADAPTATION] = 0;
                  break;
                case "cpu":
                  w[Ie.ADAPTATION] = 1;
                  break;
                case "bandwidth":
                  w[Ie.ADAPTATION] = 2;
                  break;
                case "other":
                  w[Ie.ADAPTATION] = 3;
              }
              let B = 0;
              b.adaptionChangeReason && (B += gv(b.adaptionChangeReason)), f.qualityLimitationReason && (B += gv(f.qualityLimitationReason) << 3), w[Ie.ADAPTATION] = B, w[Ie.PLAYER_STATUS] = o_[C._player ? C._player.videoElementStatus : "uninit"], st(w, Ie.NACKS, b.nacksCount), st(w, Ie.PLIS, b.plisCount), st(w, Ie.FIRS, b.firsCount), st(w, Ie.AVG_ENCODE, b.avgEncodeMs);
              let V = S && S.videoSend.find((z) => z.ssrc === E);
              if (V) {
                let z = A ? Rr : Rr * bo;
                V.timestamp && b.timestamp && (z = b.timestamp - V.timestamp), V.packets != null && b.packets != null && st(w, Ie.PACKAGE_RATE, 1e3 * (b.packets - V.packets) / z), b.packetsLost != null && V.packetsLost != null && st(w, Ie.PACKAGE_LOST, b.packetsLost - V.packetsLost), V.bytes != null && b.bytes != null && st(w, Ie.BITRATE, 8 * (b.bytes - V.bytes) / z);
              }
              return w;
            }(u[0].ssrcId, e, n, l, i), p = i ? null : function(E, f, S) {
              let C = f.videoSend.find((B) => B.ssrc === E);
              if (!C) return null;
              let A = {}, b = C.inputFrame, w = b && b.height || S && S.videoHeight || 0, D = b && b.width || S && S.videoWidth || 0, k = b && b.frameRate || 0;
              return st(A, Al.HEIGHT, w), st(A, Al.WIDTH, D), st(A, Al.FRAME_RATE, k), A;
            }(u[0].ssrcId, e, l), g = i ? null : function(E) {
              let f = {};
              return st(f, Ie.RETRANSMIT, E.bitrate.retransmit), st(f, Ie.TARGET_ENCODED, E.bitrate.targetEncoded), st(f, Ie.ACTUAL_ENCODED, E.bitrate.actualEncoded), st(f, Ie.TRANSMIT, E.bitrate.transmit), st(f, Ie.BANDWIDTH, E.sendBandwidth), f;
            }(e);
            s = Object.assign({}, h, p, g);
          } else a = i ? void 0 : function(h, p, g) {
            let E = p.videoSend.find((C) => C.ssrc === h);
            if (!E) return;
            let f = {}, S = E.sentFrame;
            if (S && (st(f, Do.HEIGHT, S.height), st(f, Do.WIDTH, S.width), st(f, Do.FRAME_RATE, S.frameRate)), g) {
              let C = g.videoSend.find((A) => A.ssrc === h);
              if (C) {
                let A = Rr * bo;
                C.timestamp && E.timestamp && (A = E.timestamp - C.timestamp), C.packets != null && E.packets != null && st(f, Do.PACKAGE_RATE, 1e3 * (E.packets - C.packets) / A), E.packetsLost != null && C.packetsLost != null && st(f, Do.PACKAGE_LOST, E.packetsLost - C.packetsLost), C.bytes != null && E.bytes != null && st(f, Do.BITRATE, 8 * (E.bytes - C.bytes) / A);
              }
            }
            return f;
          }(u[0].ssrcId, e, n);
          break;
        case U.LocalAudioTrack:
          o = i ? void 0 : function(h, p, g, E) {
            let f = p.audioSend.find((w) => w.ssrc === h);
            if (!f) return;
            let S = {};
            S[zr.DISABLED] = E._originMediaStreamTrack && !E._originMediaStreamTrack.enabled || E._mediaStreamTrack && !E._mediaStreamTrack.enabled ? 1 : 0;
            let C = 100 * E._source.getAccurateVolumeLevel(), A = f.inputLevel;
            if (A != null) {
              let w = Math.ceil(50 * Math.log10(100 * A + 1));
              st(S, zr.LEVEL, w);
            }
            st(S, g0.PCM_LEVEL, C), st(S, zr.AEC_RETURN_LOSS, f.aecReturnLoss), st(S, zr.AEC_RETURN_LOSS_ENH, f.aecReturnLossEnhancement), S[zr.FREEZE] = 0;
            let b = g && g.audioSend.find((w) => w.ssrc === h);
            if (b) {
              let w = Rr * bo;
              b.timestamp && f.timestamp && (w = f.timestamp - b.timestamp), b.bytes != null && f.bytes != null && st(S, zr.BITRATE, 8 * (f.bytes - b.bytes) / w), b.packets != null && f.packets != null && st(S, zr.PACKAGE_RATE, 1e3 * (f.packets - b.packets) / w);
            }
            return S;
          }(u[0].ssrcId, e, n, l);
      }
    }), { high: s, low: a, audio: o };
  }
  getInboundStats(e, n, i) {
    if (!this.requestRemoteMedia) return;
    let r = this.requestRemoteMedia() || [], o = [];
    return r.forEach((s) => {
      let [a, c] = s, d = { peer: a.uid };
      if (c.has(Q.VIDEO) && a.videoTrack) {
        let l = a._videoSSRC && this.requestVideoIsReady && this.requestVideoIsReady(a._videoSSRC) || false, u = a.videoTrack ? function(h, p, g, E, f, S, C) {
          var A;
          let b = p.videoRecv.find((lt) => lt.ssrc === h);
          if (!b) return;
          let w = {}, { receivedFrame: D, outputFrame: k, decodeFrameRate: B } = b, V = g && g.videoRecv.find((lt) => lt.ssrc === h);
          if (w[Qe.FREEZE] = f && _u.isRemoteVideoFreeze(E, b, V) ? 1 : 0, st(w, Po.FRAME_RATE_DECODE, B), st(w, Qe.QP_SUM, b.qpSumPerFrame), b.framesRateFirefox && st(w, Qe.FRAME_RATE, b.framesRateFirefox), D && st(w, Qe.FRAME_RATE, D.frameRate), V) {
            let lt = p.timestamp - g.timestamp || (C ? Rr : bo * Rr);
            b.packetsLost != null && V.packetsLost != null && st(w, Qe.PACKAGE_LOST, b.packetsLost - V.packetsLost), V.bytes != null && b.bytes != null && st(w, Qe.BITRATE, 8 * (b.bytes - V.bytes) / lt), V.packets != null && b.packets != null && st(w, Qe.PACKAGE_RATE, 1e3 * (b.packets - V.packets) / lt);
          }
          if (C) return w;
          D ? (st(w, Qe.HEIGHT, D.height), st(w, Qe.WIDTH, D.width)) : E && (st(w, Qe.HEIGHT, E._videoHeight || 0), st(w, Qe.WIDTH, E._videoWidth || 0)), k && st(w, Po.FRAME_RATE_OUTPUT, k.frameRate);
          let z = (A = E._player) === null || A === void 0 ? void 0 : A.rendFrameRate.toFixed(0);
          if (z && st(w, Po.FRAME_RATE_RENDER, +z), st(w, Qe.JITTER_BUFFER, b.jitterBufferMs), st(w, Qe.CURRENT_DELAY, b.currentDelayMs), st(w, Qe.FIRS, b.firsCount), st(w, Qe.NACKS, b.nacksCount), st(w, Qe.PLIS, b.plisCount), E) {
            w[Qe.DISABLED] = E._originMediaStreamTrack.enabled && E._mediaStreamTrack.enabled ? 0 : 1;
            let lt = E._player;
            if (lt) {
              let { freezeTimeCounterList: vt, renderFreezeAccTime: Dt, videoElementStatus: ce } = lt;
              if (vt && vt.length > 0 && st(w, Po.FREEZE_TIME, vt.splice(0, 1)[0]), S && yr.visibility === "visible" && ce === nn.PLAYING && ft().supportRequestVideoFrameCallback) {
                let Wt = Math.min(6e3, Dt);
                lt.renderFreezeAccTime = Math.max(0, Dt - Wt), st(w, Po.FREEZE_TIME_RENDER, Wt);
              }
              if (typeof b.totalFreezesDuration == "number") {
                let Wt = V && V.totalFreezesDuration ? b.totalFreezesDuration - V.totalFreezesDuration : b.totalFreezesDuration;
                st(w, Po.FREEZE_DURATION, 1e3 * Wt);
              }
            }
          }
          if (w[Qe.PLAYER_STATUS] = o_[E._player ? E._player.videoElementStatus : "uninit"], V && b.totalInterFrameDelay !== void 0 && b.totalSquaredInterFrameDelay !== void 0 && V.totalInterFrameDelay !== void 0 && V.totalSquaredInterFrameDelay !== void 0) {
            let lt = b.totalInterFrameDelay - V.totalInterFrameDelay, vt = b.totalSquaredInterFrameDelay - V.totalSquaredInterFrameDelay, Dt = b.framesDecodeCount - V.framesDecodeCount, ce = lt / Dt * 1e3, Wt = Math.round(1e3 * Math.sqrt((vt - Math.pow(lt, 2) / Dt) / Dt));
            !isNaN(Wt) && ce + Wt > Math.max(3 * ce, ce + 150) && (w[Qe.I_FRAME_DELAY] = Wt);
          }
          return w;
        }(a._videoSSRC, e, n, a.videoTrack, l === true, this.needUploadRenderFreezeTime, i) : void 0;
        u && (d.video = u);
      }
      if (c.has(Q.AUDIO) && a.audioTrack) {
        let l = a.audioTrack ? function(u, h, p, g, E) {
          let f = h.audioRecv.find((V) => V.ssrc === u);
          if (!f) return;
          let S = {}, C = p && p.audioRecv.find((V) => V.ssrc === u), { receivedFrames: A, droppedFrames: b } = f;
          var w, D;
          if (st(S, mi.JITTER, f.jitterMs), A != null && b != null && (S[mi.FREEZE] = (D = b, (w = A) === 0 || 100 * D / w > 20 ? 1 : 0)), C) {
            let V = h.timestamp - p.timestamp || (E ? Rr : Rr * bo);
            f.packets != null && C.packets != null && st(S, mi.PACKAGE_RATE, 1e3 * (f.packets - C.packets) / V), C.bytes != null && f.bytes != null && st(S, mi.BITRATE, 8 * (f.bytes - C.bytes) / V), f.packetsLost != null && C.packetsLost != null && st(S, mi.PACKAGE_LOST, f.packetsLost - C.packetsLost);
          }
          if (E) return S;
          let k = 100 * g._source.getAccurateVolumeLevel(), B = f.outputLevel;
          if (B != null) {
            let V = Math.ceil(50 * Math.log10(100 * B + 1));
            st(S, T0.LEVEL, V);
          }
          if (st(S, mi.PCM_LEVEL, k), g && (S[mi.DISABLED] = g._originMediaStreamTrack.enabled && g._mediaStreamTrack.enabled ? 0 : 1), st(S, mi.JITTER_BUFFER, f.jitterBufferMs), st(S, mi.CURRENT_DELAY, f.jitterBufferMs), S[mi.PLAYER_STATUS] = o_[En.getPlayerState(g.getTrackId())], C) {
            let V = f.concealedSamples - C.concealedSamples;
            V > 0 && st(S, mi.CONCEALED_SAMPLES, V);
          }
          return S;
        }(a._audioSSRC, e, n, a.audioTrack, i) : void 0;
        l && (d.audio = l);
      }
      (d.video || d.audio) && o.push(d);
    }), this.needUploadRenderFreezeTime = !this.needUploadRenderFreezeTime, o;
  }
  startUploadTransportStats() {
    this.uploadTransportStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats();
  }
  stopUploadTransportStats() {
    this.uploadTransportStarted = false;
  }
  startUploadOutboundStats() {
    this.uploadOutboundStarted || (this.uploadOutboundStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = window.setInterval(() => {
      if (!this.requestAllTracks || !this.requestUpload) return;
      let e = (this.requestAllTracks() || []).find((n) => n instanceof ou);
      if (e && e._external.getDenoiserStats) {
        let n = e._external.getDenoiserStats();
        n && this.requestUpload(wc.DENOISER_STATS, n);
      }
    }, 2e3), this.uploadExtStatsTimer && window.clearInterval(this.uploadExtStatsTimer), this.uploadExtStatsTimer = window.setInterval(() => {
      !this.requestAllTracks || !this.requestUpload || this.requestAllTracks().forEach((e) => {
        e.getProcessorStats().forEach((n) => {
          this.requestUpload && this.requestUpload(n.type, n.stats);
        });
      });
    }, 2e3));
  }
  stopUploadOutboundStats() {
    this.uploadOutboundStarted && (this.uploadOutboundStarted = false, this.lastSendStats && (this.lastSendStats.videoSend = [], this.lastSendStats.audioSend = [], this.lastSendStats = void 0), this.uploadOutboundDenoiserStatsTimer && window.clearInterval(this.uploadOutboundDenoiserStatsTimer), this.uploadOutboundDenoiserStatsTimer = void 0);
  }
  startUploadInboundStats() {
    this.uploadInboundStarted || (this.uploadInboundStarted = true, this.uploadWRTCStatsTimer || this.startUploadWRTCStats(), this.uploadInboundExtStatsTimer && window.clearInterval(this.uploadInboundExtStatsTimer), this.uploadInboundExtStatsTimer = window.setInterval(() => {
      !this.requestUpload || !this.requestRemoteMedia || (this.requestRemoteMedia() || []).forEach((e) => {
        let [n, i] = e;
        i.has(Q.VIDEO) && n.videoTrack && n.videoTrack.getProcessorStats().forEach((r) => {
          this.requestUpload && this.requestUpload(r.type, r.stats);
        }), i.has(Q.AUDIO) && n.audioTrack && n.audioTrack.getProcessorStats().forEach((r) => {
          this.requestUpload && this.requestUpload(r.type, r.stats);
        });
      });
    }, 2e3));
  }
  stopUploadInboundStats() {
    this.uploadInboundStarted && (this.uploadInboundStarted = false, this.lastRecvStats && (this.lastRecvStats.videoRecv = [], this.lastRecvStats.audioRecv = [], this.lastRecvStats = void 0));
  }
  startUploadExtensionUsageStats() {
    if (this.uploadExtensionUsageStarted) return;
    this.uploadExtensionUsageStarted = true, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer);
    let e = /* @__PURE__ */ new Map();
    this.uploadExtUsageStatsTimer = window.setInterval(async () => {
      let n = Date.now(), i = { connectionInterval: v("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3, details: [], lts: n }, r = [], o = this.requestAllTracks && this.requestAllTracks() || [];
      for (let d of o) !d.muted && d.enabled && (r = r.concat(await d.getProcessorUsage()));
      let s = this.requestRemoteMedia && this.requestRemoteMedia() || [];
      for (let [d, l] of s) l.has(Q.VIDEO) && d.videoTrack && (r = r.concat(await d.videoTrack.getProcessorUsage())), l.has(Q.AUDIO) && d.audioTrack && (r = r.concat(await d.audioTrack.getProcessorUsage()));
      if (r.length === 0) return;
      i.details = function(d, l) {
        let u = {};
        for (let { id: E, value: f, level: S, direction: C } of d) {
          var h;
          let A = (h = l.get(E)) !== null && h !== void 0 ? h : 0, b = f === 2 ? A + v("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : A;
          var p, g;
          l.set(E, b), u[E] ? (f === 2 && (u[E].value = f), S > u[E].level && (u[E].level = S), C === "remote" && (u[E].remoteUidCount += 1), u[E].totalTs = (p = l.get(E)) !== null && p !== void 0 ? p : 0) : u[E] = { value: f, level: S, remoteUidCount: C === "local" ? 0 : 1, totalTs: (g = l.get(E)) !== null && g !== void 0 ? g : 0 };
        }
        return Object.keys(u).map((E) => {
          let { level: f, value: S, totalTs: C } = u[E];
          return { id: E, level: f, value: S, totalTs: C };
        });
      }(r, e);
      let a = Date.now(), c = a > n ? a : n + 1;
      this.requestUpload && this.requestUpload(wc.EXTENSION_USAGE_STATS, { usageStats: i, sendTs: c });
    }, v("EXTENSION_USAGE_UPLOAD_INTERVAL"));
  }
  stopUploadExtensionUsageStats() {
    this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = false, this.uploadExtUsageStatsTimer && window.clearInterval(this.uploadExtUsageStatsTimer), this.uploadExtUsageStatsTimer = void 0);
  }
};
var ir = class {
  get hasVideo() {
    return this._video_enabled_ && !this._video_muted_ && this._video_added_;
  }
  get hasAudio() {
    return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;
  }
  get audioTrack() {
    if (this.hasAudio || this._audio_pre_subscribed) return this._audioTrack;
  }
  get videoTrack() {
    if (this.hasVideo || this._video_pre_subscribed) return this._videoTrack;
  }
  get dataChannels() {
    return this._dataChannels;
  }
  constructor(e, n) {
    T(this, "uid", void 0), T(this, "_uintid", void 0), T(this, "_trust_in_room_", true), T(this, "_trust_audio_enabled_state_", true), T(this, "_trust_video_enabled_state_", true), T(this, "_trust_audio_mute_state_", true), T(this, "_trust_video_mute_state_", true), T(this, "_audio_muted_", false), T(this, "_video_muted_", false), T(this, "_audio_enabled_", true), T(this, "_video_enabled_", true), T(this, "_audio_added_", false), T(this, "_video_added_", false), T(this, "_is_pre_created", false), T(this, "_video_pre_subscribed", false), T(this, "_audio_pre_subscribed", false), T(this, "_trust_video_stream_added_state_", true), T(this, "_trust_audio_stream_added_state_", true), T(this, "_audioTrack", void 0), T(this, "_videoTrack", void 0), T(this, "_dataChannels", []), T(this, "_audioSSRC", void 0), T(this, "_videoSSRC", void 0), T(this, "_audioOrtc", void 0), T(this, "_videoOrtc", void 0), T(this, "_cname", void 0), T(this, "_rtxSsrcId", void 0), T(this, "_videoMid", void 0), T(this, "_audioMid", void 0), this.uid = e, this._uintid = n;
  }
};
var Ui = function(t11) {
  return t11.SEND_ONLY = "SEND_ONLY", t11.RECEIVE_ONLY = "RECEIVE_ONLY", t11;
}({});
function uW(t11, e) {
  var n;
  let i;
  switch (e) {
    case U.LocalAudioTrack:
      i = Ct.Audio;
      break;
    case U.LocalVideoTrack:
      i = W(n = t11._hints).call(n, Gt.SCREEN_TRACK) ? Ct.Screen : Ct.High;
      break;
    case U.LocalVideoLowTrack:
      i = Ct.Low;
  }
  return i;
}
function lm(t11) {
  let e = ft();
  if (t11.some((n) => n._bypassWebAudio)) throw new N(R.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
  if (!e.webAudioMediaStreamDest) throw new N(R.NOT_SUPPORTED, "cannot publish multiple tracks because your browser does not support audio mixing");
}
function E_(t11, e) {
  lm(t11);
  let n = new ge();
  return t11.forEach((i) => n.addAudioTrack(i)), n;
}
var Tv;
var Sv;
var Rv;
var Cv;
var Iv;
var vv;
var yv;
var Av;
var bv;
var wv;
var Ov;
var Ht;
function Nv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Yd(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Nv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : Nv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var An = (Tv = Pi(Ui.SEND_ONLY), Sv = Pi(Ui.SEND_ONLY), Rv = Pi(), Cv = Pi(Ui.RECEIVE_ONLY), Iv = Pi(Ui.RECEIVE_ONLY), vv = Pi(Ui.RECEIVE_ONLY), yv = Pi(Ui.RECEIVE_ONLY), Av = Pi(Ui.RECEIVE_ONLY), bv = Pi(Ui.RECEIVE_ONLY), wv = Pi(), Ov = Pi(Ui.RECEIVE_ONLY), Ht = class extends Xt {
  get state() {
    return this._state;
  }
  set state(t11) {
    let e = this._state;
    this._state = t11, this.emit(tt.StateChange, e, this._state);
  }
  constructor(t11, e) {
    super(), T(this, "isPlanB", false), T(this, "store", void 0), T(this, "statsUploader", void 0), T(this, "sendConnection", void 0), T(this, "recvConnection", void 0), T(this, "localTrackMap", /* @__PURE__ */ new Map()), T(this, "remoteUserMap", /* @__PURE__ */ new Map()), T(this, "localDataChannels", []), T(this, "pendingLocalTracks", []), T(this, "pendingRemoteTracks", []), T(this, "statsCollector", void 0), T(this, "dtlsFailedCount", 0), T(this, "sendMutex", new ze("P2PChannel2-send-mutex")), T(this, "recvMutex", new ze("P2PChannel2-recv-mutex")), T(this, "_state", Rt.Disconnected), T(this, "_restartStates", ["disconnected", "failed"]), T(this, "reconnectInterval", void 0), T(this, "uploadUnplinkStarted", false), T(this, "uploadDownlinkStarted", false), T(this, "uplinkStateUploadInterval", void 0), T(this, "downlinkStatsUploadInterval", void 0), T(this, "handleMuteLocalTrack", async (n, i, r) => {
      let o = await this.sendMutex.lock("Locking from P2PChannel2.handleMuteLocalTrack");
      try {
        if (!this.sendConnection || this.state !== Rt.Connected) return void r(new N(R.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established."));
        let c = this.filterTobeMutedTracks(n);
        if (c.length === 0) return void i();
        let d = c.find((p) => p[0] === "videoLowTrack");
        d && d[1].track._originMediaStreamTrack.stop(), await this.sendConnection.muteLocal(c.map((p) => {
          let [, { id: g }] = p;
          return g;
        }));
        let l = false;
        var s, a;
        n.trackMediaType === "video" ? l = !((s = this.localTrackMap.get(U.LocalAudioTrack)) === null || s === void 0 || !s.track._muted) : l = ((a = this.localTrackMap.get(U.LocalVideoTrack)) === null || a === void 0 ? void 0 : a.id) === void 0;
        let u = this.createMuteMessage(c);
        await kt(this, tt.RequestMuteLocal, u);
        let h = n.trackMediaType === "video" ? to.MUTE_LOCAL_VIDEO : to.MUTE_LOCAL_AUDIO;
        await kt(this, tt.RequestP2PMuteLocal, { action: h, message: u, isMuteAll: l }), i();
      } catch (c) {
        r(c);
      } finally {
        o();
      }
    }), T(this, "handleUnmuteLocalTrack", async (n, i, r) => {
      let o = await this.sendMutex.lock("Locking from P2PChannel2.handleUnmuteLocalTrack");
      try {
        if (!this.sendConnection || this.state !== Rt.Connected) return void r(new N(R.INVALID_OPERATION, "Cannot call P2PChannel2.handleUnmuteLocalTrack before sendConnection established."));
        let s = this.filterTobeUnmutedTracks(n);
        if (s.length === 0) return void i();
        await this.sendConnection.unmuteLocal(s.map((d) => {
          let [, { id: l }] = d;
          return l;
        }));
        let a = this.createUnmuteMessage(s), c = n.trackMediaType === "video" ? to.UNMUTE_LOCAL_VIDEO : to.UNMUTE_LOCAL_AUDIO;
        await kt(this, tt.RequestP2PMuteLocal, { action: c, message: a }), i();
      } catch (s) {
        r(s);
      } finally {
        o();
      }
    }), T(this, "handleUpdateVideoEncoder", async (n, i, r) => {
      let o = await this.sendMutex.lock("Locking from P2PChannel2.handleSetVideoEncoder");
      try {
        let s = this.localTrackMap.get(U.LocalVideoTrack);
        if (!this.sendConnection || !s || s.track !== n || this.state !== Rt.Connected) return void i();
        let { id: a, track: c } = s;
        a && (await this.sendConnection.updateSendParameters(a, c), await this.sendConnection.updateEncoderConfig(a, c), this.emit(tt.UpdateVideoEncoder, c)), i();
      } catch (s) {
        r(s);
      } finally {
        o();
      }
    }), T(this, "handleUpdateVideoSendParameters", async (n, i, r) => {
      let o = await this.sendMutex.lock("Locking from P2PChannel2.handleUpdateVideoSendParameters");
      try {
        let s = this.localTrackMap.get(U.LocalVideoTrack);
        if (!this.sendConnection || !s || s.track !== n || this.state !== Rt.Connected) return void i();
        let { id: a, track: c } = s;
        a && await this.sendConnection.updateSendParameters(a, c), i();
      } catch (s) {
        r(s);
      } finally {
        o();
      }
    }), T(this, "handleReplaceTrack", async (n, i, r, o) => {
      let s;
      _.debug("[".concat(this.store.clientId, "] P2PChannel2 handleReplaceTrack for [track-id-").concat(n.getTrackId(), "]")), typeof o == "boolean" && o || (s = await this.sendMutex.lock("From P2PChannel2.handleReplaceTrack"));
      try {
        var a;
        let d = Array.from(this.localTrackMap.entries()).find((l) => {
          let [, { track: u }] = l;
          return n === u;
        });
        if (!this.sendConnection || !d || d[1].id === void 0 || this.state !== Rt.Connected) return void i();
        if (await ((a = this.sendConnection) === null || a === void 0 ? void 0 : a.replaceTrack(n, d[1].id)), d[0] === U.LocalVideoTrack && ft().supportDualStreamEncoding) {
          let l = this.localTrackMap.get(U.LocalVideoLowTrack);
          if (l) {
            let u = n._mediaStreamTrack.clone();
            l.track._originMediaStreamTrack.stop(), l.track._mediaStreamTrack = u, l.track._originMediaStreamTrack = u, await new j((h, p) => {
              this.handleReplaceTrack(l.track, h, p, true);
            });
          }
        }
        i();
      } catch (d) {
        r(d);
      } finally {
        var c;
        (c = s) === null || c === void 0 || c();
      }
    }), T(this, "handleGetLocalVideoStats", (n) => {
      n(this.statsCollector.getLocalVideoTrackStats());
    }), T(this, "handleGetLocalAudioStats", (n) => {
      n(this.statsCollector.getLocalAudioTrackStats());
    }), T(this, "handleGetRemoteVideoStats", (n) => this.statsCollector.getRemoteVideoTrackStats(n.uid)[n.uid]), T(this, "handleGetRemoteAudioStats", (n) => this.statsCollector.getRemoteAudioTrackStats(n.uid)[n.uid]), this.store = t11, this.statsCollector = e, this.statsCollector.addP2PChannel(this), this.statsUploader = new pu(t11), this.bindStatsUploaderEvents(), this.reconnectInterval = window.setInterval(() => {
      [this.sendConnection, this.recvConnection].forEach((n) => {
        n && (n.iceConnectionState !== "disconnected" && n.iceConnectionState !== "failed" || this.handleDisconnect(n.direction));
      });
    }, v("ICE_RESTART_INTERVAL"));
  }
  async startP2PConnection(t11, e) {
    throw new N(R.NOT_SUPPORTED, "p2p mode does not support startP2PConnection.");
  }
  async connect(t11) {
    throw new N(R.NOT_SUPPORTED, "p2p mode does not support connect.");
  }
  async startP2P(t11, e) {
    let n;
    try {
      if (e) {
        this.recvConnection && (_.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset recvConnection.")), this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection)), n = await this.recvMutex.lock("From P2PChannel.startP2P"), this.recvConnection = new mv(t11, this.store, cn.RECEIVE_ONLY), this.bindConnectionEvents(this.recvConnection);
        let i = await this.recvConnection.establish(e);
        return { iceParameters: i.iceParameters, dtlsParameters: i.dtlsParameters, sdp: i.sdp };
      }
      {
        this.state = Rt.New, this.sendConnection && (_.warning("[".concat(this.store.clientId, "] P2PChannel.startP2P reset sendConnection.")), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection)), n = await this.sendMutex.lock("From P2PChannel.startP2P"), this.sendConnection = new mv(t11, this.store), this.store.peerConnectionStart(), this.bindConnectionEvents(this.sendConnection);
        let i = await this.sendConnection.establish();
        return { iceParameters: i.iceParameters, dtlsParameters: i.dtlsParameters, sdp: i.sdp };
      }
    } finally {
      n && n();
    }
  }
  async p2pConnect(t11) {
    if (!this.sendConnection) throw new N(R.UNEXPECTED_ERROR, "Cannot P2PChannel2.p2pConnect before P2PChannel2.startP2PConnection .");
    this.store.peerConnectionStart(), await this.sendConnection.connect(t11), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = Rt.Connected;
  }
  async addRemoteCandidate(t11, e) {
    if (e === cn.RECEIVE_ONLY) {
      if (!this.sendConnection) throw new N(R.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
      await this.sendConnection.addRemoteCandidate(t11);
    } else {
      if (!this.recvConnection) throw new N(R.UNEXPECTED_ERROR, "Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");
      await this.recvConnection.addRemoteCandidate(t11);
    }
  }
  publish(t11, e, n) {
    var i = this;
    return Bi(function* () {
      let r = yield Tt(i.sendMutex.lock("From P2PChannel.publish"));
      try {
        if (!i.sendConnection || i.state !== Rt.Connected) {
          i.throwIfTrackTypeNotMatch(t11);
          let d = t11.filter((l) => i.pendingLocalTracks.indexOf(l) === -1);
          return void (i.pendingLocalTracks = i.pendingLocalTracks.concat(d));
        }
        i.store.pubId = i.store.pubId + 1, qe.markPublishStart(i.store.clientId, i.store.pubId);
        let o = i.filterTobePublishedTracks(t11, e, n);
        if (o.length === 0) return void (yield Tt(i.tryToUnmuteAudio(t11)));
        o.forEach((d) => {
          let { track: l, type: u } = d, h = Date.now();
          i.store.publish(l.getTrackId(), u === U.LocalAudioTrack ? "audio" : "video", h);
        }), i.bindLocalTrackEvents(o);
        let s = yield Tt(i.sendConnection.send(o.map((d) => {
          let { track: l } = d;
          return l;
        }), i.store.codec, i.store.audioCodec)), a = (yield Tt(s.next())).value, c = i.createGatewayPublishMessage(o, a);
        try {
          yield c;
        } catch (d) {
          throw s.throw(d), (d == null ? void 0 : d.code) === R.WS_ABORT && o.forEach((l) => {
            let { track: u } = l;
            i.pendingLocalTracks.indexOf(u) === -1 && i.pendingLocalTracks.push(u);
          }), i.unbindLocalTrackEvents(o), d;
        }
        yield Tt(s.next()), o.forEach((d) => {
          let { type: l } = d;
          i.statsCollector.addLocalStats(l);
        }), i.statsUploader.startUploadOutboundStats(), i.assignLocalTracks(o, a), o.forEach((d) => {
          let { track: l, type: u } = d, h = Date.now();
          i.store.publish(l.getTrackId(), u === U.LocalAudioTrack ? "audio" : "video", void 0, h);
        }), i.startUploadUplinkState();
      } finally {
        r();
      }
    })();
  }
  async unpublish(t11) {
    if (!this.sendConnection || this.state !== Rt.Connected) return void (t11.length === 0 ? this.pendingLocalTracks.length = 0 : this.pendingLocalTracks = this.pendingLocalTracks.filter((r) => !W(t11).call(t11, r)));
    let e = this.filterTobeUnpublishedTracks(t11);
    if (e.length === 0) return;
    let n = e.find((r) => r[0] === "videoLowTrack");
    n && n[1].track.close();
    let i = this.createGatewayUnpublishMessage(e);
    if (await this.sendConnection.stopSending(e.map((r) => {
      let [, { id: o }] = r;
      return o;
    })), this.withdrawLocalTracks(e), this.unbindLocalTrackEvents(e.map((r) => {
      let [o, { track: s }] = r;
      return { type: o, track: s };
    })), e.forEach((r) => {
      let [o] = r;
      this.statsCollector.removeLocalStats(o);
    }), this.localTrackMap.size === 0 && (this.statsUploader.stopUploadOutboundStats(), this.stopUploadUplinkState()), this.sendConnection && this.state === Rt.Connected) return n && n[1].track.close(), i;
    t11.forEach((r) => {
      let o = this.pendingLocalTracks.indexOf(r);
      o !== -1 && this.pendingLocalTracks.splice(o, 1);
    });
  }
  startUploadUplinkState() {
    if (this.uploadUnplinkStarted) return;
    this.uploadUnplinkStarted = true, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval);
    let t11 = () => {
      let e = [], n = [];
      Array.from(this.localTrackMap.entries()).forEach((i) => {
        let [r, { track: o, ssrcs: s }] = i, a = { stream_type: uW(o, r), ssrcs: s };
        o._muted || !o._enabled ? e.push(a) : n.push(a);
      }), e.length > 0 && e.forEach((i) => {
        kt(this, tt.RequestMuteLocal, [i]);
      }), n.length > 0 && n.forEach((i) => {
        kt(this, tt.RequestUnmuteLocal, [i]);
      });
    };
    t11(), this.uplinkStateUploadInterval = window.setInterval(() => {
      t11();
    }, 3e3);
  }
  stopUploadUplinkState() {
    this.uploadUnplinkStarted && (this.uploadUnplinkStarted = false, this.uplinkStateUploadInterval && window.clearInterval(this.uplinkStateUploadInterval));
  }
  publishLowStream(t11) {
    return Bi(function* () {
      throw new N(R.NOT_SUPPORTED, "p2p mode does not support publishLowStream.");
    })();
  }
  async republish() {
    this.pendingLocalTracks.length > 0 && (_.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await Ge(this, tt.RequestRePublish, this.pendingLocalTracks), this.emit(tt.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);
  }
  async unpublishLowStream() {
    throw new N(R.NOT_SUPPORTED, "p2p mode does not support unpublishLowStream.");
  }
  async subscribe(t11, e, n, i) {
    var r;
    if (!this.recvConnection) throw new N(R.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
    if ((r = this.remoteUserMap.get(t11)) !== null && r !== void 0 && r.has(e)) return;
    let { track: o, mid: s, transceiver: a } = await this.recvConnection.receive(e, [{ ssrcId: n }], String(t11.uid), i);
    e === Q.AUDIO ? (t11._audioTrack ? t11._audioTrack._updateOriginMediaStreamTrack(o) : (t11._audioTrack = new Ks(o, t11.uid, t11._uintid, this.store), _.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(t11._audioTrack.getTrackId()))), a && t11._audioTrack._updateRtpTransceiver(a), this.bindRemoteTrackEvents(t11, t11._audioTrack)) : (t11._videoSSRC = n, t11._videoTrack ? t11._videoTrack._updateOriginMediaStreamTrack(o) : (t11._videoTrack = new Hs(o, t11.uid, t11._uintid, this.store), _.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(t11._videoTrack.getTrackId()))), a && t11._videoTrack._updateRtpTransceiver(a), this.bindRemoteTrackEvents(t11, t11._videoTrack));
    let c = this.remoteUserMap.get(t11);
    c ? c.set(e, s) : this.remoteUserMap.set(t11, /* @__PURE__ */ new Map([[e, s]])), this.statsCollector.addRemoteStats(t11.uid), this.statsUploader.startUploadInboundStats(), this.startUploadDownlinkState();
    let d = this.pendingRemoteTracks.findIndex((l) => {
      let { user: u, kind: h } = l;
      return u.uid === t11.uid && e === h;
    });
    d !== -1 && (this.pendingRemoteTracks.splice(d, 1), this.emit(tt.MediaReconnectEnd, t11.uid));
  }
  async mockSubscribe(t11, e, n, i) {
    if (!this.recvConnection) throw new N(R.INVALID_OPERATION, "Cannot subscribe remote user when recvConnection disconnected.");
    await this.recvConnection.mockReceive(e, [{ ssrcId: n }], String(t11.uid), i);
  }
  async unsubscribe(t11, e, n) {
    let i = this.pendingRemoteTracks.filter((o) => {
      let { user: s, kind: a } = o;
      return e !== void 0 ? s.uid === t11.uid && e === a : s.uid === t11.uid;
    });
    if (i.forEach((o) => {
      let s = this.pendingRemoteTracks.indexOf(o);
      this.pendingRemoteTracks.splice(s, 1);
    }), this.recvConnection || n || i.forEach((o) => {
      let { kind: s } = o;
      var a;
      if (s === Q.AUDIO) (a = t11._audioTrack) === null || a === void 0 || a._destroy(), t11._audioTrack = void 0;
      else if (s === Q.VIDEO) {
        var c;
        (c = t11._videoTrack) === null || c === void 0 || c._destroy(), t11._videoTrack = void 0;
      }
    }), !this.recvConnection) return;
    let r = this.filterTobeUnSubscribedTracks(t11, e);
    r.length !== 0 && (await this.recvConnection.stopReceiving(r.map((o) => {
      let [, { id: s }] = o;
      return s;
    })), this.withdrawRemoteTracks(r), this.remoteUserMap.size === 0 && (this.statsUploader.stopUploadInboundStats(), this.stopUploadDownlinkState()), r.forEach((o) => {
      let [s, { kind: a }] = o;
      var c, d;
      if (a === Q.VIDEO && s._videoSSRC && ((c = this.recvConnection) === null || c === void 0 || c.setStatsRemoteVideoIsReady(s._videoSSRC, false)), a === Q.VIDEO) this.unbindRemoteTrackEvents(s._videoTrack), n || ((d = s._videoTrack) === null || d === void 0 || d._destroy(), s._videoTrack = void 0);
      else if (a === Q.AUDIO) {
        var l;
        this.unbindRemoteTrackEvents(s._audioTrack), !n && ((l = s._audioTrack) === null || l === void 0 || l._destroy(), s._audioTrack = void 0);
      }
    }), r.forEach((o) => {
      let [, { kind: s }] = o;
      kt(this, tt.RequestP2PMuteRemote, s);
    }));
  }
  startUploadDownlinkState() {
    if (this.uploadDownlinkStarted) return;
    this.uploadDownlinkStarted = true, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval);
    let t11 = () => Array.from(this.remoteUserMap.entries()).forEach((e) => {
      let [, n] = e;
      [Q.VIDEO, Q.AUDIO].forEach((i) => {
        n.has(i) ? kt(this, tt.RequestP2PUnmuteRemote, i) : kt(this, tt.RequestP2PMuteRemote, i);
      });
    });
    t11(), this.downlinkStatsUploadInterval = window.setInterval(() => {
      t11();
    }, 3e3);
  }
  stopUploadDownlinkState() {
    this.uploadDownlinkStarted && (this.uploadDownlinkStarted = false, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval));
  }
  getAllDataChannels() {
    return this.localDataChannels;
  }
  async massSubscribe(t11) {
    throw new N(R.NOT_SUPPORTED, "p2p mode does not support massSubscribe.");
  }
  async massSubscribeNoLock(t11) {
    throw new N(R.NOT_SUPPORTED, "p2p mode does not support massSubscribeNoLock.");
  }
  async massUnsubscribe(t11) {
    throw new N(R.NOT_SUPPORTED, "p2p mode does not support massUnsubscribe.");
  }
  async massUnsubscribeNoLock(t11) {
    throw new N(R.NOT_SUPPORTED, "p2p mode does not support massUnsubscribeNoLock.");
  }
  async muteRemote(t11, e) {
    if (!this.recvConnection) return;
    let n = this.remoteUserMap.get(t11);
    if (!n) return void _.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(t11.uid, "."));
    if (!n.get(e)) return void _.warning("[".concat(this.store.clientId, "] P2PChannel2.muteRemote has no remote user ").concat(t11.uid, " media type ").concat(e, "."));
    let i = e === Q.VIDEO ? t11._videoSSRC : t11._audioSSRC;
    i !== void 0 && this.recvConnection.setStatsRemoteVideoIsReady(i, false);
  }
  async unmuteRemote(t11, e) {
    return this.unmuteRemoteNoLock(t11, e);
  }
  async unmuteRemoteNoLock(t11, e) {
    if (!this.recvConnection) return;
    let n = this.remoteUserMap.get(t11);
    if (!n) return void _.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(t11.uid, "."));
    n.get(e) || _.warning("[".concat(this.store.clientId, "] P2PChannel2.unmuteRemote has no remote user ").concat(t11.uid, " media type ").concat(e, "."));
  }
  getAllTracks(t11) {
    let e = this.localTrackMap.get(U.LocalAudioTrack);
    if ((e == null ? void 0 : e.track) instanceof ge) {
      let n = e.track;
      return Array.from(this.localTrackMap.entries()).filter((i) => {
        let [r] = i;
        return r !== U.LocalAudioTrack;
      }).filter((i) => {
        let [r] = i;
        return !(t11 && r === U.LocalVideoLowTrack);
      }).map((i) => {
        let [, { track: r }] = i;
        return r;
      }).concat(n.trackList);
    }
    return Array.from(this.localTrackMap.entries()).filter((n) => {
      let [i] = n;
      return !(t11 && i === U.LocalVideoLowTrack);
    }).map((n) => {
      let [, { track: i }] = n;
      return i;
    });
  }
  reportPublishEvent(t11, e, n, i, r) {
    if (t11) {
      let s = this.localTrackMap.get(U.LocalAudioTrack), a = i ? this.localTrackMap.get(U.LocalVideoLowTrack) : this.localTrackMap.get(U.LocalVideoTrack);
      X.publish(this.store.sessionId, { eventElapse: qe.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: t11, ec: e, audioName: s == null ? void 0 : s.track.getTrackLabel(), videoName: a == null ? void 0 : a.track.getTrackLabel(), screenshare: (a == null ? void 0 : a.track._hints.indexOf(Gt.SCREEN_TRACK)) !== -1, audio: !!s, video: !!a, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r });
    } else {
      var o;
      n || (n = []);
      let s = n.find((c) => c instanceof Qt), a = i ? (o = this.localTrackMap.get(U.LocalVideoTrack)) === null || o === void 0 ? void 0 : o.track : n.find((c) => c instanceof Ft);
      X.publish(this.store.sessionId, { eventElapse: qe.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: t11, ec: e, audioName: s == null ? void 0 : s.getTrackLabel(), videoName: a == null ? void 0 : a.getTrackLabel(), screenshare: (a == null ? void 0 : a._hints.indexOf(Gt.SCREEN_TRACK)) !== -1, audio: !!s, video: !!a, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r });
    }
  }
  reportSubscribeEvent(t11, e, n, i) {
    let r = i === Q.VIDEO ? n._videoSSRC : n._audioSSRC;
    r && X.subscribe(this.store.sessionId, { succ: t11, ec: e, video: i === Q.VIDEO, audio: i === Q.AUDIO, peerid: n.uid, subscribeRequestid: i === Q.VIDEO ? n._videoSSRC : n._audioSSRC, p2pid: this.store.p2pId, eventElapse: qe.measureFromSubscribeStart(this.store.clientId, r) });
  }
  reset() {
    _.debug("[".concat(this.store.clientId, "] P2PChannel2.reset")), this.sendMutex = new ze("P2PChannel2-send-mutex"), this.sendMutex = new ze("P2PChannel2-recv-mutex"), this.sendConnection && (this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0), this.recvConnection && (this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
    let t11 = this.localTrackMap.get(U.LocalAudioTrack);
    if ((t11 == null ? void 0 : t11.track) instanceof ge) {
      if (t11.track.trackList.length > 0) {
        let e = t11.track;
        t11.track.trackList.forEach((n) => {
          e.removeAudioTrack(n);
        });
      }
      t11.track.close();
    }
    this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.reconnectInterval && (window.clearInterval(this.reconnectInterval), this.reconnectInterval = void 0), this.state = Rt.Disconnected;
  }
  getStats(t11) {
    var e, n;
    return t11 ? (n = this.recvConnection) === null || n === void 0 ? void 0 : n.getStats() : (e = this.sendConnection) === null || e === void 0 ? void 0 : e.getStats();
  }
  getRemoteVideoIsReady(t11) {
    var e;
    return ((e = this.recvConnection) === null || e === void 0 ? void 0 : e.getRemoteVideoIsReady(t11)) || false;
  }
  getLocalAudioVolume() {
    let t11 = this.localTrackMap.get(U.LocalAudioTrack);
    if (t11) return t11.track.getVolumeLevel();
  }
  getLocalVideoSize() {
    let t11 = this.localTrackMap.get(U.LocalVideoTrack);
    if (t11) return { width: t11.track.videoWidth || 0, height: t11.track.videoHeight || 0 };
  }
  getEncoderConfig(t11) {
    let e = this.localTrackMap.get(t11);
    return e && e.track instanceof Ft || e && e.track instanceof Qt ? e.track._encoderConfig : void 0;
  }
  getLocalMedia(t11) {
    return this.localTrackMap.get(t11);
  }
  hasLocalMedia() {
    return this.localTrackMap.size > 0;
  }
  hasRemoteMedia(t11, e) {
    if (!t11) return this.remoteUserMap.size > 0;
    let n = this.remoteUserMap.get(t11);
    return !!n && (!e || n.has(e));
  }
  async hasRemoteMediaWithLock(t11, e) {
    if (!t11) return this.remoteUserMap.size > 0;
    let n = this.remoteUserMap.get(t11);
    return !!n && (!e || n.has(e));
  }
  getRemoteMedia(t11) {
    var e;
    let n = Array.from(xn(e = this.remoteUserMap).call(e)).find((i) => i.uid === t11);
    return n ? { audioTrack: n.audioTrack, audioSSRC: n._audioSSRC, videoTrack: n.videoTrack, videoSSRC: n._videoSSRC } : {};
  }
  getAudioLevels() {
    let t11 = Array.from(this.remoteUserMap.entries()).map((n) => {
      let [i] = n;
      return { uid: i.uid, level: i.audioTrack ? 100 * i.audioTrack._source.getAccurateVolumeLevel() : 0 };
    }), e = this.localTrackMap.get(U.LocalAudioTrack);
    return e && t11.push({ level: 100 * e.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), t11 = ed(t11).call(t11, (n, i) => n.level - i.level), t11;
  }
  async disconnectForReconnect() {
    this.sendConnection && this.recvConnection && (_.debug("[".concat(this.store.clientId, "] P2PChannel2.disconnectForReconnect closing P2PConnection")), this.state = Rt.Reconnecting, v("KEEP_LAST_FRAME") && this.remoteUserMap.size !== 0 && Array.from(this.remoteUserMap.entries()).forEach((t11) => {
      let [e] = t11;
      var n;
      e._videoTrack && e._videoTrack._player && ((n = e._videoTrack._player.getVideoElement()) === null || n === void 0 || n.pause(), e._videoTrack._player.isKeepLastFrame = true, e._videoTrack._originMediaStreamTrack.stop());
    }), this.sendConnection.close(), this.unbindConnectionEvents(this.sendConnection), this.sendConnection = void 0, this.recvConnection.close(), this.unbindConnectionEvents(this.recvConnection), this.recvConnection = void 0, this.localTrackMap.size !== 0 && (Array.from(this.localTrackMap.entries()).forEach((t11) => {
      var e;
      let [n, { track: i }] = t11;
      switch (n) {
        case U.LocalVideoTrack:
          W(e = i._hints).call(e, Gt.LOW_STREAM) ? i.close() : this.pendingLocalTracks.push(i);
          break;
        case U.LocalAudioTrack:
          i instanceof ge ? this.pendingLocalTracks = this.pendingLocalTracks.concat(i.trackList) : this.pendingLocalTracks.push(i);
        case U.LocalVideoLowTrack:
      }
    }), this.emit(tt.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), this.remoteUserMap.size !== 0 && Array.from(this.remoteUserMap.entries()).forEach((t11) => {
      let [e, n] = t11;
      Array.from(xn(n).call(n)).forEach((i) => {
        this.setPendingRemoteMedia(e, i);
      }), this.emit(tt.MediaReconnectStart, e.uid);
    }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.stopUploadUplinkState(), this.stopUploadDownlinkState(), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), _.debug("[".concat(this.store.clientId, "] P2PChannel2 disconnected, waiting to reconnect.")));
  }
  hasPendingRemoteMedia(t11, e) {
    for (let n of this.pendingRemoteTracks) {
      let { user: i, kind: r } = n;
      if ((t11 instanceof ir ? t11.uid : t11) === i.uid && e === r) return true;
    }
    return false;
  }
  setPendingRemoteMedia(t11, e) {
    this.hasPendingRemoteMedia(t11, e) || this.pendingRemoteTracks.push({ user: t11, kind: e });
  }
  async restartICE(t11, e) {
    let n, i;
    if (t11 === cn.SEND_ONLY) {
      if (!this.sendConnection) throw new N(R.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established.");
      n = await this.sendMutex.lock("From P2PChannel.restartICE"), i = this.sendConnection;
    } else {
      if (!this.recvConnection) throw new N(R.INVALID_OPERATION, "Cannot call P2PChannel2.handleMuteLocalTrack before recvConnection established.");
      n = await this.recvMutex.lock("From P2PChannel.restartICE"), i = this.recvConnection;
    }
    try {
      if (e) {
        let r = await i.restartICE(e);
        return i.isInRestartIce = false, r;
      }
      {
        let r = await i.restartICE();
        if (r) {
          let o = await Ge(this, tt.RequestP2PRestartICE, { direction: cn.RECEIVE_ONLY, iceParameter: r });
          await i.restartICE(o), i.isInRestartIce = false;
        }
      }
    } finally {
      n();
    }
  }
  getUplinkNetworkQuality() {
    if (!this.sendConnection) return 0;
    let t11 = this.sendConnection.getStats(), e = this.localTrackMap.get(U.LocalVideoTrack), n = this.localTrackMap.get(U.LocalAudioTrack), i = t11.videoSend.find((p) => {
      var g;
      return p.ssrc === (e == null || (g = e.ssrcs) === null || g === void 0 ? void 0 : g[0].ssrcId);
    }), r = t11.audioSend.find((p) => {
      var g;
      return p.ssrc === (n == null || (g = n.ssrcs) === null || g === void 0 ? void 0 : g[0].ssrcId);
    });
    if (!i || !r) return 1;
    let o = ni(this, tt.NeedSignalRTT), s = i ? i.rttMs : void 0, a = r ? r.rttMs : void 0, c = s && a ? (s + a) / 2 : s || a, d = (c && o ? (c + o) / 2 : c || o) || 0, l = 100 * t11.sendPacketLossRate * 0.7 / 50 + 0.3 * d / 1500, u = l < 0.17 ? 1 : l < 0.36 ? 2 : l < 0.59 ? 3 : l < 0.1 ? 4 : 5, h = e == null ? void 0 : e.track;
    if (h && h._encoderConfig && h._hints.indexOf(Gt.SCREEN_TRACK) === -1) {
      let p = h._encoderConfig.bitrateMax, g = t11.bitrate.actualEncoded;
      if (p && g) {
        let E = (1e3 * p - g) / (1e3 * p);
        return OO[E < 0.15 ? 0 : E < 0.3 ? 1 : E < 0.45 ? 2 : E < 0.6 ? 3 : 4][u];
      }
    }
    return u;
  }
  getDownlinkNetworkQuality() {
    if (!this.recvConnection) return 0;
    let t11 = this.recvConnection.getStats(), e = 0;
    return Array.from(this.remoteUserMap.entries()).forEach((n) => {
      let [i] = n, r = i._audioSSRC, o = i._videoSSRC, s = t11.audioRecv.find((g) => g.ssrc === r), a = t11.videoRecv.find((g) => g.ssrc === o);
      if (!s && !a) return void (e += 1);
      let c = ni(this, tt.NeedSignalRTT), d = t11.rtt, l = (d && c ? (d + c) / 2 : d || c) || 0, u = s ? s.jitterMs : void 0, h = t11.recvPacketLossRate, p = 0.7 * h * 100 / 50 + 0.3 * l / 1500;
      u && (p = 0.6 * h * 100 / 50 + 0.2 * l / 1500 + 0.2 * u / 400), e += p < 0.1 ? 1 : p < 0.17 ? 2 : p < 0.36 ? 3 : p < 0.59 ? 4 : 5;
    }), this.remoteUserMap.size > 0 ? Math.round(e / this.remoteUserMap.size) : e;
  }
  async muteLocalTrack(t11) {
    return new j((e, n) => {
      this.handleMuteLocalTrack(t11, e, n);
    });
  }
  filterTobePublishedTracks(t11, e, n) {
    let i = [], r = ft(), o = this.getAllTracks();
    t11 = Ls(t11 = t11.filter((c) => o.indexOf(c) === -1));
    let s = false, a = false;
    for (let c of t11) {
      if (c instanceof Ft && (this.localTrackMap.has(U.LocalVideoTrack) || s ? new N(R.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (i.push({ track: c, type: U.LocalVideoTrack }), s = true), e)) {
        let d = this.getLowVideoTrack(c, n);
        i.push({ track: d, type: U.LocalVideoLowTrack });
      }
      if (c instanceof Qt) {
        let d = this.localTrackMap.get(U.LocalAudioTrack);
        if (d) {
          if (!(d.track instanceof ge)) throw new N(R.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
          if (c._bypassWebAudio) throw new N(R.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
          d.track.addAudioTrack(c), this.bindLocalAudioTrackEvents(c, true);
        } else if (a) {
          let l = i.find((u) => {
            let { type: h } = u;
            return h === U.LocalAudioTrack;
          });
          if (!(l.track instanceof ge)) throw new N(R.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
          if (c._bypassWebAudio) throw new N(R.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
          l.track.addAudioTrack(c);
        } else {
          if (!r.webAudioMediaStreamDest || c instanceof ge || c._bypassWebAudio) i.push({ track: c, type: U.LocalAudioTrack });
          else {
            let l = new ge();
            l.addAudioTrack(c), i.push({ track: l, type: U.LocalAudioTrack });
          }
          a = true;
        }
      }
    }
    return i;
  }
  filterTobeUnpublishedTracks(t11) {
    let e = [], n = this.getAllTracks();
    t11 = Ls(t11 = t11.filter((i) => n.indexOf(i) !== -1));
    for (let i of t11) {
      if (i instanceof Qt) {
        let r = this.localTrackMap.get(U.LocalAudioTrack);
        if (!r) continue;
        r.track instanceof ge ? (r.track.removeAudioTrack(i), this.unbindLocalAudioTrackEvents(i), r.track.trackList.length === 0 && (e.push([U.LocalAudioTrack, r]), r.track.close())) : e.push([U.LocalAudioTrack, r]);
      }
      if (i instanceof Ft) {
        let r = this.localTrackMap.get(U.LocalVideoTrack);
        if (!r) continue;
        e.push([U.LocalVideoTrack, r]);
        let o = this.localTrackMap.get(U.LocalVideoLowTrack);
        o && e.push([U.LocalVideoLowTrack, o]);
      }
    }
    return e;
  }
  bindLocalTrackEvents(t11) {
    t11.forEach((e) => {
      let { track: n, type: i } = e;
      switch (i) {
        case U.LocalVideoTrack:
          n.addListener(H.GET_STATS, this.handleGetLocalVideoStats), n.addListener(H.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), n.addListener(H.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), n.addListener(H.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), n.addListener(H.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), n.addListener(H.NEED_REPLACE_TRACK, this.handleReplaceTrack), n.addListener(H.NEED_MUTE_TRACK, this.handleMuteLocalTrack), n.addListener(H.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          break;
        case U.LocalAudioTrack:
          this.bindLocalAudioTrackEvents(n);
        case U.LocalVideoLowTrack:
      }
    });
  }
  bindLocalAudioTrackEvents(t11, e) {
    t11 instanceof ge ? t11.trackList.forEach((n) => {
      n.addListener(H.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), n.addListener(H.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), n.addListener(H.GET_STATS, this.handleGetLocalAudioStats), n.addListener(H.NEED_MUTE_TRACK, this.handleMuteLocalTrack), n.addListener(H.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
    }) : (t11.addListener(H.GET_STATS, this.handleGetLocalAudioStats), t11.addListener(H.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t11.addListener(H.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t11.addListener(H.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t11.addListener(H.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), e || t11.addListener(H.NEED_REPLACE_TRACK, this.handleReplaceTrack));
  }
  unbindLocalTrackEvents(t11) {
    t11 || (t11 = Array.from(this.localTrackMap.entries()).map((e) => {
      let [n, { track: i }] = e;
      return { track: i, type: n };
    })), t11.forEach((e) => {
      let { track: n, type: i } = e;
      switch (i) {
        case U.LocalVideoTrack:
          n.off(H.GET_STATS, this.handleGetLocalVideoStats), n.off(H.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), n.off(H.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), n.off(H.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), n.off(H.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), n.off(H.NEED_REPLACE_TRACK, this.handleReplaceTrack), n.off(H.NEED_MUTE_TRACK, this.handleMuteLocalTrack), n.off(H.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          break;
        case U.LocalAudioTrack:
          this.unbindLocalAudioTrackEvents(n);
        case U.LocalVideoLowTrack:
      }
    });
  }
  unbindLocalAudioTrackEvents(t11) {
    t11 instanceof ge ? t11.trackList.forEach((e) => {
      e.off(H.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.off(H.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.off(H.GET_STATS, this.handleGetLocalAudioStats), e.off(H.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.off(H.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
    }) : (t11.off(H.GET_STATS, this.handleGetLocalAudioStats), t11.off(H.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t11.off(H.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t11.off(H.NEED_REPLACE_TRACK, this.handleReplaceTrack), t11.off(H.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t11.off(H.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
  }
  bindRemoteTrackEvents(t11, e) {
    e instanceof Hs && e.addListener(H.GET_STATS, (n) => {
      n(this.handleGetRemoteVideoStats(t11));
    }), e instanceof Ks && e.addListener(H.GET_STATS, (n) => {
      n(this.handleGetRemoteAudioStats(t11));
    });
  }
  unbindRemoteTrackEvents(t11) {
    t11 && t11.removeAllListeners(H.GET_STATS);
  }
  unbindAllRemoteTrackEvents() {
    Array.from(this.remoteUserMap.entries()).forEach((t11) => {
      let [e, n] = t11;
      n.has(Q.AUDIO) && this.unbindRemoteTrackEvents(e._audioTrack), n.has(Q.VIDEO) && this.unbindRemoteTrackEvents(e._videoTrack);
    });
  }
  createGatewayPublishMessage(t11, e) {
    return t11.map((n, i) => {
      var r;
      let o, { track: s, type: a } = n;
      switch (a) {
        case U.LocalAudioTrack:
          o = Ct.Audio;
          break;
        case U.LocalVideoTrack:
          o = W(r = s._hints).call(r, Gt.SCREEN_TRACK) ? Ct.Screen : Ct.High;
          break;
        case U.LocalVideoLowTrack:
          o = Ct.Low;
      }
      return { kind: a === U.LocalAudioTrack ? Q.AUDIO : Q.VIDEO, stream_type: o, mid: e[i].id, ssrcs: e[i].localSSRC, isMuted: s.muted || !s.enabled };
    });
  }
  createGatewayUnpublishMessage(t11) {
    return t11.map((e) => {
      var n;
      let i, [r, { track: o, ssrcs: s, id: a }] = e;
      switch (r) {
        case U.LocalVideoTrack:
          i = W(n = o._hints).call(n, Gt.SCREEN_TRACK) ? Ct.Screen : Ct.High;
          break;
        case U.LocalAudioTrack:
          i = Ct.Audio;
          break;
        case U.LocalVideoLowTrack:
          i = Ct.Low;
      }
      return { stream_type: i, ssrcs: s, mid: a };
    });
  }
  assignLocalTracks(t11, e) {
    t11.forEach((n, i) => {
      let { track: r, type: o } = n;
      this.localTrackMap.set(o, { track: r, id: e[i].id, ssrcs: e[i].localSSRC });
    });
  }
  withdrawLocalTracks(t11) {
    t11.forEach((e) => {
      let [n] = e;
      this.localTrackMap.delete(n);
    });
  }
  bindConnectionEvents(t11) {
    t11.onConnectionStateChange = async (e) => {
      var n;
      _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: ").concat(t11.name, ".onConnectionStateChange(").concat(e, ")")), this.emit(tt.PeerConnectionStateChange, e), e !== "connected" || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), e === "connected" && (t11.isInRestartIce = false), W(n = this._restartStates).call(n, e) && !t11.isInRestartIce && (e === "disconnected" && await Me(800), t11.iceConnectionState !== "disconnected" && t11.iceConnectionState !== "failed" || this.handleDisconnect(t11.direction));
    }, t11.onICEConnectionStateChange = (e) => {
      e !== "connected" || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e, ")")), X.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e, tag: Zt.TRACER }).onSuccess(), this.emit(tt.IceConnectionStateChange, e);
    }, t11.onICETransportStateChange = (e) => {
      _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e, ")"));
    }, t11.onDTLSTransportStateChange = (e) => {
      _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e, ")"));
    }, t11.onDTLSTransportError = (e) => {
      _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e, ")"));
    }, t11.onFirstAudioDecoded = (e) => {
      var n;
      let i = Array.from(xn(n = this.remoteUserMap).call(n)).find((o) => o._audioSSRC === e);
      var r;
      i && (this.store.subscribe(i.uid, "audio", void 0, void 0, void 0, Date.now()), (r = i.audioTrack) === null || r === void 0 || r.emit(Ws.FIRST_FRAME_DECODED), X.firstRemoteFrame(this.store.sessionId, De.FIRST_AUDIO_DECODE, Jt.FIRST_AUDIO_DECODE, { peer: i._uintid, subscribeElapse: qe.measureFromSubscribeStart(this.store.clientId, e), subscribeRequestid: e, p2pid: this.store.p2pId }));
    }, t11.onFirstAudioReceived = (e) => {
      var n;
      let i = Array.from(xn(n = this.remoteUserMap).call(n)).find((r) => r._audioSSRC === e);
      i && X.firstRemoteFrame(this.store.sessionId, De.FIRST_AUDIO_RECEIVED, Jt.FIRST_AUDIO_RECEIVED, { peer: i._uintid, subscribeElapse: qe.measureFromSubscribeStart(this.store.clientId, e), subscribeRequestid: e, p2pid: this.store.p2pId });
    }, t11.onFirstVideoDecoded = (e, n, i) => {
      this.reportVideoFirstFrameDecoded(e, n, i);
    }, t11.onFirstVideoReceived = (e) => {
      var n;
      let i = Array.from(xn(n = this.remoteUserMap).call(n)).find((r) => r._videoSSRC === e);
      i && X.firstRemoteFrame(this.store.sessionId, De.FIRST_VIDEO_RECEIVED, Jt.FIRST_VIDEO_RECEIVED, { peer: i._uintid, subscribeElapse: qe.measureFromSubscribeStart(this.store.clientId, e), subscribeRequestid: e, p2pid: this.store.p2pId });
    }, t11.onSelectedLocalCandidateChanged = (e, n) => {
      let i = e.candidateType === "relay", r = n.candidateType === "relay";
      n.candidateType !== "unknown" && i === r || this.emit(tt.ConnectionTypeChange, i), _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(eo(n)), " -> ").concat(JSON.stringify(eo(e)), ")"));
    }, t11.onSelectedRemoteCandidateChanged = (e, n) => {
      _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(eo(n)), " -> ").concat(JSON.stringify(eo(e)), ")"));
    }, t11.onFirstVideoDecodedTimeout = (e) => {
      this.reportVideoFirstFrameDecoded(e, void 0, void 0, true);
    }, t11.onLocalCandidate = (e) => {
      this.emit(tt.LocalCandidate, { candidate: e, direction: t11.direction });
    };
  }
  unbindConnectionEvents(t11) {
    t11.onConnectionStateChange = void 0, t11.onICEConnectionStateChange = void 0, t11.onICETransportStateChange = void 0, t11.onDTLSTransportStateChange = void 0, t11.onDTLSTransportError = void 0, t11.onFirstAudioDecoded = void 0, t11.onFirstAudioReceived = void 0, t11.onFirstVideoDecoded = void 0, t11.onFirstVideoReceived = void 0, t11.onSelectedLocalCandidateChanged = void 0, t11.onSelectedRemoteCandidateChanged = void 0, t11.onFirstVideoDecodedTimeout = void 0, t11.onLocalCandidate = void 0;
  }
  async handleDisconnect(t11) {
    let e = t11 === cn.SEND_ONLY ? this.sendConnection : this.recvConnection;
    e && !e.isInRestartIce && (e.isInRestartIce = true, _.debug("[".concat(this.store.clientId, "] [P2PChannel-").concat(e.name, "] start use restartICE")), t11 === cn.SEND_ONLY ? this.restartICE(t11) : Ge(this, tt.RequestP2PRestartICE, { direction: cn.SEND_ONLY }));
  }
  filterTobeMutedTracks(t11) {
    let e = [];
    if (this.getAllTracks().indexOf(t11) === -1) return e;
    let n = this.localTrackMap.get(U.LocalAudioTrack);
    if (t11 instanceof Qt && (n == null ? void 0 : n.track) instanceof ge) return n.track.isActive || e.push([U.LocalAudioTrack, n]), e;
    let i = Array.from(this.localTrackMap.entries()).find((r) => {
      let [, { track: o }] = r;
      return t11 === o;
    });
    if (i && (e.push(i), i[0] === U.LocalVideoTrack)) {
      let r = this.localTrackMap.get(U.LocalVideoLowTrack);
      r && e.push([U.LocalVideoLowTrack, r]);
    }
    return e;
  }
  filterTobeUnmutedTracks(t11) {
    let e = [], n = this.localTrackMap.get(U.LocalAudioTrack);
    if (t11 instanceof Qt && (n == null ? void 0 : n.track) instanceof ge) return n.track.isActive && e.push([U.LocalAudioTrack, n]), e;
    let i = Array.from(this.localTrackMap.entries()).find((r) => {
      let [, { track: o }] = r;
      return t11 === o;
    });
    if (i) if (i[0] === U.LocalVideoTrack) {
      e.push(i);
      let r = this.localTrackMap.get(U.LocalVideoLowTrack);
      r && e.push([U.LocalVideoLowTrack, r]);
    } else e.push(i);
    return e;
  }
  createMuteMessage(t11) {
    return t11.map((e) => {
      var n;
      let i, [r, { track: o, ssrcs: s, id: a }] = e;
      switch (r) {
        case U.LocalAudioTrack:
          i = Ct.Audio;
          break;
        case U.LocalVideoTrack:
          i = W(n = o._hints).call(n, Gt.SCREEN_TRACK) ? Ct.Screen : Ct.High;
          break;
        case U.LocalVideoLowTrack:
          i = Ct.Low;
      }
      return { stream_type: i, ssrcs: s, mid: a };
    });
  }
  createUnmuteMessage(t11) {
    return t11.map((e) => {
      var n;
      let i, [r, { track: o, ssrcs: s, id: a }] = e;
      switch (r) {
        case U.LocalAudioTrack:
          i = Ct.Audio;
          break;
        case U.LocalVideoTrack:
          i = W(n = o._hints).call(n, Gt.SCREEN_TRACK) ? Ct.Screen : Ct.High;
          break;
        case U.LocalVideoLowTrack:
          i = Ct.Low;
      }
      return { stream_type: i, ssrcs: s, mid: a };
    });
  }
  filterTobeUnSubscribedTracks(t11, e) {
    let n = [], i = this.remoteUserMap.get(t11);
    if (!i) return n;
    if (e) {
      let r = i.get(e);
      if (!r) return n;
      n.push([t11, { kind: e, id: r }]);
    } else Array.from(i.entries()).forEach((r) => {
      let [o, s] = r;
      n.push([t11, { kind: o, id: s }]);
    });
    return n;
  }
  createUnsubscribeMessage(t11) {
    let e = [];
    return t11.forEach((n) => {
      let [i, { kind: r, id: o }] = n;
      switch (r) {
        case Q.VIDEO:
          return void (i._videoSSRC && e.push({ stream_type: Q.VIDEO, ssrcId: i._videoSSRC }));
        case Q.AUDIO:
          return void (i._audioSSRC && e.push({ stream_type: Q.AUDIO, ssrcId: i._audioSSRC }));
      }
    }), e;
  }
  withdrawRemoteTracks(t11) {
    t11.forEach((e) => {
      let [n, { kind: i }] = e, r = this.remoteUserMap.get(n);
      r && (r.delete(i), Array.from(r.entries()).length === 0 && this.remoteUserMap.delete(n));
    });
  }
  async updateBitrateLimit(t11) {
    let e = this.localTrackMap.get(U.LocalVideoTrack), n = this.localTrackMap.get(U.LocalVideoLowTrack);
    e && await e.track.setBitrateLimit(t11.uplink), n && t11.low_stream_uplink && await n.track.setBitrateLimit({ max_bitrate: t11.low_stream_uplink.bitrate, min_bitrate: t11.low_stream_uplink.bitrate || 0 });
  }
  isP2PDisconnected() {
    if (this.sendConnection && this.recvConnection) {
      let t11 = this.sendConnection.peerConnectionState, e = this.recvConnection.peerConnectionState;
      return t11 !== "connected" && e !== "connected";
    }
    return true;
  }
  async tryToUnmuteAudio(t11) {
    for (let e = 0; e < t11.length; e++) if (t11[e] instanceof Qt) {
      let n = this.filterTobeUnmutedTracks(t11[e]);
      if (n.length === 0) continue;
      let i = this.createUnmuteMessage(n);
      return void await kt(this, tt.RequestUnmuteLocal, i);
    }
  }
  bindStatsUploaderEvents() {
    this.statsUploader.requestStats = (t11) => this.getStats(t11), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()).filter((t11) => {
      let [, { ssrcs: e }] = t11;
      return !!e;
    }), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (t11) => {
      var e;
      return !((e = this.recvConnection) === null || e === void 0 || !e.getRemoteVideoIsReady(t11));
    }, this.statsUploader.requestUpload = (t11, e) => this.emit(tt.RequestUpload, t11, e), this.statsUploader.requestUploadStats = (t11) => this.emit(tt.RequestUploadStats, t11), this.statsUploader.requestAllTracks = () => this.getAllTracks();
  }
  unbindStatsUploaderEvents() {
    this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
  }
  async requestReconnect() {
    this.dtlsFailedCount += 1, await Me(hf(this.dtlsFailedCount, Ee)), this.emit(tt.RequestReconnect);
  }
  async reconnectP2P() {
  }
  canPublishLowStream() {
    return this.localTrackMap.has(U.LocalVideoTrack) || this.pendingLocalTracks.some((t11) => t11 instanceof Ft);
  }
  throwIfTrackTypeNotMatch(t11) {
    if (t11.filter((e) => e instanceof Ft).length > 1) throw new N(R.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
    if (t11.filter((e) => e instanceof Qt).length > 1 && (t11.some((e) => e instanceof Qt && e._bypassWebAudio) || !ft().webAudioMediaStreamDest)) throw new N(R.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
    for (let e of t11) {
      if (e instanceof Ft && this.pendingLocalTracks.some((n) => n instanceof Ft)) throw new N(R.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
      if (e instanceof Qt && this.pendingLocalTracks.some((n) => n instanceof Qt) && (!ft().webAudioMediaStreamDest || e._bypassWebAudio || this.pendingLocalTracks.some((n) => n instanceof Qt && n._bypassWebAudio))) throw new N(R.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
    }
  }
  getLowVideoTrack(t11, e) {
    let n = !v("DISABLE_DUAL_STREAM_USE_ENCODING") && ft().supportDualStreamEncoding, i = Yd(Yd({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), e), r;
    r = n ? t11._mediaStreamTrack.clone() : dm(t11, i);
    let o = Ut(8, "track-low-"), s = new Ft(r, Yd(Yd({}, n && { scaleResolutionDownBy: GE(i, t11) }), {}, { frameRate: i.framerate, bitrateMax: i.bitrate, bitrateMin: i.bitrate }), void 0, void 0, o);
    return s.on(Ko.TRANSCEIVER_UPDATED, (a) => {
      t11._updateRtpTransceiver(a, na.LOW_STREAM);
    }), s._hints.push(Gt.LOW_STREAM), t11.addListener(H.NEED_CLOSE, () => {
      s.close();
    }), s;
  }
  async globalLock() {
    return this.recvMutex.lock("From P2PChannel2.globalLock");
  }
  reportVideoFirstFrameDecoded(t11, e, n, i) {
    var r;
    let o = Array.from(xn(r = this.remoteUserMap).call(r)).find((s) => s._videoSSRC === t11);
    if (o) {
      i || this.store.subscribe(o.uid, "video", void 0, void 0, void 0, void 0, Date.now());
      let s = this.store.keyMetrics, a = s.subscribe.find((c) => c.userId === o.uid && c.type === "video");
      X.firstRemoteVideoDecode(this.store.sessionId, De.FIRST_VIDEO_DECODE, Jt.FIRST_VIDEO_DECODE, { peer: o._uintid, videowidth: e, videoheight: n, subscribeElapse: qe.measureFromSubscribeStart(this.store.clientId, t11), subscribeRequestid: t11, p2pid: this.store.p2pId, apEnd: s.requestAPEnd || 0, apStart: s.requestAPStart || 0, joinGwEnd: s.joinGatewayEnd || 0, joinGwStart: s.joinGatewayStart || 0, pcEnd: s.peerConnectionEnd || 0, pcStart: s.peerConnectionStart || 0, subscriberEnd: (a == null ? void 0 : a.subscribeEnd) || 0, subscriberStart: (a == null ? void 0 : a.subscribeStart) || 0, videoAddNotify: (a == null ? void 0 : a.streamAdded) || 0, state: i ? 1 : 0 });
    }
  }
  async remoteMediaSsrcChanged(t11, e, n) {
    if (!this.recvConnection) return false;
    let i = this.remoteUserMap.get(t11);
    if (!i) return false;
    let r = i.get(e);
    if (!r) return false;
    let o = await this.recvConnection.getRemoteSSRC(r);
    return o !== void 0 && o !== n;
  }
  isPreSubScribe(t11) {
    return false;
  }
  async publishDataChannel(t11) {
    throw new N(R.NOT_SUPPORTED);
  }
  async unpublishDataChannel(t11) {
    throw new N(R.NOT_SUPPORTED);
  }
  async subscribeDataChannel(t11, e) {
    throw new N(R.NOT_SUPPORTED);
  }
  async unsubscribeDataChannel(t11, e) {
    throw new N(R.NOT_SUPPORTED);
  }
  hasPendingRemoteDataChannel(t11, e) {
    throw new N(R.NOT_SUPPORTED);
  }
  setPendingRemoteDataChannel(t11, e) {
    throw new N(R.NOT_SUPPORTED);
  }
  async preConnect(t11) {
    throw new N(R.NOT_SUPPORTED);
  }
  getEstablishParams() {
    throw new N(R.NOT_SUPPORTED);
  }
  async reSubscribe(t11) {
    throw new N(R.NOT_SUPPORTED);
  }
  async updateVideoStreamParameter(t11, e) {
    throw new N(R.NOT_SUPPORTED);
  }
  unbindRtpTransceiver() {
    this.localTrackMap.size !== 0 && Array.from(this.localTrackMap.entries()).forEach((t11) => {
      let [e, { track: n }] = t11;
      e === U.LocalVideoLowTrack ? n._updateRtpTransceiver(void 0, na.LOW_STREAM) : n._updateRtpTransceiver(void 0);
    });
  }
}, q(Ht.prototype, "p2pConnect", [Tv], Object.getOwnPropertyDescriptor(Ht.prototype, "p2pConnect"), Ht.prototype), q(Ht.prototype, "unpublish", [Sv], Object.getOwnPropertyDescriptor(Ht.prototype, "unpublish"), Ht.prototype), q(Ht.prototype, "unpublishLowStream", [Rv], Object.getOwnPropertyDescriptor(Ht.prototype, "unpublishLowStream"), Ht.prototype), q(Ht.prototype, "subscribe", [Cv], Object.getOwnPropertyDescriptor(Ht.prototype, "subscribe"), Ht.prototype), q(Ht.prototype, "mockSubscribe", [Iv], Object.getOwnPropertyDescriptor(Ht.prototype, "mockSubscribe"), Ht.prototype), q(Ht.prototype, "unsubscribe", [vv], Object.getOwnPropertyDescriptor(Ht.prototype, "unsubscribe"), Ht.prototype), q(Ht.prototype, "muteRemote", [yv], Object.getOwnPropertyDescriptor(Ht.prototype, "muteRemote"), Ht.prototype), q(Ht.prototype, "unmuteRemote", [Av], Object.getOwnPropertyDescriptor(Ht.prototype, "unmuteRemote"), Ht.prototype), q(Ht.prototype, "hasRemoteMediaWithLock", [bv], Object.getOwnPropertyDescriptor(Ht.prototype, "hasRemoteMediaWithLock"), Ht.prototype), q(Ht.prototype, "disconnectForReconnect", [wv], Object.getOwnPropertyDescriptor(Ht.prototype, "disconnectForReconnect"), Ht.prototype), q(Ht.prototype, "remoteMediaSsrcChanged", [Ov], Object.getOwnPropertyDescriptor(Ht.prototype, "remoteMediaSsrcChanged"), Ht.prototype), Ht);
function Pi(t11) {
  return function(e, n, i) {
    let r = e[n];
    if (typeof r != "function") throw new Error("Cannot use mutex on object property.");
    return i.value = async function() {
      for (var o = arguments.length, s = new Array(o), a = 0; a < o; a++) s[a] = arguments[a];
      switch (t11) {
        case Ui.SEND_ONLY: {
          let c = await this.sendMutex.lock("From P2PChannel2.".concat(n));
          try {
            return await r.apply(this, s);
          } finally {
            c();
          }
        }
        case Ui.RECEIVE_ONLY: {
          let c = await this.recvMutex.lock("From P2PChannel2.".concat(n));
          try {
            return await r.apply(this, s);
          } finally {
            c();
          }
        }
        default: {
          let c = await this.sendMutex.lock("From P2PChannel2.".concat(n)), d = await this.recvMutex.lock("From P2PChannel2.".concat(n));
          try {
            return await r.apply(this, s);
          } finally {
            c(), d();
          }
        }
      }
    }, i;
  };
}
function Dv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function wo(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Dv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : Dv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var _u = class t8 {
  constructor(e) {
    T(this, "store", void 0), T(this, "onStatsException", void 0), T(this, "onUploadPublishDuration", void 0), T(this, "onStatsChanged", void 0), T(this, "localStats", /* @__PURE__ */ new Map()), T(this, "remoteStats", /* @__PURE__ */ new Map()), T(this, "updateStatsInterval", void 0), T(this, "trafficStats", void 0), T(this, "trafficStatsPeerList", []), T(this, "uplinkStats", void 0), T(this, "exceptionMonitor", void 0), T(this, "p2pChannel", void 0), T(this, "scalabilityMode", xE.L1T1), T(this, "updateStats", () => {
      this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));
    }), this.store = e, this.exceptionMonitor = new rm(), this.exceptionMonitor.on("exception", (n, i, r) => {
      this.onStatsException && this.onStatsException(n, i, r);
    });
  }
  startUpdateStats() {
    this.updateStatsInterval || (this.updateStatsInterval = window.setInterval(this.updateStats, 1e3));
  }
  stopUpdateStats() {
    this.updateStatsInterval && (window.clearInterval(this.updateStatsInterval), this.updateStatsInterval = void 0);
  }
  reset() {
    this.localStats = /* @__PURE__ */ new Map(), this.remoteStats = /* @__PURE__ */ new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;
  }
  getLocalAudioTrackStats() {
    return this.localStats.get(U.LocalAudioTrack) || wo({}, KE);
  }
  getLocalVideoTrackStats() {
    return this.localStats.get(U.LocalVideoTrack) || wo({}, YE);
  }
  getRemoteAudioTrackStats(e) {
    let n = (o, s) => {
      if (!this.trafficStats) return s;
      let a = this.trafficStats.peer_delay.find((c) => c.peer_uid === o);
      return a && (s.publishDuration = a.B_ppad + (Date.now() - this.trafficStats.timestamp)), s;
    }, i = {};
    if (e) {
      var r;
      let o = (r = this.remoteStats.get(e)) === null || r === void 0 ? void 0 : r.audioStats;
      o && (i[e] = n(e, o));
    } else Array.from(this.remoteStats.entries()).forEach((o) => {
      let [s, { audioStats: a }] = o;
      a && (i[s] = n(s, a));
    });
    return i;
  }
  getRemoteNetworkQualityStats(e) {
    let n = {};
    if (e) {
      var i;
      let r = (i = this.remoteStats.get(e)) === null || i === void 0 ? void 0 : i.networkStats;
      r && (n[e] = r);
    } else Array.from(this.remoteStats.entries()).forEach((r) => {
      let [o, { networkStats: s }] = r;
      s && (n[o] = s);
    });
    return n;
  }
  getRemoteVideoTrackStats(e) {
    let n = (o, s) => {
      if (!this.trafficStats) return s;
      let a = this.trafficStats.peer_delay.find((c) => c.peer_uid === o);
      return a && (s.publishDuration = a.B_ppvd + (Date.now() - this.trafficStats.timestamp)), s;
    }, i = {};
    if (e) {
      var r;
      let o = (r = this.remoteStats.get(e)) === null || r === void 0 ? void 0 : r.videoStats;
      o && (i[e] = n(e, o));
    } else Array.from(this.remoteStats.entries()).forEach((o) => {
      let [s, { videoStats: a }] = o;
      a && (i[s] = n(s, a));
    });
    return i;
  }
  getRTCStats() {
    let e = 0, n = 0, i = 0, r = 0, o = this.localStats.get(U.LocalAudioTrack);
    o && (e += o.sendBytes, n += o.sendBitrate);
    let s = this.localStats.get(U.LocalVideoTrack);
    s && (e += s.sendBytes, n += s.sendBitrate);
    let a = this.localStats.get(U.LocalVideoLowTrack);
    a && (e += a.sendBytes, n += a.sendBitrate), this.remoteStats.forEach((d) => {
      let { audioStats: l, videoStats: u } = d;
      l && (i += l.receiveBytes, r += l.receiveBitrate), u && (i += u.receiveBytes, r += u.receiveBitrate);
    });
    let c = 1;
    return this.trafficStats && (c += this.trafficStats.peer_delay.length), { Duration: 0, UserCount: c, SendBitrate: n, SendBytes: e, RecvBytes: i, RecvBitrate: r, OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0, RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0 };
  }
  addLocalStats(e) {
    this.localStats.set(e, void 0);
  }
  removeLocalStats(e) {
    e ? this.localStats.delete(e) : this.localStats.clear();
  }
  addRemoteStats(e) {
    this.remoteStats.set(e, {});
  }
  removeRemoteStats(e) {
    e ? this.remoteStats.delete(e) : this.remoteStats.clear();
  }
  addP2PChannel(e) {
    this.p2pChannel = e;
  }
  updateTrafficStats(e) {
    e.peer_delay = e.peer_delay.filter((n) => n.B_ppad !== void 0 || n.B_ppvd !== void 0), e.peer_delay.filter((n) => this.trafficStatsPeerList.indexOf(n.peer_uid) === -1).forEach((n) => {
      var i;
      let r = (i = this.p2pChannel) === null || i === void 0 ? void 0 : i.getRemoteMedia(n.peer_uid), o = r != null && r.videoSSRC ? qe.measureFromSubscribeStart(this.store.clientId, r.videoSSRC) : 0, s = r != null && r.audioSSRC ? qe.measureFromSubscribeStart(this.store.clientId, r.audioSSRC) : 0;
      n.B_ppad !== void 0 && n.B_ppvd !== void 0 && (this.onUploadPublishDuration && this.onUploadPublishDuration(n.peer_uid, n.B_ppad, n.B_ppvd, o > s ? o : s), this.trafficStatsPeerList.push(n.peer_uid));
    }), this.trafficStats = e;
  }
  updateUplinkStats(e) {
    this.uplinkStats && this.uplinkStats.B_fir !== e.B_fir && _.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e.B_fir)), this.uplinkStats = e;
  }
  static isRemoteVideoFreeze(e, n, i) {
    if (!e) return false;
    let r = !!i && n.framesDecodeFreezeTime > i.framesDecodeFreezeTime, o = !i || n.framesDecodeCount > i.framesDecodeCount;
    return r || !o;
  }
  static isRemoteAudioFreeze(e) {
    return !!e && e._isFreeze();
  }
  isLocalVideoFreeze(e) {
    return !(!e.inputFrame || !e.sentFrame) && e.inputFrame.frameRate > 5 && e.sentFrame.frameRate < 3;
  }
  updateLocalStats(e) {
    Array.from(this.localStats.entries()).forEach((n) => {
      let [i, r] = n;
      switch (i) {
        case U.LocalVideoTrack:
        case U.LocalVideoLowTrack: {
          let s = r, a = wo({}, YE), c = e.getStats(), d = e.getLocalMedia(i);
          if (c) {
            let l = c.videoSend.find((u) => u.ssrc === (d == null ? void 0 : d.ssrcs[0].ssrcId));
            if (l) {
              let u = e.getLocalVideoSize(), h = e.getEncoderConfig(U.LocalVideoTrack);
              l.codec !== "H264" && l.codec !== "H265" && l.codec !== "VP8" && l.codec !== "VP9" && l.codec !== "AV1X" && l.codec !== "AV1" || (a.codecType = l.codec), a.sendBytes = l.bytes, a.sendBitrate = s ? 8 * Math.max(0, a.sendBytes - s.sendBytes) : 0, l.inputFrame ? (a.captureFrameRate = l.inputFrame.frameRate, a.captureResolutionHeight = l.inputFrame.height, a.captureResolutionWidth = l.inputFrame.width) : u && (a.captureResolutionWidth = u.width, a.captureResolutionHeight = u.height), l.sentFrame ? (a.sendFrameRate = l.sentFrame.frameRate, a.sendResolutionHeight = l.sentFrame.height, a.sendResolutionWidth = l.sentFrame.width) : u && (a.sendResolutionWidth = u.width, a.sendResolutionHeight = u.height), l.avgEncodeMs && (a.encodeDelay = l.avgEncodeMs), h && h.bitrateMax && (a.targetSendBitrate = 1e3 * h.bitrateMax), a.sendPackets = l.packets, a.sendPacketsLost = l.packetsLost, a.sendJitterMs = l.jitterMs, a.sendRttMs = l.rttMs, a.totalDuration = s ? s.totalDuration + 1 : 1, a.totalFreezeTime = s ? s.totalFreezeTime : 0, this.isLocalVideoFreeze(l) && (a.totalFreezeTime += 1), l.scalabilityMode && this.scalabilityMode !== l.scalabilityMode && (_.debug("[".concat(this.store.clientId, "]: The scalabilityMode of the video sending stream is ").concat(l.scalabilityMode)), this.scalabilityMode = l.scalabilityMode);
            }
            this.trafficStats && (a.currentPacketLossRate = (this.trafficStats.B_pvlr4 || 0) / 100);
          }
          var o;
          this.localStats.set(i, a), ((s == null ? void 0 : s.sendResolutionWidth) !== a.sendResolutionWidth || (s == null ? void 0 : s.sendResolutionHeight) !== a.sendResolutionHeight) && ((o = this.onStatsChanged) === null || o === void 0 || o.call(this, "resolution", { width: a.sendResolutionWidth, height: a.sendResolutionHeight })), a && d && this.exceptionMonitor.setLocalVideoStats(this.store.uid, d.track, a);
          break;
        }
        case U.LocalAudioTrack: {
          let s = r, a = wo({}, KE), c = e.getStats(), d = e.getLocalMedia(i);
          if (c) {
            let l = c.audioSend.find((u) => u.ssrc === (d == null ? void 0 : d.ssrcs[0].ssrcId));
            if (l) {
              if (l.codec !== "opus" && l.codec !== "aac" && l.codec !== "PCMU" && l.codec !== "PCMA" && l.codec !== "G722" || (a.codecType = l.codec), l.inputLevel) a.sendVolumeLevel = Math.round(32767 * l.inputLevel);
              else {
                let u = e.getLocalAudioVolume();
                u && (a.sendVolumeLevel = Math.round(32767 * u));
              }
              a.sendBytes = l.bytes, a.sendPackets = l.packets, a.sendPacketsLost = l.packetsLost, a.sendJitterMs = l.jitterMs, a.sendRttMs = l.rttMs, a.sendBitrate = s ? 8 * Math.max(0, a.sendBytes - s.sendBytes) : 0;
            }
          }
          this.trafficStats && (a.currentPacketLossRate = (this.trafficStats.B_palr4 || 0) / 100), this.localStats.set(U.LocalAudioTrack, a), a && d && this.exceptionMonitor.setLocalAudioStats(this.store.uid, d.track, a);
          break;
        }
      }
    });
  }
  updateRemoteStats(e) {
    Array.from(this.remoteStats.entries()).forEach((n) => {
      var i, r;
      let [o, { videoStats: s, audioStats: a, videoPcStats: c }] = n, d = a, l = s, u = c, h = wo({}, GO), p = wo({}, WO), g = wo({}, kG), { audioTrack: E, videoTrack: f, audioSSRC: S, videoSSRC: C } = e.getRemoteMedia(o), A;
      A = e instanceof An ? e.getStats(true) : e.getStats();
      let b = (i = A) === null || i === void 0 ? void 0 : i.audioRecv.find((k) => k.ssrc === S), w = (r = A) === null || r === void 0 ? void 0 : r.videoRecv.find((k) => k.ssrc === C), D = this.trafficStats && this.trafficStats.peer_delay.find((k) => k.peer_uid === o);
      if (b && (b.codec !== "opus" && b.codec !== "aac" && b.codec !== "PCMU" && b.codec !== "PCMA" && b.codec !== "G722" || (h.codecType = b.codec), b.outputLevel ? h.receiveLevel = Math.round(32767 * b.outputLevel) : E && (h.receiveLevel = Math.round(32767 * E.getVolumeLevel())), h.receiveBytes = b.bytes, h.receivePackets = b.packets, h.receivePacketsLost = b.packetsLost, h.receivePacketsDiscarded = b.packetsDiscarded, h.packetLossRate = h.receivePacketsLost / (h.receivePackets + h.receivePacketsLost), h.receiveBitrate = d ? 8 * Math.max(0, h.receiveBytes - d.receiveBytes) : 0, h.totalDuration = d ? d.totalDuration + 1 : 1, h.totalFreezeTime = d ? d.totalFreezeTime : 0, h.freezeRate = h.totalFreezeTime / h.totalDuration, h.receiveDelay = b.jitterBufferMs, h.totalDuration > 10 && t8.isRemoteAudioFreeze(E) && (h.totalFreezeTime += 1)), w) {
        w.codec !== "H264" && w.codec !== "H265" && w.codec !== "VP8" && w.codec !== "VP9" && w.codec !== "AV1X" && w.codec !== "AV1" || (p.codecType = w.codec), p.receiveBytes = w.bytes, p.receiveBitrate = l ? 8 * Math.max(0, p.receiveBytes - l.receiveBytes) : 0, p.decodeFrameRate = w.decodeFrameRate < 0 ? 0 : w.decodeFrameRate, p.renderFrameRate = w.decodeFrameRate < 0 ? 0 : w.decodeFrameRate, w.outputFrame && (p.renderFrameRate = w.outputFrame.frameRate), w.receivedFrame ? (p.receiveFrameRate = w.receivedFrame.frameRate, p.receiveResolutionHeight = w.receivedFrame.height, p.receiveResolutionWidth = w.receivedFrame.width) : f && (p.receiveResolutionHeight = f._videoHeight || 0, p.receiveResolutionWidth = f._videoWidth || 0), w.framesRateFirefox !== void 0 && (p.receiveFrameRate = Math.round(w.framesRateFirefox)), p.receivePackets = w.packets, p.receivePacketsLost = w.packetsLost, p.packetLossRate = p.receivePacketsLost / (p.receivePackets + p.receivePacketsLost), p.totalDuration = l ? l.totalDuration + 1 : 1, p.totalFreezeTime = l ? l.totalFreezeTime : 0, p.receiveDelay = w.jitterBufferMs || 0;
        let k = !!C && e.getRemoteVideoIsReady(C);
        f && k && t8.isRemoteVideoFreeze(f, w, u) && (p.totalFreezeTime += 1), p.freezeRate = p.totalFreezeTime / p.totalDuration;
      }
      D && (h.end2EndDelay = D.B_ad, p.end2EndDelay = D.B_vd, h.transportDelay = D.B_ed, p.transportDelay = D.B_ed, h.currentPacketLossRate = D.B_ealr4 / 100, p.currentPacketLossRate = D.B_evlr4 / 100, g.uplinkNetworkQuality = D.B_punq ? D.B_punq : 0, g.downlinkNetworkQuality = D.B_pdnq ? D.B_pdnq : 0), this.remoteStats.set(o, { audioStats: h, videoStats: p, videoPcStats: w, networkStats: g }), E && this.exceptionMonitor.setRemoteAudioStats(E, h), f && this.exceptionMonitor.setRemoteVideoStats(f, p);
    });
  }
};
var Eu = class {
  constructor() {
    T(this, "destChannelMediaInfos", /* @__PURE__ */ new Map()), T(this, "srcChannelMediaInfo", void 0);
  }
  setSrcChannelInfo(e) {
    MR(e), this.srcChannelMediaInfo = e;
  }
  addDestChannelInfo(e) {
    MR(e), this.destChannelMediaInfos.set(e.channelName, e);
  }
  removeDestChannelInfo(e) {
    Xu(e), this.destChannelMediaInfos.delete(e);
  }
  getSrcChannelMediaInfo() {
    return this.srcChannelMediaInfo;
  }
  getDestChannelMediaInfo() {
    return this.destChannelMediaInfos;
  }
};
function Pv(t11) {
  if (!(t11 instanceof Eu)) return new O(R.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw();
  let e = t11.getSrcChannelMediaInfo(), n = t11.getDestChannelMediaInfo();
  if (!e) return new O(R.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw();
  if (n.size === 0) return new O(R.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw();
}
function kv(t11) {
  var e = {}, n = false;
  function i(r, o) {
    return n = true, { done: false, value: new Of(o = new om(function(s) {
      s(t11[r](o));
    }), 1) };
  }
  return e[Ds !== void 0 && zw || "@@iterator"] = function() {
    return this;
  }, e.next = function(r) {
    return n ? (n = false, r) : i("next", r);
  }, typeof t11.throw == "function" && (e.throw = function(r) {
    if (n) throw n = false, r;
    return i("throw", r);
  }), typeof t11.return == "function" && (e.return = function(r) {
    return n ? (n = false, r) : i("return", r);
  }), e;
}
var hW = ae(p0);
function Lv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Mv(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Lv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : Lv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var Pt;
function Uv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function qd(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Uv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : Uv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var Va = (Pt = class Xa extends Yl {
  get peerConnectionState() {
    return this.peerConnection.connectionState;
  }
  get iceConnectionState() {
    return this.peerConnection.iceConnectionState;
  }
  get currentLocalDescription() {
    return this.peerConnection.currentLocalDescription;
  }
  get currentRemoteDescription() {
    return this.peerConnection.currentRemoteDescription;
  }
  get localCodecs() {
    return [...new Set(this.localCapabilities && this.localCapabilities.videoCodecs.map((e) => e.rtpMap && e.rtpMap.encodingName.toLowerCase() || "").filter((e) => {
      var n;
      return W(n = Object.keys(Ju)).call(n, e);
    }))];
  }
  constructor(e, n) {
    super(e, n), T(this, "store", void 0), T(this, "peerConnection", void 0), T(this, "remoteSDP", void 0), T(this, "initialOffer", void 0), T(this, "statsFilter", void 0), T(this, "useRTX", false), T(this, "localCapabilities", void 0), T(this, "localCandidateCount", 0), T(this, "allCandidatesReceived", false), T(this, "establishPromise", void 0), T(this, "mutex", new ze("P2PConnection-mutex")), this.store = n, this.peerConnection = new RTCPeerConnection(Xa.resolvePCConfiguration(e), { optional: [{ googDscp: true }] }), this.statsFilter = Nf(this.peerConnection, v("STATS_UPDATE_INTERVAL"), void 0, $t() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
  }
  async establish() {
    try {
      let e = await this.peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
      if (!e.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
      let n = io(e.sdp), i = Lc(e.sdp, { filterRTX: !this.useRTX, filterVideoFec: v("FILTER_VIDEO_FEC"), filterAudioFec: v("FILTER_AUDIO_FEC"), filterAudioCodec: ["opus"] });
      return this.localCapabilities = i, this.initialOffer = e, qd(qd({}, n), {}, { rtpCapabilities: { send: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, recv: { audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: [] }, sendrecv: i }, offerSDP: e.sdp });
    } catch (e) {
      throw new N(R.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString());
    }
  }
  async updateRemoteConnect() {
  }
  async connect(e) {
    try {
      if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
      this.remoteSDP = new class {
        constructor(i) {
          T(this, "sessionDesc", void 0), T(this, "localCapabilities", void 0), T(this, "rtpCapabilities", void 0), T(this, "candidates", void 0), T(this, "iceParameters", void 0), T(this, "dtlsParameters", void 0), T(this, "setup", void 0), T(this, "currentMidIndex", void 0), T(this, "cname", void 0), i = le(i);
          let { iceParameters: r, dtlsParameters: o, candidates: s, rtpCapabilities: a, setup: c, localCapabilities: d, sdkCodec: l, cname: u } = i, h = Le.parse(`v=0
o=- 0 0 IN IP4 127.0.0.1
s=AgoraGateway
t=0 0
a=group:BUNDLE audio video
a=msid-semantic: WMS
a=ice-lite
m=audio 9 UDP/TLS/RTP/SAVPF 0
c=IN IP4 127.0.0.1
a=rtcp:9 IN IP4 0.0.0.0
a=sendrecv
a=rtcp-mux
a=rtcp-rsize
a=mid:audio
m=video 9 UDP/TLS/RTP/SAVPF 0
c=IN IP4 127.0.0.1
a=rtcp:9 IN IP4 0.0.0.0
a=sendrecv
a=rtcp-mux
a=rtcp-rsize
a=mid:video
`);
          this.rtpCapabilities = a, this.candidates = s, this.iceParameters = r, this.dtlsParameters = o, this.setup = c, this.localCapabilities = d, this.cname = u;
          for (let p = 0; p < h.mediaDescriptions.length; p++) {
            let g = h.mediaDescriptions[p];
            if (g.attributes.iceUfrag = r.iceUfrag, g.attributes.icePwd = r.icePwd, g.attributes.fingerprints = o.fingerprints, g.attributes.candidates = s, g.attributes.setup = c, g.media.mediaType === "video") {
              g.media.fmts = a.videoCodecs.map((f) => f.payloadType.toString(10));
              let E = a.videoCodecs.filter((f) => {
                var S, C;
                return (S = f.rtpMap) === null || S === void 0 ? void 0 : W(C = S.encodingName.toLowerCase()).call(C, l);
              });
              E.length === 0 && (E = a.videoCodecs), g.attributes.payloads = E, g.attributes.extmaps = a.videoExtensions;
            }
            g.media.mediaType === "audio" && (g.media.fmts = a.audioCodecs.map((E) => E.payloadType.toString(10)), g.attributes.payloads = a.audioCodecs, g.attributes.extmaps = a.audioExtensions), h.mediaDescriptions[p] = this.mungMediaDesc(g);
          }
          this.sessionDesc = h, this.currentMidIndex = h.mediaDescriptions.length - 1;
        }
        toString() {
          return Le.print(this.sessionDesc);
        }
        send(i, r, o) {
          let { ssrcs: s, ssrcGroups: a } = Lo(r, this.cname), c = this.sessionDesc.mediaDescriptions.find((u) => i === Q.VIDEO ? u.media.mediaType === "video" : u.media.mediaType === "audio"), d = s[0].attributes.label, l = s[0].attributes.mslabel;
          return c.attributes.ssrcs = c.attributes.ssrcs.concat(s), c.attributes.ssrcGroups = c.attributes.ssrcGroups.concat(a), { id: d, mslabel: l };
        }
        batchSend(i) {
          return i.map((r) => {
            let { kind: o, ssrcMsg: s } = r;
            return this.send(o, s, void 0);
          });
        }
        stopSending(i) {
          this.sessionDesc.mediaDescriptions.forEach((r) => {
            let o = [], s = [], a = [];
            r.attributes.ssrcs.forEach((c) => {
              W(i).call(i, c.attributes.label || "") ? a.push(c) : o.push(c);
            }), r.attributes.ssrcGroups.forEach((c) => {
              var d;
              W(d = a.map((l) => l.ssrcId)).call(d, c.ssrcIds[0]) || s.push(c);
            }), r.attributes.ssrcs = o, r.attributes.ssrcGroups = s;
          });
        }
        mute(i) {
          let r = this.sessionDesc.mediaDescriptions.find((o) => o.attributes.mid === i);
          if (!r) throw new Error("mediaDescription not found with ".concat(i, " in remote SDP when calling RemoteSDP.mute."));
          r.attributes.direction = "inactive";
        }
        unmute(i) {
          let r = this.sessionDesc.mediaDescriptions.find((o) => o.attributes.mid === i);
          if (!r) throw new Error("mediaDescription not found with ".concat(i, " in remote SDP when calling RemoteSDP.unmute."));
          r.attributes.direction = "sendonly";
        }
        receive(i, r, o) {
          i.forEach((s, a) => {
            let c = s._mediaStreamTrack, d = this.sessionDesc.mediaDescriptions.findIndex((u) => u.attributes.mid === c.kind), l = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[d], s);
            this.sessionDesc.mediaDescriptions[d] = l;
          });
        }
        stopReceiving(i) {
        }
        updateCandidates(i) {
          i === On.TCP ? this.candidates.forEach((r) => {
            this.candidates.findIndex((o) => o.transport === "tcp" && o.connectionAddress === r.connectionAddress && o.port === r.port) === -1 && this.candidates.push(Mv(Mv({}, r), {}, { foundation: "tcpcandidate", priority: Number(r.priority) - 1 + "", transport: "tcp", port: Number(r.port) + 90 + "" }));
          }) : this.candidates = this.candidates.filter((r) => r.transport !== "tcp");
          for (let r of this.sessionDesc.mediaDescriptions) r.attributes.candidates = this.candidates;
        }
        restartICE(i) {
          i = le(i), this.iceParameters = i, this.sessionDesc.mediaDescriptions.forEach((r) => {
            r.attributes.iceUfrag = i.iceUfrag, r.attributes.icePwd = i.icePwd;
          });
        }
        predictReceivingMids(i) {
          let r = [];
          for (let o = 0; o < i; o++) r.push((this.currentMidIndex + o + 1).toString(10));
          return r;
        }
        mungRecvMediaDsec(i, r) {
          let o = le(i);
          return ra(o, r), vf(o, r), o;
        }
        updateRecvMedia(i, r) {
          let o = this.sessionDesc.mediaDescriptions.findIndex((s) => s.attributes.mid === i);
          if (o !== -1) {
            let s = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[o], r);
            this.sessionDesc.mediaDescriptions[o] = s;
          }
        }
        bumpMid(i) {
          this.currentMidIndex += i;
        }
        updateTrackLabel(i, r, o) {
          let s = this.sessionDesc.mediaDescriptions.find((c) => i === Q.VIDEO ? c.attributes.mid === "video" : c.attributes.mid === "audio");
          if (s) {
            let c = s.attributes.ssrcs.find((d) => d.attributes.label === r);
            var a;
            c && (c.attributes.label = o, (a = c.attributes.msid) === null || a === void 0 || a.replace(r, o));
          }
        }
        mungMediaDesc(i) {
          let r = le(i);
          return If(r), function(o) {
            let s = o.attributes.extmaps.find((a) => a.extensionName === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01");
            s && o.attributes.extmaps.splice(o.attributes.extmaps.indexOf(s), 1), o.attributes.payloads.forEach((a) => {
              let c = a.rtcpFeedbacks.findIndex((d) => d.type === "transport-cc");
              c !== -1 && a.rtcpFeedbacks.splice(c, 1);
            });
          }(r), r;
        }
        getSSRC(i) {
          for (let r of this.sessionDesc.mediaDescriptions) for (let o of r.attributes.ssrcs) if (o.attributes.label === i) return [o];
        }
      }(qd(qd({}, e), {}, { rtpCapabilities: e.rtpCapabilities.send, localCapabilities: this.localCapabilities, sdkCodec: this.store.codec }));
      let n = this.remoteSDP.toString();
      await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n });
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(n.toString()));
    }
  }
  async updateRemoteRTPCapabilities(e, n) {
    throw new N(R.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
  }
  getPreMedia(e) {
  }
  send(e, n) {
    var i = this;
    return Bi(function* () {
      let r = yield Tt(i.mutex.lock());
      try {
        if (!i.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
        let o = e.map((h) => i.peerConnection.addTrack(h._mediaStreamTrack)), s = yield Tt(i.peerConnection.createOffer()), a = Le.parse(s.sdp), c = e.map((h) => {
          let p = h._mediaStreamTrack, g = a.mediaDescriptions.find((E) => E.attributes.mid === p.kind);
          if (!g) throw new Error("Cannot extract ssrc from mediaDescription.");
          return function(E, f, S) {
            let C = E.attributes.ssrcs.filter((b) => b.attributes.label === f), A = E.attributes.ssrcGroups;
            if (C.length === 0) throw new Error("Cannot extract ssrc from plan-b SDP.");
            if (A && C.length > 1) {
              let b = A.find((w) => w.ssrcIds.indexOf(C[0].ssrcId) !== -1);
              return b ? [{ ssrcId: b.ssrcIds[0], rtx: S ? b.ssrcIds[1] : void 0 }] : [{ ssrcId: C[0].ssrcId }];
            }
            return [{ ssrcId: C[0].ssrcId }];
          }(g, p.id, i.useRTX);
        }), d;
        try {
          d = yield c;
        } catch (h) {
          throw o.forEach((p) => {
            je() && p.replaceTrack(null), i.peerConnection.removeTrack(p);
          }), h;
        }
        let l = i.mungSendOfferSDP(s.sdp, e);
        i.remoteSDP.receive(e, n, d);
        let u = i.remoteSDP.toString();
        return yield Tt(i.peerConnection.setLocalDescription({ type: "offer", sdp: l })), yield Tt(i.applySendEncodings(o, e)), yield Tt(i.peerConnection.setRemoteDescription({ type: "answer", sdp: u })), e.map((h, p) => {
          let g = h._mediaStreamTrack.id;
          return { localSSRC: c[p], id: g };
        });
      } catch (o) {
        throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(o.toString()));
      } finally {
        r();
      }
    })();
  }
  async stopSending(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
      let n = this.peerConnection.getSenders().filter((o) => {
        var s;
        return e.indexOf(((s = o.track) === null || s === void 0 ? void 0 : s.id) || "") !== -1;
      });
      if (n.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
      n.map((o) => {
        je() && o.replaceTrack(null), this.peerConnection.removeTrack(o);
      });
      let i = await this.peerConnection.createOffer();
      await this.peerConnection.setLocalDescription(i), this.remoteSDP.stopReceiving(e);
      let r = this.remoteSDP.toString();
      await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r });
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(n.toString()));
    }
  }
  async receive(e, n, i, r) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e, " before remoteSDP created."));
      let { id: o, mslabel: s } = this.remoteSDP.send(e, n, r), a = new j((l, u) => {
        let h = setTimeout(() => {
          u(new Error("Cannot receive track, id: ".concat(o)));
        }, 1e4), p = (g) => {
          let E = mt();
          if ((E.name === "Safari" && Number(E.version) === 11 || ln()) && g.track.id !== o && g.streams[0].id === s) {
            var f;
            let S = g.streams[0].getTracks()[0];
            return (f = this.remoteSDP) === null || f === void 0 || f.updateTrackLabel(e, o, g.track.id), this.peerConnection.removeEventListener("track", p), clearTimeout(h), void l(S);
          }
          if (g.track.id === o) return this.peerConnection.removeEventListener("track", p), clearTimeout(h), void l(g.track);
        };
        this.peerConnection.addEventListener("track", p);
      }), c = this.remoteSDP.toString();
      await this.peerConnection.setRemoteDescription({ type: "offer", sdp: c });
      let d = await this.peerConnection.createAnswer();
      return await this.peerConnection.setLocalDescription(d), { track: await a, id: o };
    } catch (o) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(o.toString()));
    }
  }
  async stopReceiving(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
      this.remoteSDP.stopSending(e);
      let n = this.remoteSDP.toString();
      await this.peerConnection.setRemoteDescription({ type: "offer", sdp: n });
      let i = await this.peerConnection.createAnswer();
      await this.peerConnection.setLocalDescription(i);
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(n.toString()));
    }
  }
  async muteRemote(e) {
  }
  async unmuteRemote(e) {
  }
  async muteLocal(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
      let n = this.peerConnection.getSenders().filter((i) => {
        var r;
        return e.indexOf(((r = i.track) === null || r === void 0 ? void 0 : r.id) || "") !== -1;
      });
      if (n.length !== e.length) throw new Error("sender' length doesn't match mids' length.");
      n.map((i) => {
        if (je() && i.track) i.track.enabled = false;
        else {
          let r = i.getParameters();
          r.encodings.forEach((o) => o.active = false), i.setParameters(r);
        }
      });
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(n.toString()));
    }
  }
  async unmuteLocal(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
      let n = this.peerConnection.getSenders().filter((o) => {
        var s;
        return e.indexOf(((s = o.track) === null || s === void 0 ? void 0 : s.id) || "") !== -1;
      });
      if (n.length !== e.length) throw new Error("Senders' length doesn't match mids' length.");
      n.map(async (o) => {
        if (je() && o.track) o.track.enabled = true;
        else {
          let s = o.getParameters();
          s.encodings.forEach((a) => a.active = true), await o.setParameters(s);
        }
      });
      let i = await this.peerConnection.createOffer();
      await this.peerConnection.setLocalDescription(i);
      let r = this.remoteSDP.toString();
      await this.peerConnection.setRemoteDescription({ type: "answer", sdp: r });
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(n.toString()));
    }
  }
  restartICE(e) {
    var n = this;
    return Bi(function* () {
      let i = yield Tt(n.mutex.lock("From P2PConnection.restartICE"));
      try {
        if (!n.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
        if (ft().supportPCSetConfiguration) {
          let c = n.peerConnection.getConfiguration(), d = e === On.RELAY ? "relay" : "all";
          c.iceTransportPolicy !== d && (_.debug("[".concat(n.store.clientId, "] restartICE change iceTransportPolicy from [").concat(c.iceTransportPolicy, "] to [").concat(d, "]")), c.iceTransportPolicy = d, n.peerConnection.setConfiguration(c));
        } else if (e === On.RELAY) return;
        e !== On.RELAY && n.remoteSDP.updateCandidates(e);
        let r = yield Tt(n.peerConnection.createOffer({ iceRestart: true }));
        if (!r.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
        let o = io(r.sdp), { remoteIceParameters: s } = yield o.iceParameters;
        n.remoteSDP.restartICE(s);
        let a = n.remoteSDP.toString();
        yield Tt(n.peerConnection.setLocalDescription(r)), yield Tt(n.peerConnection.setRemoteDescription({ type: "answer", sdp: a }));
      } catch (r) {
        _.warning("[".concat(n.store.clientId, "] restart ICE failed, abort operation"), r);
      } finally {
        i();
      }
    })();
  }
  close() {
    var e;
    this.peerConnection.close(), (e = this.onConnectionStateChange) === null || e === void 0 || e.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();
  }
  getStats() {
    return this.statsFilter.getStats();
  }
  getRemoteVideoIsReady(e) {
    return this.statsFilter.getVideoIsReady(e);
  }
  async updateEncoderConfig(e, n) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
      let i = await this.peerConnection.createOffer(), r = this.mungSendOfferSDP(i.sdp, [n]);
      this.remoteSDP.updateRecvMedia(n._mediaStreamTrack.kind, n);
      let o = this.remoteSDP.toString();
      await this.peerConnection.setLocalDescription({ type: "offer", sdp: r }), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o });
    } catch (i) {
      throw new N(R.EXCHANGE_SDP_FAILED, i.toString());
    }
  }
  async updateSendParameters(e, n) {
    let i = this.peerConnection.getSenders().filter((r) => {
      var o;
      return ((o = r.track) === null || o === void 0 ? void 0 : o.id) === e;
    });
    i.length === 1 && await this.applySendEncodings(i, [n]);
  }
  setStatsRemoteVideoIsReady(e, n) {
    this.statsFilter.setVideoIsReady2(e, n);
  }
  async replaceTrack(e, n) {
    let i = this.peerConnection.getSenders().find((r) => {
      var o;
      return ((o = r.track) === null || o === void 0 ? void 0 : o.id) === n;
    });
    i && await i.replaceTrack(e._mediaStreamTrack);
  }
  createDataChannels(e, n) {
    throw new N(R.NOT_SUPPORTED, "Planb mode does not support createDataChannels.");
  }
  stopDataChannels(e) {
    throw new N(R.NOT_SUPPORTED, "Planb mode does not support stopDataChannels.");
  }
  bindPCEvents() {
    this.peerConnection.oniceconnectionstatechange = () => {
      var e;
      (e = this.onICEConnectionStateChange) === null || e === void 0 || e.call(this, this.peerConnection.iceConnectionState);
    }, this.peerConnection.onconnectionstatechange = () => {
      var e;
      (e = this.onConnectionStateChange) === null || e === void 0 || e.call(this, this.peerConnection.connectionState);
    }, this.peerConnection.onicecandidate = (e) => {
      e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, _.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
    }, setTimeout(() => {
      this.allCandidatesReceived || (this.allCandidatesReceived = true, _.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
    }, v("CANDIDATE_TIMEOUT"));
  }
  unbindPCEvents() {
    this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
  }
  static resolvePCConfiguration(e) {
    let n = { iceServers: [], sdpSemantics: "plan-b" };
    return e.iceServers ? n.iceServers = e.iceServers : e.turnServer && e.turnServer.mode !== "off" && (Yu(e.turnServer.servers) ? n.iceServers = e.turnServer.servers : (n.iceServers && n.iceServers.push(...Xa.turnServerConfigToIceServers(e.turnServer.servers)), v("USE_TURN_SERVER_OF_GATEWAY") && n.iceServers && e.turnServer.serversFromGateway && n.iceServers.push(...Xa.turnServerConfigToIceServers(e.turnServer.serversFromGateway)), e.turnServer.servers.concat(e.turnServer.serversFromGateway || []).forEach((i) => {
      i.forceturn && (n.iceTransportPolicy = "relay");
    }))), n;
  }
  static turnServerConfigToIceServers(e) {
    let n = [];
    return e.forEach((i) => {
      i.security ? i.tcpport && n.push({ username: i.username, credential: i.password, credentialType: "password", urls: "turns:".concat(i.turnServerURL, ":").concat(i.tcpport, "?transport=tcp") }) : (i.udpport && n.push({ username: i.username, credential: i.password, credentialType: "password", urls: "turn:".concat(i.turnServerURL, ":").concat(i.udpport, "?transport=udp") }), i.tcpport && n.push({ username: i.username, credential: i.password, credentialType: "password", urls: "turn:".concat(i.turnServerURL, ":").concat(i.tcpport, "?transport=tcp") }));
    }), n;
  }
  async updateRtpSenderEncodings(e, n) {
    var i;
    if (n || (n = this.peerConnection.getSenders().find((d) => {
      var l;
      return ((l = d.track) === null || l === void 0 ? void 0 : l.id) === e._mediaStreamTrack.id;
    })), !n) return _.warn("[".concat(e.getTrackId(), "] no rtpSender found}"));
    if (!ft().supportSetRtpSenderParameters) return _.warn("Browser not support set rtp-sender parameters");
    let r = {}, o = {};
    if (e instanceof Ft) switch (e._optimizationMode) {
      case "motion":
        r.degradationPreference = "maintain-framerate";
        break;
      case "detail":
        r.degradationPreference = "maintain-resolution";
        break;
      default:
        r.degradationPreference = "balanced";
    }
    if (v("DSCP_TYPE") && ho()) {
      var s;
      let d = v("DSCP_TYPE");
      W(s = ["very-low", "low", "medium", "high"]).call(s, d) && (o.networkPriority = d);
    }
    let a = n.getParameters(), c = (i = a.encodings) === null || i === void 0 ? void 0 : i[0];
    c && Object.assign(c, o), Object.assign(a, r), _.debug("[".concat(e.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(a.encodings))), await n.setParameters(a);
  }
  async applySendEncodings(e, n) {
    try {
      if (!ft().supportSetRtpSenderParameters || e.length !== n.length) return;
      for (let i = 0; i < e.length; i++) {
        let r = e[i], o = n[i];
        r && o && await this.updateRtpSenderEncodings(o, r);
      }
    } catch {
      _.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
    }
  }
  mungSendOfferSDP(e, n) {
    let i = Le.parse(e);
    return n.forEach((r, o) => {
      let s = r._mediaStreamTrack, a = i.mediaDescriptions.find((c) => c.attributes.mid === s.kind);
      a && ra(a, r);
    }), Le.print(i);
  }
  bindStatsEvents() {
    this.statsFilter.onFirstAudioReceived = (e) => {
      var n;
      (n = this.onFirstAudioReceived) === null || n === void 0 || n.call(this, e);
    }, this.statsFilter.onFirstVideoReceived = (e) => {
      var n;
      (n = this.onFirstVideoReceived) === null || n === void 0 || n.call(this, e);
    }, this.statsFilter.onFirstAudioDecoded = (e) => {
      var n;
      (n = this.onFirstAudioDecoded) === null || n === void 0 || n.call(this, e);
    }, this.statsFilter.onFirstVideoDecoded = (e, n, i) => {
      var r;
      (r = this.onFirstVideoDecoded) === null || r === void 0 || r.call(this, e, n, i);
    }, this.statsFilter.onSelectedLocalCandidateChanged = (e, n) => {
      var i;
      (i = this.onSelectedLocalCandidateChanged) === null || i === void 0 || i.call(this, e, n);
    }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, n) => {
      var i;
      (i = this.onSelectedRemoteCandidateChanged) === null || i === void 0 || i.call(this, e, n);
    };
  }
  unbindStatsEvents() {
    this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;
  }
  async batchReceive(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
      let n = this.remoteSDP.batchSend(e).map((o, s) => {
        let { id: a, mslabel: c } = o, { kind: d } = e[s];
        return new j((l, u) => {
          let h = setTimeout(() => {
            u(new Error("Cannot receive track, id: ".concat(a)));
          }, 1e4), p = (g) => {
            let E = mt();
            if (E.name === "Safari" && Number(E.version) === 11 && g.track.id !== a && g.streams[0].id === c) {
              var f;
              let S = g.streams[0].getTracks()[0];
              return (f = this.remoteSDP) === null || f === void 0 || f.updateTrackLabel(d, a, g.track.id), this.peerConnection.removeEventListener("track", p), clearTimeout(h), void l({ track: S, id: a });
            }
            if (g.track.id === a) return this.peerConnection.removeEventListener("track", p), clearTimeout(h), void l({ track: g.track, id: a });
          };
          this.peerConnection.addEventListener("track", p);
        });
      }), i = this.remoteSDP.toString();
      await this.peerConnection.setRemoteDescription({ type: "offer", sdp: i });
      let r = await this.peerConnection.createAnswer();
      return await this.peerConnection.setLocalDescription(r), await j.all(n);
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(n.toString()));
    }
  }
  async getRemoteSSRC(e) {
    if (!this.remoteSDP) return;
    let n = this.remoteSDP.getSSRC(e);
    return n == null ? void 0 : n[0].ssrcId;
  }
  setConfiguration(e) {
    if (ft().supportPCSetConfiguration) {
      let n = Xa.resolvePCConfiguration(e);
      this.peerConnection.setConfiguration(n);
    }
  }
}, q(Pt.prototype, "connect", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "connect"), Pt.prototype), q(Pt.prototype, "stopSending", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "stopSending"), Pt.prototype), q(Pt.prototype, "receive", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "receive"), Pt.prototype), q(Pt.prototype, "stopReceiving", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "stopReceiving"), Pt.prototype), q(Pt.prototype, "muteRemote", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "muteRemote"), Pt.prototype), q(Pt.prototype, "unmuteRemote", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "unmuteRemote"), Pt.prototype), q(Pt.prototype, "muteLocal", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "muteLocal"), Pt.prototype), q(Pt.prototype, "unmuteLocal", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "unmuteLocal"), Pt.prototype), q(Pt.prototype, "close", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "close"), Pt.prototype), q(Pt.prototype, "updateEncoderConfig", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "updateEncoderConfig"), Pt.prototype), q(Pt.prototype, "updateSendParameters", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "updateSendParameters"), Pt.prototype), q(Pt.prototype, "replaceTrack", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "replaceTrack"), Pt.prototype), q(Pt.prototype, "getRemoteSSRC", [Jn], Object.getOwnPropertyDescriptor(Pt.prototype, "getRemoteSSRC"), Pt.prototype), Pt);
function Jn(t11, e, n) {
  let i = t11[e];
  if (typeof i != "function") throw new Error("Cannot use mutex on object property.");
  return n.value = async function() {
    let r = this.mutex, o = await r.lock("Locking from P2PConnection.".concat(e));
    try {
      for (var s = arguments.length, a = new Array(s), c = 0; c < s; c++) a[c] = arguments[c];
      return await i.apply(this, a);
    } finally {
      o();
    }
  }, n;
}
function xv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Wr(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? xv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : xv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var Fa = "9";
var Vv = 4e4;
var um = class {
  get localCapabilities() {
    return le(this._localCapabilities);
  }
  get rtpCapabilities() {
    return le(this._rtpCapabilities);
  }
  get candidates() {
    return le(this._candidates);
  }
  get iceParameters() {
    return le(this._iceParameters);
  }
  get dtlsParameters() {
    return le(this._dtlsParameters);
  }
  constructor(e) {
    T(this, "sessionDesc", void 0), T(this, "_localCapabilities", void 0), T(this, "_rtpCapabilities", void 0), T(this, "_candidates", void 0), T(this, "_iceParameters", void 0), T(this, "_dtlsParameters", void 0), T(this, "setup", void 0), T(this, "currentMidIndex", void 0), T(this, "cname", void 0), T(this, "firefoxSsrcMidMap", /* @__PURE__ */ new Map()), e = le(e);
    let { iceParameters: n, dtlsParameters: i, candidates: r, rtpCapabilities: o, setup: s, localCapabilities: a, cname: c } = e;
    this._rtpCapabilities = o, this._candidates = r, this._iceParameters = n, this._dtlsParameters = i, this._localCapabilities = a, this.setup = s, this.cname = c, this.sessionDesc = this.updateRemoteRTPCapabilities(o), this.currentMidIndex = this.sessionDesc.mediaDescriptions.length - 1;
  }
  preloadRemoteMedia(e) {
    let n = this.candidates, i = this.dtlsParameters, r = this.iceParameters, o = this.rtpCapabilities.send, s = this.sessionDesc.mediaDescriptions.length - 1;
    for (let a = 1; a < e; a++) {
      let c = 2 * a + 2e4, d = 2 * a + Vv, { ssrcs: l, ssrcGroups: u } = Lo([{ ssrcId: c }], this.cname), { ssrcs: h, ssrcGroups: p } = Lo([{ ssrcId: d, rtx: v("USE_SUB_RTX") ? d + 1 : void 0 }], this.cname);
      this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "video", port: Fa, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: o.videoCodecs.map((g) => g.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: r.iceUfrag, icePwd: r.icePwd, unrecognized: [], candidates: n, extmaps: o.videoExtensions, fingerprints: i.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: h, ssrcGroups: p, rtcpFeedbackWildcards: [], payloads: o.videoCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(++s) } }), this.sessionDesc.mediaDescriptions.push({ media: { mediaType: "audio", port: Fa, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: o.audioCodecs.map((g) => g.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: r.iceUfrag, icePwd: r.icePwd, unrecognized: [], candidates: n, extmaps: o.audioExtensions, fingerprints: i.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: l, ssrcGroups: u, rtcpFeedbackWildcards: [], payloads: o.audioCodecs, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: "sendonly", rtcpMux: true, rtcpRsize: true, mid: "".concat(++s) } }), this.currentMidIndex += 2;
    }
    this.updateBundleMids();
  }
  toString() {
    return Le.print(this.sessionDesc);
  }
  send(e, n, i, r) {
    let { ssrcs: o, ssrcGroups: s } = Lo(n, this.cname, v("SYNC_GROUP") ? i : void 0), a = this.findPreloadMediaDesc(o);
    if (a) {
      if ($t() && this.firefoxSsrcMidMap.set(o[0].ssrcId, a.attributes.mid), r && (r.twcc || r.remb)) {
        let c = this.sessionDesc.mediaDescriptions.indexOf(a);
        return this.sessionDesc.mediaDescriptions[c] = this.mungSendMediaDesc(a, r), { mid: a.attributes.mid, needExchangeSDP: true };
      }
      return { mid: a.attributes.mid, needExchangeSDP: false };
    }
    {
      let c = this.findAvailableMediaIndex(e, o), d;
      return c === -1 || c === 1 && (je() || function() {
        let l = mt();
        return !(l.name !== It.CHROME || !l.osVersion) && Number(l.version) <= 90;
      }()) || c === 0 && v("USE_SUB_RTX") || hR() ? (d = this.createOrRecycleSendMedia(e, o, s, "sendonly", r), this.updateBundleMids()) : (d = le(this.sessionDesc.mediaDescriptions[c]), d.attributes.direction = "sendonly", d.attributes.ssrcs = o, d.attributes.ssrcGroups = s, this.sessionDesc.mediaDescriptions[c] = this.mungSendMediaDesc(d, r)), $t() && this.firefoxSsrcMidMap.set(o[0].ssrcId, d.attributes.mid), { mid: d.attributes.mid, needExchangeSDP: true };
    }
  }
  sendDataChannel() {
    let { mediaDesc: e, needExchangeSDP: n } = this.createOrRecycleDataChannel();
    return this.updateBundleMids(), { mid: e.attributes.mid, needExchangeSDP: n };
  }
  batchSend(e) {
    let n = e.map((o) => {
      let { kind: s, ssrcMsg: a, mslabel: c } = o;
      return this.send(s, a, c);
    }), i = [], r = false;
    return n.forEach((o) => {
      let { mid: s, needExchangeSDP: a } = o;
      a && (r = true), i.push(s);
    }), { mids: i, needExchangeSDP: r };
  }
  stopSending(e) {
    let n = this.sessionDesc.mediaDescriptions.filter((i) => i.attributes.mid && e.indexOf(i.attributes.mid) !== -1);
    if (n.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
    n.forEach((i) => {
      i.attributes.mid === "0" || $t() || hR() ? i.attributes.ssrcs = [] : (i.attributes.ssrcs = [], i.attributes.direction = "inactive", i.media.port = "0");
    }), this.updateBundleMids();
  }
  mute(e) {
    let n = this.sessionDesc.mediaDescriptions.find((i) => i.attributes.mid === e);
    if (!n) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.mute."));
    n.attributes.direction = "inactive";
  }
  unmute(e) {
    let n = this.sessionDesc.mediaDescriptions.find((i) => i.attributes.mid === e);
    if (!n) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.unmute."));
    n.attributes.direction = "sendonly";
  }
  muteRemote(e) {
    let n = this.sessionDesc.mediaDescriptions.filter((i) => W(e).call(e, i.attributes.mid || ""));
    if (n.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
    n.forEach((i) => {
      i.attributes.direction = "inactive";
    });
  }
  unmuteRemote(e) {
    let n = this.sessionDesc.mediaDescriptions.filter((i) => W(e).call(e, i.attributes.mid || ""));
    if (n.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
    n.forEach((i) => {
      i.attributes.direction = "recvonly";
    });
  }
  receive(e, n, i, r) {
    e.forEach((o, s) => {
      this.createOrRecycleRecvMedia(o, [], "recvonly", n, i, r[s]);
    }), this.updateBundleMids();
  }
  stopReceiving(e) {
    let n = this.sessionDesc.mediaDescriptions.filter((i) => e.indexOf(i.attributes.mid) !== -1);
    if (n.length !== e.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
    n.forEach((i) => {
      i.media.port = "0", i.attributes.direction = "inactive";
    }), this.updateBundleMids();
  }
  updateRemoteRTPCapabilities(e) {
    let n = this.sessionDesc || Le.parse(`v=0
o=- 0 0 IN IP4 127.0.0.1
s=AgoraGateway
t=0 0
a=group:BUNDLE 0 1
a=msid-semantic: WMS
a=ice-lite
m=video 9 UDP/TLS/RTP/SAVPF 0
c=IN IP4 127.0.0.1
a=rtcp:9 IN IP4 0.0.0.0
a=sendonly
a=rtcp-mux
a=rtcp-rsize
a=mid:0
m=audio 9 UDP/TLS/RTP/SAVPF 0
c=IN IP4 127.0.0.1
a=rtcp:9 IN IP4 0.0.0.0
a=sendonly
a=rtcp-mux
a=rtcp-rsize
a=mid:1
`);
    this._rtpCapabilities = e;
    let i = this.rtpCapabilities.send, r = this.localCapabilities.send;
    for (let o of n.mediaDescriptions) {
      if (o.attributes.iceUfrag = this._iceParameters.iceUfrag, o.attributes.icePwd = this._iceParameters.icePwd, o.attributes.fingerprints = this._dtlsParameters.fingerprints, o.attributes.candidates = this._candidates, o.attributes.setup = this.setup, o.media.mediaType === "application" && (o.attributes.sctpPort = "5000"), o.media.mediaType === "video") {
        if (i.videoCodecs.length === 0) {
          let s = r.videoCodecs.filter((a) => {
            var c, d;
            return (c = a.rtpMap) === null || c === void 0 ? void 0 : W(d = c.encodingName.toLowerCase()).call(d, "vp8");
          }) || [r.videoCodecs[0]];
          o.media.fmts = s.map((a) => a.payloadType.toString(10)), o.attributes.payloads = s, o.attributes.extmaps = [];
        } else if (o.media.fmts = i.videoCodecs.map((s) => s.payloadType.toString(10)), o.attributes.payloads = i.videoCodecs, o.attributes.extmaps = i.videoExtensions, v("PRELOAD_MEDIA_COUNT") > 0) {
          let { ssrcs: s, ssrcGroups: a } = Lo([{ ssrcId: Vv, rtx: v("USE_SUB_RTX") ? 40001 : void 0 }], this.cname);
          o.attributes.ssrcs = s, o.attributes.ssrcGroups = a;
        }
      }
      if (o.media.mediaType === "audio") {
        if (i.audioCodecs.length === 0) {
          let s = r.audioCodecs.filter((a) => {
            var c, d;
            return (c = a.rtpMap) === null || c === void 0 ? void 0 : W(d = c.encodingName.toLowerCase()).call(d, "opus");
          }) || [r.audioCodecs[0]];
          o.media.fmts = s.map((a) => a.payloadType.toString(10)), o.attributes.payloads = s, o.attributes.extmaps = [];
        } else if (o.media.fmts = i.audioCodecs.map((s) => s.payloadType.toString(10)), o.attributes.payloads = i.audioCodecs, o.attributes.extmaps = i.audioExtensions, oa(o), v("PRELOAD_MEDIA_COUNT") > 0) {
          let { ssrcs: s, ssrcGroups: a } = Lo([{ ssrcId: 2e4 }], this.cname);
          o.attributes.ssrcs = s, o.attributes.ssrcGroups = a;
        }
      }
    }
    return this.sessionDesc = n, this.currentMidIndex = n.mediaDescriptions.length - 1, this.sessionDesc;
  }
  updateCandidates(e) {
    let n = this._candidates.filter((i) => i.transport === "udp");
    if (e === On.TCP) {
      if (n.length === 0) return;
      if (v("TCP_CANDIDATE_ONLY")) {
        let i = this._candidates.filter((r) => r.transport === "tcp");
        n.forEach((r) => {
          i.findIndex((o) => o.connectionAddress === r.connectionAddress) === -1 && i.push(Wr(Wr({}, r), {}, { foundation: "tcpcandidate", priority: Number(r.priority) - 1 + "", transport: "tcp", port: Number(r.port) + 90 + "" }));
        }), this._candidates = i;
      } else {
        let i = [];
        n.forEach((r) => {
          i.push(Wr(Wr({}, r), {}, { foundation: "tcpcandidate", priority: Number(r.priority) - 1 + "", transport: "tcp", port: Number(r.port) + 90 + "" }));
        }), this._candidates = [...n, ...i];
      }
    } else if (e === On.RELAY) {
      if (n.length !== 0) return;
      {
        let i = this._candidates.filter((r) => r.transport === "tcp");
        i.forEach((r) => {
          n.push(Wr(Wr({}, r), {}, { foundation: "udpcandidate", priority: Number(r.priority) + 1 + "", transport: "udp", port: Number(r.port) - 90 + "" }));
        }), this._candidates = [...n, ...i];
      }
    } else n.length === 0 ? (this._candidates.filter((i) => i.transport === "tcp").forEach((i) => {
      n.push(Wr(Wr({}, i), {}, { foundation: "udpcandidate", priority: Number(i.priority) + 1 + "", transport: "udp", port: Number(i.port) - 90 + "" }));
    }), this._candidates = n) : this._candidates = this._candidates.filter((i) => i.transport !== "tcp");
    for (let i of this.sessionDesc.mediaDescriptions) i.attributes.candidates = this.candidates;
  }
  restartICE(e) {
    e = le(e), this._iceParameters = e, this.sessionDesc.mediaDescriptions.forEach((n) => {
      n.attributes.iceUfrag = e.iceUfrag, n.attributes.icePwd = e.icePwd;
    });
  }
  predictReceivingMids(e) {
    let n = [];
    for (let i = 0; i < e; i++) n.push((this.currentMidIndex + i + 1).toString(10));
    return n;
  }
  findAvailableMediaIndex(e, n) {
    return this.sessionDesc.mediaDescriptions.findIndex((i) => {
      let r = i.media.mediaType === e && i.media.port !== "0" && (i.attributes.direction === "sendonly" || i.attributes.direction === "sendrecv") && i.attributes.ssrcs.length === 0;
      if ($t()) {
        if (r) {
          let o = this.firefoxSsrcMidMap.get(n[0].ssrcId);
          return !(o || i.attributes.mid !== "0" && i.attributes.mid !== "1") || !(!o || o !== i.attributes.mid);
        }
        return false;
      }
      return r;
    });
  }
  createOrRecycleDataChannel() {
    for (let i of this.sessionDesc.mediaDescriptions) if (i.media.mediaType === "application") return { mediaDesc: i, needExchangeSDP: false };
    this.currentMidIndex += 1;
    let e = "".concat(this.currentMidIndex), n = { media: { mediaType: "application", port: Fa, protos: ["UDP", "DTLS", "SCTP"], fmts: ["webrtc-datachannel"] }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: [], fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: [], ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: [], rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, mid: "".concat(e), sctpPort: "5000" } };
    return this.sessionDesc.mediaDescriptions.push(n), { mediaDesc: n, needExchangeSDP: true };
  }
  createOrRecycleRecvMedia(e, n, i, r, o, s) {
    let a = e._mediaStreamTrack.kind, c = this.rtpCapabilities.recv, d = ac(a, c, this.localCapabilities.send, a === Q.VIDEO ? r : o), l = a === Q.VIDEO ? c.videoExtensions : c.audioExtensions;
    this.currentMidIndex += 1;
    let u = "".concat(this.currentMidIndex), h = { media: { mediaType: a, port: Fa, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: d.map((g) => g.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: l, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: n, ssrcGroups: [], rtcpFeedbackWildcards: [], payloads: d, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: i, rtcpMux: true, rtcpRsize: true, mid: "".concat(u) } };
    h = this.mungRecvMediaDsec(h, e, s);
    let p = this.findFirstClosedMedia(a);
    if (p) {
      let g = this.sessionDesc.mediaDescriptions.indexOf(p);
      this.sessionDesc.mediaDescriptions[g] = h;
    } else this.sessionDesc.mediaDescriptions.push(h);
    return h;
  }
  updateRemoteCodec(e, n, i) {
    let r = [...new Set(this._rtpCapabilities.recv.videoCodecs.map((h) => h.rtpMap && h.rtpMap.encodingName.toLowerCase() || "").filter((h) => {
      var p;
      return W(p = Object.keys(Ju)).call(p, h);
    }))], o = new Set(n);
    if (r.every((h) => o.has(h))) return _.debug("codecs has not changed, no need to updateRemoteCodec, codecs: ".concat(n)), false;
    let s = this._rtpCapabilities.recv.videoCodecs.filter((h) => n.some((p) => {
      var g;
      return W(g = h.rtpMap && h.rtpMap.encodingName.toLowerCase() || "").call(g, p);
    }));
    if (s.length === 0) return _.debug("updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: ".concat(r, " codecs: ").concat(n)), false;
    let a = [...new Set(s.map((h) => h.rtpMap && h.rtpMap.encodingName.toLowerCase() || ""))], c;
    if (_.debug("updateRemoteCodec, from ".concat(r, " to ").concat(a)), e.length === 0) c = this.sessionDesc.mediaDescriptions.filter((h) => h.media.mediaType === "video" && h.attributes.direction === "recvonly");
    else if (c = this.sessionDesc.mediaDescriptions.filter((h) => h.attributes.mid && W(e).call(e, h.attributes.mid) && h.attributes.direction === "recvonly"), c.length !== e.length) return _.debug("updateRemoteCodec failed, because cannot find mids, mids: ".concat(e, ", codecs: ").concat(n)), false;
    if (v("USE_PUB_RTX") || v("USE_SUB_RTX")) {
      let h = yf(s, this.rtpCapabilities.recv.videoCodecs);
      s.push(...h);
    }
    this._rtpCapabilities.recv.videoCodecs = s;
    let d = this.localCapabilities.send, l = this.rtpCapabilities.recv, u = ac(Q.VIDEO, l, d, i);
    return c.forEach((h) => {
      let p = u.map((g) => g.payloadType.toString(10));
      _.debug("updateRemoteCodec mid: ".concat(h.attributes.mid, ", from ").concat(h.attributes.payloads, " to ").concat(u)), h.attributes.payloads = u, h.media.fmts = p;
    }), true;
  }
  createOrRecycleSendMedia(e, n, i, r, o) {
    let s = this.rtpCapabilities.send, a = e === Q.VIDEO ? s.videoCodecs : s.audioCodecs, c = e === Q.VIDEO ? s.videoExtensions : s.audioExtensions;
    this.currentMidIndex += 1;
    let d = "".concat(this.currentMidIndex), l = { media: { mediaType: e, port: Fa, protos: ["UDP", "TLS", "RTP", "SAVPF"], fmts: a.map((h) => h.payloadType.toString(10)) }, connections: [{ nettype: "IN", addrtype: "IP4", address: "127.0.0.1" }], bandwidths: [], attributes: { iceUfrag: this.iceParameters.iceUfrag, icePwd: this.iceParameters.icePwd, unrecognized: [], candidates: this.candidates, extmaps: c, fingerprints: this.dtlsParameters.fingerprints, imageattr: [], msids: [], remoteCandidatesList: [], rids: [], ssrcs: n, ssrcGroups: i, rtcpFeedbackWildcards: [], payloads: a, rtcp: { port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0" }, setup: this.setup, direction: r, rtcpMux: true, rtcpRsize: true, mid: "".concat(d) } };
    l = this.mungSendMediaDesc(l, o);
    let u = this.findFirstClosedMedia(e);
    if (u) {
      let h = this.sessionDesc.mediaDescriptions.indexOf(u);
      this.sessionDesc.mediaDescriptions[h] = l;
    } else this.sessionDesc.mediaDescriptions.push(l);
    return l;
  }
  updateBundleMids() {
    this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter((e) => e.media.port !== "0").map((e) => e.attributes.mid);
  }
  mungRecvMediaDsec(e, n, i) {
    let r = le(e);
    return If(r), ra(r, n), vf(r, n), r0(r), lu(r, i, this.localCapabilities.send), r;
  }
  mungSendMediaDesc(e, n) {
    let i = le(e);
    return lu(i, n, this.localCapabilities.recv), oa(i), i;
  }
  updateRecvMedia(e, n) {
    let i = this.sessionDesc.mediaDescriptions.findIndex((r) => r.attributes.mid === e);
    if (i !== -1) {
      let r = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i], n);
      this.sessionDesc.mediaDescriptions[i] = r;
    }
  }
  bumpMid(e) {
    this.currentMidIndex += e;
  }
  findFirstClosedMedia(e) {
    return this.sessionDesc.mediaDescriptions.find((n) => $t() ? n.media.port === "0" && n.media.mediaType === e : n.media.port === "0");
  }
  findPreloadMediaDesc(e) {
    return this.sessionDesc.mediaDescriptions.find((n) => {
      var i;
      return ((i = n.attributes) === null || i === void 0 || (i = i.ssrcs[0]) === null || i === void 0 ? void 0 : i.ssrcId) === e[0].ssrcId;
    });
  }
  getSSRC(e) {
    var n;
    return (n = this.sessionDesc.mediaDescriptions.find((i) => i.attributes.mid === e)) === null || n === void 0 ? void 0 : n.attributes.ssrcs;
  }
};
function Fv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Ar(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Fv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : Fv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var dc = function(t11) {
  return t11.BANDWIDTH = "bandwidth", t11.CPU = "cpu", t11.NONE = "none", t11.OTHER = "other", t11;
}({});
var qs = function(t11) {
  return t11[t11.DOWN = 0] = "DOWN", t11[t11.UP = 1] = "UP", t11;
}(qs || {});
var mu = /* @__PURE__ */ new Map();
function Bv(t11, e, n, i) {
  let { scale: r } = t11;
  if (r === 0 && i === qs.UP || r >= e.length - 1 && i === qs.DOWN) return t11;
  let o = Ar(Ar({}, t11), {}, { scale: i === qs.DOWN ? ++r : --r });
  switch (n) {
    case "maintain-framerate":
      o = Ar(Ar({}, o), e[r].motion);
      break;
    case "maintain-resolution":
      o = Ar(Ar({}, o), e[r].detail);
      break;
    case "balanced":
      o = Ar(Ar({}, o), e[r].balanced);
  }
  return o;
}
function S0(t11, e) {
  if (e) {
    let n = { overUse: 0, underUse: 0, adaptationList: R0(e) };
    mu.set(t11, n);
  } else mu.delete(t11);
}
function R0(t11) {
  let e = Ar({}, t11), { bitrateMax: n, frameRate: i, scaleResolutionDownBy: r, bitrateMin: o } = e, { MIN_FRAME_RATE: s, MAX_THRESHOLD_FRAMERATE: a, MAX_SCALE: c, BITRATE_MIN_THRESHOLD: d, BITRATE_MAX_THRESHOLD: l, BWE_SCALE_UP_THRESHOLD: u, BWE_SCALE_DOWN_THRESHOLD: h, PERF_SCALE_DOWN_THRESHOLD: p, PERF_SCALE_UP_THRESHOLD: g, BALANCE_BITRATE_FACTOR: E, BALANCE_FRAMERATE_FACTOR: f, BALANCE_RESOLUTION_FACTOR: S, MOTION_RESOLUTION_FACTOR: C, MOTION_BITRATE_FACTOR: A, DETAIL_FRAMERATE_FACTOR: b, DETAIL_BITRATE_FACTOR: w } = _f, D = Math.min(e.frameRate, a), k = [{ scale: 0, threshold: { bwe_down: Math.round(Math.pow(h, 1) * n), bwe_up: n, fps_down: Math.round(Math.pow(p, 1) * D), fps_up: i }, balanced: { scaleResolutionDownBy: 1, frameRate: i, bitrateMax: n, bitrateMin: o }, motion: { scaleResolutionDownBy: 1, frameRate: i, bitrateMax: n, bitrateMin: o }, detail: { scaleResolutionDownBy: 1, frameRate: i, bitrateMax: n, bitrateMin: o } }];
  for (let B = 1; B <= c; B++) {
    let V = { bwe_up: Math.round(Math.pow(u, B) * n), bwe_down: Math.round(Math.pow(h, B + 1) * n), fps_up: Math.round(Math.pow(g, B) * D), fps_down: Math.round(Math.pow(p, B + 1) * D) }, z = { scaleResolutionDownBy: r / Math.pow(S, B), frameRate: Math.max(Math.round(Math.pow(f, B) * i), s), bitrateMax: Math.max(Math.round(Math.pow(E, B) * n), l), bitrateMin: Math.max(Math.round(Math.pow(E, B) * o), d) }, lt = { scaleResolutionDownBy: r / Math.pow(C, B), frameRate: i, bitrateMax: Math.max(Math.round(Math.pow(A, B) * n), l), bitrateMin: Math.max(Math.round(Math.pow(A, B) * o), d) }, vt = { scaleResolutionDownBy: 1, frameRate: Math.max(Math.round(Math.pow(b, B) * i), s), bitrateMax: Math.max(Math.round(Math.pow(w, B) * n), l), bitrateMin: Math.max(Math.round(Math.pow(w, B) * o), d) };
    k.push({ scale: B, threshold: V, balanced: z, motion: lt, detail: vt });
  }
  return k;
}
function pW(t11, e, n, i, r, o) {
  let s = mu.get(t11) || { overUse: 0, underUse: 0, adaptationList: R0(r) }, { adaptationList: a } = s;
  mu.set(t11, s);
  let { OVERUSE_TIMES_THRESHOLD: c, UNDERUSE_TIMES_THRESHOLD: d } = _f, { scale: l } = i, u, h;
  return typeof e == "number" && e > 0 && function(p, g, E, f) {
    if (g >= E.length) return false;
    let { threshold: { fps_down: S } } = E[g];
    return v("FORCE_AG_HIGH_FRAMERATE") && f === "maintain-framerate" && (S = E[0].threshold.fps_down), p < S;
  }(e, l, a, o) && (s.overUse++, h = dc.CPU, s.overUse > c) || typeof n == "number" && n > 0 && function(p, g, E) {
    if (g >= E.length) return false;
    let { threshold: { bwe_down: f } } = E[g];
    return p < f;
  }(n, l, a) && (s.overUse++, h = dc.BANDWIDTH, s.overUse > c) ? (s.overUse = 0, s.underUse = 0, u = Bv(i, a, o, qs.DOWN), [u, h]) : (typeof e == "number" && e > 0 && typeof n == "number" && n > 0 && function(p, g, E, f) {
    if (g === 0) return;
    let { threshold: { fps_up: S } } = E[g];
    return v("FORCE_AG_HIGH_FRAMERATE") && f === "maintain-framerate" && (S = E[1].threshold.fps_up), p > S;
  }(e, l, a, o) && function(p, g, E) {
    if (g === 0) return;
    let { threshold: { bwe_up: f } } = E[g];
    return p > f;
  }(n, l, a) && (s.underUse++, s.underUse > d && (s.overUse = 0, s.underUse = 0, u = Bv(i, a, o, qs.UP), u.scale === 0 && (h = dc.NONE))), [u, h]);
}
function jv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function m_(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? jv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : jv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
function _W(t11) {
  var e;
  return !!v("ENABLE_AG_ADAPTATION") && !!(t11 instanceof XE || W(e = t11._hints).call(e, Gt.CUSTOM_TRACK)) && (!!v("FORCE_SUPPORT_AG_ADAPTATION") || !!(function(n) {
    let i = mt();
    if (i.os !== ye.IOS || !i.osVersion) return false;
    let r = i.osVersion.split(".");
    return Number(r[0]) >= n;
  }(14) && fO(17, 4) || mO(14) && gO(17, 4)));
}
var fu = /* @__PURE__ */ new Map();
function zd(t11, e) {
  let n = fu.get(t11);
  if (n) {
    let { timer: i } = n;
    window.clearTimeout(i), fu.delete(t11);
  }
  e.qualityLimitationReason = dc.NONE, S0(t11);
}
var pt;
function Gv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Qi(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Gv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : Gv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var ki = (pt = class Qa extends Yl {
  get currentLocalDescription() {
    return this.peerConnection.currentLocalDescription;
  }
  get currentRemoteDescription() {
    return this.peerConnection.currentRemoteDescription;
  }
  get peerConnectionState() {
    return this.peerConnection.connectionState;
  }
  get iceConnectionState() {
    return this.peerConnection.iceConnectionState;
  }
  get dtlsTransportState() {
    var e, n;
    return (e = (n = this.peerConnection.getReceivers()[0]) === null || n === void 0 || (n = n.transport) === null || n === void 0 ? void 0 : n.state) !== null && e !== void 0 ? e : null;
  }
  get localCodecs() {
    return [...new Set(this.localCapabilities && this.localCapabilities.send.videoCodecs.map((e) => e.rtpMap && e.rtpMap.encodingName.toLowerCase() || "").filter((e) => {
      var n;
      return W(n = Object.keys(Ju)).call(n, e);
    }))];
  }
  constructor(e, n) {
    super(e, n), T(this, "store", void 0), T(this, "peerConnection", void 0), T(this, "id", Ut(5, "connection-")), T(this, "remoteSDP", void 0), T(this, "initialOffer", void 0), T(this, "transportEventReceiver", void 0), T(this, "statsFilter", void 0), T(this, "extension", { useXR: v("USE_XR") }), T(this, "localCapabilities", void 0), T(this, "remoteCodecs", void 0), T(this, "localCandidateCount", 0), T(this, "allCandidatesReceived", false), T(this, "isPreallocation", false), T(this, "preSSRCMap", /* @__PURE__ */ new Map()), T(this, "dataStreamChannelMap", /* @__PURE__ */ new Map()), T(this, "establishPromise", void 0), T(this, "recoveredDataChannelIds", []), T(this, "currentDataChannelId", 1), T(this, "mutex", new ze("P2PConnection-mutex")), T(this, "qualityLimitationReason", dc.NONE), this.store = n, this.peerConnection = new RTCPeerConnection(Qa.resolvePCConfiguration(e), { optional: [{ googDscp: true }] }), this.statsFilter = Nf(this.peerConnection, v("STATS_UPDATE_INTERVAL"), void 0, $t() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1, this.establishPromise = this.establish();
  }
  getPreMedia(e) {
    let n = this.preSSRCMap.get(e);
    if (n !== void 0) {
      let i = this.peerConnection.getTransceivers().find((r) => r.mid === n);
      if (i) return { transceiver: i, track: i.receiver.track, id: n };
    }
  }
  async updateRemoteRTPCapabilities(e, n) {
    if (this.remoteCodecs = n, !this.remoteSDP) return void _.debug("[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: ".concat(this.localCodecs, ", codecs: ").concat(n));
    if (this.remoteSDP.updateRemoteCodec(e, n, this.store.codec)) {
      let i = await this.peerConnection.createOffer(), r = this.logSDPExchange(i.sdp || "", "offer", "local", "muteLocal");
      await this.peerConnection.setLocalDescription(i);
      let o = this.remoteSDP.toString();
      r == null ? void 0 : r(o), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o });
    } else _.debug("[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.");
  }
  async establish() {
    try {
      this.peerConnection.addTransceiver("video", { direction: "recvonly" }), this.peerConnection.addTransceiver("audio", { direction: "recvonly" });
      let e = await this.peerConnection.createOffer();
      if (!e.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
      let n = io(e.sdp), i = await s0({ filterRTX: !v("USE_PUB_RTX") && !v("USE_SUB_RTX"), filterVideoFec: v("FILTER_VIDEO_FEC"), filterAudioFec: v("FILTER_AUDIO_FEC"), filterVideoCodec: v("FILTER_VIDEO_CODEC") }, this.extension);
      return this.localCapabilities = uu(i), this.initialOffer = e, Qi(Qi({}, n), {}, { rtpCapabilities: i, offerSDP: e.sdp });
    } catch (e) {
      throw new N(R.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString());
    }
  }
  async connect(e) {
    try {
      if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
      this.remoteSDP = new um(Qi(Qi({}, e), {}, { localCapabilities: this.localCapabilities })), e.preallocation && (this.isPreallocation = true), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
      let n = this.remoteSDP.toString(), i = a0(this.initialOffer.sdp, this.extension), r = this.logSDPExchange(i || "", "offer", "local", "connect");
      this.store.descriptionStart(), await this.peerConnection.setLocalDescription({ type: "offer", sdp: i }), r == null ? void 0 : r(n), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: n });
      let o = this.peerConnection.getTransceivers()[0];
      if (o != null && o.receiver && this.tryBindTransportEvents(o.receiver), v("PRELOAD_MEDIA_COUNT") > 0) {
        this.remoteSDP.preloadRemoteMedia(v("PRELOAD_MEDIA_COUNT"));
        let a = this.remoteSDP.toString();
        await this.peerConnection.setRemoteDescription({ type: "offer", sdp: a });
        let c = await this.peerConnection.createAnswer();
        await this.peerConnection.setLocalDescription(c);
      }
      let { preSSRCs: s } = e;
      if (Array.isArray(s) && s.length > 0) {
        let { mids: a } = this.remoteSDP.batchSend(s.map((c) => ({ kind: c.kind, ssrcMsg: [{ ssrcId: c.ssrcId, rtx: c.rtx }], mslabel: c.mslabel })));
        a.forEach((c, d) => {
          this.preSSRCMap.set(s[d].ssrcId, c);
        }), await Wd(this.peerConnection, this.remoteSDP, this.extension), _.debug("[".concat(this.store.clientId, "] [P2PConnection] pre-batchReceive exchange SDP."));
      }
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(n.toString()));
    }
  }
  async updateRemoteConnect(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateRemoteConnect before remote SDP created");
      let { rtpCapabilities: n } = e;
      this.remoteSDP.updateRemoteRTPCapabilities(n), Array.isArray(this.remoteCodecs) && this.remoteCodecs.length > 0 && this.remoteSDP.updateRemoteCodec([], this.remoteCodecs, this.store.codec);
      let { preSSRCs: i } = e;
      if (Array.isArray(i) && i.length > 0) {
        let { mids: r } = this.remoteSDP.batchSend(i.map((o) => Object.assign({}, { kind: o.kind, ssrcMsg: [{ ssrcId: o.ssrcId, rtx: o.rtx }], mslabel: o.mslabel })));
        r.forEach((o, s) => {
          this.preSSRCMap.set(i[s].ssrcId, o);
        });
      }
      await Wd(this.peerConnection, this.remoteSDP, this.extension), _.debug("[P2PConnection] updateRemoteRTPCapabilities by exchanging SDP.");
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.updateRemoteConnect failed; ".concat(n.toString()));
    }
  }
  send(e, n, i) {
    var r = this;
    return Bi(function* () {
      let o = yield Tt(r.mutex.lock("From P2PConnection.send"));
      try {
        if (!r.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
        let s = [];
        e.forEach((E) => {
          let f = r.peerConnection.addTransceiver(E._mediaStreamTrack, { direction: "sendonly" });
          s.push(f), E._updateRtpTransceiver(f);
        }), $t() && v("SIMULCAST") === true && (yield Tt(r.applySimulcastForFirefox(s, e)));
        let a = yield Tt(r.peerConnection.createOffer()), c = r.remoteSDP.predictReceivingMids(e.length), d = r.mungSendOfferSDP(a.sdp, e, c), l = Le.parse(d), u = c.map((E) => {
          let f = l.mediaDescriptions.find((S) => S.attributes.mid === E);
          if (!f) throw new Error("Cannot extract ssrc from mediaDescription.");
          return n0(f, v("USE_PUB_RTX"));
        }), h;
        try {
          h = yield u;
        } catch (E) {
          h = [], r.remoteSDP.receive(e, n, i, h);
          let f = r.remoteSDP.toString();
          throw yield Tt(r.peerConnection.setLocalDescription({ type: "offer", sdp: d })), yield Tt(r.peerConnection.setRemoteDescription({ type: "answer", sdp: f })), yield Tt(r.stopSending(c, true)), E;
        }
        r.remoteSDP.receive(e, n, i, h);
        let p = r.remoteSDP.toString(), g = r.logSDPExchange(d, "offer", "local", "send");
        return yield Tt(r.peerConnection.setLocalDescription({ type: "offer", sdp: d })), yield Tt(r.applySimulcastEncodings(s, e)), yield Tt(r.applySendEncodings(s, e)), g == null ? void 0 : g(p), yield Tt(r.peerConnection.setRemoteDescription({ type: "answer", sdp: p })), s.map((E, f) => {
          let S = c[f];
          return { localSSRC: u[f], id: S, transceiver: E };
        });
      } catch (s) {
        throw s instanceof N ? s : new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(s.toString()));
      } finally {
        o();
      }
    })();
  }
  async createDataChannels(e, n) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.createDataChannels before remote SDP created");
      let i = this.dataStreamChannelMap.get(e);
      if (i && i.readyState === "open") _.debug("[P2PConnection] Channels are already available and can be reused directly.");
      else {
        let o = this.currentDataChannelId < 1023 ? this.currentDataChannelId++ : this.recoveredDataChannelIds.shift();
        if (typeof o != "number") throw new Error("create DataChannel error, because cannot get dc id");
        i = this.peerConnection.createDataChannel("datastream-channel", { id: o, negotiated: true, ordered: false, maxRetransmits: v("DATASTREAM_MAX_RETRANSMITS") }), i.binaryType = "arraybuffer", this.dataStreamChannelMap.set(e, i);
      }
      n.forEach((o) => {
        o._updateOriginDataChannel(i);
      });
      let { needExchangeSDP: r } = this.remoteSDP.sendDataChannel();
      if (r) {
        let o = this.remoteSDP.toString();
        await this.peerConnection.setRemoteDescription({ type: "offer", sdp: o });
        let s = await this.peerConnection.createAnswer();
        await this.peerConnection.setLocalDescription(s), _.debug("[P2PConnection] createDataChannels by exchanging SDP.");
      } else _.debug("[P2PConnection] createDataChannels no need to exchange SDP.");
      return;
    } catch (i) {
      throw i instanceof N ? i : new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.createDataChannels failed; ".concat(i.toString()));
    }
  }
  async stopDataChannels(e) {
    try {
      let n = this.dataStreamChannelMap.get(e);
      return n && (n.id && this.recoveredDataChannelIds.push(n.id), n.close()), void this.dataStreamChannelMap.delete(e);
    } catch (n) {
      throw n instanceof N ? n : new N(R.DATACHANNEL_FAILED, "P2PConnection.stopDataChannels failed; ".concat(n.toString()));
    }
  }
  async stopSending(e, n) {
    let i = n ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
      let r = this.peerConnection.getTransceivers().filter((c) => e.indexOf(c.mid) !== -1);
      if (r.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
      r.map((c) => {
        var d;
        zd(this.id + c.mid, this), c.direction = "inactive", (d = c.stop) === null || d === void 0 || d.call(c);
      });
      let o = await this.peerConnection.createOffer(), s = this.logSDPExchange(o.sdp || "", "offer", "local", "stopSending");
      await this.peerConnection.setLocalDescription(o), this.remoteSDP.stopReceiving(e);
      let a = this.remoteSDP.toString();
      s == null ? void 0 : s(a), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: a });
    } catch (r) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(r.toString()));
    } finally {
      i && i();
    }
  }
  async receive(e, n, i, r) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e, " before remoteSDP created."));
      let { mid: o, needExchangeSDP: s } = this.remoteSDP.send(e, n, i, r);
      s && (await Wd(this.peerConnection, this.remoteSDP, this.extension), _.debug("[".concat(this.store.clientId, "] [P2PConnection] receive ").concat(e, " by exchanging SDP.")));
      let a = this.peerConnection.getTransceivers().find((c) => c.mid === o);
      if (!a) throw new Error("Cannot get transceiver after setLocalDescription.");
      return { track: a.receiver.track, id: o, transceiver: a };
    } catch (o) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(o.toString()));
    }
  }
  async batchReceive(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
      let { mids: n, needExchangeSDP: i } = this.remoteSDP.batchSend(e);
      return i && (await Wd(this.peerConnection, this.remoteSDP, this.extension), _.debug("[".concat(this.store.clientId, "] [P2PConnection] batchReceive by exchanging SDP."))), n.map((r) => {
        let o = this.peerConnection.getTransceivers().find((s) => s.mid === r);
        if (!o) throw new Error("Cannot get transceiver after setLocalDescription.");
        return { track: o.receiver.track, id: r, transceiver: o };
      });
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(n.toString()));
    }
  }
  async stopReceiving(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
      e.forEach((o) => {
        Array.from(this.preSSRCMap.entries()).some((s) => {
          let [a, c] = s;
          if (c === o) return this.preSSRCMap.delete(a), true;
        });
      }), this.remoteSDP.stopSending(e);
      let n = this.remoteSDP.toString(), i = this.logSDPExchange(n, "offer", "remote", "stopReceiving");
      await this.peerConnection.setRemoteDescription({ type: "offer", sdp: n });
      let r = await this.peerConnection.createAnswer();
      i == null ? void 0 : i(r.sdp || ""), await this.peerConnection.setLocalDescription(r);
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(n.toString()));
    }
  }
  async muteRemote(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e, " before remote SDP created."));
      this.remoteSDP.mute(e);
      let n = this.remoteSDP.toString(), i = this.logSDPExchange(n, "offer", "remote", "muteRemote");
      await this.peerConnection.setRemoteDescription({ type: "offer", sdp: n });
      let r = await this.peerConnection.createAnswer();
      i == null ? void 0 : i(r.sdp || ""), await this.peerConnection.setLocalDescription(r);
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(n.toString()));
    }
  }
  async unmuteRemote(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e, " before remote SDP created."));
      this.remoteSDP.unmute(e);
      let n = this.remoteSDP.toString(), i = this.logSDPExchange(n, "offer", "remote", "unmuteRemote");
      await this.peerConnection.setRemoteDescription({ type: "offer", sdp: n });
      let r = await this.peerConnection.createAnswer();
      i == null ? void 0 : i(r.sdp || ""), await this.peerConnection.setLocalDescription(r);
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(n.toString()));
    }
  }
  async muteLocal(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
      let n = this.peerConnection.getTransceivers().filter((s) => s.mid && e.indexOf(s.mid) !== -1);
      if (n.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length.");
      n.map((s) => {
        s.direction = "inactive";
      });
      let i = await this.peerConnection.createOffer(), r = this.logSDPExchange(i.sdp || "", "offer", "local", "muteLocal");
      await this.peerConnection.setLocalDescription(i), this.remoteSDP.muteRemote(e);
      let o = this.remoteSDP.toString();
      r == null ? void 0 : r(o), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o });
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(n.toString()));
    }
  }
  async unmuteLocal(e) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
      let n = this.peerConnection.getTransceivers().filter((s) => s.mid && e.indexOf(s.mid) !== -1);
      if (n.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length.");
      n.map(async (s, a) => {
        s.direction = "sendonly";
      });
      let i = await this.peerConnection.createOffer(), r = this.logSDPExchange(i.sdp || "", "offer", "local", "unmuteLocal");
      await this.peerConnection.setLocalDescription(i), this.remoteSDP.unmuteRemote(e);
      let o = this.remoteSDP.toString();
      r == null ? void 0 : r(o), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o });
    } catch (n) {
      throw new N(R.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(n.toString()));
    }
  }
  restartICE(e) {
    var n = this;
    return Bi(function* () {
      let i = yield Tt(n.mutex.lock("From P2PConnection.restartICE"));
      try {
        if (!n.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
        if (ft().supportPCSetConfiguration) {
          let d = n.peerConnection.getConfiguration(), l = e === On.RELAY ? "relay" : "all";
          d.iceTransportPolicy !== l && (_.debug("[".concat(n.store.clientId, "] restartICE change iceTransportPolicy from [").concat(d.iceTransportPolicy, "] to [").concat(l, "]")), d.iceTransportPolicy = l, n.peerConnection.setConfiguration(d));
        } else if (e === On.RELAY) return;
        n.remoteSDP.updateCandidates(e);
        let r = yield Tt(n.peerConnection.createOffer({ iceRestart: true }));
        if (!r.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
        let o = io(r.sdp), { remoteIceParameters: s } = yield o.iceParameters;
        n.remoteSDP.restartICE(s);
        let a = n.remoteSDP.toString(), c = n.logSDPExchange(r.sdp || "", "offer", "local", "restartICE");
        n.store.descriptionStart(), yield Tt(n.peerConnection.setLocalDescription(r)), c == null ? void 0 : c(a), yield Tt(n.peerConnection.setRemoteDescription({ type: "answer", sdp: a }));
      } catch (r) {
        _.warning("[".concat(n.store.clientId, "] restart ICE failed, abort operation"), r);
      } finally {
        i();
      }
    })();
  }
  close() {
    var e;
    this.peerConnection.getTransceivers().forEach((n) => {
      zd(this.id + n.mid, this);
    }), this.preSSRCMap.clear(), this.peerConnection.close(), (e = this.onConnectionStateChange) === null || e === void 0 || e.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy(), this.dataStreamChannelMap.clear(), this.recoveredDataChannelIds = [], this.currentDataChannelId = 1;
  }
  getStats() {
    return Qi(Qi({}, this.statsFilter.getStats()), {}, { qualityLimitationReason: this.qualityLimitationReason });
  }
  getRemoteVideoIsReady(e) {
    return this.statsFilter.getVideoIsReady(e);
  }
  async updateEncoderConfig(e, n) {
    try {
      if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
      let i = await this.peerConnection.createOffer(), r = this.mungSendOfferSDP(i.sdp, [n], [e]);
      this.remoteSDP.updateRecvMedia(e, n);
      let o = this.remoteSDP.toString(), s = this.logSDPExchange(r, "offer", "local", "updateEncoderConfig");
      await this.peerConnection.setLocalDescription({ type: "offer", sdp: r }), s == null ? void 0 : s(o), await this.peerConnection.setRemoteDescription({ type: "answer", sdp: o });
    } catch (i) {
      throw new N(R.EXCHANGE_SDP_FAILED, i.toString());
    }
  }
  async updateSendParameters(e, n) {
    let i = this.peerConnection.getTransceivers().filter((r) => r.mid === e);
    i.length === 1 && (this.isVP8Simulcast(n) ? $t() || await this.applySimulcastEncodings(i, [n]) : await this.applySendEncodings(i, [n]));
  }
  setStatsRemoteVideoIsReady(e, n) {
    this.statsFilter.setVideoIsReady2(e, n);
  }
  async replaceTrack(e, n) {
    let i = this.peerConnection.getTransceivers().find((r) => r.mid === n);
    i && await i.sender.replaceTrack(e._mediaStreamTrack);
  }
  async getSelectedCandidatePair() {
    let e = this.peerConnection.getReceivers();
    if (e.length > 0 && e[0].transport && e[0].transport.iceTransport && e[0].transport.iceTransport.getSelectedCandidatePair && e[0].transport.iceTransport.getSelectedCandidatePair()) {
      let n = e[0].transport.iceTransport, { local: i, remote: r } = n.getSelectedCandidatePair();
      return { local: Qi(Qi({}, hr), {}, { candidateType: i.type, protocol: i.protocol, address: i.address, port: i.port }), remote: Qi(Qi({}, hr), {}, { candidateType: r.type, protocol: r.protocol, address: r.address, port: r.port }) };
    }
    return this.statsFilter.getSelectedCandidatePair();
  }
  bindPCEvents() {
    this.peerConnection.oniceconnectionstatechange = () => {
      var e;
      (e = this.onICEConnectionStateChange) === null || e === void 0 || e.call(this, this.peerConnection.iceConnectionState);
    }, this.peerConnection.onconnectionstatechange = () => {
      var e;
      (e = this.onConnectionStateChange) === null || e === void 0 || e.call(this, this.peerConnection.connectionState);
    }, this.peerConnection.onicecandidate = (e) => {
      e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = true, _.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount));
    }, setTimeout(() => {
      this.allCandidatesReceived || (this.allCandidatesReceived = true, _.debug("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount));
    }, v("CANDIDATE_TIMEOUT"));
  }
  unbindPCEvents() {
    this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;
  }
  static resolvePCConfiguration(e) {
    let n = { iceServers: [] };
    return e.iceServers ? n.iceServers = e.iceServers : e.turnServer && e.turnServer.mode !== "off" && (Yu(e.turnServer.servers) ? n.iceServers = e.turnServer.servers : (n.iceServers && n.iceServers.push(...Qa.turnServerConfigToIceServers(e.turnServer.servers)), v("USE_TURN_SERVER_OF_GATEWAY") && n.iceServers && e.turnServer.serversFromGateway && n.iceServers.push(...Qa.turnServerConfigToIceServers(e.turnServer.serversFromGateway)), v("FORCE_TURN_TCP") ? n.iceTransportPolicy = "relay" : e.turnServer.servers.concat(e.turnServer.serversFromGateway || []).forEach((i) => {
      i.forceturn && (n.iceTransportPolicy = "relay");
    }))), v("ENABLE_ENCODED_TRANSFORM") && ft().supportWebRTCEncodedTransform && (n.encodedInsertableStreams = true), n;
  }
  static turnServerConfigToIceServers(e) {
    let n = [];
    return e.forEach((i) => {
      i.security ? i.tcpport && n.push({ username: i.username, credential: i.password, credentialType: "password", urls: "turns:".concat(Us(i.turnServerURL), ":").concat(i.tcpport, "?transport=tcp") }) : (i.udpport && !v("FORCE_TURN_TCP") && n.push({ username: i.username, credential: i.password, credentialType: "password", urls: "turn:".concat(i.turnServerURL, ":").concat(i.udpport, "?transport=udp") }), i.tcpport && n.push({ username: i.username, credential: i.password, credentialType: "password", urls: "turn:".concat(i.turnServerURL, ":").concat(i.tcpport, "?transport=tcp") }));
    }), n;
  }
  tryBindTransportEvents(e) {
    let n = e.transport;
    if (n) {
      this.transportEventReceiver = e, n.onstatechange = () => {
        var r;
        n != null && n.state && ((r = this.onDTLSTransportStateChange) === null || r === void 0 || r.call(this, n.state));
      }, n.onerror = (r) => {
        var o;
        (o = this.onDTLSTransportError) === null || o === void 0 || o.call(this, "error" in r ? r.error : r);
      };
      let i = n.iceTransport;
      i && (i.onstatechange = () => {
        let r = n == null ? void 0 : n.iceTransport.state;
        var o;
        r && ((o = this.onICETransportStateChange) === null || o === void 0 || o.call(this, r));
      }, i.getSelectedCandidatePair && (i.onselectedcandidatepairchange = () => {
        if (i.getSelectedCandidatePair()) {
          let { local: r, remote: o } = i.getSelectedCandidatePair();
          _.info("[".concat(this.store.clientId, "] [pc-").concat(this.store.p2pId, "] selectedcandidatepairchange: local ").concat(JSON.stringify({ candidateType: r.type, protocol: r.protocol }), ", remote ").concat(JSON.stringify({ candidateType: o.type, protocol: o.protocol, address: o.address, port: o.port }), " )"));
        }
      }));
    }
  }
  tryUnbindTransportEvents() {
    this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));
  }
  async updateRtpSenderEncodings(e, n) {
    var i, r;
    if (n || (n = this.peerConnection.getSenders().find((f) => f.track === e._mediaStreamTrack)), !n) return _.warn("[".concat(e.getTrackId(), "] no rtpSender found}"));
    if (this.isVP8Simulcast(e)) return _.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");
    if (!ft().supportSetRtpSenderParameters) return _.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");
    let o = {}, s = {};
    switch (e._optimizationMode) {
      case "motion":
        o.degradationPreference = "maintain-framerate";
        break;
      case "detail":
        o.degradationPreference = "maintain-resolution";
        break;
      case "balanced":
        o.degradationPreference = "balanced";
    }
    let a = function(E, f) {
      return E.getTransceivers().find((S) => S.sender.track === f || S.receiver.track === f);
    }(this.peerConnection, e._mediaStreamTrack), c = xG(e);
    if (_W(e) && a && n && c && this.getLocalVideoStats && W(i = ["vp8", "vp9"]).call(i, this.store.codec)) {
      var d;
      let E = o.degradationPreference || (W(d = e._hints).call(d, Gt.CUSTOM_TRACK) ? v("CUSTOM_ADAPTATION_DEFAULT_MODE") : "maintain-framerate");
      (function(f, S, C, A, b, w) {
        if (zd(f, C), b(S), A !== "balanced" && A !== "maintain-framerate" && A !== "maintain-resolution") return;
        let D = -1;
        S0(f, S);
        let k = window.setInterval(() => {
          let V = fu.get(f);
          if (!v("ENABLE_AG_ADAPTATION") || !V) return zd(f, C), void b(S);
          let z = w();
          if (z.sendPackets > 0 && z.OutgoingAvailableBandwidth > 0) {
            if (D === -1) return void (D = Date.now());
            if (Date.now() - D < 1e3) return;
            let lt = z.sendFrameRate, vt = z.OutgoingAvailableBandwidth, [Dt, ce] = pW(f, lt, vt, V.adaptationConfig, S, A);
            ce && (C.qualityLimitationReason = ce), Dt && V.adaptationConfig.scale !== Dt.scale && (_.debug("[".concat(f, "] applyAdaptation: ").concat(C.qualityLimitationReason, `
           sendFps `).concat(lt, ", bwe ").concat(vt, ", switch from ").concat(V.adaptationConfig.scale, " to ").concat(Dt.scale, " ")), V.adaptationConfig = m_(m_({}, V.adaptationConfig), Dt), b(Dt));
          }
        }, v("CHECK_LOCAL_STATS_INTERVAL")), B = m_({}, S);
        fu.set(f, { timer: k, adaptationConfig: B, originConfig: S, adaptationFunc: b }), _.debug("[".concat(f, "] start adaptation, originConfig: ").concat(JSON.stringify(S), ", degradationPreference: ").concat(A));
      })(this.id + a.mid, c, this, E, (f) => {
        n && this.updateAdaptation(n, f);
      }, this.getLocalVideoStats.bind(this));
    }
    if (e._encoderConfig) {
      var l;
      let { bitrateMax: E, frameRate: f, scaleResolutionDownBy: S } = e._encoderConfig;
      E && (s.maxBitrate = 1e3 * E), (W(l = e._hints).call(l, Gt.LOW_STREAM) || e.isUseScaleResolutionDownBy) && (f && (s.maxFramerate = Nn(f)), S && S >= 1 && (s.scaleResolutionDownBy = S));
    }
    let { maxFramerate: u } = v("ENCODER_CONFIG_LIMIT");
    if (u && typeof u == "number" && (s.maxFramerate = s.maxFramerate ? Math.min(s.maxFramerate, u) : u), v("DSCP_TYPE") && ho()) {
      var h;
      let E = v("DSCP_TYPE");
      W(h = ["very-low", "low", "medium", "high"]).call(h, E) && (s.networkPriority = E);
    }
    let p = n.getParameters(), g = (r = p.encodings) === null || r === void 0 ? void 0 : r[0];
    $t() && !g && (o.encodings = [s]), g && Object.assign(g, s), Object.assign(p, o), _.debug("[".concat(e.getTrackId(), "] updateRtpSenderEncodings: ").concat(JSON.stringify(p.encodings))), await n.setParameters(p), await async function(E, f, S) {
      try {
        var C;
        if (!ft().supportSetRtpSenderParameters || !/* @__PURE__ */ function(k) {
          return k === "vp9";
        }(E) || !v("ENABLE_SVC")) return;
        let A = {}, b = {}, w = f.getParameters(), D = (C = w.encodings) === null || C === void 0 ? void 0 : C[0];
        b.scalabilityMode = $E(S), D && Object.assign(D, b), Object.assign(w, A), await f.setParameters(w), _.debug("[updateAdaptation] updateRtpSenderEncodings scalabilityMode success: ".concat(JSON.stringify(w.encodings)));
      } catch (A) {
        _.debug("[updateAdaptation] updateRtpSenderEncodings scalabilityMode failed", A);
      }
    }(this.store.codec, n, v("SVC_MODE"));
  }
  async updateAdaptation(e, n) {
    var i, r;
    if (!e) return _.debug("[updateAdaptation] no rtpSender found");
    if (!ft().supportSetRtpSenderParameters) return _.debug("[updateAdaptation] Browser not support set rtp-sender parameters");
    let o = {}, { bitrateMax: s, frameRate: a, scaleResolutionDownBy: c } = n;
    s && (o.maxBitrate = 1e3 * s), a && (o.maxFramerate = Nn(a)), c && c >= 1 && W(i = ["vp8", "vp9"]).call(i, this.store.codec) && (o.scaleResolutionDownBy = c);
    let d = e.getParameters(), l = (r = d.encodings) === null || r === void 0 ? void 0 : r[0];
    l && Object.assign(l, o), Object.assign(d, {});
    try {
      await e.setParameters(d), _.debug("[updateAdaptation] updateRtpSenderEncodings: ".concat(JSON.stringify(d.encodings)));
    } catch (u) {
      !("transport" in e) || e.transport && e.transport.state === "connected" ? this.peerConnectionState !== "connected" ? _.debug("[updateAdaptation] peerConnection not connected}") : _.debug("[updateAdaptation] updateRtpSenderEncodings failed", u) : _.debug("[updateAdaptation] rtpSender transport not connected}");
    }
  }
  async applySendEncodings(e, n) {
    try {
      if (!ft().supportSetRtpSenderParameters || e.length !== n.length) return;
      for (let i = 0; i < e.length; i++) {
        let r = e[i], o = n[i];
        o instanceof Ft && !this.isVP8Simulcast(o) && await this.updateRtpSenderEncodings(o, r.sender);
      }
    } catch {
      _.debug("[".concat(this.store.clientId, "] Apply RTPSendEncodings failed."));
    }
  }
  mungSendOfferSDP(e, n, i) {
    let r = Le.parse(e);
    return n.forEach((o, s) => {
      let a = i[s], c = r.mediaDescriptions.find((d) => d.attributes.mid === a);
      c && (ra(c, o), o0(c, o, this.store.codec));
    }), Le.print(r);
  }
  bindStatsEvents() {
    this.statsFilter.onFirstAudioReceived = (e) => {
      var n;
      (n = this.onFirstAudioReceived) === null || n === void 0 || n.call(this, e);
    }, this.statsFilter.onFirstVideoReceived = (e) => {
      var n;
      (n = this.onFirstVideoReceived) === null || n === void 0 || n.call(this, e);
    }, this.statsFilter.onFirstAudioDecoded = (e) => {
      var n;
      (n = this.onFirstAudioDecoded) === null || n === void 0 || n.call(this, e);
    }, this.statsFilter.onFirstVideoDecoded = (e, n, i) => {
      var r;
      (r = this.onFirstVideoDecoded) === null || r === void 0 || r.call(this, e, n, i);
    }, this.statsFilter.onSelectedLocalCandidateChanged = (e, n) => {
      var i;
      (i = this.onSelectedLocalCandidateChanged) === null || i === void 0 || i.call(this, e, n);
    }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, n) => {
      var i;
      (i = this.onSelectedRemoteCandidateChanged) === null || i === void 0 || i.call(this, e, n);
    }, this.statsFilter.onFirstVideoDecodedTimeout = (e) => {
      var n;
      (n = this.onFirstVideoDecodedTimeout) === null || n === void 0 || n.call(this, e);
    };
  }
  unbindStatsEvents() {
    this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;
  }
  async applySimulcastForFirefox(e, n) {
    if (e.length === n.length) for (let c = 0; c < e.length; c++) {
      var i, r, o, s, a;
      let d = e[c], l = n[c];
      if (l instanceof Ft && !W(i = l._hints).call(i, Gt.LOW_STREAM) && (r = l._encoderConfig) !== null && r !== void 0 && r.bitrateMax && ((o = l._encoderConfig) === null || o === void 0 ? void 0 : o.bitrateMax) > 200 && (s = l._scalabilityMode) !== null && s !== void 0 && s.numSpatialLayers && ((a = l._scalabilityMode) === null || a === void 0 ? void 0 : a.numSpatialLayers) > 1 && this.store.codec === "vp8") {
        let u = {}, h = { high: 1e3 * (l._encoderConfig.bitrateMax - 50), medium: 5e4 };
        u.encodings = [{ rid: "m", active: true, maxBitrate: h.medium, scaleResolutionDownBy: 4 }, { rid: "h", active: true, maxBitrate: h.high }];
        let p = d.sender.getParameters();
        await d.sender.setParameters(Object.assign(p, u));
      }
    }
  }
  async applySimulcastEncodings(e, n) {
    if (!$t() && e.length === n.length) for (let i = 0; i < e.length; i++) {
      let r = n[i];
      if (r instanceof Ft && this.isVP8Simulcast(r)) {
        let o = e[i], s = {}, a = { high: 1e3 * (r._encoderConfig.bitrateMax - 50), medium: 5e4 };
        s.encodings = [{ active: true, adaptivePtime: false, networkPriority: "high", priority: "high", maxBitrate: a.high }, { active: true, adaptivePtime: false, networkPriority: "low", priority: "low", maxBitrate: a.medium, scaleResolutionDownBy: 4 }];
        let c = o.sender.getParameters();
        await o.sender.setParameters(Object.assign(c, s));
      }
    }
  }
  isVP8Simulcast(e) {
    var n, i, r, o, s;
    return !!(e instanceof Ft && v("SIMULCAST") && this.store.codec === "vp8" && !W(n = e._hints).call(n, Gt.LOW_STREAM) && (i = e._encoderConfig) !== null && i !== void 0 && i.bitrateMax && ((r = e._encoderConfig) === null || r === void 0 ? void 0 : r.bitrateMax) > 200 && (o = e._scalabilityMode) !== null && o !== void 0 && o.numSpatialLayers && ((s = e._scalabilityMode) === null || s === void 0 ? void 0 : s.numSpatialLayers) > 1);
  }
  logSDPExchange(e, n, i, r) {
    if (v("SDP_LOGGING")) return _.upload("[".concat(this.store.clientId, "] exchanging ").concat(i, " ").concat(n, " SDP during P2PConnection.").concat(r, `
`), e), n === "offer" ? (o) => {
      this.logSDPExchange(o, "answer", i === "local" ? "remote" : "local", r);
    } : void 0;
  }
  async getRemoteSSRC(e) {
    if (!this.remoteSDP) return;
    let n = this.remoteSDP.getSSRC(e);
    return n && n.length !== 0 ? n[0].ssrcId : void 0;
  }
  setConfiguration(e) {
    if (ft().supportPCSetConfiguration) {
      let n = Qa.resolvePCConfiguration(e);
      this.peerConnection.setConfiguration(n);
    }
  }
}, q(pt.prototype, "updateRemoteRTPCapabilities", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "updateRemoteRTPCapabilities"), pt.prototype), q(pt.prototype, "connect", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "connect"), pt.prototype), q(pt.prototype, "updateRemoteConnect", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "updateRemoteConnect"), pt.prototype), q(pt.prototype, "createDataChannels", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "createDataChannels"), pt.prototype), q(pt.prototype, "receive", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "receive"), pt.prototype), q(pt.prototype, "batchReceive", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "batchReceive"), pt.prototype), q(pt.prototype, "stopReceiving", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "stopReceiving"), pt.prototype), q(pt.prototype, "muteRemote", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "muteRemote"), pt.prototype), q(pt.prototype, "unmuteRemote", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "unmuteRemote"), pt.prototype), q(pt.prototype, "muteLocal", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "muteLocal"), pt.prototype), q(pt.prototype, "unmuteLocal", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "unmuteLocal"), pt.prototype), q(pt.prototype, "close", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "close"), pt.prototype), q(pt.prototype, "updateEncoderConfig", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "updateEncoderConfig"), pt.prototype), q(pt.prototype, "updateSendParameters", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "updateSendParameters"), pt.prototype), q(pt.prototype, "replaceTrack", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "replaceTrack"), pt.prototype), q(pt.prototype, "updateAdaptation", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "updateAdaptation"), pt.prototype), q(pt.prototype, "getRemoteSSRC", [pn], Object.getOwnPropertyDescriptor(pt.prototype, "getRemoteSSRC"), pt.prototype), pt);
function pn(t11, e, n) {
  let i = t11[e];
  if (typeof i != "function") throw new Error("Cannot use mutex on object property.");
  return n.value = async function() {
    let r = this.mutex, o = await r.lock("From P2PConnection.".concat(e));
    try {
      for (var s = arguments.length, a = new Array(s), c = 0; c < s; c++) a[c] = arguments[c];
      return await i.apply(this, a);
    } finally {
      o();
    }
  }, n;
}
var at;
function Wv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Zi(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Wv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : Wv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
function Hv(t11) {
  var e, n, i, r = 2;
  for (typeof Symbol < "u" && (n = hW, i = Symbol.iterator); r--; ) {
    if (n && (e = t11[n]) != null) return e.call(t11);
    if (i && (e = t11[i]) != null) return new bl(e.call(t11));
    n = "@@asyncIterator", i = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function bl(t11) {
  function e(n) {
    if (Object(n) !== n) return j.reject(new TypeError(n + " is not an object."));
    var i = n.done;
    return j.resolve(n.value).then(function(r) {
      return { value: r, done: i };
    });
  }
  return bl = function(n) {
    this.s = n, this.n = n.next;
  }, bl.prototype = { s: null, n: null, next: function() {
    return e(this.n.apply(this.s, arguments));
  }, return: function(n) {
    var i = this.s.return;
    return i === void 0 ? j.resolve({ value: n, done: true }) : e(i.apply(this.s, arguments));
  }, throw: function(n) {
    var i = this.s.return;
    return i === void 0 ? j.reject(n) : e(i.apply(this.s, arguments));
  } }, new bl(t11);
}
var Jd = (at = class extends Xt {
  get state() {
    return this._state;
  }
  set state(t11) {
    let e = this._state;
    this._state = t11, this.emit(tt.StateChange, e, this._state);
  }
  constructor(t11, e) {
    super(), T(this, "isPlanB", void 0), T(this, "store", void 0), T(this, "statsUploader", void 0), T(this, "connection", void 0), T(this, "localTrackMap", /* @__PURE__ */ new Map()), T(this, "remoteUserMap", /* @__PURE__ */ new Map()), T(this, "localDataChannels", []), T(this, "remoteDataChannelMap", /* @__PURE__ */ new Map()), T(this, "pendingLocalTracks", []), T(this, "pendingRemoteTracks", []), T(this, "pendingLocalDataChannels", []), T(this, "pendingRemoteDataChannels", []), T(this, "statsCollector", void 0), T(this, "shouldForwardP2PCreation", void 0), T(this, "iceFailedCount", 0), T(this, "dtlsFailedCount", 0), T(this, "mutex", new ze("P2PChannel-mutex")), T(this, "_state", Rt.Disconnected), T(this, "_pcStatsUploadType", v("NEW_ICE_RESTART") ? Tr.FIRST_CONNECTION : Tr.OLD_FIRST_CONNECTION), T(this, "_isInRestartIce", false), T(this, "_isStartRestartIce", false), T(this, "_restartStates", ["disconnected", "failed"]), T(this, "_restartTimer", void 0), T(this, "_isFirstConnected", true), T(this, "handleMuteLocalTrack", async (n, i, r) => {
      let o = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");
      try {
        if (!this.connection || this.state !== Rt.Connected) return void r(new N(R.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established."));
        let s = this.filterTobeMutedTracks(n);
        if (s.length === 0) return void i();
        let a = s.find((d) => d[0] === "videoLowTrack");
        a && a[1].track._originMediaStreamTrack.stop(), await this.connection.muteLocal(s.map((d) => {
          let [, { id: l }] = d;
          return l;
        }));
        let c = this.createMuteMessage(s);
        await kt(this, tt.RequestMuteLocal, c), i();
      } catch (s) {
        r(s);
      } finally {
        o();
      }
    }), T(this, "handleUnmuteLocalTrack", async (n, i, r) => {
      let o = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");
      try {
        if (!this.connection || this.state !== Rt.Connected) return void r(new N(R.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));
        let s = this.filterTobeUnmutedTracks(n);
        if (s.length === 0) return void i();
        let a = s.find((d) => d[0] === "videoLowTrack");
        if (a) {
          let d = a[1];
          if (d.track._originMediaStreamTrack.stop(), !v("DISABLE_DUAL_STREAM_USE_ENCODING") && ft().supportDualStreamEncoding) {
            let l = n._mediaStreamTrack.clone();
            d.track._mediaStreamTrack = l, d.track._originMediaStreamTrack = l;
          } else {
            let l = dm(n, Ac(this, tt.RequestLowStreamParameter));
            d.track._mediaStreamTrack = l, d.track._originMediaStreamTrack = l;
          }
          await new j((l, u) => {
            this.handleReplaceTrack(d.track, l, u, true);
          });
        }
        await this.connection.unmuteLocal(s.map((d) => {
          let [, { id: l }] = d;
          return l;
        }));
        let c = this.createUnmuteMessage(s);
        await kt(this, tt.RequestUnmuteLocal, c), i();
      } catch (s) {
        r(s);
      } finally {
        o();
      }
    }), T(this, "handleUpdateVideoEncoder", async (n, i, r) => {
      let o = await this.mutex.lock("Locking from P2PChannel.handleSetVideoEncoder");
      try {
        let s = this.localTrackMap.get(U.LocalVideoTrack);
        if (!this.connection || !s || s.track !== n || this.state !== Rt.Connected) return void i();
        let { id: a, track: c } = s;
        await this.connection.updateSendParameters(a, c), await this.connection.updateEncoderConfig(a, c), this.emit(tt.UpdateVideoEncoder, c), i();
      } catch (s) {
        r(s);
      } finally {
        o();
      }
    }), T(this, "handleUpdateVideoSendParameters", async (n, i, r) => {
      let o = await this.mutex.lock("Locking from P2PChannel.handleUpdateVideoSendParameters");
      try {
        let s = this.localTrackMap.get(U.LocalVideoTrack);
        if (!this.connection || !s || s.track !== n || this.state !== Rt.Connected) return void i();
        let { id: a, track: c } = s;
        await this.connection.updateSendParameters(a, c), i();
      } catch (s) {
        r(s);
      } finally {
        o();
      }
    }), T(this, "handleReplaceMixingTrack", async (n, i, r, o) => {
      if (!this.connection || this.state !== Rt.Connected) return void i();
      let s = E_([n]), a;
      _.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will replace audioTrack [").concat(s.getTrackId(), "]")), typeof o == "boolean" && o || (a = await this.mutex.lock("From P2PChannel.handleReplaceMixingTrack"));
      try {
        await this.replaceTrack(n, s), i();
      } catch (d) {
        r(d);
      } finally {
        var c;
        (c = a) === null || c === void 0 || c();
      }
    }), T(this, "handleReplaceTrack", async (n, i, r, o) => {
      let s;
      _.debug("[".concat(this.store.clientId, "] P2PChannel handleReplaceTrack for [track-id-").concat(n.getTrackId(), "]")), typeof o == "boolean" && o || (s = await this.mutex.lock("From P2PChannel.handleReplaceTrack"));
      try {
        var a;
        let d = Array.from(this.localTrackMap.entries()).find((l) => {
          let [, { track: u }] = l;
          return n === u;
        });
        if (!this.connection || !d || this.state !== Rt.Connected) return void i();
        if (await ((a = this.connection) === null || a === void 0 ? void 0 : a.replaceTrack(n, d[1].id)), this.isPlanB) {
          let l = d[1];
          l.id = n._mediaStreamTrack.id, this.localTrackMap.set(d[0], l);
        }
        if (d[0] === U.LocalVideoTrack && !v("DISABLE_DUAL_STREAM_USE_ENCODING") && ft().supportDualStreamEncoding) {
          let l = this.localTrackMap.get(U.LocalVideoLowTrack);
          if (l) {
            let u = n._mediaStreamTrack.clone();
            l.track._originMediaStreamTrack.stop(), l.track._mediaStreamTrack = u, l.track._originMediaStreamTrack = u, await new j((h, p) => {
              this.handleReplaceTrack(l.track, h, p, true);
            });
          }
        }
        i();
      } catch (d) {
        r(d);
      } finally {
        var c;
        (c = s) === null || c === void 0 || c();
      }
    }), T(this, "handleGetRTCStats", (n) => {
      n(this.statsCollector.getRTCStats());
    }), T(this, "handleGetLocalVideoStats", (n) => {
      n(this.statsCollector.getLocalVideoTrackStats());
    }), T(this, "handleGetLocalAudioStats", (n) => {
      n(this.statsCollector.getLocalAudioTrackStats());
    }), T(this, "handleGetRemoteVideoStats", (n) => this.statsCollector.getRemoteVideoTrackStats(n.uid)[n.uid]), T(this, "handleGetRemoteAudioStats", (n) => this.statsCollector.getRemoteAudioTrackStats(n.uid)[n.uid]), this.store = t11, this.statsCollector = e, this.statsCollector.addP2PChannel(this), this.statsUploader = new pu(this.store), this.bindStatsUploaderEvents(), this.isPlanB = !ft().supportUnifiedPlan || v("CHROME_FORCE_PLAN_B") && ho(), this.shouldForwardP2PCreation = v("FORWARD_P2P_CREATION") && ft().supportPCSetConfiguration && lf(), this.shouldForwardP2PCreation && (this.connection = this.isPlanB ? new Va({}, this.store) : new ki({}, this.store), this.bindConnectionEvents(this.connection));
  }
  async startP2PConnection(t11) {
    var e;
    this.state = Rt.New;
    let n = this.shouldForwardP2PCreation && ((e = this.connection) === null || e === void 0 ? void 0 : e.peerConnectionState) === "closed";
    if (this.shouldForwardP2PCreation && !n || (n && this.connection && (_.warning("[".concat(this.store.clientId, "] P2PChannel.startP2PConnection ForwardP2P closed.")), this.connection.close(), this.unbindConnectionEvents(this.connection)), this.connection = this.isPlanB ? new Va(t11, this.store) : new ki(t11, this.store), this.bindConnectionEvents(this.connection)), !this.connection) throw new N(R.UNEXPECTED_ERROR, "Cannot P2PChannel.startConnection before P2PConnection initialization .");
    return this._pcStatsUploadType = v("NEW_ICE_RESTART") ? Tr.FIRST_CONNECTION : Tr.OLD_FIRST_CONNECTION, this._isFirstConnected = true, this._isInRestartIce = false, this._isStartRestartIce = false, this.connection.setConfiguration(t11), this.connection.establishPromise;
  }
  async connect(t11) {
    if (!this.connection) throw new N(R.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
    v("ENABLE_PREALLOC_PC") && this.state === Rt.Connected ? await this.connection.updateRemoteConnect(t11) : (this.store.peerConnectionStart(), await this.connection.connect(t11), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = Rt.Connected);
  }
  updateRemoteRTPCapabilities(t11) {
    let e = Array.from(this.localTrackMap.entries()).filter((r) => {
      var o;
      let [s] = r;
      return W(o = [U.LocalVideoLowTrack, U.LocalVideoTrack]).call(o, s);
    }), n = e.map((r) => {
      let [, { id: o }] = r;
      return o;
    }), i = e.map((r) => {
      let [o] = r;
      return o;
    });
    if (this.connection instanceof ki) {
      if (X.updateRemoteRTPCapabilities(this.store.sessionId, { trackTypes: JSON.stringify(i), localCodecs: JSON.stringify(this.connection.localCodecs), remoteCodecs: JSON.stringify(t11) }), !W(t11).call(t11, this.store.codec)) {
        let r = ["vp9", "vp8", "h264"].find((o) => W(t11).call(t11, o));
        r && (this.store.codec = r, _.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, " updateRemoteRTPCapabilities] default codec is not available, hence the fallback to ").concat(r, ".")));
      }
      this.connection.updateRemoteRTPCapabilities(n, t11);
    }
  }
  async getEstablishParams() {
    var t11;
    if (this.connection instanceof ki && this.connection.peerConnectionState !== "closed" && W(t11 = [Rt.New, Rt.Connected]).call(t11, this.state)) return this.connection.establishPromise;
  }
  async publishDataChannel(t11) {
    if (!this.connection || this.state !== Rt.Connected) {
      if (this.state === Rt.Disconnected) throw new N(R.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
      return t11.forEach((n) => {
        var i;
        W(i = this.pendingLocalDataChannels).call(i, n) || this.pendingLocalDataChannels.push(n);
      }), [];
    }
    let e = this.filterTobePublishedDataChannels(t11);
    return e.length === 0 ? [] : (e.forEach((n) => {
      let i = Date.now();
      this.store.publish(n.id.toString(), "datachannel", i);
    }), await this.connection.createDataChannels(this.store.uid, e), e.forEach((n) => {
      this.localDataChannels.push(n);
      let i = Date.now();
      this.store.publish(n.id + "", "datachannel", void 0, i);
    }), t11.map((n) => ({ streamId: n.id, ordered: n.ordered, maxRetransmits: n.maxRetransmits, metadata: n.metadata, channelId: n._originDataChannelId })));
  }
  publish(t11, e, n) {
    var i = this;
    return Bi(function* () {
      let r = yield Tt(i.mutex.lock("From P2PChannel.publish"));
      try {
        if (!i.connection || i.state !== Rt.Connected) {
          if (i.state === Rt.Disconnected) throw new N(R.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
          i.throwIfTrackTypeNotMatch(t11);
          let s = t11.filter((a) => i.pendingLocalTracks.indexOf(a) === -1);
          return void (i.pendingLocalTracks = i.pendingLocalTracks.concat(s));
        }
        i.store.pubId = i.store.pubId + 1, qe.markPublishStart(i.store.clientId, i.store.pubId);
        let o = i.filterTobePublishedTracks(t11, e, n);
        if (o.length === 0) return void (yield Tt(i.tryToUnmuteAudio(t11)));
        yield* kv(Hv(i.doPublish(i.connection, o)));
      } finally {
        r();
      }
    })();
  }
  doPublish(t11, e) {
    var n = this;
    return Bi(function* () {
      e.forEach((u) => {
        let { track: h, type: p } = u, g = Date.now();
        n.store.publish(h.getTrackId(), p === U.LocalAudioTrack ? "audio" : "video", g);
      }), n.bindLocalTrackEvents(e);
      let i = e.map((u) => {
        let { track: h } = u;
        return h;
      }), r = yield Tt(t11.send(e.map((u) => {
        let { track: h } = u;
        return h;
      }), n.store.codec, n.store.audioCodec)), o = (yield Tt(r.next())).value, s = n.createGatewayPublishMessage(e, o), a;
      try {
        a = yield s;
      } catch (u) {
        throw r.throw(u), (u == null ? void 0 : u.code) === R.WS_ABORT && e.forEach((h) => {
          let { track: p } = h;
          n.pendingLocalTracks.indexOf(p) === -1 && n.pendingLocalTracks.push(p);
        }), n.unbindLocalTrackEvents(e), u;
      }
      let c = n.mapPubResToRemoteConfig(s, a), d = (yield Tt(r.next(c))).value, l = v("ENABLE_VIDEO_SEI");
      i.forEach(async (u) => {
        let h = u.getRTCRtpTransceiver();
        h && l && (u.trackMediaType === Q.VIDEO ? await BG(h.sender, u) : u.trackMediaType === Q.AUDIO && await async function(p) {
          if (!ft().supportWebRTCEncodedTransform) return void _.warning("browser not support audio encoded transform");
          if (Bd.has(p) || !p.track) return;
          let g = { track: p.track };
          if (oo()) {
            if (!p.createEncodedStreams) return void _.warning("browser not support createEncodedStreams() API");
            let f = null;
            try {
              f = p.createEncodedStreams();
            } catch (C) {
              return void _.error("create audio-encoded-streams error", C && C.message);
            }
            let S = new TransformStream({ transform(C, A) {
              g.controller || (g.controller = A), p.track && p.track.id !== g.track.id && (_.debug("audio track changed: ".concat(g.track.id, " => ").concat(p.track.id)), g.track.removeEventListener("ended", E), g.track = p.track, g.track.addEventListener("ended", E)), A.enqueue(C);
            } });
            f.readable.pipeThrough(S).pipeTo(f.writable);
          } else if (je()) {
            if (typeof RTCRtpScriptTransform > "u") return void _.warning("browser not support RTCRtpScriptTransform");
            let f = vl(), S = new MessageChannel();
            await new j((A) => f.onmessage = (b) => {
              b.data === "registered" && A(void 0);
            });
            let C = new RTCRtpScriptTransform(f, { name: "tx", port: S.port2 }, [S.port2]);
            p.transform = C, await new j((A) => f.onmessage = (b) => {
              b.data === "started" && A(void 0);
            }), S.port1.onmessage = (A) => {
              var b;
              A.data.transformed && p.track && ((b = p.track) === null || b === void 0 ? void 0 : b.id) !== g.track.id && (_.debug("audio track changed: ".concat(g.track.id, " => ").concat(p.track.id)), g.track.removeEventListener("ended", E), g.track = p.track, g.track.addEventListener("ended", E));
            }, g.worker = f;
          }
          function E() {
            if (p.track) {
              if (this.id !== p.track.id) return;
              p.track.removeEventListener("ended", E);
            }
            let f = Bd.get(p);
            if (f) {
              Bd.delete(p);
              try {
                var S, C;
                (S = f.controller) === null || S === void 0 || S.terminate(), (C = f.worker) === null || C === void 0 || C.terminate();
              } catch (A) {
                _.warning(A && A.message);
              }
            }
          }
          Bd.set(p, g), p.track.addEventListener("ended", E);
        }(h.sender));
      }), e.forEach((u) => {
        let { type: h } = u;
        n.statsCollector.addLocalStats(h);
      }), n.assignLocalTracks(e, d), n.statsUploader.startUploadOutboundStats(), e.forEach((u) => {
        let { track: h, type: p } = u, g = Date.now();
        n.store.publish(h.getTrackId(), p === U.LocalAudioTrack ? "audio" : "video", void 0, g);
      });
    })();
  }
  async updateVideoStreamParameter(t11, e) {
    let n = this.localTrackMap.get(e);
    if (!n) return;
    if (!(n.track instanceof Ft)) return _.warn("[updateVideoStreamParameter]: track is not an instance of LocalVideoTrack");
    if (!(this.connection instanceof ki || this.connection instanceof Va)) return _.warn("[updateVideoStreamParameter]: connection is not P2PConnection or P2PConnectionPlanB");
    let { track: i } = n, r = function(o, s) {
      let a = {};
      return o.height && o.width && (a.scaleResolutionDownBy = GE(o, s)), a.maxFramerate = o.framerate ? Nn(o.framerate) : void 0, a.maxBitrate = o.bitrate ? 1e3 * o.bitrate : void 0, a;
    }(t11, i);
    if (i._encoderConfig || (i._encoderConfig = {}), e !== U.LocalVideoLowTrack || !v("DISABLE_DUAL_STREAM_USE_ENCODING") && ft().supportDualStreamEncoding) r.scaleResolutionDownBy != null && (i._encoderConfig.scaleResolutionDownBy = r.scaleResolutionDownBy);
    else {
      let o = i._originMediaStreamTrack;
      if (!o.canvas) return _.warn("[".concat(i.getTrackId(), "] no canvas on track"));
      (function(s, a) {
        let c = s.canvas;
        a.width && (c.width = Nn(a.width)), a.height && (c.height = Nn(a.height)), a.framerate && (c.stopCapture && c.stopCapture(), c.stopCapture = Rf(() => {
          !c.startCapture && c.stopCapture && c.stopCapture(), c.startCapture && c.startCapture();
        }, Nn(a.framerate)));
      })(o, t11);
    }
    r.maxBitrate != null && (i._encoderConfig.bitrateMax = r.maxBitrate / 1e3), r.maxFramerate != null && (i._encoderConfig.frameRate && typeof i._encoderConfig.frameRate == "object" ? i._encoderConfig.frameRate.max = r.maxFramerate : i._encoderConfig.frameRate = { max: r.maxFramerate }), _.debug("[".concat(i.getTrackId(), "] LowStreamEncoderConfig: , ").concat(JSON.stringify(i._encoderConfig))), await this.connection.updateRtpSenderEncodings(i);
  }
  publishLowStream(t11) {
    var e = this;
    return Bi(function* () {
      if (!e.connection || e.state !== Rt.Connected) return;
      let n = yield Tt(e.mutex.lock("Locking from P2PChannel.publishLowStream"));
      try {
        let r = e.localTrackMap.get(U.LocalVideoTrack);
        if (!r) throw new N(R.UNEXPECTED_ERROR, "Could not find high stream");
        if (e.localTrackMap.has(U.LocalVideoLowTrack)) throw new N(R.UNEXPECTED_ERROR, "[".concat(e.store.clientId, "] Can't publish low stream when stream already publish"));
        let o = [{ track: e.getLowVideoTrack(r.track, t11), type: U.LocalVideoLowTrack }];
        if (yield* kv(Hv(e.doPublish(e.connection, o))), r.track.muted || !r.track.enabled) {
          var i;
          let s = (i = e.localTrackMap.get(U.LocalVideoLowTrack)) === null || i === void 0 ? void 0 : i.id;
          s !== void 0 && (yield Tt(e.connection.muteLocal([s])));
        }
      } finally {
        n();
      }
    })();
  }
  async republish() {
    this.pendingLocalTracks.length > 0 && (_.debug("[".concat(this.store.clientId, "] Emit P2PChannelEvents.RequestRePublish to republish tracks.")), await Ge(this, tt.RequestRePublish, this.pendingLocalTracks), this.emit(tt.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []), this.pendingLocalDataChannels.length > 0 && (_.debug("Emit P2PChannelEvents.RequestRePublishDataChannel to republish datachannels."), await Ge(this, tt.RequestRePublishDataChannel, this.pendingLocalDataChannels), this.pendingLocalDataChannels = []);
  }
  async reSubscribe(t11) {
    for (let e = this.pendingRemoteTracks.length - 1; e >= 0; e--) {
      let { user: n, kind: i } = this.pendingRemoteTracks[e];
      (i !== Q.AUDIO || n._audio_added_ && n._audioSSRC) && (i !== Q.VIDEO || n._video_added_ && n._videoSSRC) || this.pendingRemoteTracks.splice(e, 1);
    }
    if (t11) await Ge(this, tt.RequestReSubscribe, this.pendingRemoteTracks);
    else for (let { user: e, kind: n } of this.pendingRemoteTracks) await this.subscribe(e, n, n === Q.VIDEO ? e._videoSSRC : e._audioSSRC);
    this.pendingRemoteTracks.forEach((e) => {
      let { user: n } = e;
      this.emit(tt.MediaReconnectEnd, n.uid);
    }), this.pendingRemoteTracks = [];
  }
  async unpublish(t11) {
    if (!this.connection || this.state !== Rt.Connected) return void t11.forEach((i) => {
      let r = this.pendingLocalTracks.indexOf(i);
      r !== -1 && this.pendingLocalTracks.splice(r, 1);
    });
    let e = this.filterTobeUnpublishedTracks(t11);
    if (e.length === 0) return;
    let n = e.find((i) => i[0] === "videoLowTrack");
    return n && n[1].track.close(), this.doUnpublish(this.connection, e);
  }
  async unpublishDataChannel(t11) {
    if (!this.connection || this.state !== Rt.Connected) return void t11.forEach((n) => {
      let i = this.pendingLocalDataChannels.indexOf(n);
      i !== -1 && this.pendingLocalDataChannels.splice(i, 1);
    });
    let e = this.filterTobeUnpublishedDataChannels(t11);
    return e.length !== 0 ? (e.forEach((n) => {
      let i = this.localDataChannels.indexOf(n);
      i !== -1 && this.localDataChannels.splice(i, 1);
    }), this.localDataChannels.length === 0 && await this.connection.stopDataChannels(this.store.uid), e.map((n) => n.id)) : void 0;
  }
  async unpublishLowStream() {
    if (!this.connection || this.state !== Rt.Connected) return;
    let t11 = this.localTrackMap.get(U.LocalVideoLowTrack);
    if (!t11) return;
    t11.track.close();
    let e = [[U.LocalVideoLowTrack, t11]];
    return this.doUnpublish(this.connection, e);
  }
  async doUnpublish(t11, e) {
    let n = this.createGatewayUnpublishMessage(e);
    return await t11.stopSending(e.map((i) => {
      let [, { id: r }] = i;
      return r;
    })), this.withdrawLocalTracks(e), this.unbindLocalTrackEvents(e.map((i) => {
      let [r, { track: o }] = i;
      return { type: r, track: o };
    })), e.forEach((i) => {
      let [r] = i;
      this.statsCollector.removeLocalStats(r);
    }), this.localTrackMap.size === 0 && this.statsUploader.stopUploadOutboundStats(), n;
  }
  async subscribeDataChannel(t11, e) {
    if (!this.connection || this.state !== Rt.Connected) throw new N(R.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
    let n = e.filter((i) => {
      var r;
      return !((r = this.remoteDataChannelMap.get(t11)) !== null && r !== void 0 && r.get(i.id));
    });
    if (n.length !== 0) return await this.connection.createDataChannels(t11.uid, n), n.forEach((i) => {
      var r;
      this.remoteDataChannelMap.has(t11) ? (r = this.remoteDataChannelMap.get(t11)) === null || r === void 0 || r.set(i.id, i) : this.remoteDataChannelMap.set(t11, /* @__PURE__ */ new Map([[i.id, i]]));
      let o = this.pendingRemoteDataChannels.findIndex((s) => {
        let { user: a, id: c } = s;
        return a.uid === t11.uid && c === i.id;
      });
      o !== -1 && this.pendingRemoteDataChannels.splice(o, 1);
    }), n.map((i) => i.id);
  }
  async subscribe(t11, e, n, i, r) {
    var o;
    if (!this.connection || this.state !== Rt.Connected) throw new N(R.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
    if ((o = this.remoteUserMap.get(t11)) !== null && o !== void 0 && o.has(e)) return;
    let s, a, c, d = this.connection.getPreMedia(n);
    if (d) _.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] preSSRCMap has ssrcId: ").concat(n, ", no need to send sub to gateway.")), c = d.transceiver, s = d.track, a = d.id;
    else if (r) {
      let h = r.find((g) => {
        let { stream_type: E } = g;
        return E === e;
      });
      if (!h) throw new N(R.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(e, " for user: ").concat(t11.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(e, "."));
      let p = await this.connection.receive(e, h.ssrcs, String(t11._uintid), h.attributes);
      this.connection instanceof ki && (c = p.transceiver), s = p.track, a = p.id;
    } else {
      let h = await this.connection.receive(e, [{ ssrcId: n, rtx: i }], String(t11._uintid), void 0);
      this.connection instanceof ki && (c = h.transceiver), s = h.track, a = h.id;
    }
    e === Q.AUDIO ? (t11._audioTrack ? t11._audioTrack._updateOriginMediaStreamTrack(s) : (t11._audioTrack = new Ks(s, t11.uid, t11._uintid, this.store), _.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(t11._audioTrack.getTrackId()))), c && t11._audioTrack._updateRtpTransceiver(c), this.bindRemoteTrackEvents(t11, t11._audioTrack)) : (t11._videoTrack ? t11._videoTrack._updateOriginMediaStreamTrack(s) : (t11._videoTrack = new Hs(s, t11.uid, t11._uintid, this.store), _.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(t11._videoTrack.getTrackId()))), c && t11._videoTrack._updateRtpTransceiver(c), this.bindRemoteTrackEvents(t11, t11._videoTrack)), v("ENABLE_VIDEO_SEI") && c && (e == Q.VIDEO ? await async function(h) {
      let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!ft().supportWebRTCEncodedTransform) return void _.warning("browser not support video encoded transform");
      if (!h.track) return;
      if (xa.has(h)) {
        let f = xa.get(h);
        return void (f && (f.onSei = p.onSei));
      }
      let g = { track: h.track, onSei: p.onSei };
      if (oo()) {
        if (!h.createEncodedStreams) return void _.warning("browser not support createEncodedStreams() API");
        let f = null;
        try {
          f = h.createEncodedStreams();
        } catch (C) {
          return void _.error("create video-encoded-streams error", C && C.message);
        }
        let S = new TransformStream({ transform(C, A) {
          g.controller || (g.controller = A), h.track && h.track.id !== g.track.id && (_.debug("video track changed: ".concat(g.track.id, " => ").concat(h.track.id)), g.track.removeEventListener("ended", E), g.track = h.track, g.track.addEventListener("ended", E));
          let b = function(w) {
            let D = new DataView(w.data), k = 0;
            for (; k + 4 < w.data.byteLength; ) {
              if (D.getUint8(k + 0) === 0 && D.getUint8(k + 1) === 0 && D.getUint8(k + 2) === 0 && D.getUint8(k + 3) === 1 && D.getUint8(k + 4) === 6) {
                let B = k + 6, V = 0, z = 0;
                for (; (z = D.getUint8(B++)) === 255; ) V += 255;
                V += z;
                let lt = FG(w.data, B, V);
                return new Uint8Array(lt);
              }
              k++;
            }
            return null;
          }(C);
          b && g.onSei && g.onSei(b), A.enqueue(C);
        } });
        f.readable.pipeThrough(S).pipeTo(f.writable);
      } else if (je()) {
        if (typeof RTCRtpScriptTransform > "u") return void _.warning("browser not support RTCRtpScriptTransform");
        let f = vl(), S = new MessageChannel();
        await new j((A) => f.onmessage = (b) => {
          b.data === "registered" && A(void 0);
        });
        let C = new RTCRtpScriptTransform(f, { name: "rx", port: S.port2 }, [S.port2]);
        h.transform = C, await new j((A) => f.onmessage = (b) => {
          b.data === "started" && A(void 0);
        }), S.port1.onmessage = (A) => {
          var b;
          A.data.transformed && h.track && ((b = h.track) === null || b === void 0 ? void 0 : b.id) !== g.track.id ? (_.debug("video track changed: ".concat(g.track.id, " => ").concat(h.track.id)), g.track.removeEventListener("ended", E), g.track = h.track, g.track.addEventListener("ended", E)) : A.data.sei && g.onSei && g.onSei(A.data.sei);
        }, g.worker = f;
      }
      function E() {
        if (h.track) {
          if (this.id !== h.track.id) return;
          h.track.removeEventListener("ended", E);
        }
        (function(f) {
          let S = xa.get(f);
          if (S) {
            xa.delete(f);
            try {
              var C, A;
              (C = S.controller) === null || C === void 0 || C.terminate(), (A = S.worker) === null || A === void 0 || A.terminate();
            } catch (b) {
              _.warning(b && b.message);
            }
          }
        })(h);
      }
      xa.set(h, g), h.track.addEventListener("ended", E);
    }(c.receiver, { onSei: (h) => {
      var p;
      (p = t11._videoTrack) === null || p === void 0 || p._onSei(h);
    } }) : e == Q.AUDIO && await async function(h) {
      if (!ft().supportWebRTCEncodedTransform) return void _.warning("browser not support audio encoded transform");
      if (jd.has(h)) return;
      let p = { track: h.track };
      if (oo()) {
        if (!h.createEncodedStreams) return void _.warning("browser not support createEncodedStreams() API");
        let E = null;
        try {
          E = h.createEncodedStreams();
        } catch (S) {
          return void _.error("create audio-encoded-streams error", S && S.message);
        }
        let f = new TransformStream({ transform(S, C) {
          p.controller || (p.controller = C), h.track && h.track.id !== p.track.id && (_.debug("audio track changed: ".concat(p.track.id, " => ").concat(h.track.id)), p.track.removeEventListener("ended", g), p.track = h.track, p.track.addEventListener("ended", g)), C.enqueue(S);
        } });
        E.readable.pipeThrough(f).pipeTo(E.writable);
      } else if (je()) {
        if (typeof RTCRtpScriptTransform > "u") return void _.warning("browser not support RTCRtpScriptTransform");
        let E = vl(), f = new MessageChannel();
        await new j((C) => E.onmessage = (A) => {
          A.data === "registered" && C(void 0);
        });
        let S = new RTCRtpScriptTransform(E, { name: "rx", port: f.port2 }, [f.port2]);
        h.transform = S, await new j((C) => E.onmessage = (A) => {
          A.data === "started" && C(void 0);
        }), f.port1.onmessage = (C) => {
          var A;
          C.data.transformed && h.track && ((A = h.track) === null || A === void 0 ? void 0 : A.id) !== p.track.id && (_.debug("audio track changed: ".concat(p.track.id, " => ").concat(h.track.id)), p.track.removeEventListener("ended", g), p.track = h.track, p.track.addEventListener("ended", g));
        }, p.worker = E;
      }
      function g() {
        h.track.removeEventListener("ended", g), function(E) {
          let f = jd.get(E);
          if (f) {
            jd.delete(E);
            try {
              var S, C;
              (S = f.controller) === null || S === void 0 || S.terminate(), (C = f.worker) === null || C === void 0 || C.terminate();
            } catch (A) {
              _.warning(A && A.message);
            }
          }
        }(h);
      }
      jd.set(h, p), h.track.addEventListener("ended", g);
    }(c.receiver));
    let l = this.remoteUserMap.get(t11);
    l ? l.set(e, a) : this.remoteUserMap.set(t11, /* @__PURE__ */ new Map([[e, a]])), this.statsCollector.addRemoteStats(t11.uid), this.statsUploader.startUploadInboundStats();
    let u = this.pendingRemoteTracks.findIndex((h) => {
      let { user: p, kind: g } = h;
      return p.uid === t11.uid && e === g;
    });
    u !== -1 && (this.pendingRemoteTracks.splice(u, 1), this.emit(tt.MediaReconnectEnd, t11.uid));
  }
  async massSubscribe(t11) {
    return this.massSubscribeNoLock(t11);
  }
  async massSubscribeNoLock(t11) {
    if (!this.connection || this.state !== Rt.Connected) throw new N(R.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected.");
    t11 = t11.filter((r) => {
      var o;
      let { user: s, mediaType: a } = r;
      return !((o = this.remoteUserMap.get(s)) !== null && o !== void 0 && o.has(a));
    });
    let e = [], n = /* @__PURE__ */ new Map();
    t11.forEach((r) => {
      if (!this.connection) return;
      let o = this.connection.getPreMedia(r.ssrcId);
      o ? n.set(r.ssrcId, o) : e.push(r);
    });
    let i = await this.connection.batchReceive(e.map((r) => {
      let { user: o, mediaType: s, ssrcId: a, rtxSsrcId: c } = r;
      return { kind: s, ssrcMsg: [{ ssrcId: a, rtx: c }], mslabel: String(o._uintid) };
    }));
    e.forEach((r, o) => {
      n.set(r.ssrcId, i[o]);
    }), t11.forEach((r) => {
      let { user: o, mediaType: s, ssrcId: a } = r, c = n.get(a);
      if (!c) return void _.debug("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] cannot find ").concat(o.uid, " subscribe data,").concat(s, ", ").concat(a));
      let { track: d, id: l, transceiver: u } = c;
      s === Q.AUDIO ? (o._audioTrack ? o._audioTrack._updateOriginMediaStreamTrack(d) : (o._audioTrack = new Ks(d, o.uid, o._uintid, this.store), _.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote audio track: ").concat(o._audioTrack.getTrackId()))), u && o._audioTrack._updateRtpTransceiver(u), this.bindRemoteTrackEvents(o, o._audioTrack)) : (o._videoTrack ? o._videoTrack._updateOriginMediaStreamTrack(d) : (o._videoTrack = new Hs(d, o.uid, o._uintid, this.store), _.info("[".concat(this.store.clientId, "] [").concat(this.store.p2pId, "] create remote video track: ").concat(o._videoTrack.getTrackId()))), u && o._videoTrack._updateRtpTransceiver(u), this.bindRemoteTrackEvents(o, o._videoTrack));
      let h = this.remoteUserMap.get(o);
      h ? h.set(s, l) : this.remoteUserMap.set(o, /* @__PURE__ */ new Map([[s, l]])), this.statsCollector.addRemoteStats(o.uid), this.statsUploader.startUploadInboundStats();
      let p = this.pendingRemoteTracks.findIndex((g) => {
        let { user: E, kind: f } = g;
        return E.uid === o.uid && s === f;
      });
      p !== -1 && (this.pendingRemoteTracks.splice(p, 1), this.emit(tt.MediaReconnectEnd, o.uid));
    });
  }
  async unsubscribe(t11, e, n) {
    let i = this.pendingRemoteTracks.filter((s) => {
      let { user: a, kind: c } = s;
      return e !== void 0 ? a.uid === t11.uid && e === c : a.uid === t11.uid;
    });
    if (i.forEach((s) => {
      let a = this.pendingRemoteTracks.indexOf(s);
      this.pendingRemoteTracks.splice(a, 1);
    }), this.connection && this.state === Rt.Connected || n || i.forEach((s) => {
      let { kind: a } = s;
      var c;
      if (a === Q.AUDIO) (c = t11._audioTrack) === null || c === void 0 || c._destroy(), t11._audioTrack = void 0;
      else if (a === Q.VIDEO) {
        var d;
        (d = t11._videoTrack) === null || d === void 0 || d._destroy(), t11._videoTrack = void 0;
      }
    }), !this.connection || this.state !== Rt.Connected) return;
    let r = this.filterTobeUnSubscribedTracks(t11, e);
    if (r.length === 0) return;
    await this.connection.stopReceiving(r.map((s) => {
      let [, { id: a }] = s;
      return a;
    }));
    let o = this.createUnsubscribeMessage(r);
    return this.withdrawRemoteTracks(r), this.remoteUserMap.size === 0 && this.statsUploader.stopUploadInboundStats(), r.forEach((s) => {
      let [a, { kind: c }] = s;
      var d, l;
      if (c === Q.VIDEO && a._videoSSRC && ((d = this.connection) === null || d === void 0 || d.setStatsRemoteVideoIsReady(a._videoSSRC, false)), c === Q.VIDEO) this.unbindRemoteTrackEvents(a._videoTrack), n || ((l = a._videoTrack) === null || l === void 0 || l._destroy(), a._videoTrack = void 0);
      else if (c === Q.AUDIO) {
        var u;
        this.unbindRemoteTrackEvents(a._audioTrack), !n && ((u = a._audioTrack) === null || u === void 0 || u._destroy(), a._audioTrack = void 0);
      }
    }), o;
  }
  async unsubscribeDataChannel(t11, e) {
    if (e.forEach((r) => {
      let o = this.pendingRemoteDataChannels.findIndex((s) => s.id === r.id);
      o !== -1 && this.pendingRemoteDataChannels.splice(o, 1);
    }), !this.connection) return;
    let n = this.filterTobeUnSubscribedDataChannels(t11, e);
    if (n.length === 0) return;
    e.forEach((r) => {
      r._close();
    });
    let i = this.remoteDataChannelMap.get(t11);
    return n.forEach((r) => {
      i && i.delete(r.id);
    }), i && i.size === 0 && (this.remoteDataChannelMap.delete(t11), await this.connection.stopDataChannels(t11.uid)), n.map((r) => r.id);
  }
  async massUnsubscribe(t11) {
    return this.massUnsubscribeNoLock(t11);
  }
  async massUnsubscribeNoLock(t11) {
    let e = [];
    for (let { user: r, mediaType: o } of t11) {
      let s = this.pendingRemoteTracks.filter((a) => {
        let { user: c, kind: d } = a;
        return o !== void 0 ? c.uid === r.uid && o === d : c.uid === r.uid;
      });
      s.forEach((a) => {
        let c = this.pendingRemoteTracks.indexOf(a);
        this.pendingRemoteTracks.splice(c, 1);
      }), e = e.concat(s);
    }
    if (!this.connection || this.state !== Rt.Connected) return void e.forEach((r) => {
      let { user: o, kind: s } = r;
      var a;
      if (s === Q.AUDIO) (a = o._audioTrack) === null || a === void 0 || a._destroy(), o._audioTrack = void 0;
      else if (s === Q.VIDEO) {
        var c;
        (c = o._videoTrack) === null || c === void 0 || c._destroy(), o._videoTrack = void 0;
      }
    });
    let n = ji(t11).call(t11, (r, o) => {
      let { user: s, mediaType: a } = o, c = this.filterTobeUnSubscribedTracks(s, a);
      return r.concat(c);
    }, []);
    if (n.length === 0) return;
    await this.connection.stopReceiving(n.map((r) => {
      let [, { id: o }] = r;
      return o;
    }));
    let i = this.createUnsubscribeAllMessage(n);
    return this.withdrawRemoteTracks(n), this.remoteUserMap.size === 0 && this.statsUploader.stopUploadInboundStats(), n.forEach((r) => {
      let [o, { kind: s }] = r;
      var a, c;
      if (s === Q.VIDEO && o._videoSSRC && ((a = this.connection) === null || a === void 0 || a.setStatsRemoteVideoIsReady(o._videoSSRC, false)), s === Q.VIDEO) this.unbindRemoteTrackEvents(o._videoTrack), (c = o._videoTrack) === null || c === void 0 || c._destroy(), o._videoTrack = void 0;
      else if (s === Q.AUDIO) {
        var d;
        this.unbindRemoteTrackEvents(o._audioTrack), (d = o._audioTrack) === null || d === void 0 || d._destroy(), o._audioTrack = void 0;
      }
    }), i;
  }
  isPreSubScribe(t11) {
    return !this.connection || this.state !== Rt.Connected ? false : !!this.connection.getPreMedia(t11);
  }
  async muteRemote(t11, e) {
    if (!this.connection) return;
    let n = this.remoteUserMap.get(t11);
    if (!n) return void _.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(t11.uid, "."));
    if (!n.get(e)) return void _.warning("[".concat(this.store.clientId, "] P2PChannel.muteRemote has no remote user ").concat(t11.uid, " media type ").concat(e, "."));
    let i = e === Q.VIDEO ? t11._videoSSRC : t11._audioSSRC;
    i !== void 0 && this.connection.setStatsRemoteVideoIsReady(i, false);
  }
  async unmuteRemote(t11, e) {
    return this.unmuteRemoteNoLock(t11, e);
  }
  async unmuteRemoteNoLock(t11, e) {
    if (!this.connection) return;
    let n = this.remoteUserMap.get(t11);
    if (!n) return void _.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(t11.uid, "."));
    n.get(e) || _.warning("[".concat(this.store.clientId, "] P2PChannel.unmuteRemote has no remote user ").concat(t11.uid, " media type ").concat(e, "."));
  }
  getAllTracks(t11) {
    let e = this.localTrackMap.get(U.LocalAudioTrack);
    if ((e == null ? void 0 : e.track) instanceof ge) {
      let n = e.track;
      return Array.from(this.localTrackMap.entries()).filter((i) => {
        let [r] = i;
        return r !== U.LocalAudioTrack;
      }).filter((i) => {
        let [r] = i;
        return !(t11 && r === U.LocalVideoLowTrack);
      }).map((i) => {
        let [, { track: r }] = i;
        return r;
      }).concat(n.trackList);
    }
    return Array.from(this.localTrackMap.entries()).filter((n) => {
      let [i] = n;
      return !(t11 && i === U.LocalVideoLowTrack);
    }).map((n) => {
      let [, { track: i }] = n;
      return i;
    });
  }
  getAllDataChannels() {
    return this.localDataChannels;
  }
  reportPublishEvent(t11, e, n, i, r) {
    if (t11) {
      let s = this.localTrackMap.get(U.LocalAudioTrack), a = i ? this.localTrackMap.get(U.LocalVideoLowTrack) : this.localTrackMap.get(U.LocalVideoTrack);
      X.publish(this.store.sessionId, { eventElapse: qe.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: t11, ec: e, audioName: s == null ? void 0 : s.track.getTrackLabel(), videoName: a == null ? void 0 : a.track.getTrackLabel(), screenshare: (a == null ? void 0 : a.track._hints.indexOf(Gt.SCREEN_TRACK)) !== -1, audio: !!s, video: !!a, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r });
    } else {
      var o;
      n || (n = []);
      let s = n.find((c) => c instanceof Qt), a = i ? (o = this.localTrackMap.get(U.LocalVideoTrack)) === null || o === void 0 ? void 0 : o.track : n.find((c) => c instanceof Ft);
      X.publish(this.store.sessionId, { eventElapse: qe.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: t11, ec: e, audioName: s == null ? void 0 : s.getTrackLabel(), videoName: a == null ? void 0 : a.getTrackLabel(), screenshare: (a == null ? void 0 : a._hints.indexOf(Gt.SCREEN_TRACK)) !== -1, audio: !!s, video: !!a, p2pid: this.store.p2pId, publishRequestid: this.store.pubId, extend: r });
    }
  }
  reportSubscribeEvent(t11, e, n, i) {
    let r = i === Q.VIDEO ? n._videoSSRC : n._audioSSRC;
    r && X.subscribe(this.store.sessionId, { succ: t11, ec: e, video: i === Q.VIDEO, audio: i === Q.AUDIO, peerid: n.uid, subscribeRequestid: r, p2pid: this.store.p2pId, eventElapse: qe.measureFromSubscribeStart(this.store.clientId, r), preSsrc: this.isPreSubScribe(r) });
  }
  reset() {
    _.debug("[".concat(this.store.clientId, "] P2PChannel.reset")), this.mutex = new ze("P2PChannel-mutex"), this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.shouldForwardP2PCreation && (this.connection = this.isPlanB ? new Va({}, this.store) : new ki({}, this.store), this.bindConnectionEvents(this.connection)), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.unbindRtpTransceiver();
    let t11 = this.localTrackMap.get(U.LocalAudioTrack);
    if ((t11 == null ? void 0 : t11.track) instanceof ge) {
      if (t11.track.trackList.length > 0) {
        let e = t11.track;
        t11.track.trackList.forEach((n) => {
          e.removeAudioTrack(n);
        });
      }
      t11.track.close();
    }
    this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.localDataChannels = [], this.remoteDataChannelMap.clear(), this.pendingLocalDataChannels = [], this.pendingRemoteDataChannels = [], this.state = Rt.Disconnected;
  }
  getStats() {
    var t11;
    return (t11 = this.connection) === null || t11 === void 0 ? void 0 : t11.getStats();
  }
  getRemoteVideoIsReady(t11) {
    var e;
    return ((e = this.connection) === null || e === void 0 ? void 0 : e.getRemoteVideoIsReady(t11)) || false;
  }
  getLocalAudioVolume() {
    let t11 = this.localTrackMap.get(U.LocalAudioTrack);
    if (t11) return t11.track.getVolumeLevel();
  }
  getLocalVideoSize() {
    let t11 = this.localTrackMap.get(U.LocalVideoTrack);
    if (t11) return { width: t11.track.videoWidth || 0, height: t11.track.videoHeight || 0 };
  }
  getEncoderConfig(t11) {
    let e = this.localTrackMap.get(t11);
    return e && e.track instanceof Ft || e && e.track instanceof Qt ? e.track._encoderConfig : void 0;
  }
  getLocalMedia(t11) {
    return this.localTrackMap.get(t11);
  }
  hasLocalMedia() {
    return this.localTrackMap.size > 0;
  }
  hasRemoteMedia(t11, e) {
    if (!t11) return this.remoteUserMap.size > 0;
    let n = this.remoteUserMap.get(t11);
    return !!n && (!e || n.has(e));
  }
  async hasRemoteMediaWithLock(t11, e) {
    if (!t11) return this.remoteUserMap.size > 0;
    let n = this.remoteUserMap.get(t11);
    return !!n && (!e || n.has(e));
  }
  getRemoteMedia(t11) {
    var e;
    let n = Array.from(xn(e = this.remoteUserMap).call(e)).find((i) => i.uid === t11);
    return n ? { audioTrack: n.audioTrack, audioSSRC: n._audioSSRC, videoTrack: n.videoTrack, videoSSRC: n._videoSSRC } : {};
  }
  getAudioLevels() {
    let t11 = Array.from(this.remoteUserMap.entries()).map((n) => {
      let [i] = n;
      return { uid: i.uid, level: i.audioTrack ? 100 * i.audioTrack._source.getAccurateVolumeLevel() : 0 };
    }), e = this.localTrackMap.get(U.LocalAudioTrack);
    return e && t11.push({ level: 100 * e.track._source.getAccurateVolumeLevel(), uid: this.store.uid }), t11 = ed(t11).call(t11, (n, i) => n.level - i.level), t11;
  }
  async disconnectForReconnect() {
    this.connection && (_.debug("[".concat(this.store.clientId, "] P2PChannel.disconnectForReconnect closing P2PConnection")), this.state = Rt.Reconnecting, v("KEEP_LAST_FRAME") && this.remoteUserMap.size !== 0 && Array.from(this.remoteUserMap.entries()).forEach((t11) => {
      let [e] = t11;
      var n;
      e._videoTrack && e._videoTrack._player && ((n = e._videoTrack._player.getVideoElement()) === null || n === void 0 || n.pause(), e._videoTrack._player.isKeepLastFrame = true, e._videoTrack._originMediaStreamTrack.stop());
    }), this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0, this.shouldForwardP2PCreation && (this.connection = this.isPlanB ? new Va({}, this.store) : new ki({}, this.store), this.bindConnectionEvents(this.connection)), this.localTrackMap.size !== 0 && (Array.from(this.localTrackMap.entries()).forEach((t11) => {
      var e;
      let [n, { track: i }] = t11;
      switch (n) {
        case U.LocalVideoTrack:
          W(e = i._hints).call(e, Gt.LOW_STREAM) ? i.close() : this.pendingLocalTracks.push(i);
          break;
        case U.LocalAudioTrack:
          i instanceof ge ? this.pendingLocalTracks = this.pendingLocalTracks.concat(i.trackList) : this.pendingLocalTracks.push(i);
        case U.LocalVideoLowTrack:
      }
    }), this.emit(tt.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), this.remoteUserMap.size !== 0 && Array.from(this.remoteUserMap.entries()).forEach((t11) => {
      let [e, n] = t11;
      Array.from(xn(n).call(n)).forEach((i) => {
        this.setPendingRemoteMedia(e, i);
      }), this.emit(tt.MediaReconnectStart, e.uid);
    }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.localDataChannels.length !== 0 && (this.localDataChannels.forEach((t11) => {
      this.pendingLocalDataChannels.push(t11);
    }), this.localDataChannels.length = 0), this.remoteDataChannelMap.size !== 0 && (Array.from(this.remoteDataChannelMap.entries()).forEach((t11) => {
      let [e, n] = t11;
      Array.from(xn(n).call(n)).forEach((i) => {
        this.setPendingRemoteDataChannel(e, i);
      });
    }), this.remoteDataChannelMap.clear()), this.statsUploader.stopUploadOutboundStats(), this.statsUploader.stopUploadInboundStats(), this.statsUploader.stopUploadTransportStats(), _.debug("[".concat(this.store.clientId, "] P2PChannel disconnected, waiting to reconnect.")));
  }
  hasPendingRemoteDataChannel(t11, e) {
    for (let n of this.pendingRemoteDataChannels) {
      let { user: i, id: r } = n;
      if ((t11 instanceof ir ? t11.uid : t11) === i.uid && r === e) return true;
    }
    return false;
  }
  setPendingRemoteDataChannel(t11, e) {
    this.hasPendingRemoteDataChannel(t11, e) || this.pendingRemoteDataChannels.push({ user: t11, id: e });
  }
  hasPendingRemoteMedia(t11, e) {
    for (let n of this.pendingRemoteTracks) {
      let { user: i, kind: r } = n;
      if ((t11 instanceof ir ? t11.uid : t11) === i.uid && e === r) return true;
    }
    return false;
  }
  setPendingRemoteMedia(t11, e) {
    this.hasPendingRemoteMedia(t11, e) || this.pendingRemoteTracks.push({ user: t11, kind: e });
  }
  restartICE(t11) {
    var e = this;
    return Bi(function* () {
      if (!e.connection || e.state !== Rt.Connected) return;
      let n = yield Tt(e.mutex.lock("From P2PChannel.restartICE")), i;
      try {
        i = yield Tt(e.connection.restartICE(t11));
        let o = yield Tt(i.next());
        if (o.done) return;
        let s = o.value, a = yield s;
        switch (e.reportPCDisconnectedOrFailed(t11), t11) {
          case On.TCP:
            e._pcStatsUploadType = Tr.TCP_RESTART;
            break;
          case On.RELAY:
            e._pcStatsUploadType = Tr.RELAY_RESTART;
            break;
          default:
            e._pcStatsUploadType = Tr.OLD_RESTART;
        }
        e._isInRestartIce = true, i.next(a);
      } catch (o) {
        var r;
        (r = i) === null || r === void 0 || r.throw(o);
      } finally {
        n();
      }
    })();
  }
  getUplinkNetworkQuality() {
    if (!this.connection) return 0;
    let t11 = this.connection.getStats(), e = this.localTrackMap.get(U.LocalVideoTrack), n = this.localTrackMap.get(U.LocalAudioTrack), i = t11.videoSend.find((p) => p.ssrc === (e == null ? void 0 : e.ssrcs[0].ssrcId)), r = t11.audioSend.find((p) => p.ssrc === (n == null ? void 0 : n.ssrcs[0].ssrcId));
    if (!i || !r) return 1;
    let o = ni(this, tt.NeedSignalRTT), s = i ? i.rttMs : void 0, a = r ? r.rttMs : void 0, c = s && a ? (s + a) / 2 : s || a, d = (c && o ? (c + o) / 2 : c || o) || 0, l = 100 * t11.sendPacketLossRate * 0.7 / 50 + 0.3 * d / 1500, u = l < 0.17 ? 1 : l < 0.36 ? 2 : l < 0.59 ? 3 : l < 0.1 ? 4 : 5, h = e == null ? void 0 : e.track;
    if (h && h._encoderConfig && h._hints.indexOf(Gt.SCREEN_TRACK) === -1) {
      let p = h._encoderConfig.bitrateMax, g = t11.bitrate.actualEncoded;
      if (p && g) {
        let E = (1e3 * p - g) / (1e3 * p);
        return OO[E < 0.15 ? 0 : E < 0.3 ? 1 : E < 0.45 ? 2 : E < 0.6 ? 3 : 4][u];
      }
    }
    return u;
  }
  getDownlinkNetworkQuality() {
    if (!this.connection) return 0;
    let t11 = this.connection.getStats(), e = 0;
    return Array.from(this.remoteUserMap.entries()).forEach((n) => {
      let [i] = n, r = i._audioSSRC, o = i._videoSSRC, s = t11.audioRecv.find((g) => g.ssrc === r), a = t11.videoRecv.find((g) => g.ssrc === o);
      if (!s && !a) return void (e += 1);
      let c = ni(this, tt.NeedSignalRTT), d = t11.rtt, l = (d && c ? (d + c) / 2 : d || c) || 0, u = s ? s.jitterMs : void 0, h = t11.recvPacketLossRate, p = 0.7 * h * 100 / 50 + 0.3 * l / 1500;
      u && (p = 0.6 * h * 100 / 50 + 0.2 * l / 1500 + 0.2 * u / 400), e += p < 0.1 ? 1 : p < 0.17 ? 2 : p < 0.36 ? 3 : p < 0.59 ? 4 : 5;
    }), this.remoteUserMap.size > 0 ? Math.round(e / this.remoteUserMap.size) : e;
  }
  async muteLocalTrack(t11) {
    return new j((e, n) => {
      this.handleMuteLocalTrack(t11, e, n);
    });
  }
  async replaceTrack(t11, e) {
    var n;
    if (_.debug("[".concat(this.store.clientId, "] P2PChannel replaceTrack from [").concat(t11.getTrackId(), "] to [").concat(e.getTrackId(), "]")), !this.connection || this.state !== Rt.Connected) return;
    let i = Array.from(this.localTrackMap.entries()).find((o) => {
      let [, { track: s }] = o;
      return t11 === s;
    });
    if (!i) return;
    let r = i[0];
    if (t11 !== e && (this.unbindLocalTrackEvents([{ track: t11, type: r }]), this.bindLocalTrackEvents([{ track: e, type: r }]), i[1].track = e), await ((n = this.connection) === null || n === void 0 ? void 0 : n.replaceTrack(e, i[1].id)), this.isPlanB) {
      let o = i[1];
      o.id = e._mediaStreamTrack.id, this.localTrackMap.set(r, o);
    }
    if (r === U.LocalVideoTrack && !v("DISABLE_DUAL_STREAM_USE_ENCODING") && ft().supportDualStreamEncoding) {
      let o = this.localTrackMap.get(U.LocalVideoLowTrack);
      if (o) {
        let s = t11._mediaStreamTrack.clone();
        o.track._originMediaStreamTrack.stop(), o.track._mediaStreamTrack = s, o.track._originMediaStreamTrack = s, await new j((a, c) => {
          this.handleReplaceTrack(o.track, a, c, true);
        });
      }
    }
  }
  filterTobePublishedTracks(t11, e, n) {
    let i = [], r = this.getAllTracks();
    t11 = Ls(t11 = t11.filter((c) => r.indexOf(c) === -1));
    let o, s = false, a = this.localTrackMap.get(U.LocalAudioTrack);
    for (let c of t11) {
      if (c instanceof Ft && (this.localTrackMap.has(U.LocalVideoTrack) || s ? new N(R.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (i.push({ track: c, type: U.LocalVideoTrack }), s = true), e)) {
        let d = this.getLowVideoTrack(c, n);
        i.push({ track: d, type: U.LocalVideoLowTrack });
      }
      if (c instanceof Qt) if (a) {
        let d = a.track;
        if (d instanceof ge) lm([c]), d.addAudioTrack(c), this.bindLocalAudioTrackEvents(c, true);
        else {
          let l = E_([d, c]);
          _.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will replace audioTrack [").concat(l.getTrackId(), "]")), this.replaceTrack(d, l);
        }
      } else o instanceof ge ? (lm([c]), o.addAudioTrack(c)) : o || !c._useAudioElement && ft().webAudioMediaStreamDest && !c._bypassWebAudio ? o = E_(o ? [c, o] : [c]) : o = c;
    }
    return o && (_.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection will send audioTrack [").concat(o.getTrackId(), "]")), i.push({ track: o, type: U.LocalAudioTrack })), i;
  }
  filterTobeUnpublishedTracks(t11) {
    let e = [], n = this.getAllTracks();
    t11 = Ls(t11 = t11.filter((i) => n.indexOf(i) !== -1));
    for (let i of t11) {
      if (i instanceof Qt) {
        let r = this.localTrackMap.get(U.LocalAudioTrack);
        if (!r) continue;
        r.track instanceof ge ? (r.track.removeAudioTrack(i), this.unbindLocalAudioTrackEvents(i), r.track.trackList.length === 0 && (e.push([U.LocalAudioTrack, r]), r.track.close())) : e.push([U.LocalAudioTrack, r]);
      }
      if (i instanceof Ft) {
        let r = this.localTrackMap.get(U.LocalVideoTrack);
        if (!r) continue;
        e.push([U.LocalVideoTrack, r]);
        let o = this.localTrackMap.get(U.LocalVideoLowTrack);
        o && e.push([U.LocalVideoLowTrack, o]);
      }
    }
    return e;
  }
  filterTobePublishedDataChannels(t11) {
    return t11 = (t11 = Ls(t11)).filter((e) => this.localDataChannels.findIndex((n) => n.id === e.id) === -1);
  }
  filterTobeUnpublishedDataChannels(t11) {
    return t11 = (t11 = (t11 = Ls(t11)).filter((e) => this.localDataChannels.indexOf(e) !== -1)).filter((e) => e._originDataChannel);
  }
  bindLocalTrackEvents(t11) {
    t11.forEach((e) => {
      let { track: n, type: i } = e;
      switch (i) {
        case U.LocalVideoTrack:
          n.addListener(H.GET_STATS, this.handleGetLocalVideoStats), n.addListener(H.GET_RTC_STATS, this.handleGetRTCStats), n.addListener(H.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), n.addListener(H.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), n.addListener(H.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), n.addListener(H.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), n.addListener(H.NEED_REPLACE_TRACK, this.handleReplaceTrack), n.addListener(H.NEED_MUTE_TRACK, this.handleMuteLocalTrack), n.addListener(H.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          break;
        case U.LocalAudioTrack:
          this.bindLocalAudioTrackEvents(n);
        case U.LocalVideoLowTrack:
      }
    });
  }
  bindLocalAudioTrackEvents(t11, e) {
    t11 instanceof ge ? t11.trackList.forEach((n) => {
      n.addListener(H.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), n.addListener(H.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), n.addListener(H.GET_STATS, this.handleGetLocalAudioStats), n.addListener(H.NEED_MUTE_TRACK, this.handleMuteLocalTrack), n.addListener(H.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
    }) : (t11.addListener(H.GET_STATS, this.handleGetLocalAudioStats), t11.addListener(H.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t11.addListener(H.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t11.addListener(H.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t11.addListener(H.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), e || (t11.addListener(H.NEED_REPLACE_TRACK, this.handleReplaceTrack), t11.addListener(H.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack)));
  }
  unbindLocalTrackEvents(t11) {
    t11 || (t11 = Array.from(this.localTrackMap.entries()).map((e) => {
      let [n, { track: i }] = e;
      return { track: i, type: n };
    })), t11.forEach((e) => {
      let { track: n, type: i } = e;
      switch (i) {
        case U.LocalVideoTrack:
          n.off(H.GET_STATS, this.handleGetLocalVideoStats), n.off(H.GET_RTC_STATS, this.handleGetRTCStats), n.off(H.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), n.off(H.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), n.off(H.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), n.off(H.NEED_UPDATE_VIDEO_SEND_PARAMETERS, this.handleUpdateVideoSendParameters), n.off(H.NEED_REPLACE_TRACK, this.handleReplaceTrack), n.off(H.NEED_MUTE_TRACK, this.handleMuteLocalTrack), n.off(H.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
          break;
        case U.LocalAudioTrack:
          this.unbindLocalAudioTrackEvents(n);
        case U.LocalVideoLowTrack:
      }
    });
  }
  unbindLocalAudioTrackEvents(t11) {
    t11 instanceof ge ? t11.trackList.forEach((e) => {
      e.off(H.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.off(H.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.off(H.GET_STATS, this.handleGetLocalAudioStats), e.off(H.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.off(H.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
    }) : (t11.off(H.GET_STATS, this.handleGetLocalAudioStats), t11.off(H.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t11.off(H.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t11.off(H.NEED_REPLACE_TRACK, this.handleReplaceTrack), t11.off(H.NEED_REPLACE_MIXING_TRACK, this.handleReplaceMixingTrack), t11.off(H.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t11.off(H.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));
  }
  bindRemoteTrackEvents(t11, e) {
    e instanceof Hs && e.addListener(H.GET_STATS, (n) => {
      n(this.handleGetRemoteVideoStats(t11));
    }), e instanceof Ks && e.addListener(H.GET_STATS, (n) => {
      n(this.handleGetRemoteAudioStats(t11));
    });
  }
  unbindRemoteTrackEvents(t11) {
    t11 && t11.removeAllListeners(H.GET_STATS);
  }
  unbindAllRemoteTrackEvents() {
    Array.from(this.remoteUserMap.entries()).forEach((t11) => {
      let [e, n] = t11;
      n.has(Q.AUDIO) && this.unbindRemoteTrackEvents(e._audioTrack), n.has(Q.VIDEO) && this.unbindRemoteTrackEvents(e._videoTrack);
    });
  }
  createGatewayPublishMessage(t11, e) {
    return t11.map((n, i) => {
      var r;
      let o, s, { track: a, type: c } = n;
      switch (c) {
        case U.LocalAudioTrack:
          o = Ct.Audio, s = { dtx: a instanceof ou && a._config.DTX, hq: false, lq: false, stereo: false, speech: false };
          break;
        case U.LocalVideoTrack:
          o = W(r = a._hints).call(r, Gt.SCREEN_TRACK) ? Ct.Screen : Ct.High, s = Zi(Zi({}, GR(a)), {}, { codec: this.store.codec, svc_mode: $E() });
          break;
        case U.LocalVideoLowTrack:
          o = Ct.Low, s = Zi(Zi({}, GR(a)), {}, { codec: this.store.codec, svc_mode: $E() });
      }
      return { stream_type: o, attributes: s, ssrcs: e[i] };
    });
  }
  createGatewayUnpublishMessage(t11) {
    return t11.map((e) => {
      var n;
      let i, [r, { track: o, ssrcs: s, id: a }] = e;
      switch (r) {
        case U.LocalVideoTrack:
          i = W(n = o._hints).call(n, Gt.SCREEN_TRACK) ? Ct.Screen : Ct.High;
          break;
        case U.LocalAudioTrack:
          i = Ct.Audio;
          break;
        case U.LocalVideoLowTrack:
          i = Ct.Low;
      }
      return { stream_type: i, ssrcs: s, mid: a };
    });
  }
  assignLocalTracks(t11, e) {
    t11.forEach((n, i) => {
      let { track: r, type: o } = n;
      this.localTrackMap.set(o, { track: r, id: e[i].id, ssrcs: e[i].localSSRC });
    });
  }
  withdrawLocalTracks(t11) {
    t11.forEach((e) => {
      let [n] = e;
      this.localTrackMap.delete(n);
    });
  }
  bindConnectionEvents(t11) {
    t11.onConnectionStateChange = async (e) => {
      if (_.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(e, ")")), this.emit(tt.PeerConnectionStateChange, e), e !== "connected" || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), e === "connected" && (this._restartTimer && (clearTimeout(this._restartTimer), this._restartTimer = void 0), (this._isFirstConnected || this._isInRestartIce) && this.reportPCStats(Date.now(), true, this._pcStatsUploadType), this._isInRestartIce = false, this._isFirstConnected = false, this._isStartRestartIce = false), v("NEW_ICE_RESTART")) {
        var n;
        if (W(n = this._restartStates).call(n, e)) {
          if (this._isStartRestartIce) return;
          this._isStartRestartIce = true;
          let i = (s) => {
            (t11.iceConnectionState === "disconnected" || t11.iceConnectionState === "checking" || t11.iceConnectionState === "failed") && (_.debug("[".concat(this.store.clientId, "] [P2PChannel] start use restartICE, type is ").concat(s)), ni(this, tt.QueryClientConnectionState) === "CONNECTED" && this.emit(tt.RequestRestartICE, s));
          }, r = () => {
            t11.iceConnectionState !== "disconnected" && t11.iceConnectionState !== "checking" && t11.iceConnectionState !== "failed" || (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), _.debug("[".concat(this.store.clientId, "] P2PConnection disconnected timeout, force reconnect")), setTimeout(() => this.emit(tt.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
          }, o = v("ICE_RESTART_INTERVAL");
          return void (this._restartTimer = window.setTimeout(() => {
            if (v("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE") && ft().supportPCSetConfiguration) i(On.RELAY), this._restartTimer = window.setTimeout(r, o);
            else if ($t()) i(On.UDP), this._restartTimer = window.setTimeout(r, 4e3);
            else {
              if (i(On.TCP), ft().supportPCSetConfiguration) return void (this._restartTimer = window.setTimeout(() => {
                i(On.RELAY), this._restartTimer = window.setTimeout(r, o);
              }, o));
              this._restartTimer = window.setTimeout(r, o);
            }
          }, 800));
        }
      } else {
        if (e === "disconnected" && t11.iceConnectionState === "disconnected") return setTimeout(() => {
          t11.iceConnectionState === "disconnected" && v("ICE_RESTART") && ni(this, tt.QueryClientConnectionState) === "CONNECTED" && this.emit(tt.RequestRestartICE);
        }, 800), void setTimeout(() => {
          t11.peerConnectionState === "disconnected" && (_.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection disconnected timeout 4000ms, force reconnect")), this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isInRestartIce = false, setTimeout(() => this.emit(tt.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());
        }, 4e3);
        e === "failed" && (_.debug("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection state failed, force reconnect")), this.reportPCDisconnectedOrFailed(), setTimeout(() => this.emit(tt.P2PLost), 0), this.iceFailedCount += 1, await this.requestReconnect());
      }
    }, t11.onICEConnectionStateChange = (e) => {
      e !== "connected" || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e, ")")), X.reportApiInvoke(this.store.sessionId, { name: "ICEConnectionStateChange", options: e, tag: Zt.TRACER }).onSuccess(), this.emit(tt.IceConnectionStateChange, e);
    }, t11.onICETransportStateChange = (e) => {
      _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e, ")"));
    }, t11.onDTLSTransportStateChange = (e) => {
      _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e, ")"));
    }, t11.onDTLSTransportError = (e) => {
      _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e, ")"));
    }, t11.onFirstAudioDecoded = (e) => {
      var n;
      let i = Array.from(xn(n = this.remoteUserMap).call(n)).find((o) => o._audioSSRC === e);
      var r;
      i && (this.store.subscribe(i.uid, "audio", void 0, void 0, void 0, Date.now()), (r = i.audioTrack) === null || r === void 0 || r.emit(Ws.FIRST_FRAME_DECODED), X.firstRemoteFrame(this.store.sessionId, De.FIRST_AUDIO_DECODE, Jt.FIRST_AUDIO_DECODE, { peer: i._uintid, subscribeElapse: qe.measureFromSubscribeStart(this.store.clientId, e), subscribeRequestid: e, p2pid: this.store.p2pId }));
    }, t11.onFirstAudioReceived = (e) => {
      var n;
      let i = Array.from(xn(n = this.remoteUserMap).call(n)).find((r) => r._audioSSRC === e);
      i && X.firstRemoteFrame(this.store.sessionId, De.FIRST_AUDIO_RECEIVED, Jt.FIRST_AUDIO_RECEIVED, { peer: i._uintid, subscribeElapse: qe.measureFromSubscribeStart(this.store.clientId, e), subscribeRequestid: e, p2pid: this.store.p2pId });
    }, t11.onFirstVideoDecoded = (e, n, i) => {
      this.reportVideoFirstFrameDecoded(e, n, i);
    }, t11.onFirstVideoReceived = (e) => {
      var n;
      let i = Array.from(xn(n = this.remoteUserMap).call(n)).find((r) => r._videoSSRC === e);
      i && X.firstRemoteFrame(this.store.sessionId, De.FIRST_VIDEO_RECEIVED, Jt.FIRST_VIDEO_RECEIVED, { peer: i._uintid, subscribeElapse: qe.measureFromSubscribeStart(this.store.clientId, e), subscribeRequestid: e, p2pid: this.store.p2pId });
    }, t11.onSelectedLocalCandidateChanged = (e, n) => {
      let i = e.candidateType === "relay", r = n.candidateType === "relay";
      n.candidateType !== "unknown" && i === r || this.emit(tt.ConnectionTypeChange, i), _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(eo(n)), " -> ").concat(JSON.stringify(eo(e)), ")"));
    }, t11.onSelectedRemoteCandidateChanged = (e, n) => {
      _.info("[".concat(this.store.clientId, "] [p2pId: ").concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(eo(n)), " -> ").concat(JSON.stringify(eo(e)), ")"));
    }, t11.onFirstVideoDecodedTimeout = (e) => {
      this.reportVideoFirstFrameDecoded(e, void 0, void 0, true);
    }, t11.getLocalVideoStats = () => {
      let e = this.statsCollector.getLocalVideoTrackStats(), n = this.statsCollector.getRTCStats();
      return Zi(Zi({}, e), n);
    };
  }
  unbindConnectionEvents(t11) {
    t11.onConnectionStateChange = void 0, t11.onICEConnectionStateChange = void 0, t11.onICETransportStateChange = void 0, t11.onDTLSTransportStateChange = void 0, t11.onDTLSTransportError = void 0, t11.onFirstAudioDecoded = void 0, t11.onFirstAudioReceived = void 0, t11.onFirstVideoDecoded = void 0, t11.onFirstVideoReceived = void 0, t11.onSelectedLocalCandidateChanged = void 0, t11.onSelectedRemoteCandidateChanged = void 0, t11.onFirstVideoDecodedTimeout = void 0, t11.getLocalVideoStats = void 0;
  }
  filterTobeMutedTracks(t11) {
    let e = [];
    if (this.getAllTracks().indexOf(t11) === -1) return e;
    let n = this.localTrackMap.get(U.LocalAudioTrack);
    if (t11 instanceof Qt && (n == null ? void 0 : n.track) instanceof ge) return n.track.isActive || e.push([U.LocalAudioTrack, n]), e;
    let i = Array.from(this.localTrackMap.entries()).find((r) => {
      let [, { track: o }] = r;
      return t11 === o;
    });
    if (i && (e.push(i), i[0] === U.LocalVideoTrack)) {
      let r = this.localTrackMap.get(U.LocalVideoLowTrack);
      r && e.push([U.LocalVideoLowTrack, r]);
    }
    return e;
  }
  filterTobeUnmutedTracks(t11) {
    let e = [], n = this.localTrackMap.get(U.LocalAudioTrack);
    if (t11 instanceof Qt && (n == null ? void 0 : n.track) instanceof ge) return n.track.isActive && e.push([U.LocalAudioTrack, n]), e;
    let i = Array.from(this.localTrackMap.entries()).find((r) => {
      let [, { track: o }] = r;
      return t11 === o;
    });
    if (i) if (i[0] === U.LocalVideoTrack) {
      e.push(i);
      let r = this.localTrackMap.get(U.LocalVideoLowTrack);
      r && e.push([U.LocalVideoLowTrack, r]);
    } else e.push(i);
    return e;
  }
  createMuteMessage(t11) {
    return t11.map((e) => {
      var n;
      let i, [r, { track: o, ssrcs: s, id: a }] = e;
      switch (r) {
        case U.LocalAudioTrack:
          i = Ct.Audio;
          break;
        case U.LocalVideoTrack:
          i = W(n = o._hints).call(n, Gt.SCREEN_TRACK) ? Ct.Screen : Ct.High;
          break;
        case U.LocalVideoLowTrack:
          i = Ct.Low;
      }
      return { stream_type: i, ssrcs: s, mid: a };
    });
  }
  createUnmuteMessage(t11) {
    return t11.map((e) => {
      var n;
      let i, [r, { track: o, ssrcs: s, id: a }] = e;
      switch (r) {
        case U.LocalAudioTrack:
          i = Ct.Audio;
          break;
        case U.LocalVideoTrack:
          i = W(n = o._hints).call(n, Gt.SCREEN_TRACK) ? Ct.Screen : Ct.High;
          break;
        case U.LocalVideoLowTrack:
          i = Ct.Low;
      }
      return { stream_type: i, ssrcs: s, mid: a };
    });
  }
  filterTobeUnSubscribedTracks(t11, e) {
    let n = [], i = this.remoteUserMap.get(t11);
    if (!i) return n;
    if (e) {
      let r = i.get(e);
      if (!r) return n;
      n.push([t11, { kind: e, id: r }]);
    } else Array.from(i.entries()).forEach((r) => {
      let [o, s] = r;
      n.push([t11, { kind: o, id: s }]);
    });
    return n;
  }
  filterTobeUnSubscribedDataChannels(t11, e) {
    let n = [];
    return e.forEach((i) => {
      var r;
      (r = this.remoteDataChannelMap.get(t11)) !== null && r !== void 0 && r.has(i.id) && n.push(i);
    }), n;
  }
  createUnsubscribeMessage(t11) {
    let e = [];
    return t11.forEach((n) => {
      let [i, { kind: r, id: o }] = n;
      switch (r) {
        case Q.VIDEO:
          return void (i._videoSSRC && e.push({ stream_type: Q.VIDEO, ssrcId: i._videoSSRC }));
        case Q.AUDIO:
          return void (i._audioSSRC && e.push({ stream_type: Q.AUDIO, ssrcId: i._audioSSRC }));
      }
    }), e;
  }
  createUnsubscribeAllMessage(t11) {
    let e = /* @__PURE__ */ new Map();
    return t11.forEach((n) => {
      let [i, { kind: r }] = n;
      if (e.has(i)) {
        let o = e.get(i);
        r === Q.VIDEO ? o |= ve.Video : o |= ve.Audio, e.set(i, o);
      } else r === Q.VIDEO ? e.set(i, ve.Video) : e.set(i, ve.Audio);
    }), { users: Array.from(e.entries()).map((n) => {
      let [i, r] = n;
      return { stream_id: i.uid, stream_type: r };
    }) };
  }
  withdrawRemoteTracks(t11) {
    t11.forEach((e) => {
      let [n, { kind: i }] = e, r = this.remoteUserMap.get(n);
      r && (r.delete(i), Array.from(r.entries()).length === 0 && this.remoteUserMap.delete(n));
    });
  }
  async updateBitrateLimit(t11) {
    let e = this.localTrackMap.get(U.LocalVideoTrack), n = this.localTrackMap.get(U.LocalVideoLowTrack);
    e && await e.track.setBitrateLimit(t11.uplink), n && t11.low_stream_uplink && await n.track.setBitrateLimit({ max_bitrate: t11.low_stream_uplink.bitrate, min_bitrate: t11.low_stream_uplink.bitrate || 0 });
  }
  isP2PDisconnected() {
    return this.connection ? this.connection.peerConnectionState !== "connected" : true;
  }
  mapPubResToRemoteConfig(t11, e) {
    return t11.map((n, i) => {
      var r;
      let { stream_type: o } = n;
      return (r = e.find((s) => {
        let { stream_type: a } = s;
        return o === a;
      })) === null || r === void 0 ? void 0 : r.attributes;
    });
  }
  async tryToUnmuteAudio(t11) {
    for (let n = 0; n < t11.length; n++) if (t11[n] instanceof Qt) {
      var e;
      let i = this.filterTobeUnmutedTracks(t11[n]);
      if (i.length === 0) continue;
      await ((e = this.connection) === null || e === void 0 ? void 0 : e.unmuteLocal(i.map((o) => {
        let [, { id: s }] = o;
        return s;
      })));
      let r = this.createUnmuteMessage(i);
      return void await kt(this, tt.RequestUnmuteLocal, r);
    }
  }
  bindStatsUploaderEvents() {
    this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = (t11) => {
      var e;
      return !((e = this.connection) === null || e === void 0 || !e.getRemoteVideoIsReady(t11));
    }, this.statsUploader.requestUpload = (t11, e) => this.emit(tt.RequestUpload, t11, e), this.statsUploader.requestUploadStats = (t11) => this.emit(tt.RequestUploadStats, t11), this.statsUploader.requestAllTracks = () => this.getAllTracks();
  }
  unbindStatsUploaderEvents() {
    this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;
  }
  async requestReconnect() {
    this.dtlsFailedCount += 1, await Me(hf(this.dtlsFailedCount, Ee)), this.emit(tt.RequestReconnect);
  }
  async reconnectP2P() {
    let t11 = Array.from(this.localTrackMap.entries()), e = this.createGatewayUnpublishMessage(t11);
    Array.from(this.remoteUserMap.entries()), e.length > 0 && await Ge(this, tt.RequestUnpublishForReconnectPC, e), this.disconnectForReconnect(), this.emit(tt.RequestReconnectPC);
  }
  canPublishLowStream() {
    return this.localTrackMap.has(U.LocalVideoTrack) || this.pendingLocalTracks.some((t11) => t11 instanceof Ft);
  }
  throwIfTrackTypeNotMatch(t11) {
    if (t11.filter((e) => e instanceof Ft).length > 1) throw new N(R.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
    if (t11.filter((e) => e instanceof Qt).length > 1 && (t11.some((e) => e instanceof Qt && e._bypassWebAudio) || !ft().webAudioMediaStreamDest)) throw new N(R.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
    for (let e of t11) {
      if (e instanceof Ft && this.pendingLocalTracks.some((n) => n instanceof Ft)) throw new N(R.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
      if (e instanceof Qt && this.pendingLocalTracks.some((n) => n instanceof Qt) && (!ft().webAudioMediaStreamDest || e._bypassWebAudio || this.pendingLocalTracks.some((n) => n instanceof Qt && n._bypassWebAudio))) throw new N(R.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
    }
  }
  getLowVideoTrack(t11, e) {
    let n = !v("DISABLE_DUAL_STREAM_USE_ENCODING") && ft().supportDualStreamEncoding, i = Zi(Zi({}, { width: 160, height: 120, framerate: 15, bitrate: 50 }), e), r;
    r = n ? t11._mediaStreamTrack.clone() : dm(t11, i);
    let o = Ut(8, "track-low-"), s = new Ft(r, Zi(Zi({}, n && { scaleResolutionDownBy: GE(i, t11) }), {}, { frameRate: i.framerate, bitrateMax: i.bitrate, bitrateMin: i.bitrate }), void 0, void 0, o);
    return s.on(Ko.TRANSCEIVER_UPDATED, (a) => {
      t11._updateRtpTransceiver(a, na.LOW_STREAM);
    }), s._hints.push(Gt.LOW_STREAM), t11.on("sei-to-send", (a) => {
      s.emit("sei-to-send", a);
    }), t11.addListener(H.NEED_CLOSE, () => {
      s.close();
    }), s;
  }
  async globalLock() {
    return this.mutex.lock("From P2PChannel.globalLock");
  }
  async reportPCStats(t11, e, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    if (this.connection && this.connection instanceof ki) {
      var r, o, s, a;
      let c = this.store.keyMetrics.descriptionStart || 0, { iceConnectionState: d, dtlsTransportState: l, peerConnectionState: u } = this.connection, { local: h, remote: p } = await this.connection.getSelectedCandidatePair();
      X.pcStats(this.store.sessionId, { startTime: c, eventElapse: t11 - c || 0, iceconnectionsate: d, dtlsstate: l, connectionstate: u, intSucc: e ? 1 : 2, error: i, selectedLocalCandidateProtocol: (r = h == null ? void 0 : h.protocol) !== null && r !== void 0 ? r : "", selectedLocalCandidateType: (o = h.candidateType) !== null && o !== void 0 ? o : "", selectedLocalCandidateAddress: "".concat(h.address, ":").concat(h.port), selectedRemoteCandidateProtocol: (s = p.protocol) !== null && s !== void 0 ? s : "", selectedRemoteCandidateType: (a = p.candidateType) !== null && a !== void 0 ? a : "", selectedRemoteCandidateAddress: "".concat(p.address, ":").concat(p.port), restartCnt: n, preallocation: this.connection.isPreallocation });
    }
  }
  reportVideoFirstFrameDecoded(t11, e, n, i) {
    var r;
    let o = Array.from(xn(r = this.remoteUserMap).call(r)).find((s) => s._videoSSRC === t11);
    if (o) {
      i || this.store.subscribe(o.uid, "video", void 0, void 0, void 0, void 0, Date.now());
      let s = this.store.keyMetrics, a = s.subscribe.find((c) => c.userId === o.uid && c.type === "video");
      X.firstRemoteVideoDecode(this.store.sessionId, De.FIRST_VIDEO_DECODE, Jt.FIRST_VIDEO_DECODE, { peer: o._uintid, videowidth: e, videoheight: n, subscribeElapse: qe.measureFromSubscribeStart(this.store.clientId, t11), subscribeRequestid: t11, p2pid: this.store.p2pId, apEnd: s.requestAPEnd || 0, apStart: s.requestAPStart || 0, joinGwEnd: s.joinGatewayEnd || 0, joinGwStart: s.joinGatewayStart || 0, pcEnd: s.peerConnectionEnd || 0, pcStart: s.peerConnectionStart || 0, subscriberEnd: (a == null ? void 0 : a.subscribeEnd) || 0, subscriberStart: (a == null ? void 0 : a.subscribeStart) || 0, videoAddNotify: (a == null ? void 0 : a.streamAdded) || 0, state: i ? 1 : 0, firstFrame: (a == null ? void 0 : a.firstFrame) || 0 });
    }
  }
  async remoteMediaSsrcChanged(t11, e, n) {
    if (!this.connection) return false;
    let i = this.remoteUserMap.get(t11);
    if (!i) return false;
    let r = i.get(e);
    if (!r) return false;
    let o = await this.connection.getRemoteSSRC(r);
    return o !== void 0 && o !== n;
  }
  unbindRtpTransceiver() {
    this.localTrackMap.size !== 0 && Array.from(this.localTrackMap.entries()).forEach((t11) => {
      let [e, { track: n }] = t11;
      e === U.LocalVideoLowTrack ? n._updateRtpTransceiver(void 0, na.LOW_STREAM) : n._updateRtpTransceiver(void 0);
    });
  }
  reportPCDisconnectedOrFailed(t11) {
    this.connection && this.connection instanceof ki && (this.connection.iceConnectionState !== "disconnected" && this.connection.iceConnectionState !== "checking" && this.connection.iceConnectionState !== "failed" || (this._isFirstConnected ? (this.reportPCStats(Date.now(), false, this._pcStatsUploadType), this._isFirstConnected = false) : this._pcStatsUploadType === Tr.TCP_RESTART && t11 === On.RELAY ? this.reportPCStats(Date.now(), false, this._pcStatsUploadType) : this.reportPCStats(Date.now(), false, Tr.DISCONNECTED_OR_FAILED)));
  }
}, q(at.prototype, "startP2PConnection", [tn], Object.getOwnPropertyDescriptor(at.prototype, "startP2PConnection"), at.prototype), q(at.prototype, "connect", [tn], Object.getOwnPropertyDescriptor(at.prototype, "connect"), at.prototype), q(at.prototype, "updateRemoteRTPCapabilities", [tn], Object.getOwnPropertyDescriptor(at.prototype, "updateRemoteRTPCapabilities"), at.prototype), q(at.prototype, "publishDataChannel", [tn], Object.getOwnPropertyDescriptor(at.prototype, "publishDataChannel"), at.prototype), q(at.prototype, "unpublish", [tn], Object.getOwnPropertyDescriptor(at.prototype, "unpublish"), at.prototype), q(at.prototype, "unpublishDataChannel", [tn], Object.getOwnPropertyDescriptor(at.prototype, "unpublishDataChannel"), at.prototype), q(at.prototype, "unpublishLowStream", [tn], Object.getOwnPropertyDescriptor(at.prototype, "unpublishLowStream"), at.prototype), q(at.prototype, "subscribeDataChannel", [tn], Object.getOwnPropertyDescriptor(at.prototype, "subscribeDataChannel"), at.prototype), q(at.prototype, "subscribe", [tn], Object.getOwnPropertyDescriptor(at.prototype, "subscribe"), at.prototype), q(at.prototype, "massSubscribe", [tn], Object.getOwnPropertyDescriptor(at.prototype, "massSubscribe"), at.prototype), q(at.prototype, "unsubscribe", [tn], Object.getOwnPropertyDescriptor(at.prototype, "unsubscribe"), at.prototype), q(at.prototype, "unsubscribeDataChannel", [tn], Object.getOwnPropertyDescriptor(at.prototype, "unsubscribeDataChannel"), at.prototype), q(at.prototype, "massUnsubscribe", [tn], Object.getOwnPropertyDescriptor(at.prototype, "massUnsubscribe"), at.prototype), q(at.prototype, "muteRemote", [tn], Object.getOwnPropertyDescriptor(at.prototype, "muteRemote"), at.prototype), q(at.prototype, "unmuteRemote", [tn], Object.getOwnPropertyDescriptor(at.prototype, "unmuteRemote"), at.prototype), q(at.prototype, "hasRemoteMediaWithLock", [tn], Object.getOwnPropertyDescriptor(at.prototype, "hasRemoteMediaWithLock"), at.prototype), q(at.prototype, "disconnectForReconnect", [tn], Object.getOwnPropertyDescriptor(at.prototype, "disconnectForReconnect"), at.prototype), q(at.prototype, "updateBitrateLimit", [tn], Object.getOwnPropertyDescriptor(at.prototype, "updateBitrateLimit"), at.prototype), q(at.prototype, "remoteMediaSsrcChanged", [tn], Object.getOwnPropertyDescriptor(at.prototype, "remoteMediaSsrcChanged"), at.prototype), at);
function tn(t11, e, n) {
  let i = t11[e];
  if (typeof i != "function") throw new Error("Cannot use mutex on object property.");
  return n.value = async function() {
    let r = this.mutex, o = await r.lock("From P2PChannel.".concat(e));
    try {
      for (var s = arguments.length, a = new Array(s), c = 0; c < s; c++) a[c] = arguments[c];
      return await i.apply(this, a);
    } finally {
      o();
    }
  }, n;
}
var C0 = {};
function Ba(t11) {
  (!(arguments.length > 1 && arguments[1] !== void 0) || arguments[1]) && _.debug("install service ".concat(t11.name)), C0[t11.name] = t11;
}
function Za(t11) {
  let e = C0[t11];
  if (!e) throw new N(R.INVALID_OPERATION, "".concat(t11, " not found, please use AgoraRTC.use(").concat(t11, "Service) to load it first"));
  return e;
}
function Kv(t11, e) {
  return Za("DataStream").create(t11, e);
}
function Yv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function qv(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Yv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : Yv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var EW = Date.now();
var mW = 20;
var hm = /* @__PURE__ */ new Map();
var wl = /* @__PURE__ */ new Map();
async function I0(t11) {
  let e = hm.get(t11), n = Array.isArray(e) && e[e.length - 1], i = wl.get(t11);
  if (!n) return void (i.isSyncing = false);
  let r = { uid: n.uid, payload: n.payload };
  i.firstRecvTs === 0 && (i.firstRecvTs = n.recvTs, i.firstSendTs = n.sendTs);
  let o = n.sendTs - i.firstSendTs, s = o - (Date.now() - i.firstRecvTs);
  s > 0 && (i.firstRecvTs = Date.now() - o);
  let a = n.mediaDelay + s;
  a <= 0 ? (e.pop(), v0(n.context, r), a = 0) : a = Math.min(a, mW), setTimeout(() => e.length && I0(t11), a);
}
function v0(t11, e) {
  t11.safeEmit(ut.STREAM_MESSAGE, e.uid, e.payload), t11.onStreamMessage && t11.onStreamMessage(e);
}
function fW(t11) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 ? arguments[2] : void 0;
  if (!t11.syncWithAudio) return v0(n, { uid: t11.uid, payload: t11.payload });
  let i = "".concat(n.id, "-").concat(t11.uid), r = hm.get(i) || [], o = r.findIndex((d) => t11.sendTs >= d.sendTs), s = qv(qv({}, t11), {}, { context: n, mediaDelay: e, recvTs: Date.now() });
  o === -1 ? r.push(s) : r.splice(o, 0, s), hm.set(i, r);
  let a = false;
  var c;
  wl.has(i) ? a = !((c = wl.get(i)) === null || c === void 0 || !c.isSyncing) : wl.set(i, { isSyncing: a, firstRecvTs: 0, firstSendTs: 0 }), a || I0(i);
}
var gW = mt().name;
function zv(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Jv(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? zv(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : zv(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var zs = "websdk_ng_cache_parameter";
var TW = v("MAX_PRELOAD_ASYNC_LENGTH");
var SW = 1e4;
var Mo = /* @__PURE__ */ new Map();
var Uo = [];
var f_ = null;
var g_ = 0;
var T_ = 0;
var Xd = /* @__PURE__ */ new Map();
var RW = /* @__PURE__ */ function(t11, e) {
  let n = [], i = 0, r = async () => {
    let o = n.shift();
    o && await o(), n.length > 0 && i < e ? r() : i--;
  };
  return async function() {
    for (var o = arguments.length, s = new Array(o), a = 0; a < o; a++) s[a] = arguments[a];
    return new j(async (c, d) => {
      n.push(async () => {
        try {
          let l = await t11(...s);
          c(l);
        } catch (l) {
          d(l);
        }
      }), i < e && (i++, r());
    });
  };
}(y0, TW);
var S_ = mn.CancelToken.source();
async function y0(t11, e, n, i, r, o) {
  try {
    if (!v("ENABLE_PRELOAD")) return;
    if (!ft().supportWebCrypto) return void po(() => {
      _.warn("Your browser does not support preloading, this feature  be run in a secure environment");
    }, "preload_webcrypto_not_supported");
    if (!n && n !== null) throw new N(R.INVALID_PARAMS, "Invalid token: ".concat(n, ". If you don not use token, set it to null"));
    n && Pe(n, "token", 1, 2047), Pe(t11, "appid", 1, 2047), Xu(e), i && Qu(i);
    let s = Ms();
    _.debug("preload channel ".concat(e, ", uid is ").concat(i));
    let a = { appId: t11, cname: e, token: n || t11, uid: typeof i != "string" ? i : null, sid: s, proxyServer: r }, c, d;
    typeof i == "string" ? (a.stringUid = i, [d, c] = await j.all([YG(i, { sid: s, appId: t11 }, S_.token), ev(Jv(Jv({}, a), {}, { token: n || t11, uid: 0 }), S_.token)]), a.uid = d.uid, c.gatewayInfo.uid = a.uid, c.gatewayInfo.res.uid = a.uid) : (o && (a.stringUid = o), c = await ev(a, S_.token));
    let l = { sid: s, appId: t11, cname: e, token: n || t11, uid: a.stringUid || i, intUid: a.uid || c.gatewayInfo.uid, stringUid: a.stringUid, ts: Date.now(), sua: d, ap: c };
    await async function(u) {
      let h;
      try {
        u.uid && A0({ appId: u.appId, cname: u.cname, token: u.token, uid: u.uid, stringUid: u.stringUid });
        let p = O0(u), g = await async function(f, S) {
          try {
            let C = await window.crypto.subtle.importKey("raw", yO(S), "AES-GCM", false, ["encrypt"]), A = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: new Uint8Array(1) }, C, Fo(window.btoa(JSON.stringify(f))));
            return so(new Uint8Array(A));
          } catch {
            return;
          }
        }(u, u.token || u.appId);
        if (!g) return;
        h = w0(zs);
        let E = h ? JSON.parse(h) : [];
        E.push({ [p]: g }), E.length > v("AP_CACHE_NUM") && E.shift(), gu(zs, JSON.stringify(E));
      } catch (p) {
        _.warn("Error caching server parameters:", p.message), gu(zs, "");
      }
    }(l), g_++;
  } catch (s) {
    throw T_++, function(a) {
      f_ || (f_ = window.setTimeout(() => {
        let d = "";
        Xd.forEach((l, u) => {
          d += "".concat(u, ": ").concat(l, " ;");
        }), X.reportApiInvoke(null, { name: Te.PRELOAD, options: { success: g_, failed: T_, err: d } }).onError(a), g_ = 0, T_ = 0, Xd.clear(), f_ = null;
      }, SW));
      let c = Xd.get(a.code) || 0;
      Xd.set(a.code, c + 1);
    }(s), s;
  }
}
async function Xv(t11) {
  try {
    let e = A0(t11);
    if (!e || t11.cloudProxyServer !== "disabled") return;
    let n = await async function(i, r) {
      try {
        let o = await window.crypto.subtle.importKey("raw", yO(r), "AES-GCM", false, ["decrypt"]), s = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: new Uint8Array(1) }, o, Fo(i));
        return JSON.parse(window.atob(so(new Uint8Array(s))));
      } catch {
        return;
      }
    }(e, t11.token || t11.appId);
    if (!n || !function(i, r) {
      return i.cname === r.cname && i.appId === r.appId && i.token === r.token ? r.stringUid ? i.stringUid === r.stringUid : typeof r.uid == "number" ? i.uid === r.uid : i.uid == r.uid : false;
    }(n, t11)) return;
    if (n && Date.now() - n.ts < v("AP_CACHE_LIFETIME")) return n;
  } catch (e) {
    _.warn("Error get preloadInfo", e.message);
  }
}
function A0(t11) {
  let e;
  try {
    if (e = w0(zs), !e) return;
    let n = JSON.parse(e), i = O0(t11), r = function(s, a) {
      for (let c = s.length - 1; c >= 0; c--) if (a(s[c])) return c;
      return -1;
    }(n, (s) => i in s);
    if (r === -1) return;
    let o = n.splice(r, 1)[0];
    return gu(zs, JSON.stringify(n)), o[i];
  } catch (n) {
    _.warn("Error delete preload info: ".concat(e), n.message), gu(zs, "");
  }
}
function Df(t11) {
  if (t11) {
    let e = Mo.get(t11);
    e && (window.clearTimeout(e), e = null, Mo.delete(t11)), W(Uo).call(Uo, t11) || t11.cloudProxyServer !== "disabled" || Uo.push(t11);
  }
  if (Mo.size < v("AP_CACHE_NUM") && Uo.length > 0) {
    let e = Uo.shift();
    Mo.set(e, window.setTimeout(async () => {
      let { appId: n, cname: i, token: r, stringUid: o, uid: s, proxyServer: a } = e;
      try {
        await RW(n, i, r, s, a, o), Mo.has(e) && Df(e);
      } catch (c) {
        _.warn("update preload failed", c.message), b0(e);
      }
    }, v("AP_UPDATE_INTERVAL")));
  }
}
function b0(t11) {
  let e = Uo.indexOf(t11);
  e !== -1 && Uo.splice(e, 1);
  let n = Mo.get(t11);
  n && (window.clearTimeout(n), n = null, Mo.delete(t11), Df());
}
function Qv(t11, e) {
  let n = t11.sua, i = t11.ap;
  e && n && X.reqUserAccount(t11.sid, { lts: n.requestTime, elapse: n.elapse, success: true, serverAddr: n.url, stringUid: e, uid: t11.intUid, errorCode: null, extend: n.req }), X.reportResourceTiming(t11.ap.url, t11.sid), X.joinWebProxyAP(t11.sid, { lts: i.requestTime, elapse: i.elapse, sucess: 1, apServerAddr: i.url, turnServerAddrList: i.proxyInfo.addresses.map((r) => r.ip).join(","), eventType: "disabled", unilbsServerIds: [ue.CHOOSE_SERVER, ue.CLOUD_PROXY_FALLBACK].toString() }), X.joinChooseServer(t11.sid, { lts: i.requestTime, elapse: i.elapse, succ: true, csAddr: i.url, opid: i.opid, serverList: i.gatewayInfo.gatewayAddrs.map((r) => r.address), ec: null, cid: i.gatewayInfo.cid.toString(), uid: i.gatewayInfo.uid.toString(), csIp: i.gatewayInfo.csIp, unilbsServerIds: [ue.CHOOSE_SERVER].toString(), isHttp3: i.isHttp3 });
}
function w0(t11) {
  return window.atob(window.localStorage.getItem(t11) || "");
}
function gu(t11, e) {
  window.localStorage.setItem(t11, window.btoa(e));
}
function O0(t11) {
  let e = "".concat(t11.appId, "_").concat(t11.cname);
  return typeof t11.uid == "string" && (e += "_s_".concat(t11.uid)), typeof t11.uid == "number" && (e += "_".concat(t11.uid)), t11.token && (e += "_".concat(t11.token)), bO(e);
}
function CW(t11) {
  let e = function() {
    let n = yW.pop();
    return n ? (n.offset = n.limit = 0, n) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
  }();
  return function(n, i) {
    let r = n.appId;
    r !== void 0 && (de(i, 10), Hr(i, r));
    let o = n.cid;
    o !== void 0 && (de(i, 16), de(i, o));
    let s = n.cname;
    s !== void 0 && (de(i, 26), Hr(i, s));
    let a = n.deviceId;
    a !== void 0 && (de(i, 34), Hr(i, a));
    let c = n.elapse;
    c !== void 0 && (de(i, 40), Kr(i, c));
    let d = n.fileSize;
    d !== void 0 && (de(i, 48), Kr(i, Ss(d)));
    let l = n.height;
    l !== void 0 && (de(i, 56), Kr(i, Ss(l)));
    let u = n.jpg;
    u !== void 0 && (de(i, 66), de(i, u.length), Zv(i, u));
    let h = n.networkType;
    h !== void 0 && (de(i, 72), Kr(i, Ss(h)));
    let p = n.osType;
    p !== void 0 && (de(i, 80), Kr(i, Ss(p)));
    let g = n.requestId;
    g !== void 0 && (de(i, 90), Hr(i, g));
    let E = n.sdkVersion;
    E !== void 0 && (de(i, 98), Hr(i, E));
    let f = n.sequence;
    f !== void 0 && (de(i, 104), Kr(i, Ss(f)));
    let S = n.sid;
    S !== void 0 && (de(i, 114), Hr(i, S));
    let C = n.timestamp;
    C !== void 0 && (de(i, 120), Kr(i, C));
    let A = n.uid;
    A !== void 0 && (de(i, 128), de(i, A));
    let b = n.vid;
    b !== void 0 && (de(i, 136), de(i, b));
    let w = n.width;
    w !== void 0 && (de(i, 144), Kr(i, Ss(w)));
    let D = n.service;
    D !== void 0 && (de(i, 152), de(i, D));
    let k = n.callbackData;
    k !== void 0 && (de(i, 162), de(i, k.length), Zv(i, k));
    let B = n.ticket;
    B !== void 0 && (de(i, 170), Hr(i, B));
    let V = n.vendorConfigs;
    V !== void 0 && (de(i, 178), Hr(i, V));
  }(t11, e), function(n) {
    let i = n.bytes, r = n.limit;
    return i.length === r ? i : i.subarray(0, r);
  }(e);
}
function IW(t11) {
  return function(n) {
    let i = {};
    t: for (; !AW(n); ) {
      let r = $a(n);
      switch (r >>> 3) {
        case 0:
          break t;
        case 1:
          i.code = $a(n);
          break;
        case 2:
          i.msg = $v(n, $a(n));
          break;
        case 3:
          i.requestId = $v(n, $a(n));
          break;
        case 4:
          i.timestamp = bW(n, false);
          break;
        default:
          vW(n, 7 & r);
      }
    }
    return i;
  }({ bytes: e = t11, offset: 0, limit: e.length });
  var e;
}
function vW(t11, e) {
  switch (e) {
    case 0:
      for (; 128 & gi(t11); ) ;
      break;
    case 2:
      R_(t11, $a(t11));
      break;
    case 5:
      R_(t11, 4);
      break;
    case 1:
      R_(t11, 8);
      break;
    default:
      throw new Error("Unimplemented type: " + e);
  }
}
function Ss(t11) {
  return { low: t11 |= 0, high: t11 >> 31, unsigned: t11 >= 0 };
}
var yW = [];
function R_(t11, e) {
  if (t11.offset + e > t11.limit) throw new Error("Skip past limit");
  t11.offset += e;
}
function AW(t11) {
  return t11.offset >= t11.limit;
}
function $u(t11, e) {
  let n = t11.bytes, i = t11.offset, r = t11.limit, o = i + e;
  if (o > n.length) {
    let s = new Uint8Array(2 * o);
    s.set(n), t11.bytes = s;
  }
  return t11.offset = o, o > r && (t11.limit = o), i;
}
function N0(t11, e) {
  let n = t11.offset;
  if (n + e > t11.limit) throw new Error("Read past limit");
  return t11.offset += e, n;
}
function Zv(t11, e) {
  let n = $u(t11, e.length);
  t11.bytes.set(e, n);
}
function $v(t11, e) {
  let n = N0(t11, e), i = String.fromCharCode, r = t11.bytes, o = "ï¿½", s = "";
  for (let a = 0; a < e; a++) {
    let c, d, l, u, h = r[a + n];
    128 & h ? (224 & h) == 192 ? a + 1 >= e ? s += o : (c = r[a + n + 1], (192 & c) != 128 ? s += o : (u = (31 & h) << 6 | 63 & c, u < 128 ? s += o : (s += i(u), a++))) : (240 & h) == 224 ? a + 2 >= e ? s += o : (c = r[a + n + 1], d = r[a + n + 2], (49344 & (c | d << 8)) != 32896 ? s += o : (u = (15 & h) << 12 | (63 & c) << 6 | 63 & d, u < 2048 || u >= 55296 && u <= 57343 ? s += o : (s += i(u), a += 2))) : (248 & h) == 240 ? a + 3 >= e ? s += o : (c = r[a + n + 1], d = r[a + n + 2], l = r[a + n + 3], (12632256 & (c | d << 8 | l << 16)) != 8421504 ? s += o : (u = (7 & h) << 18 | (63 & c) << 12 | (63 & d) << 6 | 63 & l, u < 65536 || u > 1114111 ? s += o : (u -= 65536, s += i(55296 + (u >> 10), 56320 + (1023 & u)), a += 3))) : s += o : s += i(h);
  }
  return s;
}
function Hr(t11, e) {
  let n = e.length, i = 0;
  for (let s = 0; s < n; s++) {
    let a = e.charCodeAt(s);
    a >= 55296 && a <= 56319 && s + 1 < n && (a = (a << 10) + e.charCodeAt(++s) - 56613888), i += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
  }
  de(t11, i);
  let r = $u(t11, i), o = t11.bytes;
  for (let s = 0; s < n; s++) {
    let a = e.charCodeAt(s);
    a >= 55296 && a <= 56319 && s + 1 < n && (a = (a << 10) + e.charCodeAt(++s) - 56613888), a < 128 ? o[r++] = a : (a < 2048 ? o[r++] = a >> 6 & 31 | 192 : (a < 65536 ? o[r++] = a >> 12 & 15 | 224 : (o[r++] = a >> 18 & 7 | 240, o[r++] = a >> 12 & 63 | 128), o[r++] = a >> 6 & 63 | 128), o[r++] = 63 & a | 128);
  }
}
function gi(t11) {
  return t11.bytes[N0(t11, 1)];
}
function ty(t11, e) {
  let n = $u(t11, 1);
  t11.bytes[n] = e;
}
function $a(t11) {
  let e, n = 0, i = 0;
  do
    e = gi(t11), n < 32 && (i |= (127 & e) << n), n += 7;
  while (128 & e);
  return i;
}
function de(t11, e) {
  for (e >>>= 0; e >= 128; ) ty(t11, 127 & e | 128), e >>>= 7;
  ty(t11, e);
}
function bW(t11, e) {
  let n, i = 0, r = 0, o = 0;
  return n = gi(t11), i = 127 & n, 128 & n && (n = gi(t11), i |= (127 & n) << 7, 128 & n && (n = gi(t11), i |= (127 & n) << 14, 128 & n && (n = gi(t11), i |= (127 & n) << 21, 128 & n && (n = gi(t11), r = 127 & n, 128 & n && (n = gi(t11), r |= (127 & n) << 7, 128 & n && (n = gi(t11), r |= (127 & n) << 14, 128 & n && (n = gi(t11), r |= (127 & n) << 21, 128 & n && (n = gi(t11), o = 127 & n, 128 & n && (n = gi(t11), o |= (127 & n) << 7))))))))), { low: i | r << 28, high: r >>> 4 | o << 24, unsigned: e };
}
function Kr(t11, e) {
  let n = e.low >>> 0, i = (e.low >>> 28 | e.high << 4) >>> 0, r = e.high >>> 24, o = r === 0 ? i === 0 ? n < 16384 ? n < 128 ? 1 : 2 : n < 1 << 21 ? 3 : 4 : i < 16384 ? i < 128 ? 5 : 6 : i < 1 << 21 ? 7 : 8 : r < 128 ? 9 : 10, s = $u(t11, o), a = t11.bytes;
  switch (o) {
    case 10:
      a[s + 9] = r >>> 7 & 1;
    case 9:
      a[s + 8] = o !== 9 ? 128 | r : 127 & r;
    case 8:
      a[s + 7] = o !== 8 ? i >>> 21 | 128 : i >>> 21 & 127;
    case 7:
      a[s + 6] = o !== 7 ? i >>> 14 | 128 : i >>> 14 & 127;
    case 6:
      a[s + 5] = o !== 6 ? i >>> 7 | 128 : i >>> 7 & 127;
    case 5:
      a[s + 4] = o !== 5 ? 128 | i : 127 & i;
    case 4:
      a[s + 3] = o !== 4 ? n >>> 21 | 128 : n >>> 21 & 127;
    case 3:
      a[s + 2] = o !== 3 ? n >>> 14 | 128 : n >>> 14 & 127;
    case 2:
      a[s + 1] = o !== 2 ? n >>> 7 | 128 : n >>> 7 & 127;
    case 1:
      a[s] = o !== 1 ? 128 | n : 127 & n;
  }
}
var ey = {};
var ny = {};
var Tu = 4294967296;
var D0 = Tu * Tu;
var iy = D0 / 2;
P0(0, true);
var ry = P0(0);
var wW = sa(0, -2147483648, false);
var OW = sa(-1, 2147483647, false);
function P0(t11, e) {
  let n, i, r;
  return e ? (r = 0 <= (t11 >>>= 0) && t11 < 256) && (i = ny[t11], i) ? i : (n = sa(t11, 0, true), r && (ny[t11] = n), n) : (r = -128 <= (t11 |= 0) && t11 < 128) && (i = ey[t11], i) ? i : (n = sa(t11, t11 < 0 ? -1 : 0, false), r && (ey[t11] = n), n);
}
function sa(t11, e, n) {
  return { low: 0 | t11, high: 0 | e, unsigned: !!n };
}
function DW(t11, e) {
  if (isNaN(t11)) return ry;
  {
    if (t11 <= -iy) return wW;
    if (t11 + 1 >= iy) return OW;
  }
  return t11 < 0 ? ry : sa(t11 % Tu | 0, t11 / Tu | 0, e);
}
function oy(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
var pm = class t9 extends Xt {
  get connectionState() {
    return this._connectionState;
  }
  set connectionState(e) {
    if (this._connectionState === e) return;
    let n = this._connectionState;
    this._connectionState = e, this.emit(Mi.CONNECTION_STATE_CHANGE, e, n);
  }
  get quality() {
    return this._quality;
  }
  set quality(e) {
    this._quality = e > 1 ? 1 : e < 0.1 ? 0.1 : e, this._qualityTimer && (window.clearTimeout(this._qualityTimer), this._qualityTimer = null), this._quality >= 1 || (this._qualityTimer = window.setTimeout(() => {
      this.quality = this._quality / this._qualityRatio;
    }, 6e4));
  }
  constructor(e) {
    var n;
    super(), T(this, "name", "AgoraRTCImageModeration"), T(this, "_connectionState", Xn.CONNECTING), T(this, "_sequence", 0), T(this, "_moderationStartTime", void 0), T(this, "_workerConnection", void 0), T(this, "_workerMessageLengthLimit", void 0), T(this, "_qualityRatio", void 0), T(this, "_connectInfo", void 0), T(this, "_cancelTokenSource", mn.CancelToken.source()), T(this, "_retryConfig", void 0), T(this, "_moderationInterval", void 0), T(this, "_moderationTimer", null), T(this, "_moderationMode", 1), T(this, "_quality", 1), T(this, "_qualityTimer", null), T(this, "_ticket", void 0), T(this, "_moderationIntervalMinimum", void 0), T(this, "_uploadFailedNum", 0), T(this, "_uploadNum", 0), T(this, "_uploadTimer", null), T(this, "_extraInfo", void 0), T(this, "_vendor", ""), T(this, "_encoder", new TextEncoder()), T(this, "_moderationId", void 0), T(this, "inspectImage", () => {
      if (this.connectionState !== Xn.CONNECTED) throw new O(R.OPERATION_ABORTED, "image moderation service connection status is ".concat(this.connectionState));
      this._moderationTimer && (window.clearInterval(this._moderationTimer), this._moderationTimer = null), this._moderationTimer = window.setInterval(() => {
        this.connectionState === Xn.CONNECTED ? this.requestToInspectImage() : _.debug("[".concat(this._moderationId, "] Moderation State is not connected , "), this.connectionState);
      }, this._moderationInterval < this._moderationIntervalMinimum ? this._moderationIntervalMinimum : this._moderationInterval), this.requestToInspectImage();
    }), this._moderationId = Ut(5, "image-moderation-"), this._workerMessageLengthLimit = v("IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT"), this._moderationIntervalMinimum = v("IMAGE_MODERATION_INTERVAL_MINIMUM"), this._moderationInterval = (n = e.interval) !== null && n !== void 0 ? n : 1e3, e.extraInfo && (this._extraInfo = this._encoder.encode(e.extraInfo)), e.vendor && (this._vendor = e.vendor), this._qualityRatio = v("IMAGE_MODERATION_QUALITY_RATIO"), this._moderationStartTime = Number(Date.now()), this._workerConnection = new Qo("worker-" + this._moderationId, Ee), this.on(Mi.STATE_CHANGE, (i, r) => {
      _.debug("[".concat(this._moderationId, "] Moderation operation :").concat(hs[i], " ").concat(r || ""));
    }), this.handleWorkerEvents();
  }
  async init(e, n) {
    this.emit(Mi.STATE_CHANGE, hs.CONNECT_AP), this._connectInfo = e;
    let i = this._cancelTokenSource.token;
    return this._retryConfig = n, new j((r, o) => {
      this.on(Mi.CONNECTION_STATE_CHANGE, (s, a) => {
        s === Xn.CONNECTED && r();
      }), this.requestAP(e, i, n).then((s) => {
        this.connectWorker(s);
      }).catch((s) => {
        o(s);
      });
    });
  }
  updateConfig(e) {
    var n;
    this._moderationInterval = (n = e.interval) !== null && n !== void 0 ? n : 1e3, e.extraInfo && (this._extraInfo = this._encoder.encode(e.extraInfo)), e.vendor && (this._vendor = e.vendor), _.debug("[".concat(this._moderationId, "] updateConfig: ").concat(JSON.stringify(e))), this.connectionState === Xn.CONNECTED && this.inspectImage();
  }
  async requestAP(e, n, i) {
    let r = v("WEBCS_DOMAIN").map((c) => "https://".concat(c, "/api/v1")), o = await function(c, d, l, u) {
      let { appId: h, areaCode: p, cname: g, sid: E, token: f, uid: S } = d;
      Ys++;
      let C = "moderation_plugin", A = { service_name: C, json_body: JSON.stringify({ appId: h, areaCode: p, cname: g, command: "allocateEdge", requestId: Ys, seq: Ys, sid: E, appToken: f, ts: Date.now(), uid: S + "" }) }, b, w, D = c[0];
      return Wi(async () => {
        b = Date.now();
        let k = await Hi(D, { data: A, cancelToken: l, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
        if (w = Date.now() - b, k.code !== 0) {
          let z = new O(R.UNEXPECTED_RESPONSE, "moderation plugin ap error, code" + k.code, { retry: true, responseTime: w });
          throw _.error(z.toString()), z;
        }
        let B = JSON.parse(k.json_body);
        if (B.code !== 200) {
          let z = new O(R.UNEXPECTED_RESPONSE, "moderation plugin ap error, code: ".concat(B.code, ", reason: ").concat(B.reason), { code: B.code, responseTime: w });
          throw _.error(z.toString()), z;
        }
        if (!B.servers || !Array.isArray(B.servers) || B.servers.length === 0) {
          let z = new O(R.UNEXPECTED_RESPONSE, "moderation plugin ap empty server", { code: B.code, responseTime: w });
          throw _.error(z.toString()), z;
        }
        if (!B.servers.some((z) => !!z.wss)) {
          let z = new O(R.UNEXPECTED_RESPONSE, "moderation plugin ap empty port", { code: B.code, responseTime: w });
          throw _.error(z.toString()), z;
        }
        let V = v("IMAGE_MODERATION_WORKER_HOST");
        return { addressList: B.servers.map((z) => {
          let { address: lt, wss: vt } = z;
          if (lt && vt) return "wss://".concat(lt.replace(/\./g, "-"), ".").concat(V, ":").concat(vt, "/moderation");
        }).filter((z) => !!z), workerToken: B.workerToken, vid: B.vid, ticket: B.appTicket, responseTime: w };
      }, (k, B) => (X.apworkerEvent(E, { success: true, sc: 200, serviceName: C, responseDetail: JSON.stringify(k.addressList), firstSuccess: B === 0, responseTime: w, serverIp: c[B % c.length] }), false), (k, B) => (X.apworkerEvent(E, { success: false, sc: k.data && k.data.code || 200, serviceName: C, responseTime: w, serverIp: c[B % c.length] }), !!(k.code !== R.OPERATION_ABORTED && k.code !== R.UNEXPECTED_RESPONSE || k.data && k.data.retry) && (D = c[(B + 1) % c.length], true)), u);
    }(r, e, n, i);
    this.emit(Mi.STATE_CHANGE, hs.AP_CONNECTED);
    let { addressList: s, ticket: a } = o;
    return this._ticket = a, s;
  }
  async connectWorker(e) {
    this.emit(Mi.STATE_CHANGE, hs.CONNECT_WORKER), await this._workerConnection.init(e, 1e4);
  }
  handleWorkerEvents() {
    this._workerConnection.on(it.CONNECTED, async () => {
      this.emit(Mi.STATE_CHANGE, hs.WORKER_CONNECTED, this._workerConnection.url), this.connectionState = Xn.CONNECTED;
    }), this._workerConnection.on(it.CLOSED, () => {
      this.connectionState = Xn.CLOSED;
    }), this._workerConnection.on(it.FAILED, () => {
      this.connectionState = Xn.CLOSED;
    }), this._workerConnection.on(it.RECONNECTING, () => {
      this.connectionState = this.connectionState === Xn.CONNECTED ? Xn.RECONNECTING : Xn.CONNECTING;
    }), this._workerConnection.on(it.ON_MESSAGE, async (e) => {
      if (e.data instanceof ArrayBuffer) {
        let n = IW(new Uint8Array(e.data));
        v("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && _.debug("[".concat(this._moderationId, "] Response message for worker of image moderation "), JSON.stringify(n)), this._uploadNum++, n.code === void 0 || n.code === 0 || (this._uploadFailedNum++, _.error("[".concat(this._moderationId, "] Error response from worke, code is ").concat(n.code, ", msg is ").concat(n.msg)), this._uploadTimer || (this._uploadTimer = window.setTimeout(() => {
          X.reportApiInvoke(this._connectInfo.sid || null, { name: Te.IMAGE_MODERATION_UPLOAD, options: [this._uploadFailedNum, this._uploadNum, n.code], tag: Zt.TRACER }).onError(new O(R.IMAGE_MODERATION_UPLOAD_FAILED, n.msg)), this._uploadTimer = null;
        }, v("IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL"))));
      } else _.error("[".concat(this._moderationId, "] Unexpected message type from worker"));
    }), this._workerConnection.on(it.WILL_RECONNECT, (e, n, i) => {
      e === "recover" && i(e), i("tryNext");
    }), this._workerConnection.on(it.REQUEST_NEW_URLS, (e, n) => {
      this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e).catch(n);
    });
  }
  static intToLong(e) {
    return { low: e |= 0, high: e >> 31, unsigned: e >= 0 };
  }
  async requestToInspectImage() {
    let e = ni(this, Mi.CLIENT_LOCAL_VIDEO_TRACK), n = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
    if (e) {
      if (!e.isPlaying) return void (v("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && _.debug("Only the track being played can be inspected"));
      this._sequence++;
      let i = await this.generateRequestData(e, n);
      this._workerConnection.sendMessage(i, true, true);
    } else v("SHOW_IMAGE_MODERATION_WORKER_MESSAGE") && _.debug("Only the track being published can be inspected");
  }
  async generateRequestData(e, n) {
    let { appId: i, cname: r, cid: o, vid: s, sid: a, uid: c } = n, d = Date.now(), l = await e.getCurrentFrameImage("image/jpeg", this.quality), u = await QO(l, i, r), h = this._sequence + "-" + o + "-" + c + "-" + d + "-" + Ut(12, ""), p = { appId: i, cid: o, cname: r, deviceId: "", elapse: t9.intToLong(Number(d - this._moderationStartTime)), fileSize: l.buffer.byteLength, height: l.height, width: l.width, jpg: u, networkType: 6, osType: 7, requestId: h, sdkVersion: "4.22.0", sequence: this._sequence, sid: a, timestamp: DW(d), uid: c, vid: s, service: this._moderationMode, ticket: this._ticket, callbackData: this._extraInfo, vendorConfigs: this._vendor };
    this._extraInfo === void 0 && delete p.callbackData;
    let g = CW(p);
    if (g.byteLength < this._workerMessageLengthLimit) {
      if (v("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")) {
        let E = function(f) {
          for (var S = 1; S < arguments.length; S++) {
            var C = arguments[S] != null ? arguments[S] : {};
            S % 2 ? oy(Object(C), true).forEach(function(A) {
              T(f, A, C[A]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(f, Object.getOwnPropertyDescriptors(C)) : oy(Object(C)).forEach(function(A) {
              Object.defineProperty(f, A, Object.getOwnPropertyDescriptor(C, A));
            });
          }
          return f;
        }({}, p);
        delete E.jpg, _.debug("[".concat(this._moderationId, "] Request message for worker of image moderation service: "), JSON.stringify(E));
      }
      return g;
    }
    {
      let E = this.quality * this._qualityRatio;
      return this.quality = E, await this.generateRequestData(e, { appId: i, cname: r, cid: o, vid: s, sid: a, uid: c });
    }
  }
  close() {
    this._cancelTokenSource.cancel(), this._cancelTokenSource = mn.CancelToken.source(), this._workerConnection && this._workerConnection.close(), this._moderationTimer && window.clearInterval(this._moderationTimer), this._moderationTimer = null, this._uploadTimer && window.clearTimeout(this._uploadTimer), this._uploadTimer = null, this.connectionState = Xn.CLOSED, this.emit(Mi.STATE_CHANGE, hs.CLOSED);
  }
};
function k0(t11) {
  if (Nt(t11.interval, "interval", 1e3, 1 / 0), t11 && t11.extraInfo && t11.extraInfo.length > 1024) throw new O(R.INVALID_PARAMS, "config.extraInfo length cannot exceed 1024 bytes");
  if (t11 && t11.vendor && t11.vendor.length > 1024) throw new O(R.INVALID_PARAMS, "config.vendor length cannot exceed 1024 bytes");
}
var PW = { name: "ImageModeration", create: function(t11) {
  let { config: e } = t11;
  return k0(e), new pm(e);
} };
var sy;
var ay;
var cy;
var dy;
var ly;
var uy;
var hy;
var py;
var _y;
var Ey;
var my;
var fy;
var gy;
var Ty;
var Sy;
var Ry;
var Cy;
var Iy;
var vy;
var yy;
var Ay;
var by;
var wy;
var Oy;
var Ny;
var Dy;
var Py;
var ky;
var Ly;
var My;
var Uy;
var xy;
var Vy;
var Fy;
var By;
var jy;
var Gy;
var Wy;
var Hy;
var Ky;
var G;
function Yy(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function xi(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Yy(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : Yy(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
ze.setLogger(_);
var kW = (sy = $(), ay = $({ argsMap: (t11, e) => {
  if (!Array.isArray(e)) {
    if (!(e instanceof no)) return [e];
    e = [e];
  }
  return e.map((n) => n ? Object(n).toString() : "null");
} }), cy = $({ argsMap: (t11, e) => (e || (e = []), Array.isArray(e) || e.trackMediaType !== fa.DATA ? (Array.isArray(e) || (e = [e]), e.map((n) => n.getTrackId())) : [e.getChannelId()]) }), dy = $({ argsMap: (t11, e, n, i) => [typeof e == "object" ? e.uid : e, n, i] }), ly = $({ argsMap: (t11, e, n) => [e, n] }), uy = $({ argsMap: (t11, e) => e.map((n) => {
  let { user: i, mediaType: r } = n;
  return [i == null ? void 0 : i.uid, r];
}) }), hy = $({ argsMap: (t11, e, n, i) => [typeof e == "object" ? e.uid : e, n, i] }), py = $({ argsMap: (t11, e) => e.map((n) => {
  let { user: i, mediaType: r } = n;
  return { uid: i == null ? void 0 : i.uid, mediaType: r };
}) }), _y = $(), Ey = $(), my = $(), fy = $(), gy = $(), Ty = $(), Sy = $(), Ry = $(), Cy = $(), Iy = $(), vy = $(), yy = $(), Ay = $(), by = $(), wy = $({ argsMap: (t11, e) => [e] }), Oy = $(), Ny = $(), Dy = $(), Py = $(), ky = $(), Ly = $(), My = $(), Uy = $(), xy = $({ argsMap: (t11, e) => (Array.isArray(e) || (e = [e]), [JSON.stringify(e)]) }), Vy = $(), Fy = $(), By = $(), jy = $(), Gy = $(), Wy = $(), Hy = $({ reportResult: true }), Ky = $(), G = class extends Xt {
  get connectionState() {
    return this._gateway.state;
  }
  get remoteUsers() {
    return this._users;
  }
  get localTracks() {
    return this._p2pChannel.getAllTracks(true);
  }
  get uid() {
    return this._uid;
  }
  get channelName() {
    return this._channelName;
  }
  get localDataChannels() {
    return this._p2pChannel.getAllDataChannels();
  }
  get mode() {
    return this._config.mode;
  }
  get role() {
    var t11;
    return ((t11 = this._config) === null || t11 === void 0 ? void 0 : t11.role) || "audience";
  }
  get codec() {
    return this._config.codec;
  }
  get audioCodec() {
    return this._config.audioCodec || "opus";
  }
  get isStringUID() {
    return !!this._joinInfo && !!this._joinInfo.stringUid;
  }
  get __className__() {
    return "Client";
  }
  constructor(t11) {
    let e;
    if (super(), T(this, "store", void 0), T(this, "_uid", void 0), T(this, "_channelName", void 0), T(this, "_uintUid", void 0), T(this, "_users", []), T(this, "_config", void 0), T(this, "_clientId", void 0), T(this, "_appId", void 0), T(this, "_sessionId", null), T(this, "_key", void 0), T(this, "_rtmConfig", {}), T(this, "_joinInfo", void 0), T(this, "_gateway", void 0), T(this, "_statsCollector", void 0), T(this, "_configDistribute", void 0), T(this, "_leaveMutex", new ze("client-leave")), T(this, "_publishMutex", new ze("client-publish")), T(this, "_renewTokenMutex", new ze("client-renewtoken")), T(this, "_subscribeMutex", new ze("client-subscribe")), T(this, "_encryptionMode", "none"), T(this, "_encryptionSecret", null), T(this, "_encryptionSalt", null), T(this, "_encryptDataStream", false), T(this, "_encryptDataStreamKey", null), T(this, "_encryptDataStreamIv", null), T(this, "_proxyServer", void 0), T(this, "_turnServer", { servers: [], mode: "auto" }), T(this, "_cloudProxyServerMode", "disabled"), T(this, "_isDualStreamEnabled", false), T(this, "_defaultStreamFallbackType", void 0), T(this, "_lowStreamParameter", void 0), T(this, "_streamFallbackTypeCacheMap", /* @__PURE__ */ new Map()), T(this, "_remoteStreamTypeCacheMap", /* @__PURE__ */ new Map()), T(this, "_axiosCancelSource", mn.CancelToken.source()), T(this, "_audioVolumeIndicationInterval", void 0), T(this, "_networkQualityInterval", void 0), T(this, "_userOfflineTimeout", void 0), T(this, "_streamRemovedTimeout", void 0), T(this, "_liveTranscodeStreamingClient", void 0), T(this, "_liveRawStreamingClient", void 0), T(this, "_channelMediaRelayClient", void 0), T(this, "_networkQualitySensitivity", "normal"), T(this, "_p2pChannel", void 0), T(this, "_useLocalAccessPoint", false), T(this, "_setLocalAPVersion", void 0), T(this, "_joinAndNotLeaveYet", false), T(this, "_numberOfJoinCount", 0), T(this, "_remoteDefaultVideoStreamType", void 0), T(this, "_inspect", void 0), T(this, "_moderation", void 0), T(this, "_license", void 0), T(this, "_pendingPublishedUsers", []), T(this, "ntpAlignErrorCount", 0), T(this, "remoteInboundOffset", 0), T(this, "_handleLocalTrackEnable", (n, i, r) => {
      this.publish(n, false).then(i).catch(r);
    }), T(this, "_handleLocalTrackDisable", (n, i, r) => {
      this.unpublish(n).then(i).catch(r);
    }), T(this, "_handleUserOnline", (n) => {
      if (v("BLOCK_LOCAL_CLIENT") && Io(n.uid, this.channelName)) return void _.debug("[".concat(n.uid, "] will be ignored in local"));
      this.isStringUID && typeof n.uid != "string" && _.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID"));
      let i = this._users.find((r) => r.uid === n.uid);
      if (i) i._trust_in_room_ = true, i._is_pre_created && (i._is_pre_created = false, this.safeEmit(ut.USER_JOINED, i));
      else {
        let r = new ir(n.uid, n.uint_id || n.uid);
        this._users.push(r), _.debug("[".concat(this._clientId, "] user online"), n.uid), this.safeEmit(ut.USER_JOINED, r);
      }
    }), T(this, "_handleUserOffline", (n) => {
      if (v("BLOCK_LOCAL_CLIENT") && Io(n.uid, this.channelName)) return;
      let i = this._users.find((r) => r.uid === n.uid);
      i && (this._handleRemoveStream(n), this._handleRemoveDataChannels(n), i._audio_pre_subscribed || i._video_pre_subscribed ? i._is_pre_created = true : Wl(this._users, i), this._remoteStreamTypeCacheMap.delete(i.uid), this._streamFallbackTypeCacheMap.delete(i.uid), _.debug("[".concat(this._clientId, "] user offline"), n.uid, "reason:", n.reason), this.safeEmit(ut.USER_LEAVED, i, n.reason));
    }), T(this, "_handleAddAudioOrVideoStream", (n, i, r, o, s, a, c) => {
      if (v("BLOCK_LOCAL_CLIENT") && Io(i, this.channelName)) return;
      let d = this._users.find((u) => u.uid === i);
      if (!d) return void _.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
      _.debug("[".concat(this._clientId, "] stream added with uid ").concat(i, ", type ").concat(n)), this.store.subscribe(d.uid, n, void 0, void 0, void 0, Date.now());
      let l = n === "audio" ? d.hasAudio : d.hasVideo;
      d._uintid || (d._uintid = s || i), n === "audio" ? d._trust_audio_stream_added_state_ = true : d._trust_video_stream_added_state_ = true, n === "audio" ? (d._audio_added_ = true, r !== void 0 && (d._audioSSRC = r), o !== void 0 && (d._cname = o), a && (d._audioOrtc = a)) : (d._video_added_ = true, r !== void 0 && (d._videoSSRC = r), o !== void 0 && (d._cname = o), c !== void 0 && (d._rtxSsrcId = c), a && (d._videoOrtc = a)), (n === "audio" ? d.hasAudio : d.hasVideo) && !l && (_.info("[".concat(this._clientId, "] remote user ").concat(d.uid, " published ").concat(n)), this.safeEmit(ut.USER_PUBLISHED, d, n)), n === "video" ? X.onGatewayStream(this._sessionId, De.ON_ADD_VIDEO_STREAM, Jt.ON_ADD_VIDEO_STREAM, { peer: s || i, ssrc: d._videoSSRC }) : X.onGatewayStream(this._sessionId, De.ON_ADD_AUDIO_STREAM, Jt.ON_ADD_AUDIO_STREAM, { peer: s || i, ssrc: d._audioSSRC }), this._p2pChannel.remoteMediaSsrcChanged(d, n, r).then((u) => {
        if (u && (_.debug("[".concat(this._clientId, "] resubscribe ").concat(n, " for user ").concat(d.uid, " after rejoin because SSRC id changed.")), this._p2pChannel instanceof Jd)) return this._p2pChannel.unsubscribe(d, n, true).then(() => this._subscribe(d, n, true).catch((h) => {
          _.error("[".concat(this._clientId, "] resubscribe error"), h.toString());
        }));
      }), this._p2pChannel.hasPendingRemoteMedia(d, n) && (_.debug("[".concat(this._clientId, "] resubscribe ").concat(n, " for user ").concat(d.uid, " after reconnect.")), this._subscribe(d, n, true).catch((u) => {
        _.error("[".concat(this._clientId, "] resubscribe error"), u.toString());
      }));
    }), T(this, "_handleRemoveStream", (n) => {
      if (v("BLOCK_LOCAL_CLIENT") && Io(n.uid, this.channelName)) return;
      let i = this._users.find((o) => o.uid === n.uid);
      if (!i) return void _.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)"));
      _.debug("[".concat(this._clientId, "] stream removed with uid ").concat(n.uid));
      let r = () => {
      };
      i.hasAudio && i.hasVideo ? r = () => {
        _.info("[".concat(this._clientId, "] remote user ").concat(i.uid, " unpublished audio track")), this.safeEmit(ut.USER_UNPUBLISHED, i, "audio"), _.info("[".concat(this._clientId, "] remote user ").concat(i.uid, " unpublished video track")), this.safeEmit(ut.USER_UNPUBLISHED, i, "video");
      } : i.hasVideo ? r = () => {
        _.info("[".concat(this._clientId, "] remote user ").concat(i.uid, " unpublished video track")), this.safeEmit(ut.USER_UNPUBLISHED, i, "video");
      } : i.hasAudio && (r = () => {
        _.info("[".concat(this._clientId, "] remote user ").concat(i.uid, " unpublished audio track")), this.safeEmit(ut.USER_UNPUBLISHED, i, "audio");
      }), i._video_pre_subscribed || i._audio_pre_subscribed || (i._trust_audio_stream_added_state_ = true, i._trust_video_stream_added_state_ = true, i._audio_added_ = false, i._video_added_ = false, this._p2pChannel instanceof Jd && this._p2pChannel.unsubscribe(i).then((o) => {
        if (o) return this._gateway.unsubscribe(o, i.uid);
      }), i._audioSSRC = void 0, i._videoSSRC = void 0, i._audioOrtc = void 0, i._videoOrtc = void 0, i._rtxSsrcId = void 0), X.onGatewayStream(this._sessionId, De.ON_REMOVE_STREAM, Jt.ON_REMOVE_STREAM, { peer: n.uint_id || n.uid }), r();
    }), T(this, "_handleSetStreamLocalEnable", (n, i, r) => {
      if (v("BLOCK_LOCAL_CLIENT") && Io(i, this.channelName)) return;
      let o = this._users.find((c) => c.uid === i);
      if (!o) return void _.error("[".concat(this._clientId, "] can not find target user!(disable_local)"));
      _.debug("[".concat(this._clientId, "] local ").concat(n, " ").concat(r ? "enabled" : "disabled", " with uid ").concat(i));
      let s = n === "audio" ? o.hasAudio : o.hasVideo;
      if (n === "audio") {
        o._trust_audio_enabled_state_ = true;
        let c = o._audio_enabled_;
        if (o._audio_enabled_ = r, o._audio_enabled_ === c) return;
        {
          let d = o._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
          _.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(i, ", msg: ").concat(d)), this.safeEmit(ut.USER_INFO_UPDATED, i, d);
        }
      } else {
        o._trust_video_enabled_state_ = true;
        let c = o._video_enabled_;
        if (o._video_enabled_ = r, o._video_enabled_ === c) return;
        {
          let d = o._video_enabled_ ? "enable-local-video" : "disable-local-video";
          _.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(i, ", msg: ").concat(d)), this.safeEmit(ut.USER_INFO_UPDATED, i, d);
        }
      }
      let a = n === "audio" ? o.hasAudio : o.hasVideo;
      return s !== a ? !s && a ? (_.info("[".concat(this._clientId, "] remote user ").concat(i, " published ").concat(n)), void this.safeEmit(ut.USER_PUBLISHED, o, n)) : (n === "video" && o._videoTrack && o._videoTrack._destroy(), n === "audio" && o._audioTrack, this._p2pChannel.muteRemote(o, n), _.info("[".concat(this._clientId, "] remote user ").concat(i, " unpublished ").concat(n)), void this.safeEmit(ut.USER_UNPUBLISHED, o, n)) : void 0;
    }), T(this, "_handleMuteStream", (n, i, r) => {
      if (v("BLOCK_LOCAL_CLIENT") && Io(n, this.channelName)) return;
      _.debug("[".concat(this._clientId, "] receive mute message"), n, i, r);
      let o = this._users.find((c) => c.uid === n);
      if (!o) return void _.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(n));
      let s = i === "audio" ? o.hasAudio : o.hasVideo;
      if (i === "audio") {
        o._trust_audio_mute_state_ = true;
        let c = o._audio_muted_;
        if (o._audio_muted_ = r, o._audio_muted_ === c) return;
        {
          let d = o._audio_muted_ ? "mute-audio" : "unmute-audio";
          _.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(n, ", msg: ").concat(d)), this.safeEmit(ut.USER_INFO_UPDATED, n, d);
        }
      } else {
        o._trust_video_mute_state_ = true;
        let c = o._video_muted_;
        if (o._video_muted_ = r, o._video_muted_ === c) return;
        {
          let d = o._video_muted_ ? "mute-video" : "unmute-video";
          _.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(n, ", msg: ").concat(d)), this.safeEmit(ut.USER_INFO_UPDATED, n, d);
        }
      }
      let a = i === "audio" ? o.hasAudio : o.hasVideo;
      if (s !== a) {
        if (!s && a) return (i === "audio" ? o._audioSSRC : o._videoSSRC) ? (_.info("[".concat(this._clientId, "] remote user ").concat(n, " published ").concat(i)), void this.safeEmit(ut.USER_PUBLISHED, o, i)) : void _.warning("[".concat(this._clientId, "] remote user ").concat(n, " receive ").concat(i, " unmute message  before add stream message, ").concat(i, " SSRC doesn't exist yet."));
        i === "video" && o._videoTrack && !o._video_pre_subscribed && o._videoTrack._destroy(), i === "audio" && o._audioTrack, this._p2pChannel.muteRemote(o, i), _.info("[".concat(this._clientId, "] remote user ").concat(n, " unpublished ").concat(i)), this.safeEmit(ut.USER_UNPUBLISHED, o, i);
      }
    }), T(this, "_handleP2PLost", async (n) => {
      _.debug("[".concat(this._clientId, "] receive p2p lost"), n), parseInt(n.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : _.warning("[".concat(this._clientId, "] P2PLost stream not found"), n);
    }), T(this, "_handleTokenWillExpire", () => {
      _.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), this.safeEmit(ut.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);
    }), T(this, "_handleBeforeUnload", (n) => {
      n.type === "beforeunload" && n.returnValue !== void 0 && n.returnValue !== "" || (this.leave(), _.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide")));
    }), T(this, "_handleUpdateNetworkQuality", () => {
      if (this._networkQualitySensitivity === "normal") return;
      if (navigator && navigator.onLine !== void 0 && !navigator.onLine) return void this.safeEmit(ut.NETWORK_QUALITY, { downlinkNetworkQuality: 6, uplinkNetworkQuality: 6 });
      let n = { downlinkNetworkQuality: 0, uplinkNetworkQuality: 0 };
      n.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), n.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.safeEmit(ut.NETWORK_QUALITY, n);
    }), T(this, "_handleP2PAddAudioOrVideoStream", (n, i, r, o) => {
      let s = this._users.find((c) => c.uid === i);
      if (!s) return void _.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
      _.debug("[".concat(this._clientId, "] stream added with uid ").concat(i, ", type ").concat(n)), this.store.subscribe(s.uid, n, void 0, void 0, void 0, Date.now());
      let a = n === "audio" ? s.hasAudio : s.hasVideo;
      n === "audio" ? s._trust_audio_stream_added_state_ = true : s._trust_video_stream_added_state_ = true, n === "audio" ? (s._audio_added_ = true, r !== void 0 && (s._audioSSRC = r), o !== void 0 && (s._audioMid = o)) : (s._video_added_ = true, r !== void 0 && (s._videoSSRC = r), o !== void 0 && (s._videoMid = o)), (n === "audio" ? s.hasAudio : s.hasVideo) && !a && (_.info("[".concat(this._clientId, "] remote user ").concat(s.uid, " published ").concat(n)), this.safeEmit(ut.USER_PUBLISHED, s, n)), this._p2pChannel.hasPendingRemoteMedia(s, n) && (_.debug("[".concat(this._clientId, "] resubscribe ").concat(n, " for user ").concat(s.uid, " after reconnect.")), this._subscribe(s, n, true).catch((c) => {
        _.error("[".concat(this._clientId, "] resubscribe error"), c.toString());
      }));
    }), this._config = t11, this._clientId = Ut(5, "client-"), this.store = new ME(t11.codec, t11.audioCodec, t11.mode, this._clientId), this.store.clientCreated(), t11.proxyServer && this.setProxyServer(t11.proxyServer, true), t11.turnServer && this.setTurnServer(t11.turnServer, true), _.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(ii, " build: ").concat(Ef, ", mode: ").concat(this.mode, ", codec: ").concat(this.codec)), t11.clientRoleOptions) try {
      fR(t11.clientRoleOptions), e = Object.assign({}, t11.clientRoleOptions);
    } catch (n) {
      _.warning("[".concat(this._clientId, "] ").concat(n.toString()));
    }
    this._statsCollector = new _u(this.store), this._statsCollector.onStatsException = (n, i, r) => {
      _.debug("[".concat(this._clientId, "] receive exception msg, code: ").concat(n, ", msg: ").concat(i, ", uid: ").concat(r)), this.safeEmit(ut.EXCEPTION, { code: n, msg: i, uid: r });
    }, this._statsCollector.onUploadPublishDuration = (n, i, r, o) => {
      let s = this._users.find((a) => a.uid === n);
      s && X.peerPublishStatus(this._sessionId, { subscribeElapse: o, audioPublishDuration: i, videoPublishDuration: r, peer: s._uintid });
    }, this.store.useP2P = t11.mode === "p2p", this._gateway = new tm(this.store, { clientId: this._clientId, mode: this.mode, codec: this.codec, websocketRetryConfig: t11.websocketRetryConfig || Ee, httpRetryConfig: t11.httpRetryConfig || Ee, forceWaitGatewayResponse: t11.forceWaitGatewayResponse === void 0 || t11.forceWaitGatewayResponse, statsCollector: this._statsCollector, role: t11.role, clientRoleOptions: e }), this._configDistribute = new im(), this.store.useP2P ? (this._p2pChannel = new An(this.store, this._statsCollector), this._handleP2PEvents()) : this._p2pChannel = new Jd(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents();
  }
  async joinMeta(t11, e, n, i, r) {
    let o = !(arguments.length > 5 && arguments[5] !== void 0) || arguments[5], s = arguments.length > 6 && arguments[6] !== void 0 && arguments[6];
    Ot("JOIN_GATEWAY_USE_443PORT_ONLY", o), Ot("JOIN_GATEWAY_USE_DUAL_DOMAIN", s);
    let a = this._gateway.signal.websocket;
    return a instanceof Nc && (a.use443PortOnly = o, a.tryDoubleDomain = s), async function(c, d, l) {
      bd.get(c) || bd.set(c, []), wd.get(c) || wd.set(c, d), Yi.get(c) || Yi.set(c, 0);
      let u = bd.get(c), h = wd.get(c);
      if (!u || !h) throw new Error("concurrent: deferQueue or maxConcurrency is null");
      if (Yi.get(c) === h) {
        let S = vc();
        u.push(S), await S.promise;
      }
      Yi.set(c, Yi.get(c) + 1);
      for (var p = arguments.length, g = new Array(p > 3 ? p - 3 : 0), E = 3; E < p; E++) g[E - 3] = arguments[E];
      let f = await l(...g);
      return Yi.set(c, Yi.get(c) - 1), Yi.get(c) === h - 1 && u.length > 0 && (u[0].resolve(), u.shift()), Yi.get(c) === 0 && (bd.set(c, []), wd.set(c, 0), Yi.set(c, 0)), f;
    }("client.join", v("JOIN_MAX_CONCURRENCY"), this.join.bind(this), t11, e, n, i, r);
  }
  async join(t11, e, n, i, r) {
    let o = ++this._numberOfJoinCount;
    this.store.joinStart(), i && (this.store.uid = i);
    let s = (Nd || Nd || (Nd = (window.location.protocol.split(":")[0] || "").toUpperCase(), Nd)) === "HTTPS", a = vR() ? window.isSecureContext : "Browser Not Support";
    (!vR() && !s || !window.isSecureContext) && _.warning("The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser"), this.connectionState === "DISCONNECTED" && (this.store.avoidJoinStart = Math.round(Date.now()), _.debug("[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart))), X.setAppId(t11);
    try {
      if (!n && n !== null) throw new O(R.INVALID_PARAMS, "Invalid token: ".concat(n, ". If you don not use token, set it to null"));
      n && Pe(n, "token", 1, 2047), Pe(t11, "appid", 1, 2047), Xu(e), i && Qu(i), r && Pe(r, "optionalInfo", 1, 2047);
    } catch (E) {
      throw X.reportApiInvoke(Ms(), { name: Te.JOIN, options: [t11, e, n, i], states: { isHttps: s, isSecureContext: a }, tag: Zt.TRACER }).onError(E), E;
    }
    if (this._leaveMutex.isLocked && (_.debug("[".concat(this._clientId, "] join: waiting leave operation")), (await this._leaveMutex.lock())(), _.debug("[".concat(this._clientId, "] join: continue"))), this._joinAndNotLeaveYet = true, this.connectionState !== "DISCONNECTED") {
      let E = new O(R.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state"));
      throw X.reportApiInvoke(Ms(), { name: Te.JOIN, options: [t11, e, n, i], states: { isHttps: s, isSecureContext: a }, tag: Zt.TRACER }).onError(E), E;
    }
    this._gateway.state = "CONNECTING";
    let c = await Xv({ appId: t11, cname: e, uid: i, stringUid: typeof i == "string" ? i : void 0, token: n || t11, cloudProxyServer: this._cloudProxyServerMode });
    if (!this._joinAndNotLeaveYet) throw new O(R.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
    let d = (c == null ? void 0 : c.sid) || Ms();
    _.info("[".concat(this._clientId, "] start join channel ").concat(e, ", join number: ").concat(o)), this._sessionId || (this._sessionId = d, this.store.sessionId = this._sessionId);
    let l = X.reportApiInvoke(d, { name: Te.JOIN, options: [t11, e, n, i], states: { isHttps: s, isSecureContext: a }, tag: Zt.TRACER }), u = xi(xi({}, this._rtmConfig), {}, { clientId: this._clientId, appId: t11, sid: this._sessionId, cname: e, uid: typeof i != "string" ? i : null, turnServer: this._turnServer, proxyServer: this._proxyServer, token: n || t11, cloudProxyServer: this._cloudProxyServerMode, optionalInfo: r, license: this._license, useLocalAccessPoint: this._useLocalAccessPoint, preload: !!c }, this._remoteDefaultVideoStreamType !== void 0 && { defaultVideoStream: this._remoteDefaultVideoStreamType });
    if (this._useLocalAccessPoint && (u.setLocalAPVersion = this._setLocalAPVersion), typeof i == "string" && (u.stringUid = i, this._uintUid ? (u.uid = this._uintUid, this._uintUid = void 0) : u.uid = 0), this._encryptionMode !== "none" && this._encryptionSecret) {
      if (u.aesmode = this._encryptionMode, u.aespassword = await (async (E) => {
        let f = function(b) {
          let w = window.atob(`MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu
STM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+
HvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy
xQiYDz3vqa6bP29adwIDAQAB`), D = new Uint8Array(new ArrayBuffer(w.length));
          for (let k = 0; k < w.length; k += 1) D[k] = w.charCodeAt(k);
          return D;
        }(), S = await window.crypto.subtle.importKey("spki", f, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]), C = uf(E), A = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, S, C);
        return function(b) {
          let w = "";
          for (let D = 0; D < b.length; D += 1) w += String.fromCharCode(b[D]);
          return window.btoa(w);
        }(new Uint8Array(A));
      })(this._encryptionSecret), !this._joinAndNotLeaveYet) throw new O(R.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
      this._encryptionSalt && (u.aessalt = this._encryptionSalt);
    }
    if (this._encryptDataStream && (this._encryptionMode === "aes-128-gcm2" || this._encryptionMode === "aes-256-gcm2")) if (this._encryptionSalt && this._encryptionSecret) if (window.crypto.subtle) {
      let E = new TextEncoder(), f = v("USE_PURE_ENCRYPTION_MASTER_KEY") ? E.encode(u.appId + this._encryptionSecret + this._encryptionSecret) : E.encode(u.appId + u.cname + this._encryptionSecret);
      this._encryptDataStreamIv = await async function(S, C, A) {
        let b = await window.crypto.subtle.importKey("raw", C, "PBKDF2", false, ["deriveBits", "deriveKey"]), w = S === "aes-128-gcm2" ? 128 : 256, D = await window.crypto.subtle.deriveBits({ name: "PBKDF2", iterations: AR, hash: "SHA-256", salt: A }, b, w + TB);
        return new Uint8Array(D).subarray(w / 8);
      }(this._encryptionMode, f, Fo(this._encryptionSalt)), this._encryptDataStreamKey = await async function(S, C, A) {
        let b = await window.crypto.subtle.importKey("raw", C, "PBKDF2", false, ["deriveBits", "deriveKey"]), w = S === "aes-128-gcm2" ? 128 : 256;
        return await window.crypto.subtle.deriveKey({ name: "PBKDF2", iterations: AR, hash: "SHA-256", salt: A }, b, { name: "AES-GCM", length: w }, true, ["encrypt", "decrypt"]);
      }(this._encryptionMode, f, Fo(this._encryptionSalt));
    } else a ? _.warning("[".concat(this._clientId, "] encrypt datastream must be running in a secure context, fallback to plain data stream")) : _.warning("[".concat(this._clientId, "] current browser do not support WebCrypto ,fallback to plain data stream")), this._encryptDataStream = false;
    else this._encryptDataStream = false, _.debug("[".concat(this._clientId, "] no salt / secret, cannot support encrypt data stream, fallback to plain data stream"));
    this._startSession(this._sessionId, { channel: e, appId: t11, stringUid: u.stringUid });
    let h = this._sessionId;
    setTimeout(() => {
      this.connectionState === "CONNECTING" && h === this._sessionId && X.joinChannelTimeout(this._sessionId, 5);
    }, 5e3);
    try {
      var p;
      let E, f = u.cloudProxyServer;
      if (W(p = ["proxy3", "proxy4", "proxy5"]).call(p, f)) {
        let w = v("PROXY_SERVER_TYPE3");
        Array.isArray(w) ? u.proxyServer = w[0] : u.proxyServer = w;
      }
      if (X.setProxyServer(u.proxyServer), _.setProxyServer(u.proxyServer), this.store.requestAPStart(), c) {
        if (_.debug("[".concat(this._clientId, "] get serverInfo Success from Preload Cache ").concat(u.stringUid ? ", ".concat(u.stringUid, " => ").concat(c.intUid) : "", " ")), u.stringUid && !u.uid && (u.uid = c.intUid), E = { gatewayInfo: c.ap.gatewayInfo }, v("JOIN_WITH_FALLBACK_MEDIA_PROXY") && u.turnServer.mode === "auto") if (c.ap.proxyInfo.addresses.length === 0) _.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers");
        else {
          let w = (await kO(c.ap.proxyInfo, c.ap.gatewayInfo.uid)).map((D) => ({ turnServerURL: D.address, tcpport: D.tcpport || Ve.tcpport, udpport: D.udpport || Ve.udpport, username: D.username || Ve.username, password: D.password || Ve.password, forceturn: false, security: true }));
          u.turnServer = { mode: "manual", servers: w };
        }
        Qv(c, u.stringUid);
      } else {
        if (u.stringUid && !u.uid) {
          let w;
          [w, E] = await j.all([h0(u.stringUid, u, this._axiosCancelSource.token, this._config.httpRetryConfig || Ee, this.store), tv(u, this._axiosCancelSource.token, this._config.httpRetryConfig || Ee, true, this.store)]), _.debug("[".concat(this._clientId, "] getUserAccount Success ").concat(u.stringUid, " => ").concat(w)), u.uid = w, E.gatewayInfo.uid = w, E.gatewayInfo.res.uid = w;
        } else E = await tv(u, this._axiosCancelSource.token, this._config.httpRetryConfig || Ee, true, this.store);
        if (!this._joinAndNotLeaveYet) throw new O(R.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
      }
      this.store.requestAPEnd(), setTimeout(() => {
        this._configDistribute.startGetConfigDistribute(u, this._axiosCancelSource.token), this._configDistribute.on(FE.UPDATE_BITRATE_LIMIT, (w) => {
          this._p2pChannel.updateBitrateLimit(w);
        });
      }, 0), this._key = n || t11;
      let S = E.gatewayInfo, C = u.uid ? u.uid : S.uid;
      this._joinInfo = xi(xi({}, u), {}, { cid: S.cid, uid: C, vid: S.vid, apResponse: S.res, apGatewayAddress: S.apGatewayAddress, uni_lbs_ip: S.uni_lbs_ip, gatewayAddrs: S.gatewayAddrs }), this.store.intUid = C;
      let A = await this._joinGateway();
      if (!this._joinAndNotLeaveYet) throw new O(R.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
      l.onSuccess(A), this._appId = t11, this._channelName = u.cname, this._uid = A, this.store.uid = A, setTimeout(() => {
        this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(je() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._statsCollector.startUpdateStats();
      }, 0);
      let b = u.stringUid ? "string uid: ".concat(u.stringUid, ",uid: ").concat(u.uid) : "uid: ".concat(this._uid);
      return _.info("[".concat(this._clientId, "] Joining channel success: channel: ").concat(e, ",").concat(b)), setTimeout(() => {
        _.startUpload();
      }, 5e3), this.store.joinEnd(), g = this, W(Jr).call(Jr, g) || Jr.push(g), this._cloudProxyServerMode === "disabled" && ft().supportWebCrypto && v("ENABLE_PRELOAD") && Df(this._joinInfo), A;
    } catch (E) {
      let f = Array.isArray(E) ? E[0] : E;
      throw f && f.code === R.OPERATION_ABORTED ? _.warning("[".concat(this._clientId, "] join number: ").concat(o, ", Joining channel failed, rollback"), f) : _.error("[".concat(this._clientId, "] join number: ").concat(o, ", Joining channel failed, rollback"), f), f.code !== R.OPERATION_ABORTED && this._numberOfJoinCount === o && (this._gateway.state = "DISCONNECTED", this._reset()), l.onError(f), f;
    }
    var g;
  }
  _joinGateway() {
    if (!this._joinInfo || !this._key) throw new O(R.INVALID_OPERATION);
    return this._gateway.join(this._joinInfo, this._key, !(this._joinInfo.cloudProxyServer !== "disabled" || this._joinInfo.proxyServer || !v("JOIN_WITH_FALLBACK_SIGNAL_PROXY")));
  }
  async leave() {
    _.info("[".concat(this._clientId, "] Leaving channel")), window.removeEventListener(je() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), function(e) {
      let n = Jr.indexOf(e);
      n !== -1 && Jr.splice(n, 1);
    }(this), this._statsCollector.stopUpdateStats();
    let t11 = await this._leaveMutex.lock();
    if (this.connectionState === "DISCONNECTED") return _.info("[".concat(this._clientId, "] Leaving channel repeated, success")), void t11();
    await this._gateway.leave(this.connectionState !== "CONNECTED"), _.info("[".concat(this._clientId, "] Leaving channel success")), this._joinAndNotLeaveYet = false, this.store.resetJoinChannelServiceRecords(), t11();
  }
  async publish(t11) {
    let e = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
    if (!Array.isArray(t11)) {
      if (!(t11 instanceof no)) return this._publishDataChannel(t11);
      t11 = [t11];
    }
    if (t11.length === 0) throw new O(R.INVALID_PARAMS, "param list is empty");
    let n = t11;
    if (this._gateway.role === "audience") throw new O(R.INVALID_OPERATION, "audience can not publish stream");
    for (let r of n) {
      if (!(r instanceof no)) throw new O(R.INVALID_PARAMS, "parameter is not local track");
      if (!r._enabled && e) throw new O(R.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(r.getTrackId()));
    }
    _.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(n.map((r) => "".concat(r.getTrackId(), " "))));
    let i = await this._publishMutex.lock();
    await this._configDistribute.awaitConfigDistributeComplete(), e && n.forEach((r) => {
      let o = this._configDistribute.getBitrateLimit();
      r instanceof Ft && o && r.setBitrateLimit(o.uplink);
    });
    try {
      await this._publishHighStream(n), _.info("[".concat(this._clientId, "] Publish success, id ").concat(n.map((r) => "".concat(r.getTrackId(), " "))));
    } catch (r) {
      throw _.error("[".concat(this._clientId, "] publish error"), r.toString()), r;
    } finally {
      i();
    }
  }
  async _publishDataChannel(t11) {
    Nt(t11.id, "id", 0, 65535, true), Nr(t11.ordered, "ordered"), Pe(t11.metadata, "metadata", 0, 512), _.info("[".concat(this._clientId, "] Publishing datachannels, id ").concat(t11.id));
    let e = await this._publishMutex.lock();
    try {
      if (this._p2pChannel.getAllDataChannels().findIndex((r) => r.id === t11.id) !== -1) throw new O(R.INVALID_PARAMS, "Invalid id: ".concat(t11.id, ". If you want to republish the datachannel, unpublish first"));
      if (!this._joinInfo || this._uid === void 0) throw new O(R.INVALID_OPERATION, "Can't publish datachannel, haven't joined yet!");
      if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can not publish datachannel in ".concat(this.connectionState, " state"));
      if (this._turnServer.mode === "auto" && v("FORCE_TURN") && !v("TURN_ENABLE_TCP") && !v("TURN_ENABLE_UDP")) throw new O(R.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
      let n = function(r) {
        return Kv(r, false);
      }(t11), i = await this._p2pChannel.publishDataChannel([n]);
      if (i.length > 0) {
        if (typeof n._originDataChannelId != "number") throw _.error("[".concat(this._clientId, "] can not publish with mediaType datachannel, cannot get RTCDatachannel id")), new O(R.CREATE_DATACHANNEL_ERROR);
        try {
          await j.all(i.map((r) => this._uid && this._gateway.publishDataChannel(this._uid, r, true))), await n._waitTillOpen();
        } catch (r) {
          if (r.code !== R.DISCONNECT_P2P) throw r;
        }
      }
      return _.info("[".concat(this._clientId, "] Publish dataChannels success, id ").concat(n.id)), n;
    } catch (n) {
      throw _.error("[".concat(this._clientId, "] publish datachannels error"), n.toString()), n;
    } finally {
      e();
    }
  }
  async unpublish(t11) {
    if (!this._joinInfo || this._uid === void 0) throw new O(R.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!");
    let e = [];
    if (t11) if (Array.isArray(t11)) e = t11;
    else {
      if (!(t11 instanceof no)) return this._unpublishDataChannel([t11]);
      e = [t11];
    }
    else this.store.useP2P || await this._unpublishDataChannel(), e = this._p2pChannel.getAllTracks(true);
    _.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(e.map((i) => "".concat(i.getTrackId(), " ")), " "));
    let n = await this._publishMutex.lock();
    try {
      if (this._p2pChannel instanceof An) {
        let i = await this._p2pChannel.unpublish(e);
        i && await this._gateway.sendExtensionMessage(ie.UNPUBLISH, { unpubMsg: i }, true);
      } else {
        let i = await this._p2pChannel.unpublish(e);
        i && await this._gateway.unpublish(i, this._uid), _.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(e.map((r) => "".concat(r.getTrackId()))));
      }
    } catch (i) {
      throw _.error("[".concat(this._clientId, "] unpublish error"), i.toString()), i;
    } finally {
      n && n();
    }
  }
  async _unpublishDataChannel(t11) {
    t11 !== void 0 && t11.length !== 0 || (t11 = this._p2pChannel.getAllDataChannels()), _.info("[".concat(this._clientId, "] Unpublish datachannels, datachannels ").concat(t11.map((n) => "".concat(n.id, " ")), " "));
    let e = await this._publishMutex.lock();
    try {
      let n = await this._p2pChannel.unpublishDataChannel(t11);
      n && await this._gateway.unpublishDataChannel(n), _.info("[".concat(this._clientId, "] Unpublish dataChannel success,dataChannel ").concat(t11.map((i) => "".concat(i.id))));
    } catch (n) {
      throw _.error("[".concat(this._clientId, "] unpublish dataChannel error"), n.toString()), n;
    } finally {
      e && e();
    }
  }
  async subscribe(t11, e, n) {
    if (!(t11 instanceof ir)) {
      let i = this.remoteUsers.find((r) => r.uid === t11);
      if (!i) throw new O(R.INVALID_REMOTE_USER, "user is not in the channel");
      t11 = i;
    }
    return e === "datachannel" ? this._subscribeDataChannel(t11, n) : this._subscribe(t11, e);
  }
  async presubscribe(t11, e) {
    if (Ce(e, "mediaType", ["audio", "video"]), this._p2pChannel instanceof An) throw new O(R.INVALID_OPERATION, "can't presub at p2p mode");
    if (!this._joinInfo) throw new O(R.INVALID_OPERATION, "can't presub when not join");
    if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can't presub in ".concat(this.connectionState, " state"));
    let n = e === Q.AUDIO, i = e === Q.VIDEO, r = await this._subscribeMutex.lock();
    try {
      let { ssrcId: o, ortc: s, rtxSsrcId: a, cname: c, uint_id: d } = await this._gateway.presubscribe(t11, e, true);
      if (o == null) throw new O(R.UNEXPECTED_RESPONSE, "no ssrc id");
      let l = this._users.find((h) => h.uid === t11);
      l || (l = new ir(t11, d || t11), l._is_pre_created = true, this._users.push(l)), c && (l._cname = c), l._uintid || (l._uintid = d || t11), n && (l._audioSSRC = o, l._audio_pre_subscribed = true, s && (l._audioOrtc = s)), i && (l._videoSSRC = o, l._video_pre_subscribed = true, s && (l._videoOrtc = s), a != null && (l._rtxSsrcId = a)), _.info("[".concat(this._clientId, "] presub succeed ssrc: ").concat(o)), await this._p2pChannel.subscribe(l, e, o, a, s);
      let u = n ? l._audioTrack : l._videoTrack;
      if (!u) throw new O(R.UNEXPECTED_ERROR, "can not find remote track in user");
      return n && (l._trust_audio_stream_added_state_ = true, l._audio_added_ = true), i && (l._trust_video_stream_added_state_ = true, l._video_added_ = true), u;
    } catch (o) {
      throw _.error("[".concat(this._clientId, "] presub user ").concat(t11, " error"), o), o;
    } finally {
      r();
    }
  }
  async _subscribeDataChannel(t11, e) {
    var n;
    if (Nt(e, "channelId", 0, 65535, true), !this._joinInfo) throw new O(R.INVALID_OPERATION, "Can't subscribe datachannel, not joined");
    if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "Can't subscribe datachannel in ".concat(this.connectionState, " state"));
    if (!this._users.find((a) => a === t11)) throw _.error("[".concat(this._clientId, "] can not subscribe ").concat(t11.uid, ", this user is not in the channel")), new O(R.INVALID_REMOTE_USER, "user is not in the channel");
    if (!t11.hasAudio && !t11.hasVideo && t11._dataChannels.length === 0) throw _.error("[".concat(this._clientId, "] can not subscribe ").concat(t11.uid, ", user is not published")), new O(R.INVALID_REMOTE_USER, "user is not published");
    let r = (n = t11._dataChannels) === null || n === void 0 ? void 0 : n.find((a) => a.id === e);
    if (!r) throw _.error("[".concat(this._clientId, "] can not subscribe ").concat(t11.uid, " with mediaType datachannel, remote datachannel is not published")), new O(R.REMOTE_USER_IS_NOT_PUBLISHED);
    let o = await this._subscribeMutex.lock();
    _.info("[".concat(this._clientId, "] subscribe user ").concat(t11.uid, ", mediaType: datachannel"));
    try {
      let a = await this._p2pChannel.subscribeDataChannel(t11, [r]);
      if (a && W(a).call(a, r.id)) try {
        var s;
        if (typeof r._originDataChannelId != "number") throw _.error("[".concat(this._clientId, "] can not subscribe ").concat(t11.uid, " with mediaType datachannel, cannot get RTCDatachannel")), new O(R.CREATE_DATACHANNEL_ERROR);
        let c = { id: r.id, datachannelId: r._originDataChannelId, ordered: r.ordered, maxRetransmits: r.maxRetransmits, metadata: (s = r.metadata) !== null && s !== void 0 ? s : "" };
        await this._gateway.subscribeDataChannel(t11.uid, c, true), await r._waitTillOpen();
      } catch (c) {
        if ((c == null ? void 0 : c.code) !== R.WS_ABORT) throw await this._p2pChannel.unsubscribeDataChannel(t11, [r]), c;
        await this._p2pChannel.unsubscribeDataChannel(t11, [r]), this._p2pChannel.setPendingRemoteDataChannel(t11, r.id);
      }
      return _.info("[".concat(this._clientId, "] subscribe success user ").concat(t11.uid, ", mediaType: datachannel")), r;
    } finally {
      o();
    }
  }
  async _p2pSubscribe(t11, e, n) {
    if (Ce(e, "mediaType", ["audio", "video"]), !this._joinInfo) throw new O(R.INVALID_OPERATION, "Can't subscribe stream, not joined");
    if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
    if (!this._users.find((o) => o === t11)) {
      let o = new O(R.INVALID_REMOTE_USER, "user is not in the channel");
      throw _.error("[".concat(this._clientId, "] can not subscribe ").concat(t11.uid, ", this user is not in the channel")), o;
    }
    if (!t11.hasAudio && !t11.hasVideo) {
      let o = new O(R.INVALID_REMOTE_USER, "user is not published");
      throw _.error("[".concat(this._clientId, "] can not subscribe ").concat(t11.uid, ", user is not published")), o;
    }
    if (!n && (e === "audio" && !t11.hasAudio || e === "video" && !t11.hasVideo)) {
      let o = new O(R.REMOTE_USER_IS_NOT_PUBLISHED);
      throw _.error("[".concat(this._clientId, "] can not subscribe ").concat(t11.uid, " with mediaType ").concat(e, ", remote track is not published")), o;
    }
    let r = await this._subscribeMutex.lock();
    _.info("[".concat(this._clientId, "] subscribe user ").concat(t11.uid, ", mediaType: ").concat(e));
    try {
      if (await this._p2pChannel.hasRemoteMediaWithLock(t11, e)) await this._p2pChannel.unmuteRemote(t11, e);
      else try {
        let s = e === "audio" ? t11._audioSSRC : t11._videoSSRC, a = e === "audio" ? t11._audioMid : t11._videoMid;
        this.store.subscribe(t11.uid, e, Date.now()), this._p2pChannel instanceof An && await this._p2pChannel.subscribe(t11, e, s, a);
      } catch (s) {
        throw s;
      }
      _.info("[".concat(this._clientId, "] subscribe success user ").concat(t11.uid, ", mediaType: ").concat(e)), this._defaultStreamFallbackType && this.setStreamFallbackOption(t11.uid, this._defaultStreamFallbackType).catch((s) => {
        _.warning("[".concat(this._clientId, "] auto set fallback failed"), s);
      });
      let o = e === "audio" ? t11._audioTrack : t11._videoTrack;
      if (!o) throw new O(R.UNEXPECTED_ERROR, "can not find remote track in user object");
      return o;
    } catch (o) {
      throw _.error("[".concat(this._clientId, "] subscribe user ").concat(t11.uid, " error"), o), o;
    } finally {
      r();
    }
  }
  async _subscribe(t11, e, n) {
    if (this._p2pChannel instanceof An) return this._p2pSubscribe(t11, e);
    if (Ce(e, "mediaType", ["audio", "video"]), !this._joinInfo) throw new O(R.INVALID_OPERATION, "Can't subscribe stream, not joined");
    if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
    if (!this._users.find((d) => d === t11)) {
      let d = new O(R.INVALID_REMOTE_USER, "user is not in the channel");
      throw _.error("[".concat(this._clientId, "] can not subscribe ").concat(t11.uid, ", this user is not in the channel")), d;
    }
    if (!t11.hasAudio && !t11.hasVideo) {
      let d = new O(R.INVALID_REMOTE_USER, "user is not published");
      throw _.error("[".concat(this._clientId, "] can not subscribe ").concat(t11.uid, ", user is not published")), d;
    }
    if (!(n || (e !== "audio" || t11.hasAudio && t11._audioSSRC !== void 0) && (e !== "video" || t11.hasVideo && t11._videoSSRC !== void 0))) {
      let d = new O(R.REMOTE_USER_IS_NOT_PUBLISHED);
      throw _.error("[".concat(this._clientId, "] can not subscribe ").concat(t11.uid, " with mediaType ").concat(e, ", remote track is not published")), d;
    }
    let r = e === "audio" ? t11._audioSSRC : t11._videoSSRC, o = e === "audio" ? t11._audioOrtc : t11._videoOrtc, s = e === "video" ? t11._rtxSsrcId : void 0, a = { stream_type: e === "audio" ? Q.AUDIO : Q.VIDEO, ssrcId: r }, c = await this._subscribeMutex.lock();
    _.info("[".concat(this._clientId, "] subscribe user ").concat(t11.uid, ", mediaType: ").concat(e));
    try {
      if (await this._p2pChannel.hasRemoteMediaWithLock(t11, e)) await this._p2pChannel.unmuteRemote(t11, e);
      else try {
        let l = e === "audio" ? t11._audioSSRC : t11._videoSSRC;
        l !== void 0 && l !== r && (r = l, o = e === "audio" ? t11._audioOrtc : t11._videoOrtc, s = e === "video" ? t11._rtxSsrcId : void 0, a = { stream_type: e === "audio" ? Q.AUDIO : Q.VIDEO, ssrcId: r }), qe.markSubscribeStart(this.store.clientId, r), this.store.subscribe(t11.uid, e, Date.now()), await this._p2pChannel.subscribe(t11, e, r, s, o);
        try {
          this._p2pChannel.isPreSubScribe(r) || await this._gateway.subscribe(t11.uid, a, true);
        } catch (u) {
          if ((u == null ? void 0 : u.code) !== R.WS_ABORT) throw await this._p2pChannel.unsubscribe(t11, e), u;
          await this._p2pChannel.unsubscribe(t11, e, true), this._p2pChannel.setPendingRemoteMedia(t11, e);
        }
        this.store.subscribe(t11.uid, e, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(true, null, t11, e);
      } catch (l) {
        throw this._p2pChannel.reportSubscribeEvent(false, l == null ? void 0 : l.code, t11, e), l;
      }
      _.info("[".concat(this._clientId, "] subscribe success user ").concat(t11.uid, ", mediaType: ").concat(e)), this._defaultStreamFallbackType && this.setStreamFallbackOption(t11.uid, this._defaultStreamFallbackType).catch((l) => {
        _.warning("[".concat(this._clientId, "] auto set fallback failed"), l);
      });
      let d = e === "audio" ? t11._audioTrack : t11._videoTrack;
      if (!d) throw new O(R.UNEXPECTED_ERROR, "can not find remote track in user object");
      return d;
    } catch (d) {
      throw _.error("[".concat(this._clientId, "] subscribe user ").concat(t11.uid, " error"), d), d;
    } finally {
      c();
    }
  }
  async massSubscribe(t11) {
    if (br(t11, "subscribeList"), !this._joinInfo) throw new O(R.INVALID_OPERATION, "Can't subscribe stream, not joined");
    if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
    let e = Date.now(), n = /* @__PURE__ */ new Map(), i = await this._subscribeMutex.lock();
    _.info("[".concat(this._clientId, "]start massSubscribe user ").concat(t11.map((a) => {
      let { user: c, mediaType: d } = a;
      return "user: ".concat(c == null ? void 0 : c.uid, ", mediaType: ").concat(d);
    }).join("; ")));
    let r = (t11 = [...t11]).map((a) => {
      let { user: c, mediaType: d } = a;
      return { user: c, mediaType: d };
    }), o = await this._p2pChannel.globalLock();
    try {
      var s;
      for (let c = t11.length - 1; c >= 0; c--) {
        let d = t11[c], { user: l, mediaType: u } = d;
        if (Ce(u, "mediaType", ["audio", "video"]), !l) {
          let E = new O(R.INVALID_PARAMS, "user property does not exist in subscribeList item");
          throw _.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), E;
        }
        if (!this._users.find((E) => E === l)) {
          let E = new O(R.INVALID_REMOTE_USER, "user is not in the channel");
          _.error("[".concat(this._clientId, "] can not massSubscribe ").concat(l.uid, ", this user is not in the channel")), r[c].error = E, t11.splice(c, 1);
          continue;
        }
        if (u === "audio" && (!l.hasAudio || l._audioSSRC === void 0) || u === "video" && (!l.hasVideo || l._videoSSRC === void 0)) {
          let E = new O(R.REMOTE_USER_IS_NOT_PUBLISHED);
          _.error("[".concat(this._clientId, "] can not subscribe ").concat(l.uid, " with mediaType ").concat(u, ", remote user is not published")), r[c].error = E, t11.splice(c, 1);
          continue;
        }
        let p = ve.Video | ve.LwoVideo, g = n.get(l);
        if (g) {
          if (u === "video" ? g & p : g & ve.Audio) {
            t11.splice(c, 1), _.warning("[".concat(this._clientId, "] repeat massSubscribe user:").concat(l.uid, ", mediaType:").concat(u, " twice"));
            continue;
          }
          n.set(l, g | (u === "video" ? p : ve.Audio));
        } else n.set(l, u === "video" ? p : ve.Audio);
      }
      for (let c = t11.length - 1; c >= 0; c--) {
        let d = t11[c], { user: l, mediaType: u } = d, h = ve.Video | ve.LwoVideo;
        if (this._p2pChannel.hasRemoteMedia(l, u)) {
          await this._p2pChannel.unmuteRemoteNoLock(l, u);
          let p = n.get(l);
          n.set(l, u === "video" ? p ^ h : p ^ ve.Audio), t11.splice(c, 1);
        }
      }
      this.store.massSubscribe(t11.map((c) => ({ userId: c.user.uid, type: c.mediaType })), e);
      let a = ji(s = Array.from(n.entries())).call(s, (c, d) => {
        let [l, u] = d;
        if (u === 0) return c;
        let h = { stream_id: l.uid, stream_type: u };
        return u & ve.Audio && (h.audio_ssrc = l._audioSSRC), u & ve.Video && (h.video_ssrc = l._videoSSRC), c.push(h), c;
      }, []);
      try {
        t11.length > 0 && await this._p2pChannel.massSubscribeNoLock(t11.map((d) => {
          let { user: l, mediaType: u } = d;
          return { user: l, mediaType: u, ssrcId: u === Q.VIDEO ? l._videoSSRC : l._audioSSRC, rtxSsrcId: u === Q.VIDEO ? l._rtxSsrcId : void 0 };
        }));
        let c = /* @__PURE__ */ new Map();
        if (a = a.filter((d) => d.video_ssrc && !this._p2pChannel.isPreSubScribe(d.video_ssrc) || d.audio_ssrc && !this._p2pChannel.isPreSubScribe(d.audio_ssrc) || !d.video_ssrc && !d.audio_ssrc), a.length > 0) {
          let d = await this._gateway.subscribeAll(a, true);
          ((d == null ? void 0 : d.users) || []).forEach((l) => {
            let { stream_id: u, video_error_code: h, audio_error_code: p, error_code: g } = l;
            (h || p || g) && c.set(u, { video_error_code: h, audio_error_code: p, error_code: g });
          });
        }
        if (Array.from(c.entries()).length > 0) {
          let d = [];
          Array.from(c.entries()).forEach((l) => {
            let [u, h] = l, p = this.remoteUsers.find((g) => g.uid === u);
            if (p) {
              let g;
              h.error_code || h.video_error_code && h.audio_error_code ? g = void 0 : h.video_error_code ? g = Q.VIDEO : h.audio_error_code && (g = Q.AUDIO), d.push({ user: p, mediaType: g });
            }
          }), d.length > 0 && await this._p2pChannel.massUnsubscribeNoLock(d);
        }
        for (let d of r) {
          let l = c.get(d.user.uid);
          if (l) {
            let u = l.error_code || d.mediaType === "audio" && l.audio_error_code || d.mediaType === "video" && l.video_error_code;
            if (u) {
              let h = Oc(u);
              _.error("user:".concat(d.user.uid, " mediaType:").concat(d.mediaType, " has massSubscribe error ").concat(h.desc)), d.error = new O(R.SUBSCRIBE_FAILED, "code ".concat(u, ": ").concat(h.desc));
            }
          }
          d.error || (d.mediaType === "video" ? d.track = d.user.videoTrack : d.track = d.user.audioTrack);
        }
        return this.store.massSubscribe(r.filter((d) => !d.error).map((d) => ({ userId: d.user.uid, type: d.mediaType })), void 0, Date.now()), r.forEach((d) => {
          var l;
          X.subscribe(this.store.sessionId, { succ: !!d.error, ec: ((l = d.error) === null || l === void 0 ? void 0 : l.code) || null, video: d.mediaType === Q.VIDEO, audio: d.mediaType === Q.AUDIO, peerid: d.user.uid, subscribeRequestid: d.mediaType === Q.VIDEO ? d.user._videoSSRC : d.user._audioSSRC, p2pid: this.store.p2pId, eventElapse: Math.floor(performance.now() - e), preSsrc: this._p2pChannel.isPreSubScribe(d.user._videoSSRC) }, true);
        }), _.info("[".concat(this._clientId, "] massSubscribe success ").concat(t11.map((d) => {
          let { user: l, mediaType: u } = d;
          return "user: ".concat(l == null ? void 0 : l.uid, ", mediaType: ").concat(u);
        }).join("; "))), r;
      } catch (c) {
        throw await this._p2pChannel.massUnsubscribeNoLock(t11), c;
      }
    } finally {
      o(), i();
    }
  }
  async unsubscribe(t11, e, n) {
    if (!(t11 instanceof ir)) {
      let o = this.remoteUsers.find((s) => s.uid === t11);
      if (!o) throw new O(R.INVALID_REMOTE_USER, "user is not in the channel");
      t11 = o;
    }
    if (e || this.store.useP2P) {
      if (e === "datachannel") return this._unsubscribeDataChannel(t11, n);
    } else await this._unsubscribeDataChannel(t11, n);
    if (e && Ce(e, "mediaType", ["audio", "video"]), !this._joinInfo) throw new O(R.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!");
    if (!this._users.find((o) => o === t11)) {
      let o = new O(R.INVALID_REMOTE_USER, "user is not in the channel");
      throw _.error("[".concat(this._clientId, "] can not unsubscribe ").concat(t11.uid, ", user is not in the channel")), o;
    }
    _.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(t11.uid, ", mediaType: ").concat(e));
    let r = await this._subscribeMutex.lock();
    try {
      if (this._p2pChannel instanceof An) await this._p2pChannel.unsubscribe(t11, e);
      else {
        let o = await this._p2pChannel.unsubscribe(t11, e);
        o && await this._gateway.unsubscribe(o, t11.uid), e && e !== "audio" || (t11._audio_pre_subscribed = false), e && e !== "video" || (t11._video_pre_subscribed = false), t11._is_pre_created && Wl(this._users, t11), _.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(t11.uid, ", mediaType: ").concat(e));
      }
    } catch (o) {
      if (o.code === R.DISCONNECT_P2P) return void _.warning("disconnecting p2p, abort unsubscribe request.");
      throw _.error("[".concat(this._clientId, "] unsubscribe user ").concat(t11.uid, " error"), o.toString()), o;
    } finally {
      r();
    }
  }
  async _unsubscribeDataChannel(t11, e) {
    if (e && Nt(e, "id", 0, 65535, true), !this._joinInfo) throw new O(R.INVALID_OPERATION, "Can't unsubscribe datachannel, haven't joined yet!");
    if (!this._users.find((r) => r === t11)) {
      let r = new O(R.INVALID_REMOTE_USER, "user is not in the channel");
      throw _.error("[".concat(this._clientId, "] can not unsubscribe ").concat(t11.uid, ", user is not in the channel")), r;
    }
    let i;
    if (typeof e == "number") {
      let r = t11._dataChannels.find((o) => o.id === e);
      r && (i = [r]);
    } else i = t11._dataChannels;
    if (i === void 0) {
      let r = new O(R.REMOTE_USER_IS_NOT_PUBLISHED);
      throw _.error("[".concat(this._clientId, "] can not unsubscribe ").concat(t11.uid, " with channelId ").concat(e, ", remote datachannel is not published")), r;
    }
    _.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(t11.uid, ", mediaType: datachannel, ids: ").concat(i.map((r) => r.id)));
    try {
      let r = await this._p2pChannel.unsubscribeDataChannel(t11, i);
      r && await this._gateway.unsubscribeDataChannel(r, t11.uid), _.info("[".concat(this._clientId, "] unsubscribe datachannel success uid: ").concat(t11.uid, ", mediaType: datachannel, ids: ").concat(r));
    } catch (r) {
      if (r.code === R.DISCONNECT_P2P) return void _.warning("disconnecting p2p, abort unsubscribe request.");
      throw _.error("[".concat(this._clientId, "] unsubscribe user ").concat(t11.uid, " error"), r.toString()), r;
    }
  }
  async massUnsubscribe(t11) {
    if (br(t11, "unsubscribeList"), !this._joinInfo) throw new O(R.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!");
    _.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(t11.map((n) => {
      let { user: i, mediaType: r } = n;
      return "user: ".concat(i == null ? void 0 : i.uid, ", mediaType: ").concat(r, ";");
    }).join())), t11 = [...t11];
    let e = /* @__PURE__ */ new Map();
    for (let n = t11.length - 1; n >= 0; n--) {
      let { user: i, mediaType: r } = t11[n];
      if (!i) {
        let a = new O(R.INVALID_PARAMS, "user property does not exist in unsubscribeList item");
        throw _.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), a;
      }
      if (Ce(r, "mediaType", ["video", "audio", void 0]), !this._users.find((a) => a === i)) {
        _.warning("[".concat(this._clientId, "] can not unsubscribe ").concat(i.uid, ", user is not in the channel")), t11.splice(n, 1);
        continue;
      }
      let s = ve.Video | ve.LwoVideo;
      if (e.has(i)) {
        let a = e.get(i), c;
        switch (r) {
          case "video":
            c = a & s;
            break;
          case "audio":
            c = a & ve.Audio;
            break;
          default:
            c = a & (ve.Audio | s);
        }
        if (c) {
          _.warning("[".concat(this._clientId, "] repeat massUnsubscribe user:").concat(i.uid, ",mediaType:").concat(r, " twice.")), t11.splice(n, 1);
          continue;
        }
        r ? r === "audio" ? e.set(i, a | ve.Audio) : r === "video" && e.set(i, a | s) : e.set(i, a | ve.Audio | s);
      } else r ? r === "audio" ? e.set(i, ve.Audio) : r === "video" && e.set(i, s) : e.set(i, ve.Audio | s);
    }
    try {
      let n = await this._p2pChannel.massUnsubscribe(t11);
      n && await this._gateway.massUnsubscribe(n), _.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(t11.map((i) => {
        let { user: r, mediaType: o } = i;
        return "user: ".concat(r == null ? void 0 : r.uid, ", mediaType: ").concat(o, ";");
      }).join()));
    } catch (n) {
      if (n.code === R.DISCONNECT_P2P) return void _.warning("[".concat(this._clientId, "] disconnecting p2p, abort unsubscribe request."));
      throw _.error("[".concat(this._clientId, "] massUnsubscribe error"), n.toString()), n;
    }
  }
  async setLowStreamParameter(t11) {
    (function(n) {
      if (!n) throw new N(R.INVALID_PARAMS);
      zt(n.width) || bp(n.width, "streamParameter.width"), zt(n.height) || bp(n.height, "streamParameter.height"), zt(n.framerate) || bp(n.framerate, "streamParameter.framerate"), zt(n.bitrate) || Nt(n.bitrate, "streamParameter.bitrate");
    })(t11), (!t11.width && t11.height || t11.width && !t11.height) && _.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), _.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(t11));
    let e = this._configDistribute.getLowStreamConfigDistribute();
    if (e && e.bitrate && t11.bitrate && e.bitrate < t11.bitrate && (t11.bitrate = e.bitrate), this._lowStreamParameter = t11, this._isDualStreamEnabled) return this._p2pChannel.updateVideoStreamParameter(t11, U.LocalVideoLowTrack);
  }
  async enableDualStream() {
    if (!ft().supportDualStream) throw X.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), new O(R.NOT_SUPPORTED, "Your browser is not support dual stream");
    if (this._isDualStreamEnabled) throw new O(R.INVALID_OPERATION, "Dual stream is already enabled");
    if (this._p2pChannel.canPublishLowStream()) try {
      await this._publishLowStream();
    } catch (t11) {
      throw X.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: false }), t11;
    }
    this._isDualStreamEnabled = true, X.streamSwitch(this._sessionId, { lts: Date.now(), isdual: true, succ: true }), _.info("[".concat(this._clientId, "] enable dual stream"));
  }
  async disableDualStream() {
    if (this._isDualStreamEnabled) {
      if (!this._joinInfo) throw new O(R.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
      if (this._p2pChannel.getLocalMedia(U.LocalVideoLowTrack)) try {
        let t11 = await this._p2pChannel.unpublishLowStream();
        t11 && await this._gateway.unpublish(t11, this._joinInfo.stringUid || this._joinInfo.uid);
      } catch (t11) {
        throw X.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: false }), t11;
      }
      this._isDualStreamEnabled = false, X.streamSwitch(this._sessionId, { lts: Date.now(), isdual: false, succ: true }), _.info("[".concat(this._clientId, "] disable dual stream"));
    }
  }
  async setClientRole(t11, e) {
    if (function(n) {
      Ce(n, "role", ["audience", "host"]);
    }(t11), e && fR(e), this.mode === "rtc" || this.mode === "p2p") throw _.warning("[".concat(this._clientId, "]").concat(this.mode, " mode can not use setClientRole")), new O(R.INVALID_OPERATION, "".concat(this.mode, " mode can not use setClientRole"));
    if (e && e.level && t11 === "host") throw new O(R.INVALID_OPERATION, "host mode can not set audience latency level");
    if (t11 === "audience" && this._p2pChannel.hasLocalMedia()) throw new O(R.INVALID_OPERATION, "can not set client role to audience when publishing stream");
    await this._gateway.setClientRole(t11, e), this._config.role = t11, _.info("[".concat(this._clientId, "] set client role to ").concat(t11, ", level: ").concat(e && e.level));
  }
  getRemoteInboundOffset() {
    var t11;
    let e = (t11 = this._p2pChannel.getStats()) === null || t11 === void 0 ? void 0 : t11.audioSend[0];
    if (!e || !e.timestamp) return 0;
    let n = e.timestamp - Date.now();
    return Math.abs(n) > 1e3 + e.rttMs + 100 ? this.ntpAlignErrorCount += 1 : this.ntpAlignErrorCount = 0, this.ntpAlignErrorCount >= 3 ? n : 0;
  }
  getNtpWallTimeInMs() {
    return document.visibilityState === "visible" && (this.remoteInboundOffset = this.getRemoteInboundOffset()), this.remoteInboundOffset + Date.now() + this._gateway.ntpOffset;
  }
  setProxyServer(t11, e) {
    if (Pe(t11, "proxyServer"), !e) {
      if (this.connectionState !== "DISCONNECTED") throw new O(R.INVALID_OPERATION, "Set proxy server before join channel");
      if (this._cloudProxyServerMode !== "disabled" || this._useLocalAccessPoint) throw new O(R.INVALID_OPERATION, "You have already set the proxy");
    }
    this._proxyServer = t11, X.setProxyServer(this._proxyServer), _.setProxyServer(this._proxyServer), _.info("[".concat(this._clientId, "] Set proxy server ").concat(e ? "by initialize call" : "", " success."));
  }
  setTurnServer(t11, e) {
    if (Array.isArray(t11) || (t11 = [t11]), !e) {
      if (this.connectionState !== "DISCONNECTED") throw new O(R.INVALID_OPERATION, "Set turn server before join channel");
      if (this._cloudProxyServerMode !== "disabled" || this._useLocalAccessPoint) throw new O(R.INVALID_OPERATION, "You have already set the proxy");
    }
    if (Yu(t11)) return this._turnServer = { servers: t11, mode: "original-manual" }, void _.info("[".concat(this._clientId, "] Set original turnserver ").concat(e ? "by initialize call" : "", " success: ").concat(t11.map((n) => n.urls).join(","), "."));
    t11.forEach((n) => vO(n)), this._turnServer = { servers: t11, mode: "manual" }, _.info("[".concat(this._clientId, "] Set turnserver ").concat(e ? "by initialize call" : "", " success."));
  }
  setLicense(t11) {
    if (this.connectionState !== "DISCONNECTED") throw new O(R.INVALID_OPERATION, "you should set license before join channel");
    if (Pe(t11, "license", 32, 32), !/^[A-Za-z\d]+$/.test(t11)) throw new O(R.INVALID_PARAMS, "license should only contains characters from A-Z a-z 0-9");
    this._license = t11, _.info("[".concat(this._clientId, "] set license success"), t11);
  }
  startProxyServer(t11) {
    if (this.connectionState !== "DISCONNECTED") throw new O(R.INVALID_OPERATION, "Start proxy server before join channel");
    if (this._proxyServer || this._turnServer.mode === "manual" || this._useLocalAccessPoint) throw new O(R.INVALID_OPERATION, "You have already set the proxy");
    let e = [3, 4, 5], n;
    switch (t11 === void 0 && (t11 = 3), t11) {
      case 1:
      case 2:
        throw new O(R.NOT_SUPPORTED, "proxy mode 1/2 has been deprecated and not supported.");
      case 3:
        n = "proxy3";
        break;
      case 4:
        n = "proxy4";
        break;
      case 5:
        n = "proxy5";
        break;
      default:
        throw new O(R.INVALID_PARAMS, "proxy server mode must be ".concat(e.join("|")));
    }
    this._cloudProxyServerMode = n, this.store.cloudProxyServerMode = n, _.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode);
  }
  stopProxyServer() {
    if (this.connectionState !== "DISCONNECTED") throw new O(R.INVALID_OPERATION, "Stop proxy server after leave channel");
    X.setProxyServer(), _.setProxyServer(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", _.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = { mode: "auto", servers: [] };
  }
  setLocalAccessPointsV2(t11) {
    if (!t11.accessPoints) throw new O(R.INVALID_PARAMS, "accessPoints is required.");
    br(t11.accessPoints.serverList, "accessPoints.serverList"), Pe(t11.accessPoints.domain, "accessPoints.domain");
    let e = (h, p) => {
      Nt(h, p, 0, 65535, true);
    }, n = 443;
    if (t11.accessPoints.port && (e(t11.accessPoints.port, "accessPoints.port"), n = t11.accessPoints.port), this._proxyServer || this._cloudProxyServerMode !== "disabled") throw new O(R.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
    v("CLOSE_AFB_FOR_LOCAL_AP") && (Ot("JOIN_WITH_FALLBACK_SIGNAL_PROXY", false), Ot("JOIN_WITH_FALLBACK_MEDIA_PROXY", false));
    let i = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/, r = t11.accessPoints.domain, o = t11.accessPoints.serverList.map((h) => i.test(h) ? "".concat(h.replace(/\./g, "-"), ".").concat(r) : h), s = o.map((h) => "".concat(h, ":").concat(n));
    this._useLocalAccessPoint = true, this._setLocalAPVersion = 2, Ot("WEBCS_DOMAIN", s), Ot("WEBCS_DOMAIN_BACKUP_LIST", s), Ot("GATEWAY_DOMAINS", [r]), t11.report && t11.report.hostname && Array.isArray(t11.report.hostname) && t11.report.hostname.length ? (br(t11.report.hostname, "report.hostname"), Ot("EVENT_REPORT_DOMAIN", t11.report.hostname[0]), Ot("EVENT_REPORT_BACKUP_DOMAIN", t11.report.hostname[1] || t11.report.hostname[0])) : (Ot("EVENT_REPORT_DOMAIN", o[0]), Ot("EVENT_REPORT_BACKUP_DOMAIN", o[1] || o[0]));
    let a = 6443;
    t11.report && t11.report.port && (e(t11.report.port, "report.port"), a = t11.report.port), Ot("STATS_COLLECTOR_PORT", a), t11.report ? Ot("ENABLE_EVENT_REPORT", true) : Ot("ENABLE_EVENT_REPORT", false);
    let c = "";
    t11.log && t11.log.hostname && Array.isArray(t11.log.hostname) && t11.log.hostname.length ? (br(t11.log.hostname, "log.hostname"), c = t11.log.hostname[0]) : c = o[0];
    let d = 6444;
    t11.log && t11.log.port && (e(t11.log.port, "log.port"), d = t11.log.port), Ot("LOG_UPLOAD_SERVER", "".concat(c, ":").concat(d));
    let l = [];
    t11.cds && t11.cds.hostname && Array.isArray(t11.cds.hostname) && t11.cds.hostname.length ? (br(t11.cds.hostname, "cds.hostname"), l = t11.cds.hostname) : l = o;
    let u = 443;
    t11.cds && t11.cds.port && (e(t11.cds.port, "cds.port"), u = t11.cds.port), Ot("CDS_AP", l.map((h) => "".concat(h, ":").concat(u))), t11.cds ? Ot("ENABLE_CONFIG_DISTRIBUTE", true) : Ot("ENABLE_CONFIG_DISTRIBUTE", false), _.info("set local access point v2 success");
  }
  setLocalAccessPoints(t11, e) {
    if (br(t11, "serverList"), Pe(e, "domain"), this._proxyServer || this._cloudProxyServerMode !== "disabled") throw new O(R.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
    let n = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
    t11 = t11.map((i) => n.test(i) ? "".concat(i.replace(/\./g, "-"), ".").concat(e) : i), this._useLocalAccessPoint = true, this._setLocalAPVersion = 1, Ot("WEBCS_DOMAIN", t11), Ot("WEBCS_DOMAIN_BACKUP_LIST", t11), Ot("GATEWAY_DOMAINS", [e]), Ot("EVENT_REPORT_DOMAIN", t11[0]), Ot("EVENT_REPORT_BACKUP_DOMAIN", t11[1] || t11[0]), Ot("LOG_UPLOAD_SERVER", "".concat(t11[0], ":6444")), _.info("[".concat(this._clientId, "] set local access point success"));
  }
  async setRemoteDefaultVideoStreamType(t11) {
    if (Ce(t11, "streamType", [0, 1]), this._remoteDefaultVideoStreamType = t11, this._joinInfo) try {
      await this._gateway.setDefaultRemoteVideoStreamType(t11), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;
    } catch (e) {
      throw _.error("[".concat(this._clientId, "] set default remote video stream type error"), e.toString()), e;
    }
    else _.debug("[".concat(this._clientId, "] haven't joined yet, cache remoteDefaultVideoStreamType ").concat(t11));
  }
  async setRemoteVideoStreamType(t11, e) {
    Ce(e, "streamType", [0, 1]);
    try {
      await this._gateway.setRemoteVideoStreamType(t11, e), setTimeout(() => {
        let n = this._users.find((i) => i.uid === t11);
        n && n.videoTrack && n.videoTrack.updateMediaStreamTrackResolution();
      }, 2e3);
    } catch (n) {
      throw _.error("[".concat(this._clientId, "] set remote video stream type error"), n.toString()), n;
    }
    _.info("[".concat(this._clientId, "] set remote ").concat(t11, " video stream type to ").concat(e)), this._remoteStreamTypeCacheMap.set(t11, e);
  }
  async setStreamFallbackOption(t11, e) {
    Ce(e, "fallbackType", [0, 1, 2]);
    try {
      await this._gateway.setStreamFallbackOption(t11, e);
    } catch (n) {
      throw _.error("[".concat(this._clientId, "] set stream fallback option"), n.toString()), n;
    }
    _.info("[".concat(this._clientId, "] set remote ").concat(t11, " stream fallback type to ").concat(e)), this._streamFallbackTypeCacheMap.set(t11, e);
  }
  setEncryptionConfig(t11, e, n, i) {
    (function(o) {
      Ce(o, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"]);
    })(t11), Pe(e, "secret");
    let r = ["aes-128-gcm2", "aes-256-gcm2"];
    if (W(r).call(r, t11)) {
      if (!n || !(n instanceof Uint8Array && n.length === 32)) throw new O(R.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes");
    } else if (n) throw new O(R.INVALID_PARAMS, "current encrypt mode does not need salt");
    if (i) {
      if (Nr(i, "encryptDataStream"), !W(r).call(r, t11)) throw new O(R.INVALID_PARAMS, "current encrypt mode does not support data stream");
      this._encryptDataStream = true;
    }
    new RegExp(`^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'"|{}\\[\\]])(?=.{8,})`).test(e) || _.warning(`The secret is not strong:
      The secret must contain at least 1 lowercase alphabetical character,
      The secret must contain at least 1 uppercase alphabetical character,
      The secret must contain at least 1 numeric character,
      The secret must contain at least one special character,
      The secret must be eight characters or longer.
      `), this._encryptionMode = t11, this._encryptionSecret = e, n && (this._encryptionSalt = so(n));
  }
  async renewToken(t11) {
    if (Pe(t11, "token", 1, 2047), !this._key || !this._joinInfo) throw new O(R.INVALID_OPERATION, "renewToken should not be called before user join");
    let e = this._key;
    this._key = t11, this._joinInfo && (this._joinInfo.token = t11);
    let n = await this._renewTokenMutex.lock();
    try {
      if (v("USE_NEW_TOKEN")) {
        _.debug("[".concat(this._clientId, "] start renew token with ticket from unilbs"));
        let i = await JG(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || Ee);
        _.debug("[".concat(this._clientId, "] get ticket from unilbs success")), await this._gateway.renewToken({ token: t11, ticket: i });
      } else _.debug("[".concat(this._clientId, "] start renew token without ticket")), await this._gateway.renewToken({ token: t11 });
      _.debug("[".concat(this._clientId, "] renewToken success"));
    } catch (i) {
      throw this._key = e, this._joinInfo.token = e, _.error("[".concat(this._clientId, "] renewToken failed"), i.toString()), i;
    } finally {
      n();
    }
  }
  enableAudioVolumeIndicator() {
    this._audioVolumeIndicationInterval ? _.warning("you have already enabled audio volume indicator!") : this._audioVolumeIndicationInterval = window.setInterval(() => {
      let t11 = this._p2pChannel.getAudioLevels();
      this.safeEmit(ut.VOLUME_INDICATOR, t11);
    }, v("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3);
  }
  getRTCStats() {
    let t11 = this._statsCollector.getRTCStats(), e = this._gateway.getInChannelInfo();
    return t11.Duration = Math.round(e.duration / 1e3), t11;
  }
  async startLiveStreaming(t11, e) {
    if (!e) {
      if (this.codec !== "h264") throw new O(R.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
      if (!this._p2pChannel.hasLocalMedia()) throw new O(R.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming");
    }
    if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(t11) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(t11)) throw new O(R.LIVE_STREAMING_TASK_CONFLICT);
    let n = e ? er.TRANSCODE : er.RAW;
    return this._createLiveStreamingClient(n).startLiveStreamingTask(t11, n);
  }
  setLiveTranscoding(t11) {
    return this._createLiveStreamingClient(er.TRANSCODE).setTranscodingConfig(t11);
  }
  async stopLiveStreaming(t11) {
    let e = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter((n) => n && n.hasUrl(t11));
    if (!e.length) throw new O(R.INVALID_PARAMS, "can not find live streaming url to stop");
    await j.all(e.map((n) => n && n.stopLiveStreamingTask(t11)));
  }
  async startChannelMediaRelay(t11) {
    Pv(t11), await this._createChannelMediaRelayClient().startChannelMediaRelay(t11);
  }
  async updateChannelMediaRelay(t11) {
    Pv(t11), await this._createChannelMediaRelayClient().updateChannelMediaRelay(t11);
  }
  async stopChannelMediaRelay() {
    await this._createChannelMediaRelayClient().stopChannelMediaRelay(), this._statsCollector.onStatsChanged && (this._statsCollector.onStatsChanged = void 0);
  }
  async sendStreamMessage(t11) {
    var e;
    let n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
    if (!this._joinInfo) throw new O(R.INVALID_OPERATION, "can not send data stream, not joined");
    if ((typeof t11 == "string" || t11 instanceof Uint8Array) && (t11 = { payload: t11 }), typeof t11.payload == "string") {
      let r = new TextEncoder();
      t11.payload = r.encode(t11.payload);
    }
    let i = false;
    if (this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && W(e = ["aes-128-gcm2", "aes-256-gcm2"]).call(e, this._encryptionMode) && (i = true, t11.payload = await async function(r, o, s) {
      var a;
      let c = ji(a = Array.from(s)).call(a, (E, f) => E + f, 0), d = { serverTs: 0, seq: SB++, length: s.length, checkSum: c }, l = new Uint8Array(IR(c, 2)), u = new ArrayBuffer(us), h = new DataView(u);
      h.setUint32(0, d.serverTs), h.setUint16(4, d.seq), h.setUint16(6, d.length), h.setUint16(8, d.checkSum);
      let p = 16 - s.length % 16;
      s = TR(s, new Uint8Array(p));
      let g = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: r, tagLength: yR, additionalData: l }, o, s);
      return TR(new Uint8Array(u), new Uint8Array(g));
    }(this._encryptDataStreamIv, this._encryptDataStreamKey, t11.payload)), new Blob([t11.payload]).size > 1024) throw new O(R.INVALID_PARAMS, i ? "encrypted stream message out of range." : "stream message out of range.");
    return this._gateway.signal.request(et.DATA_STREAM, { payload: so(t11.payload), syncWithAudio: t11.syncWithAudio, sendTs: Date.now() - EW }, !n);
  }
  sendMetadata(t11) {
    if (!this._joinInfo) throw new O(R.INVALID_OPERATION, "can not send metadata, not joined");
    if (new Blob([t11]).size > 1024) throw new O(R.METADATA_OUT_OF_RANGE);
    return this._gateway.signal.request(et.SEND_METADATA, { session_id: this._joinInfo.sid, metadata: so(t11) });
  }
  async sendCustomReportMessage(t11) {
    if (Array.isArray(t11) || (t11 = [t11]), t11.forEach(RB), !this._joinInfo) throw new O(R.INVALID_OPERATION, "can not send custom report, not joined");
    await X.sendCustomReportMessage(this._joinInfo.sid, t11);
  }
  getLocalAudioStats() {
    return this._statsCollector.getLocalAudioTrackStats();
  }
  getRemoteAudioStats() {
    return this._statsCollector.getRemoteAudioTrackStats();
  }
  getLocalVideoStats() {
    return this._statsCollector.getLocalVideoTrackStats();
  }
  getRemoteVideoStats() {
    return this._statsCollector.getRemoteVideoTrackStats();
  }
  getRemoteNetworkQuality() {
    return this._statsCollector.getRemoteNetworkQualityStats();
  }
  async pickSVCLayer(t11, e) {
    Ce(e.spatialLayer, "spatialLayer", [0, 1, 2, 3]), Ce(e.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
    try {
      await this._gateway.pickSVCLayer(t11, e);
    } catch (n) {
      throw _.error("[".concat(this._clientId, "] pick SVC layer failed"), n.toString()), n;
    }
  }
  async setRTMConfig(t11) {
    let { apRTM: e = false, rtmFlag: n } = t11;
    if (Nr(e, "apRTM"), Nt(n, "rtmFlag", 0), this._rtmConfig.apRTM = e, this._rtmConfig.rtmFlag = n, _.debug("[".concat(this._clientId, "] setRTMconfig ").concat(JSON.stringify(t11), " in ").concat(this.connectionState, " state")), (this.connectionState === "CONNECTED" || this.connectionState === "RECONNECTING") && this._joinInfo) return this._joinInfo.apRTM = e, this._joinInfo.rtmFlag = n, this._gateway.setRTM2Flag(n);
  }
  _reset() {
    if (_.debug("[".concat(this._clientId, "] reset client")), this._axiosCancelSource.cancel(), this._axiosCancelSource = mn.CancelToken.source(), this._streamFallbackTypeCacheMap = /* @__PURE__ */ new Map(), this._remoteStreamTypeCacheMap = /* @__PURE__ */ new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo && b0(this._joinInfo), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._encryptDataStreamKey = null, this._encryptDataStreamIv = null, this._pendingPublishedUsers = [], this._users.forEach((t11) => {
      t11._audioTrack && t11._audioTrack._destroy(), t11._videoTrack && t11._videoTrack._destroy(), t11._dataChannels && (t11._dataChannels.forEach((e) => e._close()), t11._dataChannels.length = 0);
    }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), this._cloudProxyServerMode === "fallback" && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new ze("client-publish"), this._subscribeMutex = new ze("client-subscribe"), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect) try {
      this._inspect.close(), this._inspect = void 0;
    } catch {
    }
    if (this._moderation) try {
      this.setImageModeration(false);
    } catch {
    }
  }
  _startSession(t11, e) {
    var n;
    let i = t11 || Ms();
    t11 ? _.debug("[".concat(this._clientId, "] new Session ").concat(i)) : _.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(i));
    let r = t11 ? "" : this._sessionId || "";
    this._sessionId = i, this.store.sessionId = i;
    let o = { lts: (/* @__PURE__ */ new Date()).getTime(), mode: this.mode, buildFormat: 2, stringUid: (e == null ? void 0 : e.stringUid) || ((n = this._joinInfo) === null || n === void 0 ? void 0 : n.stringUid), channelProfile: this.mode === "live" ? 1 : 0, channelMode: 0, isABTestSuccess: Number(this._configDistribute.isSuccess), lsid: r, clientRole: this.role === "audience" ? 2 : 1 };
    X.sessionInit(this._sessionId, xi({ cname: e.channel, appid: e.appId }, o)), this._joinInfo && (this._joinInfo.sid = i), this._gateway.joinInfo && (this._gateway.joinInfo.sid = i);
  }
  async _publishHighStream(t11) {
    if (!this._joinInfo || this._uid === void 0) throw new O(R.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
    if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
    if (this._turnServer.mode === "auto" && v("FORCE_TURN") && !v("TURN_ENABLE_TCP") && !v("TURN_ENABLE_UDP")) throw new O(R.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
    _.debug("[".concat(this._clientId, "] publish high stream"));
    try {
      let n = await this._p2pChannel.publish(t11, this._isDualStreamEnabled, this._lowStreamParameter);
      if (this._p2pChannel instanceof An) {
        let i = (await n.next()).value;
        if (i) {
          try {
            await this._gateway.sendExtensionMessage(ie.PUBLISH, i, true);
          } catch (r) {
            throw n.throw(r), r;
          }
          await n.next();
        }
        this._p2pChannel.reportPublishEvent(true, null);
      } else {
        let i = (await n.next()).value;
        if (i) {
          var e;
          let r;
          try {
            r = await this._gateway.publish(this._uid, i, true);
          } catch (o) {
            if (o.code !== R.DISCONNECT_P2P) throw n.throw(o), o;
          }
          await n.next(((e = r) === null || e === void 0 ? void 0 : e.ortc) || []);
        }
        this._p2pChannel.reportPublishEvent(true, null);
        for (let r of t11) r instanceof Ft && r._encoderConfig && this._gateway.setVideoProfile(r._encoderConfig), !r.muted && r.enabled || await this._p2pChannel.muteLocalTrack(r);
      }
    } catch (n) {
      if (this._p2pChannel.reportPublishEvent(false, n == null ? void 0 : n.code, t11), (n == null ? void 0 : n.code) === R.WS_ABORT) return;
      throw n;
    }
  }
  async _publishLowStream() {
    if (!this._joinInfo || this._uid === void 0) throw new O(R.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
    if (this.connectionState !== "CONNECTED" && this.connectionState !== "RECONNECTING") throw new O(R.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
    _.debug("[".concat(this._clientId, "] publish low stream"));
    let t11 = this._configDistribute.getLowStreamConfigDistribute();
    t11 && t11.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = { width: 160, height: 120, framerate: 15, bitrate: 50 }), this._lowStreamParameter && this._lowStreamParameter.bitrate && t11.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = t11.bitrate));
    try {
      let n = await this._p2pChannel.publishLowStream(this._lowStreamParameter), i = (await n.next()).value;
      if (i) {
        var e;
        let r;
        try {
          r = await this._gateway.publish(this._uid, i, true);
        } catch (o) {
          if (o.code !== R.DISCONNECT_P2P) throw n.throw(o), o;
        }
        n.next(((e = r) === null || e === void 0 ? void 0 : e.ortc) || []), this._p2pChannel.reportPublishEvent(true, null, void 0, true);
      }
    } catch (n) {
      if (this._p2pChannel.reportPublishEvent(false, n == null ? void 0 : n.code, void 0, true), (n == null ? void 0 : n.code) === R.WS_ABORT) return;
      throw n;
    }
  }
  _createLiveStreamingClient(t11) {
    let e = () => {
      if (!this._joinInfo || !this._appId) return new O(R.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw();
      let n = (i = { joinInfo: this._joinInfo, appId: this._appId, websocketRetryConfig: this._config.websocketRetryConfig, httpRetryConfig: this._config.httpRetryConfig }, Za("LiveStreaming").create(i));
      var i;
      return n.onLiveStreamError = (r, o) => {
        X.reportApiInvoke(this._sessionId, { name: Te.ON_LIVE_STREAM_ERROR, options: [r, o], tag: Zt.TRACER }).onSuccess(), this.safeEmit(ut.LIVE_STREAMING_ERROR, r, o);
      }, n.onLiveStreamWarning = (r, o) => {
        X.reportApiInvoke(this._sessionId, { name: Te.ON_LIVE_STREAM_WARNING, options: [r, o], tag: Zt.TRACER }).onSuccess(), this.safeEmit(ut.LIVE_STREAMING_WARNING, r, o);
      }, n.on(VE.REQUEST_WORKER_MANAGER_LIST, (r, o, s) => {
        if (!this._joinInfo) return s(new O(R.INVALID_OPERATION, "can not find join info to get worker manager"));
        (async function(a, c, d, l) {
          let u = v("UAP_AP").slice(0, v("AJAX_REQUEST_CONCURRENT")).map((h) => c.proxyServer ? "https://".concat(c.proxyServer, "/ap/?url=").concat(h + "/api/v1?action=uap") : "https://".concat(h, "/api/v1?action=uap"));
          return await WG(u, a, c, d, l);
        })(r, this._joinInfo, this._axiosCancelSource.token, Ee).then(o).catch(s);
      }), n;
    };
    return t11 === er.RAW ? (this._liveRawStreamingClient = this._liveRawStreamingClient || e(), this._liveRawStreamingClient) : (this._liveTranscodeStreamingClient = this._liveTranscodeStreamingClient || e(), this._liveTranscodeStreamingClient);
  }
  _createChannelMediaRelayClient() {
    if (!this._joinInfo) return new O(R.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw();
    if (!this._channelMediaRelayClient) {
      let { sendResolutionWidth: e, sendResolutionHeight: n } = this.getLocalVideoStats(), i = (t11 = { joinInfo: this._joinInfo, clientId: this._clientId, websocketRetryConfig: this._config.websocketRetryConfig, httpRetryConfig: this._config.httpRetryConfig, resolution: { width: e, height: n } }, Za("ChannelMediaRelay").create(t11));
      i.on("state", (r) => {
        r === Sn.RELAY_STATE_FAILURE && i && i.dispose(), this.safeEmit(ut.CHANNEL_MEDIA_RELAY_STATE, r);
      }), i.on("event", (r) => {
        this.safeEmit(ut.CHANNEL_MEDIA_RELAY_EVENT, r);
      }), this._channelMediaRelayClient = i, this._statsCollector.onStatsChanged = (r, o) => {
        var s;
        r === "resolution" && ((s = this._channelMediaRelayClient) === null || s === void 0 || s.setVideoProfile(o));
      };
    }
    var t11;
    return this._channelMediaRelayClient;
  }
  _handleUpdateDataChannel(t11, e) {
    let { added: n, deleted: i } = t11, r = [];
    if (e) {
      let o = [];
      this._users.forEach((s) => {
        s._dataChannels.forEach((a) => {
          n.every((c) => c.uid !== s._uintid || c.stream_id !== a.id) && o.push({ uid: s._uintid, stream_id: a.id, ordered: a.ordered, max_retrans_times: a.maxRetransmits, metadata: a.metadata });
        });
      }), o.length > 0 && this._handleUpdateDataChannel({ added: [], deleted: o });
    }
    Array.isArray(n) && n.length > 0 && n.forEach((o) => {
      let { uid: s, stream_id: a, ordered: c, max_retrans_times: d, metadata: l } = o, u = this._users.find((h) => h._uintid === s);
      if (!u) return void _.error("[".concat(this._clientId, "] can not find target user!(on_add_data_channel)"));
      if (_.debug("[".concat(this._clientId, "] data_channel added with uid ").concat(s)), W(r).call(r, u) || r.push(u), u._uintid || (u._uintid = s), u._dataChannels.findIndex((h) => h.id === o.stream_id) === -1) {
        let h = { id: a, ordered: !!c, maxRetransmits: d, metadata: l }, p = function(g) {
          return Kv(g, true);
        }(h);
        u._dataChannels.push(p), _.info("[".concat(this._clientId, "] remote user ").concat(u.uid, " published datachannel")), e || this.safeEmit(ut.USER_PUBLISHED, u, "datachannel", h);
      }
      this._p2pChannel.hasPendingRemoteDataChannel(u, o.stream_id) && (_.debug("[".concat(this._clientId, "] resubscribe datachannel for user ").concat(u.uid, " after reconnect.")), this._subscribeDataChannel(u, o.stream_id).catch((h) => {
        _.error("[".concat(this._clientId, "] resubscribe datachannel error"), h.toString());
      }));
    }), e && (this.safeEmit(ut.PUBLISHED_USER_LIST, this._pendingPublishedUsers), this._pendingPublishedUsers = []), Array.isArray(i) && i.length > 0 && i.forEach((o) => {
      let { uid: s, stream_id: a } = o, c = this._users.find((l) => l._uintid === s);
      if (!c) return void _.error("[".concat(this._clientId, "] can not find target user!(on_delete_data_channel)"));
      let d = c._dataChannels.find((l) => l.id === o.stream_id);
      d && (_.debug("[".concat(this._clientId, "] data_stream delete with uid ").concat(s)), this._p2pChannel.unsubscribeDataChannel(c, [d]).then((l) => {
        if (c._dataChannels = c._dataChannels.filter((u) => u !== d), l) return this._gateway.unsubscribeDataChannel(l, c.uid);
      }), _.info("[".concat(this._clientId, "] remote user ").concat(s, " unpublished datachannel ,id:").concat(d.id)), this.safeEmit(ut.USER_UNPUBLISHED, c, "datachannel", d._config));
    });
  }
  _handleRemoveDataChannels(t11) {
    let e = this._users.find((n) => n.uid === t11.uid);
    if (e) {
      if (e._dataChannels !== void 0 && e._dataChannels.length > 0) {
        _.debug("[".concat(this._clientId, "] datachannel removed with uid ").concat(t11.uid));
        let n = () => {
          _.info("[".concat(this._clientId, "] remote user ").concat(e.uid, " unpublished datachannel")), e._dataChannels.forEach((i) => {
            this.safeEmit(ut.USER_UNPUBLISHED, e, "datachannel", i._config);
          });
        };
        this._p2pChannel.unsubscribeDataChannel(e, e._dataChannels).then((i) => {
          if (i) return this._gateway.unsubscribeDataChannel(i, e.uid);
        }), n();
      }
    } else _.warning("[".concat(this._clientId, "] can not find target user!(on_remove_datachannel)"));
  }
  _handleGatewayEvents() {
    this._gateway.on(xe.DISCONNECT_P2P, async () => {
      await this._p2pChannel.disconnectForReconnect();
    }), this._gateway.on(xe.CONNECTION_STATE_CHANGE, (t11, e, n) => {
      var i;
      if (n === At.FALLBACK) return;
      let r = () => {
        this.safeEmit(ut.CONNECTION_STATE_CHANGE, t11, e, n);
      };
      if (X.reportApiInvoke(this._sessionId || ((i = this._gateway.joinInfo) === null || i === void 0 ? void 0 : i.sid) || null, { name: Te.CONNECTION_STATE_CHANGE, options: [t11, e, n], tag: Zt.TRACER }).onSuccess(JSON.stringify({ cur: t11, prev: e, reason: n })), _.info("[".concat(this._clientId, "] connection state change: ").concat(e, " -> ").concat(t11)), t11 === "DISCONNECTED") return this._reset(), void r();
      if (t11 === "RECONNECTING") this._users.forEach((s) => {
        s._trust_in_room_ = false, s._trust_audio_enabled_state_ = false, s._trust_video_enabled_state_ = false, s._trust_audio_mute_state_ = false, s._trust_video_mute_state_ = false, s._trust_audio_stream_added_state_ = false, s._trust_video_stream_added_state_ = false, s._is_pre_created || (s._audio_pre_subscribed || (s._audioSSRC = void 0, s._audioOrtc = void 0), s._video_pre_subscribed || (s._videoSSRC = void 0, s._videoOrtc = void 0, s._rtxSsrcId = void 0), s._cname = void 0);
      }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;
      else if (t11 === "CONNECTED") {
        var o;
        this._streamFallbackTypeCacheMap.forEach((s, a) => {
          this._gateway.setStreamFallbackOption(a, s).catch((c) => {
            _.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), c);
          });
        }), this._remoteStreamTypeCacheMap.forEach((s, a) => {
          this._gateway.setRemoteVideoStreamType(a, s).catch((c) => {
            _.warning("[".concat(this._clientId, "] auto set remote stream type failed"), c);
          });
        }), this._remoteDefaultVideoStreamType !== void 0 && ((o = this._joinInfo) === null || o === void 0 ? void 0 : o.defaultVideoStream) === void 0 && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {
          _.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected"));
        }).catch((s) => {
          _.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(s));
        }), this.store.useP2P || (this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {
          this.connectionState === "CONNECTED" && (this._userOfflineTimeout = void 0, this._users.filter((s) => !s._trust_in_room_).forEach((s) => {
            _.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(s.uid)), this._handleUserOffline({ uid: s.uid });
          }));
        }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {
          this.connectionState === "CONNECTED" && (this._streamRemovedTimeout = void 0, this._users.forEach((s) => {
            s._trust_audio_mute_state_ || (_.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(s.uid)), this._handleMuteStream(s.uid, Q.AUDIO, false)), s._trust_video_mute_state_ || (_.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(s.uid)), this._handleMuteStream(s.uid, Q.VIDEO, false)), s._trust_audio_enabled_state_ || (_.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(s.uid)), this._handleSetStreamLocalEnable("audio", s.uid, true)), s._trust_video_enabled_state_ || (_.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(s.uid)), this._handleSetStreamLocalEnable("video", s.uid, true)), s._trust_video_stream_added_state_ || (_.debug("[".concat(this._clientId, "] auto dispatch reset video stream added ").concat(s.uid)), this._handleResetAddStream(s, "video")), s._trust_audio_stream_added_state_ || (_.debug("[".concat(this._clientId, "] auto dispatch reset audio stream added ").concat(s.uid)), this._handleResetAddStream(s, "audio")), s._video_added_ || s._audio_added_ || (_.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(s.uid)), this._handleRemoveStream({ uid: s.uid, uint_id: s._uintid }));
          }));
        }, 1e3));
      }
      r();
    }), this._gateway.on(xe.REQUEST_NEW_GATEWAY_LIST, async (t11, e) => {
      if (!this._joinInfo) return e(new O(R.UNEXPECTED_ERROR, "can not recover, no join info"));
      try {
        let n, i = await Xv(xi(xi({}, this._joinInfo), {}, { uid: this._joinInfo.uid, stringUid: void 0 }));
        i ? (n = i.ap, Qv(i), this._joinInfo.preload = true) : (n = await nm(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || Ee, this.store), this._joinInfo.preload = false), this._joinInfo && (this._joinInfo.apResponse = n.gatewayInfo.res, this._joinInfo.gatewayAddrs = n.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = n.gatewayInfo.uni_lbs_ip);
        let r = [];
        n.gatewayInfo.gatewayAddrs.forEach((o) => {
          let { address: s } = o, [a, c] = s.split(":");
          this._joinInfo && this._joinInfo.proxyServer ? r.push({ proxy: this._joinInfo.proxyServer, host: a, port: c }) : r.push({ host: a, port: c });
        }), t11(r);
      } catch (n) {
        e(n);
      }
    }), this._gateway.on(xe.NETWORK_QUALITY, (t11) => {
      this._networkQualitySensitivity === "normal" && this.safeEmit(ut.NETWORK_QUALITY, t11);
    }), this._gateway.on(xe.STREAM_TYPE_CHANGE, (t11, e) => {
      this.safeEmit(ut.STREAM_TYPE_CHANGED, t11, e), X.reportApiInvoke(this._sessionId, { name: Te.STREAM_TYPE_CHANGE, options: [t11, e], tag: Zt.TRACER }).onSuccess(JSON.stringify({ uid: t11, streamType: e }));
    }), this._gateway.on(xe.IS_P2P_DISCONNECTED, (t11) => {
      this._p2pChannel.isP2PDisconnected() ? t11(true) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? t11(false) : t11(true);
    }), this._gateway.on(xe.REQUEST_P2P_CONNECTION_PARAMS, async (t11, e, n) => {
      try {
        let i = await this._p2pChannel.getEstablishParams();
        v("ENABLE_PREALLOC_PC") && i || (i = await this._p2pChannel.startP2PConnection(t11)), e(i);
      } catch (i) {
        n(i);
      }
    }), this._gateway.on(xe.JOIN_RESPONSE, (t11, e) => {
      if (this.store.useP2P) return;
      let n = qI(t11.ortc, e, t11.attributes.userAttributes.preSubSsrcs);
      this._p2pChannel.connect(n);
    }), this._gateway.on(xe.PRE_CONNECT_PC, async (t11) => {
      let { candidates: e, fingerprint: n } = t11;
      if (this._joinInfo && e.length > 0 && !this._p2pChannel.isPlanB) {
        var i;
        await this._p2pChannel.startP2PConnection({ turnServer: this._joinInfo.turnServer });
        let { cert: r, cid: o } = this._joinInfo.apResponse;
        await this._p2pChannel.connect({ iceParameters: { iceUfrag: "".concat(o, "_").concat(r), icePwd: "".concat(o, "_").concat(r) }, dtlsParameters: { fingerprints: [{ hashFunction: "sha-256", fingerprint: (i = v("FINGERPRINT")) !== null && i !== void 0 ? i : n }] }, candidates: e, rtpCapabilities: { send: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] }, recv: { audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: [] } }, setup: "active", cname: "o/i14u9pJrxRKAsu", preallocation: true });
      }
    });
  }
  _handleGatewaySignalEvents() {
    this._gateway.signal.on(dt.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(dt.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(dt.ON_ADD_AUDIO_STREAM, (t11) => this._handleAddAudioOrVideoStream("audio", t11.uid, t11.ssrcId, t11.cname, t11.uint_id, t11.ortc)), this._gateway.signal.on(dt.ON_ADD_VIDEO_STREAM, (t11) => this._handleAddAudioOrVideoStream("video", t11.uid, t11.ssrcId, t11.cname, t11.uint_id, t11.ortc, t11.rtxSsrcId)), this._gateway.signal.on(dt.ON_REMOTE_DATASTREAM_UPDATE, (t11) => {
      this._handleUpdateDataChannel(t11);
    }), this._gateway.signal.on(dt.ON_REMOTE_FULL_DATASTREAM_INFO, (t11) => {
      this._handleUpdateDataChannel({ added: t11.datastreams || [], deleted: [] }, true);
    }), this._gateway.signal.on(dt.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(dt.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(dt.MUTE_AUDIO, (t11) => this._handleMuteStream(t11.uid, Q.AUDIO, true)), this._gateway.signal.on(dt.UNMUTE_AUDIO, (t11) => this._handleMuteStream(t11.uid, Q.AUDIO, false)), this._gateway.signal.on(dt.MUTE_VIDEO, (t11) => this._handleMuteStream(t11.uid, Q.VIDEO, true)), this._gateway.signal.on(dt.UNMUTE_VIDEO, (t11) => this._handleMuteStream(t11.uid, Q.VIDEO, false)), this._gateway.signal.on(dt.RECEIVE_METADATA, (t11) => {
      let e = Fo(t11.metadata);
      this.safeEmit(ut.RECEIVE_METADATA, t11.uid, e);
    }), this._gateway.signal.on(dt.ON_DATA_STREAM, async (t11) => {
      var e;
      if (!t11) return;
      let n = Fo(t11.payload);
      if (this._encryptDataStream && this._encryptDataStreamIv && this._encryptDataStreamKey && window.crypto.subtle && W(e = ["aes-128-gcm2", "aes-256-gcm2"]).call(e, this._encryptionMode)) {
        if (t11.payload.length < us) throw new O(R.UNEXPECTED_RESPONSE, "payload length ".concat(t11.payload.length, " is less than header length ").concat(us));
        n = await async function(o, s, a) {
          let c = a.subarray(0, us), d = c.slice(8, us), l = (d[0] << 8) + d[1], u = (c[6] << 8) + c[7], h = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: o, tagLength: yR, additionalData: new Uint8Array(IR(l, 2)) }, s, a.subarray(us));
          return new Uint8Array(h).subarray(0, u);
        }(this._encryptDataStreamIv, this._encryptDataStreamKey, n);
      }
      let i = 0;
      if (t11.ordered || t11.syncWithAudio) {
        let r = this._p2pChannel.getStats(), o = this.remoteUsers.find((a) => a.uid === t11.uid), s = r == null ? void 0 : r.audioRecv.find((a) => a.ssrc === (o == null ? void 0 : o._audioSSRC));
        i = s == null ? void 0 : s.jitterBufferMs;
      }
      i == null && (i = 0), fW(xi(xi({}, t11), {}, { payload: n }), i, { id: this._clientId, onStreamMessage: typeof this.onStreamMessage == "function" ? this.onStreamMessage.bind(this) : void 0, safeEmit: this.safeEmit.bind(this) });
    }), this._gateway.signal.on(dt.ON_CRYPT_ERROR, () => {
      po(() => {
        _.warning("[".concat(this._clientId, "] on crypt error")), this.safeEmit(ut.CRYPT_ERROR);
      }, this._sessionId);
    }), this._gateway.signal.on(dt.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(dt.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
      _.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), this._gateway.leave(true, At.TOKEN_EXPIRE), this.safeEmit(ut.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();
    }), this._gateway.signal.on(dt.ON_STREAM_FALLBACK_UPDATE, (t11) => {
      _.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(t11.stream_id, ", attr: ").concat(t11.stream_type)), this.safeEmit(ut.STREAM_FALLBACK, t11.stream_id, t11.stream_type === 1 ? "fallback" : "recover");
    }), this._gateway.signal.on(dt.ON_PUBLISH_STREAM, (t11) => {
      this.uid === this._uid && (this._p2pChannel.reportPublishEvent(true, null, void 0, false, JSON.stringify({ proxy: t11.proxy })), _.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(t11))));
    }), this._gateway.signal.on(dt.ENABLE_LOCAL_VIDEO, (t11) => {
      this._handleSetStreamLocalEnable("video", t11.uid, true);
    }), this._gateway.signal.on(dt.DISABLE_LOCAL_VIDEO, (t11) => {
      this._handleSetStreamLocalEnable("video", t11.uid, false);
    }), this._gateway.signal.on(nt.REQUEST_TIMEOUT, (t11, e) => {
      if (this._joinInfo) switch (t11) {
        case et.PUBLISH: {
          if (!e) return;
          let r = e.ortc;
          if (r) {
            var n, i;
            let o = r.some((c) => {
              let { stream_type: d } = c;
              return d === Ct.Audio;
            }), s = r.some((c) => {
              let { stream_type: d } = c;
              return d !== Ct.Audio;
            }), a = r.some((c) => {
              let { stream_type: d } = c;
              return d === Ct.Screen || d === Ct.ScreenLow;
            });
            e.state === "offer" && X.publish(this._joinInfo.sid, { eventElapse: qe.measureFromPublishStart(this.store.clientId, this.store.pubId), succ: false, ec: R.TIMEOUT, audio: o, video: s, p2pid: e.p2p_id, publishRequestid: this.store.pubId, screenshare: a, audioName: o ? (n = r.find((c) => {
              let { stream_type: d } = c;
              return d === Ct.Audio;
            })) === null || n === void 0 || (n = n.ssrcs[0]) === null || n === void 0 ? void 0 : n.ssrcId.toString() : void 0, videoName: s ? (i = r.find((c) => {
              let { stream_type: d } = c;
              return d !== Ct.Audio;
            })) === null || i === void 0 || (i = i.ssrcs[0]) === null || i === void 0 ? void 0 : i.ssrcId.toString() : void 0 });
          }
          break;
        }
        case et.SUBSCRIBE:
          e && X.subscribe(this._joinInfo.sid, { succ: false, ec: R.TIMEOUT, audio: e.stream_type === Q.AUDIO, video: e.stream_type === Q.VIDEO, peerid: e.stream_id, subscribeRequestid: e.ssrcId, p2pid: this.store.p2pId, eventElapse: qe.measureFromSubscribeStart(this.store.clientId, e.ssrcId), preSsrc: this._p2pChannel.isPreSubScribe(e.ssrcId) });
      }
    }), this._gateway.signal.on(dt.ON_P2P_OK, (t11) => {
      this.uid, this._uid;
    }), this._gateway.signal.on(dt.ON_PUBLISHED_USER_LIST, (t11) => {
      if (t11 == null || !t11.users) return;
      v("BLOCK_LOCAL_CLIENT") && (t11.users = t11.users.filter((i) => !Io(i.string_id || i.stream_id, this.channelName)));
      let e = [], n = [];
      for (let i of t11.users) {
        let r = this._users.find((l) => l._uintid === i.stream_id);
        r ? r._trust_in_room_ = true : (r = new ir(i.string_id || i.stream_id, i.stream_id), this._users.push(r), this.getListeners(ut.PUBLISHED_USER_LIST).length === 0 && (_.debug("[".concat(this._clientId, "] user online"), i.stream_id), this.safeEmit(ut.USER_JOINED, r)));
        let o = ve.Audio & i.stream_type, s = (ve.Video | ve.LwoVideo) & i.stream_type, a = (65280 & i.stream_type) != 0, c = o && r.hasAudio, d = s && r.hasVideo;
        s && (r._trust_video_stream_added_state_ = true, r._video_added_ = true, r._videoSSRC = i.video_ssrc, r._rtxSsrcId = i.video_rtx), o && (r._trust_audio_stream_added_state_ = true, r._audio_added_ = true, r._audioSSRC = i.audio_ssrc), o && !c && this.getListeners(ut.PUBLISHED_USER_LIST).length === 0 && (_.info("[".concat(this._clientId, "] remote user ").concat(r.uid, " published audio")), this.safeEmit(ut.USER_PUBLISHED, r, "audio")), s && !d && this.getListeners(ut.PUBLISHED_USER_LIST).length === 0 && (_.info("[".concat(this._clientId, "] remote user ").concat(r.uid, " published video")), this.safeEmit(ut.USER_PUBLISHED, r, "video")), (o && !c || s && !d || a) && e.push(r), s && this._p2pChannel.hasPendingRemoteMedia(r, "video") && n.push({ user: r, mediaType: "video" }), o && this._p2pChannel.hasPendingRemoteMedia(r, "audio") && n.push({ user: r, mediaType: "audio" });
      }
      n.length > 0 && (_.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(n.map((i) => "user: ".concat(i.user.uid, ", mediaType: ").concat(i.mediaType)).join("; "), " ")), this.massSubscribe(n).catch((i) => {
        _.error("[".concat(this._clientId, "] mass resubscribe error"), i.toString());
      })), this.getListeners(ut.PUBLISHED_USER_LIST).length > 0 ? v("ENABLE_DATASTREAM_2") ? this._pendingPublishedUsers = e : (_.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(e.map((i) => i.uid).join(", "))), this.safeEmit(ut.PUBLISHED_USER_LIST, e)) : _.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(e.map((i) => i.uid).join(", ")));
    }), this._gateway.signal.on(dt.ON_RTP_CAPABILITY_CHANGE, (t11) => {
      let { video_codec: e } = t11;
      this._p2pChannel instanceof Jd && this._p2pChannel.updateRemoteRTPCapabilities(e.map((n) => n.toLowerCase()).filter((n) => {
        var i;
        return W(i = Object.keys(Ju)).call(i, n);
      }));
    });
  }
  _handleP2PEvents() {
    this._gateway.signal.on(dt.ON_USER_OFFLINE, () => {
      this._p2pChannel.disconnectForReconnect();
    }), this._gateway.signal.on(ie.PUBLISH, (t11, e, n) => {
      let { uid: i } = t11;
      t11.forEach((r) => {
        let { kind: o, ssrcs: s, mid: a, isMuted: c } = r;
        this._handleP2PAddAudioOrVideoStream(o, i, s[0].ssrcId, a);
        let d = this._users.find((l) => l.uid === i);
        return d && this._p2pChannel instanceof An ? this._p2pChannel.mockSubscribe(d, o, s[0].ssrcId, a).then(() => {
          e();
        }).catch(n) : e(), this._handleMuteStream(i, o, !!c);
      });
    }), this._gateway.signal.on(ie.CALL, async (t11, e, n) => {
      if (this._p2pChannel instanceof An) try {
        var i;
        e(await this._p2pChannel.startP2P({ turnServer: (i = this._joinInfo) === null || i === void 0 ? void 0 : i.turnServer }, t11));
      } catch (r) {
        n(r);
      }
    }), this._gateway.signal.on(nt.P2P_CONNECTION, async (t11) => {
      this._p2pChannel instanceof An && await this._p2pChannel.p2pConnect(t11);
    }), this._gateway.signal.on(ie.UNPUBLISH, async (t11, e, n) => {
      if (this._p2pChannel instanceof An) {
        let { unpubMsg: i, uid: r } = t11, o = this._users.find((s) => s.uid === r);
        if (!o) return _.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(r)), void e();
        try {
          i.forEach(async (s) => {
            let { stream_type: a } = s, c = a === Ct.Audio ? Q.AUDIO : Q.VIDEO;
            await this._p2pChannel.unsubscribe(o, c), this._handleMuteStream(r, c, true);
          }), e();
        } catch (s) {
          n(s);
        }
      }
    }), this._gateway.signal.on(ie.CONTROL, async (t11, e) => {
      let { action: n } = t11;
      switch (n) {
        case to.MUTE_LOCAL_VIDEO:
          this._handleMuteStream(e, Q.VIDEO, true);
          break;
        case to.MUTE_LOCAL_AUDIO:
          this._handleMuteStream(e, Q.AUDIO, true);
          break;
        case to.UNMUTE_LOCAL_VIDEO:
          this._handleP2PAddAudioOrVideoStream("video", e), this._handleMuteStream(e, Q.VIDEO, false);
          break;
        case to.UNMUTE_LOCAL_AUDIO:
          this._handleP2PAddAudioOrVideoStream("audio", e), this._handleMuteStream(e, Q.AUDIO, false);
      }
    }), this._gateway.signal.on(ie.RESTART_ICE, async (t11, e, n) => {
      if (this._p2pChannel instanceof An) try {
        let { direction: i, iceParameter: r } = t11;
        i !== cn.SEND_ONLY || r ? e(await this._p2pChannel.restartICE(i, r)) : (this._p2pChannel.handleDisconnect(i), e());
      } catch (i) {
        n(i);
      }
    }), this._gateway.signal.on(ie.CANDIDATE, (t11) => {
      if (this._p2pChannel instanceof An) {
        let { candidate: e, direction: n } = t11;
        this._p2pChannel.addRemoteCandidate(e, n);
      }
    }), this._p2pChannel.on(tt.RequestP2PRestartICE, async (t11, e, n) => {
      try {
        let { direction: i } = t11;
        e(await this._gateway.sendExtensionMessage(ie.RESTART_ICE, t11, i === cn.SEND_ONLY));
      } catch (i) {
        n(i);
      }
    }), this._p2pChannel.on(tt.LocalCandidate, (t11) => {
      this._gateway.sendExtensionMessage(ie.CANDIDATE, JSON.stringify(t11), true);
    }), this._p2pChannel.on(tt.RequestP2PMuteLocal, async (t11, e, n) => {
      try {
        await this._gateway.sendExtensionMessage(ie.CONTROL, t11, true), e();
      } catch (i) {
        n(i);
      }
    }), this._p2pChannel.on(tt.RequestP2PUnmuteRemote, async (t11, e, n) => {
      if (this._joinInfo) try {
        await this._gateway.unmuteRemote(t11, this._joinInfo.stringUid || this._joinInfo.uid), e();
      } catch (i) {
        i.code === R.DISCONNECT_P2P ? e() : n(i);
      }
      else e();
    }), this._p2pChannel.on(tt.RequestP2PMuteRemote, async (t11, e, n) => {
      if (this._joinInfo) try {
        await this._gateway.muteRemote(t11, this._joinInfo.stringUid || this._joinInfo.uid), e();
      } catch (i) {
        i.code === R.DISCONNECT_P2P ? e() : n(i);
      }
      else e();
    }), this._p2pChannel.on(tt.StateChange, (t11, e) => {
      e === Rt.Connected && this._p2pChannel.republish();
    });
  }
  _handleP2PChannelEvents() {
    this._p2pChannel.on(tt.RequestMuteLocal, async (t11, e, n) => {
      if (this._joinInfo) try {
        await this._gateway.muteLocal(t11, this._joinInfo.stringUid || this._joinInfo.uid), e();
      } catch (i) {
        i.code === R.DISCONNECT_P2P ? e() : n(i);
      }
      else e();
    }), this._p2pChannel.on(tt.RequestUnmuteLocal, async (t11, e, n) => {
      if (this._joinInfo) try {
        await this._gateway.unmuteLocal(t11, this._joinInfo.stringUid || this._joinInfo.uid), e();
      } catch (i) {
        i.code === R.DISCONNECT_P2P ? e() : n(i);
      }
      else e();
    }), this._p2pChannel.on(tt.RequestRePublish, (t11, e, n) => {
      this.publish(t11, false).then(e).catch(n);
    }), this._p2pChannel.on(tt.RequestRePublishDataChannel, (t11, e, n) => {
      j.all(t11.map(async (i) => {
        let r = await this._p2pChannel.publishDataChannel([i]);
        try {
          r.forEach((o) => {
            this._uid && this._gateway.publishDataChannel(this._uid, o, true);
          });
        } catch (o) {
          if (o.code !== R.DISCONNECT_P2P) throw o;
        }
      })).then(e).catch(n);
    }), this._p2pChannel.on(tt.RequestReSubscribe, async (t11, e, n) => {
      try {
        for (let { user: i, kind: r } of t11) r === Q.VIDEO ? await this.subscribe(i, "video") : await this.subscribe(i, "audio");
        e();
      } catch (i) {
        n(i);
      }
    }), this._p2pChannel.on(tt.RequestUpload, (t11, e) => {
      this._gateway.upload(t11, e);
    }), this._p2pChannel.on(tt.RequestUploadStats, (t11) => {
      this._gateway.uploadWRTCStats(t11);
    }), this._p2pChannel.on(tt.MediaReconnectStart, (t11) => {
      this.safeEmit(ut.MEDIA_RECONNECT_START, t11);
    }), this._p2pChannel.on(tt.MediaReconnectEnd, (t11) => {
      this.safeEmit(ut.MEDIA_RECONNECT_END, t11);
    }), this._p2pChannel.on(tt.NeedSignalRTT, (t11) => {
      t11(this._gateway.getSignalRTT());
    }), this._p2pChannel.on(tt.RequestRestartICE, async (t11) => {
      if (this._p2pChannel instanceof An) return;
      let e = await this._p2pChannel.restartICE(t11), n = await e.next();
      if (n.done) return;
      let i = n.value, r;
      try {
        r = await this._gateway.restartICE({ iceParameters: i });
      } catch (s) {
        return void e.throw(s);
      }
      let { iceParameters: o } = function(s) {
        let a = s.iceParameters;
        return { iceParameters: { iceUfrag: a.iceUfrag, icePwd: a.icePwd } };
      }(r);
      await e.next({ remoteIceParameters: o });
    }), this._p2pChannel.on(tt.RequestReconnect, async () => {
      this._gateway.reconnect();
    }), this._p2pChannel.on(tt.RequestReconnectPC, async () => {
      var t11;
      let { iceParameters: e, dtlsParameters: n, rtpCapabilities: i } = await this._p2pChannel.startP2PConnection({ turnServer: (t11 = this._joinInfo) === null || t11 === void 0 ? void 0 : t11.turnServer }), { gatewayEstablishParams: r, gatewayAddress: o } = await this._gateway.reconnectPC({ iceParameters: e, dtlsParameters: n, rtpCapabilities: i }), s = qI(r, o);
      await this._p2pChannel.connect(s), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();
    }), this._p2pChannel.on(tt.RequestUnpublishForReconnectPC, async (t11, e, n) => {
      this._joinInfo && this._uid !== void 0 ? (await this._gateway.unpublish(t11, this._uid), e()) : n();
    }), this._p2pChannel.on(tt.P2PLost, () => {
      this.safeEmit(ut.P2P_LOST, this.store.uid);
    }), this._p2pChannel.on(tt.UpdateVideoEncoder, (t11) => {
      t11._encoderConfig && this._gateway.setVideoProfile(t11._encoderConfig);
    }), this._p2pChannel.on(tt.ConnectionTypeChange, (t11) => {
      this.safeEmit(ut.IS_USING_CLOUD_PROXY, t11);
    }), this._p2pChannel.on(tt.RequestLowStreamParameter, (t11) => {
      t11(this._lowStreamParameter || { width: 160, height: 120, framerate: 15, bitrate: 50 });
    }), this._p2pChannel.on(tt.QueryClientConnectionState, (t11) => {
      t11(this.connectionState);
    });
  }
  getKeyMetrics() {
    return this.store.keyMetrics;
  }
  async enableContentInspect(t11) {
    if (!this._joinInfo || this.connectionState !== "CONNECTED") throw new O(R.INVALID_OPERATION, "[".concat(this._clientId, "] can not create content inspect, please join channel first"));
    if (this._inspect) throw new O(R.INVALID_OPERATION, "[".concat(this._clientId, "] Inspect content service already in connecting/connected state"));
    try {
      let n = (e = { config: t11 }, Za("ContentInspect").create(e));
      this._inspect = n, this.handleVideoInspectEvents(n);
      let { appId: i, cname: r, sid: o, token: s, uid: a, cid: c, vid: d } = this._joinInfo;
      await n.init({ appId: i, areaCode: "", cname: r, sid: o, token: s, uid: a, cid: c, vid: d ? Number(d) : 0 }, Ee);
    } catch (n) {
      throw Array.isArray(n) ? n[0] : n;
    }
    var e;
  }
  handleVideoInspectEvents(t11) {
    t11.on(we.CONNECTION_STATE_CHANGE, (e, n) => {
      if (this.safeEmit(ut.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, e, n), n === Ei.CONNECTED) {
        if (this.connectionState !== "CONNECTED") return void this.safeEmit(ut.CONTENT_INSPECT_ERROR, new O(R.OPERATION_ABORTED, "Content inspect was cancelled because it left the channel"));
        t11.inspectImage();
      }
    }), t11.on(we.INSPECT_RESULT, (e, n) => {
      var i;
      if ((n == null ? void 0 : n.code) === R.INVALID_OPERATION && this.connectionState === "DISCONNECTED") return _.debug("Stop inspect content because that has left channel"), this == null || (i = this._inspect) === null || i === void 0 || i.close(), void (this._inspect = void 0);
      this.safeEmit(ut.CONTENT_INSPECT_RESULT, e, n);
    }), t11.on(we.CLIENT_LOCAL_VIDEO_TRACK, (e) => {
      e(this.localTracks.filter((n) => n.trackMediaType === "video")[0]);
    });
  }
  async disableContentInspect() {
    if (!this._inspect) throw new O(R.INVALID_OPERATION, "[".concat(this._clientId, "] inspectVideoContent not started"));
    try {
      this._inspect.close(), this._inspect = void 0;
    } catch (t11) {
      throw Array.isArray(t11) ? t11[0] : t11;
    }
  }
  async setImageModeration(t11, e) {
    if (Nr(t11, "enabled"), t11) {
      if (!e) throw new O(R.INVALID_PARAMS, "config is required");
      if (k0(e), !this._joinInfo) throw new O(R.INVALID_OPERATION, "can not create image moderation, please join channel first");
      try {
        if (this._moderation) this._moderation.updateConfig(e);
        else {
          let i = (n = { config: e }, Za("ImageModeration").create(n));
          this._moderation = i, this.handleImageModerationEvents(i);
          let { appId: r, cname: o, sid: s, token: a, uid: c, cid: d, vid: l } = this._joinInfo;
          await i.init({ appId: r, areaCode: "", cname: o, sid: s, token: a, uid: c, cid: d, vid: l ? Number(l) : 0 }, Ee);
        }
      } catch (i) {
        throw Array.isArray(i) ? i[0] : i;
      }
    } else {
      var n;
      if (!this._moderation) throw new O(R.INVALID_OPERATION, "[".concat(this._clientId, "] image moderation not started"));
      try {
        this._moderation.close(), this._moderation.removeAllListeners(), this._moderation = void 0;
      } catch (i) {
        throw Array.isArray(i) ? i[0] : i;
      }
    }
  }
  handleImageModerationEvents(t11) {
    t11.on(Mi.CONNECTION_STATE_CHANGE, (e, n) => {
      if (this.safeEmit(ut.IMAGE_MODERATION_CONNECTION_STATE_CHANGE, e, n), e === Xn.CONNECTED) {
        if (this.connectionState !== "CONNECTED") throw this.setImageModeration(false), new O(R.OPERATION_ABORTED, "Image moderation was cancelled because it left the channel");
        t11.inspectImage();
      }
    }), t11.on(Mi.CLIENT_LOCAL_VIDEO_TRACK, (e) => {
      e(this.localTracks.filter((n) => n.trackMediaType === "video")[0]);
    });
  }
  setP2PTransport(t11) {
    if (function(e) {
      Ce(e, "transport", ["default", "auto", "relay", "sd-rtn"]);
    }(t11), this.mode !== "p2p") throw new O(R.INVALID_OPERATION, "only p2p mode can set p2pTransport");
    this.store.p2pTransport = t11, _.info("[".concat(this._clientId, "] set client p2pTransport to ").concat(t11));
  }
  getJoinChannelServiceRecords() {
    return _.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords;
  }
  async setPublishAudioFilterEnabled(t11) {
    Nr(t11, "enabled"), Ot("ENABLE_PUBLISH_AUDIO_FILTER", t11), this._joinInfo && await this._gateway.setPublishAudioFilterEnabled(t11);
  }
  _handleResetAddStream(t11, e) {
    switch (e) {
      case "audio":
        t11._audio_added_ = false, t11._trust_audio_stream_added_state_ = true;
        break;
      case "video":
        t11._video_added_ = false, t11._trust_video_stream_added_state_ = true;
    }
  }
}, q(G.prototype, "leave", [sy], Object.getOwnPropertyDescriptor(G.prototype, "leave"), G.prototype), q(G.prototype, "publish", [ay], Object.getOwnPropertyDescriptor(G.prototype, "publish"), G.prototype), q(G.prototype, "unpublish", [cy], Object.getOwnPropertyDescriptor(G.prototype, "unpublish"), G.prototype), q(G.prototype, "subscribe", [dy], Object.getOwnPropertyDescriptor(G.prototype, "subscribe"), G.prototype), q(G.prototype, "presubscribe", [ly], Object.getOwnPropertyDescriptor(G.prototype, "presubscribe"), G.prototype), q(G.prototype, "massSubscribe", [uy], Object.getOwnPropertyDescriptor(G.prototype, "massSubscribe"), G.prototype), q(G.prototype, "unsubscribe", [hy], Object.getOwnPropertyDescriptor(G.prototype, "unsubscribe"), G.prototype), q(G.prototype, "massUnsubscribe", [py], Object.getOwnPropertyDescriptor(G.prototype, "massUnsubscribe"), G.prototype), q(G.prototype, "setLowStreamParameter", [_y], Object.getOwnPropertyDescriptor(G.prototype, "setLowStreamParameter"), G.prototype), q(G.prototype, "enableDualStream", [Ey], Object.getOwnPropertyDescriptor(G.prototype, "enableDualStream"), G.prototype), q(G.prototype, "disableDualStream", [my], Object.getOwnPropertyDescriptor(G.prototype, "disableDualStream"), G.prototype), q(G.prototype, "setClientRole", [fy], Object.getOwnPropertyDescriptor(G.prototype, "setClientRole"), G.prototype), q(G.prototype, "setProxyServer", [gy], Object.getOwnPropertyDescriptor(G.prototype, "setProxyServer"), G.prototype), q(G.prototype, "setTurnServer", [Ty], Object.getOwnPropertyDescriptor(G.prototype, "setTurnServer"), G.prototype), q(G.prototype, "setLicense", [Sy], Object.getOwnPropertyDescriptor(G.prototype, "setLicense"), G.prototype), q(G.prototype, "startProxyServer", [Ry], Object.getOwnPropertyDescriptor(G.prototype, "startProxyServer"), G.prototype), q(G.prototype, "stopProxyServer", [Cy], Object.getOwnPropertyDescriptor(G.prototype, "stopProxyServer"), G.prototype), q(G.prototype, "setLocalAccessPointsV2", [Iy], Object.getOwnPropertyDescriptor(G.prototype, "setLocalAccessPointsV2"), G.prototype), q(G.prototype, "setLocalAccessPoints", [vy], Object.getOwnPropertyDescriptor(G.prototype, "setLocalAccessPoints"), G.prototype), q(G.prototype, "setRemoteDefaultVideoStreamType", [yy], Object.getOwnPropertyDescriptor(G.prototype, "setRemoteDefaultVideoStreamType"), G.prototype), q(G.prototype, "setRemoteVideoStreamType", [Ay], Object.getOwnPropertyDescriptor(G.prototype, "setRemoteVideoStreamType"), G.prototype), q(G.prototype, "setStreamFallbackOption", [by], Object.getOwnPropertyDescriptor(G.prototype, "setStreamFallbackOption"), G.prototype), q(G.prototype, "setEncryptionConfig", [wy], Object.getOwnPropertyDescriptor(G.prototype, "setEncryptionConfig"), G.prototype), q(G.prototype, "renewToken", [Oy], Object.getOwnPropertyDescriptor(G.prototype, "renewToken"), G.prototype), q(G.prototype, "enableAudioVolumeIndicator", [Ny], Object.getOwnPropertyDescriptor(G.prototype, "enableAudioVolumeIndicator"), G.prototype), q(G.prototype, "startLiveStreaming", [Dy], Object.getOwnPropertyDescriptor(G.prototype, "startLiveStreaming"), G.prototype), q(G.prototype, "setLiveTranscoding", [Py], Object.getOwnPropertyDescriptor(G.prototype, "setLiveTranscoding"), G.prototype), q(G.prototype, "stopLiveStreaming", [ky], Object.getOwnPropertyDescriptor(G.prototype, "stopLiveStreaming"), G.prototype), q(G.prototype, "startChannelMediaRelay", [Ly], Object.getOwnPropertyDescriptor(G.prototype, "startChannelMediaRelay"), G.prototype), q(G.prototype, "updateChannelMediaRelay", [My], Object.getOwnPropertyDescriptor(G.prototype, "updateChannelMediaRelay"), G.prototype), q(G.prototype, "stopChannelMediaRelay", [Uy], Object.getOwnPropertyDescriptor(G.prototype, "stopChannelMediaRelay"), G.prototype), q(G.prototype, "sendCustomReportMessage", [xy], Object.getOwnPropertyDescriptor(G.prototype, "sendCustomReportMessage"), G.prototype), q(G.prototype, "pickSVCLayer", [Vy], Object.getOwnPropertyDescriptor(G.prototype, "pickSVCLayer"), G.prototype), q(G.prototype, "setRTMConfig", [Fy], Object.getOwnPropertyDescriptor(G.prototype, "setRTMConfig"), G.prototype), q(G.prototype, "enableContentInspect", [By], Object.getOwnPropertyDescriptor(G.prototype, "enableContentInspect"), G.prototype), q(G.prototype, "disableContentInspect", [jy], Object.getOwnPropertyDescriptor(G.prototype, "disableContentInspect"), G.prototype), q(G.prototype, "setImageModeration", [Gy], Object.getOwnPropertyDescriptor(G.prototype, "setImageModeration"), G.prototype), q(G.prototype, "setP2PTransport", [Wy], Object.getOwnPropertyDescriptor(G.prototype, "setP2PTransport"), G.prototype), q(G.prototype, "getJoinChannelServiceRecords", [Hy], Object.getOwnPropertyDescriptor(G.prototype, "getJoinChannelServiceRecords"), G.prototype), q(G.prototype, "setPublishAudioFilterEnabled", [Ky], Object.getOwnPropertyDescriptor(G.prototype, "setPublishAudioFilterEnabled"), G.prototype), G);
var Su = class t10 {
  constructor(e, n) {
    T(this, "id", 0), T(this, "element", void 0), T(this, "peerPair", void 0), T(this, "context", void 0), T(this, "audioPlayerElement", void 0), T(this, "audioTrack", void 0), t10.count += 1, this.id = t10.count, this.element = e, this.context = n;
  }
  initPeers() {
    this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = (e) => {
      let n = document.createElement("audio");
      n.srcObject = new MediaStream([e.track]), n.play(), this.audioPlayerElement = n;
    };
  }
  async switchSdp() {
    if (!this.peerPair) return;
    let e = async (i, r) => {
      let o = r === "offer" ? await i.createOffer() : await i.createAnswer();
      return await i.setLocalDescription(o), i.iceGatheringState === "complete" ? i.localDescription : new j((s) => {
        i.onicegatheringstatechange = () => {
          i.iceGatheringState === "complete" && s(i.localDescription);
        };
      });
    }, n = async (i, r) => await i.setRemoteDescription(r);
    try {
      let i = await e(this.peerPair[0], "offer");
      await n(this.peerPair[1], i);
      let r = await e(this.peerPair[1], "answer");
      await n(this.peerPair[0], r);
    } catch (i) {
      throw new O(R.LOCAL_AEC_ERROR, i.toString()).print();
    }
  }
  async getTracksFromMediaElement(e) {
    if (this.audioTrack) return this.audioTrack;
    let n;
    try {
      e instanceof HTMLVideoElement && (e.captureStream ? e.captureStream() : e.mozCaptureStream()), n = this.context.createMediaStreamDestination(), this.context.createMediaElementSource(e).connect(n);
    } catch (r) {
      throw new O(R.LOCAL_AEC_ERROR, r.toString()).print();
    }
    if (!n) throw new O(R.LOCAL_AEC_ERROR, "no dest node when local aec").print();
    let i = n.stream.getAudioTracks()[0];
    return this.audioTrack = i, i;
  }
  getElement() {
    return this.element;
  }
  async startEchoCancellation() {
    this.context.resume(), this.peerPair && this.close(), this.initPeers();
    let e = this.element, n = await this.getTracksFromMediaElement(e);
    this.peerPair && this.peerPair[0].addTrack(n), await this.switchSdp();
  }
  close() {
    _.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach((e) => {
      e.close();
    }), this.peerPair = void 0, this.audioPlayerElement = void 0;
  }
};
var qy;
var Qd;
T(Su, "count", 0);
var LW = window.AudioContext || window.webkitAudioContext;
var MW = new (qy = $({ report: X }), q((Qd = class {
  constructor() {
    T(this, "units", []), T(this, "context", void 0);
  }
  processExternalMediaAEC(t11) {
    if (!this._doesEnvironmentNeedAEC()) return _.debug("the system does not need to process local aec"), -1;
    this.context || (this.context = new LW());
    let e = this.units.find((n) => n && n.getElement() === t11);
    return e || (e = new Su(t11, this.context), this.units.push(e)), e.startEchoCancellation(), _.debug("start processing local audio echo cancellation, id is", e.id), e.id;
  }
  _doesEnvironmentNeedAEC() {
    return mt().name !== It.SAFARI;
  }
}).prototype, "processExternalMediaAEC", [qy], Object.getOwnPropertyDescriptor(Qd.prototype, "processExternalMediaAEC"), Qd.prototype), Qd)();
function zy(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Jy(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? zy(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : zy(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var I_ = window || document;
function L0(t11) {
  let e = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
  if (!I_) return;
  let n = Mt._cspEventHandlerPointer;
  if (n && e) return void console.error(n, e);
  let i = (r) => {
    if (!(r && r.blockedURI && (Mt.onSecurityPolicyViolation || Mt.getListeners(nr.SECURITY_POLICY_VIOLATION).length > 0))) return;
    let o = r.blockedURI;
    v("CSP_DETECTED_HOSTNAME_LIST").some((s) => W(o).call(o, s)) && (Mt.onSecurityPolicyViolation && typeof Mt.onSecurityPolicyViolation == "function" && Mt.onSecurityPolicyViolation(r), Mt.getListeners(nr.SECURITY_POLICY_VIOLATION).length > 0 && Mt.safeEmit(nr.SECURITY_POLICY_VIOLATION, r));
  };
  n && I_.removeEventListener("securitypolicyviolation", n), (e || t11 && typeof t11 == "function" || Mt.getListeners(nr.SECURITY_POLICY_VIOLATION).length > 0) && I_.addEventListener("securitypolicyviolation", i), Mt._cspEventHandlerPointer = i;
}
var UW = hn;
var xW = nO;
var Xy = RegExp.prototype;
var VW = function(t11) {
  return t11 === Xy || UW(Xy, t11) ? xW(t11) : t11.flags;
};
var en = ae(VW);
function Sa(t11) {
  let e = t11.length;
  for (; --e >= 0; ) t11[e] = 0;
}
var Pf = 256;
var M0 = 286;
var lc = 30;
var uc = 15;
var _m = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
var Ol = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
var FW = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
var Qy = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var wr = new Array(576);
Sa(wr);
var hc = new Array(60);
Sa(hc);
var Fc = new Array(512);
Sa(Fc);
var Bc = new Array(256);
Sa(Bc);
var kf = new Array(29);
Sa(kf);
var Ru = new Array(lc);
function v_(t11, e, n, i, r) {
  this.static_tree = t11, this.extra_bits = e, this.extra_base = n, this.elems = i, this.max_length = r, this.has_stree = t11 && t11.length;
}
var Zy;
var $y;
var tA;
function y_(t11, e) {
  this.dyn_tree = t11, this.max_code = 0, this.stat_desc = e;
}
Sa(Ru);
var U0 = (t11) => t11 < 256 ? Fc[t11] : Fc[256 + (t11 >>> 7)];
var jc = (t11, e) => {
  t11.pending_buf[t11.pending++] = 255 & e, t11.pending_buf[t11.pending++] = e >>> 8 & 255;
};
var Bn = (t11, e, n) => {
  t11.bi_valid > 16 - n ? (t11.bi_buf |= e << t11.bi_valid & 65535, jc(t11, t11.bi_buf), t11.bi_buf = e >> 16 - t11.bi_valid, t11.bi_valid += n - 16) : (t11.bi_buf |= e << t11.bi_valid & 65535, t11.bi_valid += n);
};
var rr = (t11, e, n) => {
  Bn(t11, n[2 * e], n[2 * e + 1]);
};
var x0 = (t11, e) => {
  let n = 0;
  do
    n |= 1 & t11, t11 >>>= 1, n <<= 1;
  while (--e > 0);
  return n >>> 1;
};
var V0 = (t11, e, n) => {
  let i = new Array(16), r, o, s = 0;
  for (r = 1; r <= uc; r++) s = s + n[r - 1] << 1, i[r] = s;
  for (o = 0; o <= e; o++) {
    let a = t11[2 * o + 1];
    a !== 0 && (t11[2 * o] = x0(i[a]++, a));
  }
};
var F0 = (t11) => {
  let e;
  for (e = 0; e < M0; e++) t11.dyn_ltree[2 * e] = 0;
  for (e = 0; e < lc; e++) t11.dyn_dtree[2 * e] = 0;
  for (e = 0; e < 19; e++) t11.bl_tree[2 * e] = 0;
  t11.dyn_ltree[512] = 1, t11.opt_len = t11.static_len = 0, t11.sym_next = t11.matches = 0;
};
var B0 = (t11) => {
  t11.bi_valid > 8 ? jc(t11, t11.bi_buf) : t11.bi_valid > 0 && (t11.pending_buf[t11.pending++] = t11.bi_buf), t11.bi_buf = 0, t11.bi_valid = 0;
};
var eA = (t11, e, n, i) => {
  let r = 2 * e, o = 2 * n;
  return t11[r] < t11[o] || t11[r] === t11[o] && i[e] <= i[n];
};
var A_ = (t11, e, n) => {
  let i = t11.heap[n], r = n << 1;
  for (; r <= t11.heap_len && (r < t11.heap_len && eA(e, t11.heap[r + 1], t11.heap[r], t11.depth) && r++, !eA(e, i, t11.heap[r], t11.depth)); ) t11.heap[n] = t11.heap[r], n = r, r <<= 1;
  t11.heap[n] = i;
};
var nA = (t11, e, n) => {
  let i, r, o, s, a = 0;
  if (t11.sym_next !== 0) do
    i = 255 & t11.pending_buf[t11.sym_buf + a++], i += (255 & t11.pending_buf[t11.sym_buf + a++]) << 8, r = t11.pending_buf[t11.sym_buf + a++], i === 0 ? rr(t11, r, e) : (o = Bc[r], rr(t11, o + Pf + 1, e), s = _m[o], s !== 0 && (r -= kf[o], Bn(t11, r, s)), i--, o = U0(i), rr(t11, o, n), s = Ol[o], s !== 0 && (i -= Ru[o], Bn(t11, i, s)));
  while (a < t11.sym_next);
  rr(t11, 256, e);
};
var b_ = (t11, e) => {
  let n = e.dyn_tree, i = e.stat_desc.static_tree, r = e.stat_desc.has_stree, o = e.stat_desc.elems, s, a, c, d = -1;
  for (t11.heap_len = 0, t11.heap_max = 573, s = 0; s < o; s++) n[2 * s] !== 0 ? (t11.heap[++t11.heap_len] = d = s, t11.depth[s] = 0) : n[2 * s + 1] = 0;
  for (; t11.heap_len < 2; ) c = t11.heap[++t11.heap_len] = d < 2 ? ++d : 0, n[2 * c] = 1, t11.depth[c] = 0, t11.opt_len--, r && (t11.static_len -= i[2 * c + 1]);
  for (e.max_code = d, s = t11.heap_len >> 1; s >= 1; s--) A_(t11, n, s);
  c = o;
  do
    s = t11.heap[1], t11.heap[1] = t11.heap[t11.heap_len--], A_(t11, n, 1), a = t11.heap[1], t11.heap[--t11.heap_max] = s, t11.heap[--t11.heap_max] = a, n[2 * c] = n[2 * s] + n[2 * a], t11.depth[c] = (t11.depth[s] >= t11.depth[a] ? t11.depth[s] : t11.depth[a]) + 1, n[2 * s + 1] = n[2 * a + 1] = c, t11.heap[1] = c++, A_(t11, n, 1);
  while (t11.heap_len >= 2);
  t11.heap[--t11.heap_max] = t11.heap[1], ((l, u) => {
    let h = u.dyn_tree, p = u.max_code, g = u.stat_desc.static_tree, E = u.stat_desc.has_stree, f = u.stat_desc.extra_bits, S = u.stat_desc.extra_base, C = u.stat_desc.max_length, A, b, w, D, k, B, V = 0;
    for (D = 0; D <= uc; D++) l.bl_count[D] = 0;
    for (h[2 * l.heap[l.heap_max] + 1] = 0, A = l.heap_max + 1; A < 573; A++) b = l.heap[A], D = h[2 * h[2 * b + 1] + 1] + 1, D > C && (D = C, V++), h[2 * b + 1] = D, b > p || (l.bl_count[D]++, k = 0, b >= S && (k = f[b - S]), B = h[2 * b], l.opt_len += B * (D + k), E && (l.static_len += B * (g[2 * b + 1] + k)));
    if (V !== 0) {
      do {
        for (D = C - 1; l.bl_count[D] === 0; ) D--;
        l.bl_count[D]--, l.bl_count[D + 1] += 2, l.bl_count[C]--, V -= 2;
      } while (V > 0);
      for (D = C; D !== 0; D--) for (b = l.bl_count[D]; b !== 0; ) w = l.heap[--A], w > p || (h[2 * w + 1] !== D && (l.opt_len += (D - h[2 * w + 1]) * h[2 * w], h[2 * w + 1] = D), b--);
    }
  })(t11, e), V0(n, d, t11.bl_count);
};
var iA = (t11, e, n) => {
  let i, r, o = -1, s = e[1], a = 0, c = 7, d = 4;
  for (s === 0 && (c = 138, d = 3), e[2 * (n + 1) + 1] = 65535, i = 0; i <= n; i++) r = s, s = e[2 * (i + 1) + 1], ++a < c && r === s || (a < d ? t11.bl_tree[2 * r] += a : r !== 0 ? (r !== o && t11.bl_tree[2 * r]++, t11.bl_tree[32]++) : a <= 10 ? t11.bl_tree[34]++ : t11.bl_tree[36]++, a = 0, o = r, s === 0 ? (c = 138, d = 3) : r === s ? (c = 6, d = 3) : (c = 7, d = 4));
};
var rA = (t11, e, n) => {
  let i, r, o = -1, s = e[1], a = 0, c = 7, d = 4;
  for (s === 0 && (c = 138, d = 3), i = 0; i <= n; i++) if (r = s, s = e[2 * (i + 1) + 1], !(++a < c && r === s)) {
    if (a < d) do
      rr(t11, r, t11.bl_tree);
    while (--a != 0);
    else r !== 0 ? (r !== o && (rr(t11, r, t11.bl_tree), a--), rr(t11, 16, t11.bl_tree), Bn(t11, a - 3, 2)) : a <= 10 ? (rr(t11, 17, t11.bl_tree), Bn(t11, a - 3, 3)) : (rr(t11, 18, t11.bl_tree), Bn(t11, a - 11, 7));
    a = 0, o = r, s === 0 ? (c = 138, d = 3) : r === s ? (c = 6, d = 3) : (c = 7, d = 4);
  }
};
var oA = false;
var j0 = (t11, e, n, i) => {
  Bn(t11, 0 + (i ? 1 : 0), 3), B0(t11), jc(t11, n), jc(t11, ~n), n && t11.pending_buf.set(t11.window.subarray(e, e + n), t11.pending), t11.pending += n;
};
var BW = (t11) => {
  oA || ((() => {
    let e, n, i, r, o, s = new Array(16);
    for (i = 0, r = 0; r < 28; r++) for (kf[r] = i, e = 0; e < 1 << _m[r]; e++) Bc[i++] = r;
    for (Bc[i - 1] = r, o = 0, r = 0; r < 16; r++) for (Ru[r] = o, e = 0; e < 1 << Ol[r]; e++) Fc[o++] = r;
    for (o >>= 7; r < lc; r++) for (Ru[r] = o << 7, e = 0; e < 1 << Ol[r] - 7; e++) Fc[256 + o++] = r;
    for (n = 0; n <= uc; n++) s[n] = 0;
    for (e = 0; e <= 143; ) wr[2 * e + 1] = 8, e++, s[8]++;
    for (; e <= 255; ) wr[2 * e + 1] = 9, e++, s[9]++;
    for (; e <= 279; ) wr[2 * e + 1] = 7, e++, s[7]++;
    for (; e <= 287; ) wr[2 * e + 1] = 8, e++, s[8]++;
    for (V0(wr, 287, s), e = 0; e < lc; e++) hc[2 * e + 1] = 5, hc[2 * e] = x0(e, 5);
    Zy = new v_(wr, _m, 257, M0, uc), $y = new v_(hc, Ol, 0, lc, uc), tA = new v_(new Array(0), FW, 0, 19, 7);
  })(), oA = true), t11.l_desc = new y_(t11.dyn_ltree, Zy), t11.d_desc = new y_(t11.dyn_dtree, $y), t11.bl_desc = new y_(t11.bl_tree, tA), t11.bi_buf = 0, t11.bi_valid = 0, F0(t11);
};
var jW = (t11, e, n, i) => {
  let r, o, s = 0;
  t11.level > 0 ? (t11.strm.data_type === 2 && (t11.strm.data_type = ((a) => {
    let c, d = 4093624447;
    for (c = 0; c <= 31; c++, d >>>= 1) if (1 & d && a.dyn_ltree[2 * c] !== 0) return 0;
    if (a.dyn_ltree[18] !== 0 || a.dyn_ltree[20] !== 0 || a.dyn_ltree[26] !== 0) return 1;
    for (c = 32; c < Pf; c++) if (a.dyn_ltree[2 * c] !== 0) return 1;
    return 0;
  })(t11)), b_(t11, t11.l_desc), b_(t11, t11.d_desc), s = ((a) => {
    let c;
    for (iA(a, a.dyn_ltree, a.l_desc.max_code), iA(a, a.dyn_dtree, a.d_desc.max_code), b_(a, a.bl_desc), c = 18; c >= 3 && a.bl_tree[2 * Qy[c] + 1] === 0; c--) ;
    return a.opt_len += 3 * (c + 1) + 5 + 5 + 4, c;
  })(t11), r = t11.opt_len + 3 + 7 >>> 3, o = t11.static_len + 3 + 7 >>> 3, o <= r && (r = o)) : r = o = n + 5, n + 4 <= r && e !== -1 ? j0(t11, e, n, i) : t11.strategy === 4 || o === r ? (Bn(t11, 2 + (i ? 1 : 0), 3), nA(t11, wr, hc)) : (Bn(t11, 4 + (i ? 1 : 0), 3), ((a, c, d, l) => {
    let u;
    for (Bn(a, c - 257, 5), Bn(a, d - 1, 5), Bn(a, l - 4, 4), u = 0; u < l; u++) Bn(a, a.bl_tree[2 * Qy[u] + 1], 3);
    rA(a, a.dyn_ltree, c - 1), rA(a, a.dyn_dtree, d - 1);
  })(t11, t11.l_desc.max_code + 1, t11.d_desc.max_code + 1, s + 1), nA(t11, t11.dyn_ltree, t11.dyn_dtree)), F0(t11), i && B0(t11);
};
var GW = (t11, e, n) => (t11.pending_buf[t11.sym_buf + t11.sym_next++] = e, t11.pending_buf[t11.sym_buf + t11.sym_next++] = e >> 8, t11.pending_buf[t11.sym_buf + t11.sym_next++] = n, e === 0 ? t11.dyn_ltree[2 * n]++ : (t11.matches++, e--, t11.dyn_ltree[2 * (Bc[n] + Pf + 1)]++, t11.dyn_dtree[2 * U0(e)]++), t11.sym_next === t11.sym_end);
var WW = (t11) => {
  Bn(t11, 2, 3), rr(t11, 256, wr), ((e) => {
    e.bi_valid === 16 ? (jc(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8);
  })(t11);
};
var HW = { _tr_init: BW, _tr_stored_block: j0, _tr_flush_block: jW, _tr_tally: GW, _tr_align: WW };
var Gc = (t11, e, n, i) => {
  let r = 65535 & t11 | 0, o = t11 >>> 16 & 65535 | 0, s = 0;
  for (; n !== 0; ) {
    s = n > 2e3 ? 2e3 : n, n -= s;
    do
      r = r + e[i++] | 0, o = o + r | 0;
    while (--s);
    r %= 65521, o %= 65521;
  }
  return r | o << 16 | 0;
};
var KW = new Uint32Array((() => {
  let t11, e = [];
  for (var n = 0; n < 256; n++) {
    t11 = n;
    for (var i = 0; i < 8; i++) t11 = 1 & t11 ? 3988292384 ^ t11 >>> 1 : t11 >>> 1;
    e[n] = t11;
  }
  return e;
})());
var an = (t11, e, n, i) => {
  let r = KW, o = i + n;
  t11 ^= -1;
  for (let s = i; s < o; s++) t11 = t11 >>> 8 ^ r[255 & (t11 ^ e[s])];
  return -1 ^ t11;
};
var Zo = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
var Ra = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
var { _tr_init: YW, _tr_stored_block: Em, _tr_flush_block: qW, _tr_tally: ao, _tr_align: zW } = HW;
var { Z_NO_FLUSH: co, Z_PARTIAL_FLUSH: JW, Z_FULL_FLUSH: XW, Z_FINISH: Ri, Z_BLOCK: sA, Z_OK: _n, Z_STREAM_END: aA, Z_STREAM_ERROR: dr, Z_DATA_ERROR: QW, Z_BUF_ERROR: w_, Z_DEFAULT_COMPRESSION: ZW, Z_FILTERED: $W, Z_HUFFMAN_ONLY: Zd, Z_RLE: t32, Z_FIXED: e3, Z_DEFAULT_STRATEGY: n3, Z_UNKNOWN: i3, Z_DEFLATED: th } = Ra;
var mm = 286;
var r3 = 30;
var o3 = 19;
var s3 = 2 * mm + 1;
var a3 = 15;
var jo = 258;
var lr = 262;
var aa = 42;
var Go = 113;
var tc = 666;
var Wo = (t11, e) => (t11.msg = Zo[e], e);
var cA = (t11) => 2 * t11 - (t11 > 4 ? 9 : 0);
var Qr = (t11) => {
  let e = t11.length;
  for (; --e >= 0; ) t11[e] = 0;
};
var c3 = (t11) => {
  let e, n, i, r = t11.w_size;
  e = t11.hash_size, i = e;
  do
    n = t11.head[--i], t11.head[i] = n >= r ? n - r : 0;
  while (--e);
  e = r, i = e;
  do
    n = t11.prev[--i], t11.prev[i] = n >= r ? n - r : 0;
  while (--e);
};
var lo = (t11, e, n) => (e << t11.hash_shift ^ n) & t11.hash_mask;
var Zn = (t11) => {
  let e = t11.state, n = e.pending;
  n > t11.avail_out && (n = t11.avail_out), n !== 0 && (t11.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + n), t11.next_out), t11.next_out += n, e.pending_out += n, t11.total_out += n, t11.avail_out -= n, e.pending -= n, e.pending === 0 && (e.pending_out = 0));
};
var ti = (t11, e) => {
  qW(t11, t11.block_start >= 0 ? t11.block_start : -1, t11.strstart - t11.block_start, e), t11.block_start = t11.strstart, Zn(t11.strm);
};
var te = (t11, e) => {
  t11.pending_buf[t11.pending++] = e;
};
var ja = (t11, e) => {
  t11.pending_buf[t11.pending++] = e >>> 8 & 255, t11.pending_buf[t11.pending++] = 255 & e;
};
var fm = (t11, e, n, i) => {
  let r = t11.avail_in;
  return r > i && (r = i), r === 0 ? 0 : (t11.avail_in -= r, e.set(t11.input.subarray(t11.next_in, t11.next_in + r), n), t11.state.wrap === 1 ? t11.adler = Gc(t11.adler, e, r, n) : t11.state.wrap === 2 && (t11.adler = an(t11.adler, e, r, n)), t11.next_in += r, t11.total_in += r, r);
};
var G0 = (t11, e) => {
  let n, i, r = t11.max_chain_length, o = t11.strstart, s = t11.prev_length, a = t11.nice_match, c = t11.strstart > t11.w_size - lr ? t11.strstart - (t11.w_size - lr) : 0, d = t11.window, l = t11.w_mask, u = t11.prev, h = t11.strstart + jo, p = d[o + s - 1], g = d[o + s];
  t11.prev_length >= t11.good_match && (r >>= 2), a > t11.lookahead && (a = t11.lookahead);
  do
    if (n = e, d[n + s] === g && d[n + s - 1] === p && d[n] === d[o] && d[++n] === d[o + 1]) {
      o += 2, n++;
      do
        ;
      while (d[++o] === d[++n] && d[++o] === d[++n] && d[++o] === d[++n] && d[++o] === d[++n] && d[++o] === d[++n] && d[++o] === d[++n] && d[++o] === d[++n] && d[++o] === d[++n] && o < h);
      if (i = jo - (h - o), o = h - jo, i > s) {
        if (t11.match_start = e, s = i, i >= a) break;
        p = d[o + s - 1], g = d[o + s];
      }
    }
  while ((e = u[e & l]) > c && --r != 0);
  return s <= t11.lookahead ? s : t11.lookahead;
};
var ca = (t11) => {
  let e = t11.w_size, n, i, r;
  do {
    if (i = t11.window_size - t11.lookahead - t11.strstart, t11.strstart >= e + (e - lr) && (t11.window.set(t11.window.subarray(e, e + e - i), 0), t11.match_start -= e, t11.strstart -= e, t11.block_start -= e, t11.insert > t11.strstart && (t11.insert = t11.strstart), c3(t11), i += e), t11.strm.avail_in === 0) break;
    if (n = fm(t11.strm, t11.window, t11.strstart + t11.lookahead, i), t11.lookahead += n, t11.lookahead + t11.insert >= 3) for (r = t11.strstart - t11.insert, t11.ins_h = t11.window[r], t11.ins_h = lo(t11, t11.ins_h, t11.window[r + 1]); t11.insert && (t11.ins_h = lo(t11, t11.ins_h, t11.window[r + 3 - 1]), t11.prev[r & t11.w_mask] = t11.head[t11.ins_h], t11.head[t11.ins_h] = r, r++, t11.insert--, !(t11.lookahead + t11.insert < 3)); ) ;
  } while (t11.lookahead < lr && t11.strm.avail_in !== 0);
};
var W0 = (t11, e) => {
  let n, i, r, o = t11.pending_buf_size - 5 > t11.w_size ? t11.w_size : t11.pending_buf_size - 5, s = 0, a = t11.strm.avail_in;
  do {
    if (n = 65535, r = t11.bi_valid + 42 >> 3, t11.strm.avail_out < r || (r = t11.strm.avail_out - r, i = t11.strstart - t11.block_start, n > i + t11.strm.avail_in && (n = i + t11.strm.avail_in), n > r && (n = r), n < o && (n === 0 && e !== Ri || e === co || n !== i + t11.strm.avail_in))) break;
    s = e === Ri && n === i + t11.strm.avail_in ? 1 : 0, Em(t11, 0, 0, s), t11.pending_buf[t11.pending - 4] = n, t11.pending_buf[t11.pending - 3] = n >> 8, t11.pending_buf[t11.pending - 2] = ~n, t11.pending_buf[t11.pending - 1] = ~n >> 8, Zn(t11.strm), i && (i > n && (i = n), t11.strm.output.set(t11.window.subarray(t11.block_start, t11.block_start + i), t11.strm.next_out), t11.strm.next_out += i, t11.strm.avail_out -= i, t11.strm.total_out += i, t11.block_start += i, n -= i), n && (fm(t11.strm, t11.strm.output, t11.strm.next_out, n), t11.strm.next_out += n, t11.strm.avail_out -= n, t11.strm.total_out += n);
  } while (s === 0);
  return a -= t11.strm.avail_in, a && (a >= t11.w_size ? (t11.matches = 2, t11.window.set(t11.strm.input.subarray(t11.strm.next_in - t11.w_size, t11.strm.next_in), 0), t11.strstart = t11.w_size, t11.insert = t11.strstart) : (t11.window_size - t11.strstart <= a && (t11.strstart -= t11.w_size, t11.window.set(t11.window.subarray(t11.w_size, t11.w_size + t11.strstart), 0), t11.matches < 2 && t11.matches++, t11.insert > t11.strstart && (t11.insert = t11.strstart)), t11.window.set(t11.strm.input.subarray(t11.strm.next_in - a, t11.strm.next_in), t11.strstart), t11.strstart += a, t11.insert += a > t11.w_size - t11.insert ? t11.w_size - t11.insert : a), t11.block_start = t11.strstart), t11.high_water < t11.strstart && (t11.high_water = t11.strstart), s ? 4 : e !== co && e !== Ri && t11.strm.avail_in === 0 && t11.strstart === t11.block_start ? 2 : (r = t11.window_size - t11.strstart, t11.strm.avail_in > r && t11.block_start >= t11.w_size && (t11.block_start -= t11.w_size, t11.strstart -= t11.w_size, t11.window.set(t11.window.subarray(t11.w_size, t11.w_size + t11.strstart), 0), t11.matches < 2 && t11.matches++, r += t11.w_size, t11.insert > t11.strstart && (t11.insert = t11.strstart)), r > t11.strm.avail_in && (r = t11.strm.avail_in), r && (fm(t11.strm, t11.window, t11.strstart, r), t11.strstart += r, t11.insert += r > t11.w_size - t11.insert ? t11.w_size - t11.insert : r), t11.high_water < t11.strstart && (t11.high_water = t11.strstart), r = t11.bi_valid + 42 >> 3, r = t11.pending_buf_size - r > 65535 ? 65535 : t11.pending_buf_size - r, o = r > t11.w_size ? t11.w_size : r, i = t11.strstart - t11.block_start, (i >= o || (i || e === Ri) && e !== co && t11.strm.avail_in === 0 && i <= r) && (n = i > r ? r : i, s = e === Ri && t11.strm.avail_in === 0 && n === i ? 1 : 0, Em(t11, t11.block_start, n, s), t11.block_start += n, Zn(t11.strm)), s ? 3 : 1);
};
var O_ = (t11, e) => {
  let n, i;
  for (; ; ) {
    if (t11.lookahead < lr) {
      if (ca(t11), t11.lookahead < lr && e === co) return 1;
      if (t11.lookahead === 0) break;
    }
    if (n = 0, t11.lookahead >= 3 && (t11.ins_h = lo(t11, t11.ins_h, t11.window[t11.strstart + 3 - 1]), n = t11.prev[t11.strstart & t11.w_mask] = t11.head[t11.ins_h], t11.head[t11.ins_h] = t11.strstart), n !== 0 && t11.strstart - n <= t11.w_size - lr && (t11.match_length = G0(t11, n)), t11.match_length >= 3) if (i = ao(t11, t11.strstart - t11.match_start, t11.match_length - 3), t11.lookahead -= t11.match_length, t11.match_length <= t11.max_lazy_match && t11.lookahead >= 3) {
      t11.match_length--;
      do
        t11.strstart++, t11.ins_h = lo(t11, t11.ins_h, t11.window[t11.strstart + 3 - 1]), n = t11.prev[t11.strstart & t11.w_mask] = t11.head[t11.ins_h], t11.head[t11.ins_h] = t11.strstart;
      while (--t11.match_length != 0);
      t11.strstart++;
    } else t11.strstart += t11.match_length, t11.match_length = 0, t11.ins_h = t11.window[t11.strstart], t11.ins_h = lo(t11, t11.ins_h, t11.window[t11.strstart + 1]);
    else i = ao(t11, 0, t11.window[t11.strstart]), t11.lookahead--, t11.strstart++;
    if (i && (ti(t11, false), t11.strm.avail_out === 0)) return 1;
  }
  return t11.insert = t11.strstart < 2 ? t11.strstart : 2, e === Ri ? (ti(t11, true), t11.strm.avail_out === 0 ? 3 : 4) : t11.sym_next && (ti(t11, false), t11.strm.avail_out === 0) ? 1 : 2;
};
var Rs = (t11, e) => {
  let n, i, r;
  for (; ; ) {
    if (t11.lookahead < lr) {
      if (ca(t11), t11.lookahead < lr && e === co) return 1;
      if (t11.lookahead === 0) break;
    }
    if (n = 0, t11.lookahead >= 3 && (t11.ins_h = lo(t11, t11.ins_h, t11.window[t11.strstart + 3 - 1]), n = t11.prev[t11.strstart & t11.w_mask] = t11.head[t11.ins_h], t11.head[t11.ins_h] = t11.strstart), t11.prev_length = t11.match_length, t11.prev_match = t11.match_start, t11.match_length = 2, n !== 0 && t11.prev_length < t11.max_lazy_match && t11.strstart - n <= t11.w_size - lr && (t11.match_length = G0(t11, n), t11.match_length <= 5 && (t11.strategy === $W || t11.match_length === 3 && t11.strstart - t11.match_start > 4096) && (t11.match_length = 2)), t11.prev_length >= 3 && t11.match_length <= t11.prev_length) {
      r = t11.strstart + t11.lookahead - 3, i = ao(t11, t11.strstart - 1 - t11.prev_match, t11.prev_length - 3), t11.lookahead -= t11.prev_length - 1, t11.prev_length -= 2;
      do
        ++t11.strstart <= r && (t11.ins_h = lo(t11, t11.ins_h, t11.window[t11.strstart + 3 - 1]), n = t11.prev[t11.strstart & t11.w_mask] = t11.head[t11.ins_h], t11.head[t11.ins_h] = t11.strstart);
      while (--t11.prev_length != 0);
      if (t11.match_available = 0, t11.match_length = 2, t11.strstart++, i && (ti(t11, false), t11.strm.avail_out === 0)) return 1;
    } else if (t11.match_available) {
      if (i = ao(t11, 0, t11.window[t11.strstart - 1]), i && ti(t11, false), t11.strstart++, t11.lookahead--, t11.strm.avail_out === 0) return 1;
    } else t11.match_available = 1, t11.strstart++, t11.lookahead--;
  }
  return t11.match_available && (i = ao(t11, 0, t11.window[t11.strstart - 1]), t11.match_available = 0), t11.insert = t11.strstart < 2 ? t11.strstart : 2, e === Ri ? (ti(t11, true), t11.strm.avail_out === 0 ? 3 : 4) : t11.sym_next && (ti(t11, false), t11.strm.avail_out === 0) ? 1 : 2;
};
function $i(t11, e, n, i, r) {
  this.good_length = t11, this.max_lazy = e, this.nice_length = n, this.max_chain = i, this.func = r;
}
var ec = [new $i(0, 0, 0, 0, W0), new $i(4, 4, 8, 4, O_), new $i(4, 5, 16, 8, O_), new $i(4, 6, 32, 32, O_), new $i(4, 4, 16, 16, Rs), new $i(8, 16, 32, 32, Rs), new $i(8, 16, 128, 128, Rs), new $i(8, 32, 128, 256, Rs), new $i(32, 128, 258, 1024, Rs), new $i(32, 258, 258, 4096, Rs)];
function d3() {
  this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = th, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(2 * s3), this.dyn_dtree = new Uint16Array(2 * (2 * r3 + 1)), this.bl_tree = new Uint16Array(2 * (2 * o3 + 1)), Qr(this.dyn_ltree), Qr(this.dyn_dtree), Qr(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(a3 + 1), this.heap = new Uint16Array(2 * mm + 1), Qr(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * mm + 1), Qr(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
var Wc = (t11) => {
  if (!t11) return 1;
  let e = t11.state;
  return !e || e.strm !== t11 || e.status !== aa && e.status !== 57 && e.status !== 69 && e.status !== 73 && e.status !== 91 && e.status !== 103 && e.status !== Go && e.status !== tc ? 1 : 0;
};
var H0 = (t11) => {
  if (Wc(t11)) return Wo(t11, dr);
  t11.total_in = t11.total_out = 0, t11.data_type = i3;
  let e = t11.state;
  return e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap === 2 ? 57 : e.wrap ? aa : Go, t11.adler = e.wrap === 2 ? 0 : 1, e.last_flush = -2, YW(e), _n;
};
var K0 = (t11) => {
  let e = H0(t11);
  return e === _n && ((n) => {
    n.window_size = 2 * n.w_size, Qr(n.head), n.max_lazy_match = ec[n.level].max_lazy, n.good_match = ec[n.level].good_length, n.nice_match = ec[n.level].nice_length, n.max_chain_length = ec[n.level].max_chain, n.strstart = 0, n.block_start = 0, n.lookahead = 0, n.insert = 0, n.match_length = n.prev_length = 2, n.match_available = 0, n.ins_h = 0;
  })(t11.state), e;
};
var dA = (t11, e, n, i, r, o) => {
  if (!t11) return dr;
  let s = 1;
  if (e === ZW && (e = 6), i < 0 ? (s = 0, i = -i) : i > 15 && (s = 2, i -= 16), r < 1 || r > 9 || n !== th || i < 8 || i > 15 || e < 0 || e > 9 || o < 0 || o > e3 || i === 8 && s !== 1) return Wo(t11, dr);
  i === 8 && (i = 9);
  let a = new d3();
  return t11.state = a, a.strm = t11, a.status = aa, a.wrap = s, a.gzhead = null, a.w_bits = i, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = r + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + 3 - 1) / 3), a.window = new Uint8Array(2 * a.w_size), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << r + 6, a.pending_buf_size = 4 * a.lit_bufsize, a.pending_buf = new Uint8Array(a.pending_buf_size), a.sym_buf = a.lit_bufsize, a.sym_end = 3 * (a.lit_bufsize - 1), a.level = e, a.strategy = o, a.method = n, K0(t11);
};
var l3 = (t11, e) => {
  if (Wc(t11) || e > sA || e < 0) return t11 ? Wo(t11, dr) : dr;
  let n = t11.state;
  if (!t11.output || t11.avail_in !== 0 && !t11.input || n.status === tc && e !== Ri) return Wo(t11, t11.avail_out === 0 ? w_ : dr);
  let i = n.last_flush;
  if (n.last_flush = e, n.pending !== 0) {
    if (Zn(t11), t11.avail_out === 0) return n.last_flush = -1, _n;
  } else if (t11.avail_in === 0 && cA(e) <= cA(i) && e !== Ri) return Wo(t11, w_);
  if (n.status === tc && t11.avail_in !== 0) return Wo(t11, w_);
  if (n.status === aa && n.wrap === 0 && (n.status = Go), n.status === aa) {
    let r = th + (n.w_bits - 8 << 4) << 8, o = -1;
    if (o = n.strategy >= Zd || n.level < 2 ? 0 : n.level < 6 ? 1 : n.level === 6 ? 2 : 3, r |= o << 6, n.strstart !== 0 && (r |= 32), r += 31 - r % 31, ja(n, r), n.strstart !== 0 && (ja(n, t11.adler >>> 16), ja(n, 65535 & t11.adler)), t11.adler = 1, n.status = Go, Zn(t11), n.pending !== 0) return n.last_flush = -1, _n;
  }
  if (n.status === 57) {
    if (t11.adler = 0, te(n, 31), te(n, 139), te(n, 8), n.gzhead) te(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)), te(n, 255 & n.gzhead.time), te(n, n.gzhead.time >> 8 & 255), te(n, n.gzhead.time >> 16 & 255), te(n, n.gzhead.time >> 24 & 255), te(n, n.level === 9 ? 2 : n.strategy >= Zd || n.level < 2 ? 4 : 0), te(n, 255 & n.gzhead.os), n.gzhead.extra && n.gzhead.extra.length && (te(n, 255 & n.gzhead.extra.length), te(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (t11.adler = an(t11.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = 69;
    else if (te(n, 0), te(n, 0), te(n, 0), te(n, 0), te(n, 0), te(n, n.level === 9 ? 2 : n.strategy >= Zd || n.level < 2 ? 4 : 0), te(n, 3), n.status = Go, Zn(t11), n.pending !== 0) return n.last_flush = -1, _n;
  }
  if (n.status === 69) {
    if (n.gzhead.extra) {
      let r = n.pending, o = (65535 & n.gzhead.extra.length) - n.gzindex;
      for (; n.pending + o > n.pending_buf_size; ) {
        let a = n.pending_buf_size - n.pending;
        if (n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex, n.gzindex + a), n.pending), n.pending = n.pending_buf_size, n.gzhead.hcrc && n.pending > r && (t11.adler = an(t11.adler, n.pending_buf, n.pending - r, r)), n.gzindex += a, Zn(t11), n.pending !== 0) return n.last_flush = -1, _n;
        r = 0, o -= a;
      }
      let s = new Uint8Array(n.gzhead.extra);
      n.pending_buf.set(s.subarray(n.gzindex, n.gzindex + o), n.pending), n.pending += o, n.gzhead.hcrc && n.pending > r && (t11.adler = an(t11.adler, n.pending_buf, n.pending - r, r)), n.gzindex = 0;
    }
    n.status = 73;
  }
  if (n.status === 73) {
    if (n.gzhead.name) {
      let r, o = n.pending;
      do {
        if (n.pending === n.pending_buf_size) {
          if (n.gzhead.hcrc && n.pending > o && (t11.adler = an(t11.adler, n.pending_buf, n.pending - o, o)), Zn(t11), n.pending !== 0) return n.last_flush = -1, _n;
          o = 0;
        }
        r = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0, te(n, r);
      } while (r !== 0);
      n.gzhead.hcrc && n.pending > o && (t11.adler = an(t11.adler, n.pending_buf, n.pending - o, o)), n.gzindex = 0;
    }
    n.status = 91;
  }
  if (n.status === 91) {
    if (n.gzhead.comment) {
      let r, o = n.pending;
      do {
        if (n.pending === n.pending_buf_size) {
          if (n.gzhead.hcrc && n.pending > o && (t11.adler = an(t11.adler, n.pending_buf, n.pending - o, o)), Zn(t11), n.pending !== 0) return n.last_flush = -1, _n;
          o = 0;
        }
        r = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0, te(n, r);
      } while (r !== 0);
      n.gzhead.hcrc && n.pending > o && (t11.adler = an(t11.adler, n.pending_buf, n.pending - o, o));
    }
    n.status = 103;
  }
  if (n.status === 103) {
    if (n.gzhead.hcrc) {
      if (n.pending + 2 > n.pending_buf_size && (Zn(t11), n.pending !== 0)) return n.last_flush = -1, _n;
      te(n, 255 & t11.adler), te(n, t11.adler >> 8 & 255), t11.adler = 0;
    }
    if (n.status = Go, Zn(t11), n.pending !== 0) return n.last_flush = -1, _n;
  }
  if (t11.avail_in !== 0 || n.lookahead !== 0 || e !== co && n.status !== tc) {
    let r = n.level === 0 ? W0(n, e) : n.strategy === Zd ? ((o, s) => {
      let a;
      for (; ; ) {
        if (o.lookahead === 0 && (ca(o), o.lookahead === 0)) {
          if (s === co) return 1;
          break;
        }
        if (o.match_length = 0, a = ao(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++, a && (ti(o, false), o.strm.avail_out === 0)) return 1;
      }
      return o.insert = 0, s === Ri ? (ti(o, true), o.strm.avail_out === 0 ? 3 : 4) : o.sym_next && (ti(o, false), o.strm.avail_out === 0) ? 1 : 2;
    })(n, e) : n.strategy === t32 ? ((o, s) => {
      let a, c, d, l, u = o.window;
      for (; ; ) {
        if (o.lookahead <= jo) {
          if (ca(o), o.lookahead <= jo && s === co) return 1;
          if (o.lookahead === 0) break;
        }
        if (o.match_length = 0, o.lookahead >= 3 && o.strstart > 0 && (d = o.strstart - 1, c = u[d], c === u[++d] && c === u[++d] && c === u[++d])) {
          l = o.strstart + jo;
          do
            ;
          while (c === u[++d] && c === u[++d] && c === u[++d] && c === u[++d] && c === u[++d] && c === u[++d] && c === u[++d] && c === u[++d] && d < l);
          o.match_length = jo - (l - d), o.match_length > o.lookahead && (o.match_length = o.lookahead);
        }
        if (o.match_length >= 3 ? (a = ao(o, 1, o.match_length - 3), o.lookahead -= o.match_length, o.strstart += o.match_length, o.match_length = 0) : (a = ao(o, 0, o.window[o.strstart]), o.lookahead--, o.strstart++), a && (ti(o, false), o.strm.avail_out === 0)) return 1;
      }
      return o.insert = 0, s === Ri ? (ti(o, true), o.strm.avail_out === 0 ? 3 : 4) : o.sym_next && (ti(o, false), o.strm.avail_out === 0) ? 1 : 2;
    })(n, e) : ec[n.level].func(n, e);
    if (r !== 3 && r !== 4 || (n.status = tc), r === 1 || r === 3) return t11.avail_out === 0 && (n.last_flush = -1), _n;
    if (r === 2 && (e === JW ? zW(n) : e !== sA && (Em(n, 0, 0, false), e === XW && (Qr(n.head), n.lookahead === 0 && (n.strstart = 0, n.block_start = 0, n.insert = 0))), Zn(t11), t11.avail_out === 0)) return n.last_flush = -1, _n;
  }
  return e !== Ri ? _n : n.wrap <= 0 ? aA : (n.wrap === 2 ? (te(n, 255 & t11.adler), te(n, t11.adler >> 8 & 255), te(n, t11.adler >> 16 & 255), te(n, t11.adler >> 24 & 255), te(n, 255 & t11.total_in), te(n, t11.total_in >> 8 & 255), te(n, t11.total_in >> 16 & 255), te(n, t11.total_in >> 24 & 255)) : (ja(n, t11.adler >>> 16), ja(n, 65535 & t11.adler)), Zn(t11), n.wrap > 0 && (n.wrap = -n.wrap), n.pending !== 0 ? _n : aA);
};
var u3 = (t11, e) => {
  let n = e.length;
  if (Wc(t11)) return dr;
  let i = t11.state, r = i.wrap;
  if (r === 2 || r === 1 && i.status !== aa || i.lookahead) return dr;
  if (r === 1 && (t11.adler = Gc(t11.adler, e, n, 0)), i.wrap = 0, n >= i.w_size) {
    r === 0 && (Qr(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0);
    let c = new Uint8Array(i.w_size);
    c.set(e.subarray(n - i.w_size, n), 0), e = c, n = i.w_size;
  }
  let o = t11.avail_in, s = t11.next_in, a = t11.input;
  for (t11.avail_in = n, t11.next_in = 0, t11.input = e, ca(i); i.lookahead >= 3; ) {
    let c = i.strstart, d = i.lookahead - 2;
    do
      i.ins_h = lo(i, i.ins_h, i.window[c + 3 - 1]), i.prev[c & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = c, c++;
    while (--d);
    i.strstart = c, i.lookahead = 2, ca(i);
  }
  return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = 2, i.match_available = 0, t11.next_in = s, t11.input = a, t11.avail_in = o, i.wrap = r, _n;
};
var pc = { deflateInit: (t11, e) => dA(t11, e, th, 15, 8, n3), deflateInit2: dA, deflateReset: K0, deflateResetKeep: H0, deflateSetHeader: (t11, e) => Wc(t11) || t11.state.wrap !== 2 ? dr : (t11.state.gzhead = e, _n), deflate: l3, deflateEnd: (t11) => {
  if (Wc(t11)) return dr;
  let e = t11.state.status;
  return t11.state = null, e === Go ? Wo(t11, QW) : _n;
}, deflateSetDictionary: u3, deflateInfo: "pako deflate (from Nodeca project)" };
var h3 = (t11, e) => Object.prototype.hasOwnProperty.call(t11, e);
var eh = { assign: function(t11) {
  let e = Array.prototype.slice.call(arguments, 1);
  for (; e.length; ) {
    let n = e.shift();
    if (n) {
      if (typeof n != "object") throw new TypeError(n + "must be non-object");
      for (let i in n) h3(n, i) && (t11[i] = n[i]);
    }
  }
  return t11;
}, flattenChunks: (t11) => {
  let e = 0;
  for (let i = 0, r = t11.length; i < r; i++) e += t11[i].length;
  let n = new Uint8Array(e);
  for (let i = 0, r = 0, o = t11.length; i < o; i++) {
    let s = t11[i];
    n.set(s, r), r += s.length;
  }
  return n;
} };
var Y0 = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch {
  Y0 = false;
}
var Hc = new Uint8Array(256);
for (let t11 = 0; t11 < 256; t11++) Hc[t11] = t11 >= 252 ? 6 : t11 >= 248 ? 5 : t11 >= 240 ? 4 : t11 >= 224 ? 3 : t11 >= 192 ? 2 : 1;
Hc[254] = Hc[254] = 1;
var Kc = { string2buf: (t11) => {
  if (typeof TextEncoder == "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(t11);
  let e, n, i, r, o, s = t11.length, a = 0;
  for (r = 0; r < s; r++) n = t11.charCodeAt(r), (64512 & n) == 55296 && r + 1 < s && (i = t11.charCodeAt(r + 1), (64512 & i) == 56320 && (n = 65536 + (n - 55296 << 10) + (i - 56320), r++)), a += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
  for (e = new Uint8Array(a), o = 0, r = 0; o < a; r++) n = t11.charCodeAt(r), (64512 & n) == 55296 && r + 1 < s && (i = t11.charCodeAt(r + 1), (64512 & i) == 56320 && (n = 65536 + (n - 55296 << 10) + (i - 56320), r++)), n < 128 ? e[o++] = n : n < 2048 ? (e[o++] = 192 | n >>> 6, e[o++] = 128 | 63 & n) : n < 65536 ? (e[o++] = 224 | n >>> 12, e[o++] = 128 | n >>> 6 & 63, e[o++] = 128 | 63 & n) : (e[o++] = 240 | n >>> 18, e[o++] = 128 | n >>> 12 & 63, e[o++] = 128 | n >>> 6 & 63, e[o++] = 128 | 63 & n);
  return e;
}, buf2string: (t11, e) => {
  let n = e || t11.length;
  if (typeof TextDecoder == "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(t11.subarray(0, e));
  let i, r, o = new Array(2 * n);
  for (r = 0, i = 0; i < n; ) {
    let s = t11[i++];
    if (s < 128) {
      o[r++] = s;
      continue;
    }
    let a = Hc[s];
    if (a > 4) o[r++] = 65533, i += a - 1;
    else {
      for (s &= a === 2 ? 31 : a === 3 ? 15 : 7; a > 1 && i < n; ) s = s << 6 | 63 & t11[i++], a--;
      a > 1 ? o[r++] = 65533 : s < 65536 ? o[r++] = s : (s -= 65536, o[r++] = 55296 | s >> 10 & 1023, o[r++] = 56320 | 1023 & s);
    }
  }
  return ((s, a) => {
    if (a < 65534 && s.subarray && Y0) return String.fromCharCode.apply(null, s.length === a ? s : s.subarray(0, a));
    let c = "";
    for (let d = 0; d < a; d++) c += String.fromCharCode(s[d]);
    return c;
  })(o, r);
}, utf8border: (t11, e) => {
  (e = e || t11.length) > t11.length && (e = t11.length);
  let n = e - 1;
  for (; n >= 0 && (192 & t11[n]) == 128; ) n--;
  return n < 0 || n === 0 ? e : n + Hc[t11[n]] > e ? n : e;
} };
var q0 = function() {
  this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
};
var z0 = Object.prototype.toString;
var { Z_NO_FLUSH: p3, Z_SYNC_FLUSH: _3, Z_FULL_FLUSH: E3, Z_FINISH: m3, Z_OK: Cu, Z_STREAM_END: f3, Z_DEFAULT_COMPRESSION: g3, Z_DEFAULT_STRATEGY: T3, Z_DEFLATED: S3 } = Ra;
function _c(t11) {
  this.options = eh.assign({ level: g3, method: S3, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: T3 }, t11 || {});
  let e = this.options;
  e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new q0(), this.strm.avail_out = 0;
  let n = pc.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
  if (n !== Cu) throw new Error(Zo[n]);
  if (e.header && pc.deflateSetHeader(this.strm, e.header), e.dictionary) {
    let i;
    if (i = typeof e.dictionary == "string" ? Kc.string2buf(e.dictionary) : z0.call(e.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(e.dictionary) : e.dictionary, n = pc.deflateSetDictionary(this.strm, i), n !== Cu) throw new Error(Zo[n]);
    this._dict_set = true;
  }
}
function N_(t11, e) {
  let n = new _c(e);
  if (n.push(t11, true), n.err) throw n.msg || Zo[n.err];
  return n.result;
}
_c.prototype.push = function(t11, e) {
  let n = this.strm, i = this.options.chunkSize, r, o;
  if (this.ended) return false;
  for (o = e === ~~e ? e : e === true ? m3 : p3, typeof t11 == "string" ? n.input = Kc.string2buf(t11) : z0.call(t11) === "[object ArrayBuffer]" ? n.input = new Uint8Array(t11) : n.input = t11, n.next_in = 0, n.avail_in = n.input.length; ; ) if (n.avail_out === 0 && (n.output = new Uint8Array(i), n.next_out = 0, n.avail_out = i), (o === _3 || o === E3) && n.avail_out <= 6) this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
  else {
    if (r = pc.deflate(n, o), r === f3) return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)), r = pc.deflateEnd(this.strm), this.onEnd(r), this.ended = true, r === Cu;
    if (n.avail_out !== 0) {
      if (o > 0 && n.next_out > 0) this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
      else if (n.avail_in === 0) break;
    } else this.onData(n.output);
  }
  return true;
}, _c.prototype.onData = function(t11) {
  this.chunks.push(t11);
}, _c.prototype.onEnd = function(t11) {
  t11 === Cu && (this.result = eh.flattenChunks(this.chunks)), this.chunks = [], this.err = t11, this.msg = this.strm.msg;
};
var R3 = { Deflate: _c, deflate: N_, deflateRaw: function(t11, e) {
  return (e = e || {}).raw = true, N_(t11, e);
}, gzip: function(t11, e) {
  return (e = e || {}).gzip = true, N_(t11, e);
}, constants: Ra };
var $d = 16209;
var C3 = function(t11, e) {
  let n, i, r, o, s, a, c, d, l, u, h, p, g, E, f, S, C, A, b, w, D, k, B, V, z = t11.state;
  n = t11.next_in, B = t11.input, i = n + (t11.avail_in - 5), r = t11.next_out, V = t11.output, o = r - (e - t11.avail_out), s = r + (t11.avail_out - 257), a = z.dmax, c = z.wsize, d = z.whave, l = z.wnext, u = z.window, h = z.hold, p = z.bits, g = z.lencode, E = z.distcode, f = (1 << z.lenbits) - 1, S = (1 << z.distbits) - 1;
  t: do {
    p < 15 && (h += B[n++] << p, p += 8, h += B[n++] << p, p += 8), C = g[h & f];
    e: for (; ; ) {
      if (A = C >>> 24, h >>>= A, p -= A, A = C >>> 16 & 255, A === 0) V[r++] = 65535 & C;
      else {
        if (!(16 & A)) {
          if (!(64 & A)) {
            C = g[(65535 & C) + (h & (1 << A) - 1)];
            continue e;
          }
          if (32 & A) {
            z.mode = 16191;
            break t;
          }
          t11.msg = "invalid literal/length code", z.mode = $d;
          break t;
        }
        b = 65535 & C, A &= 15, A && (p < A && (h += B[n++] << p, p += 8), b += h & (1 << A) - 1, h >>>= A, p -= A), p < 15 && (h += B[n++] << p, p += 8, h += B[n++] << p, p += 8), C = E[h & S];
        n: for (; ; ) {
          if (A = C >>> 24, h >>>= A, p -= A, A = C >>> 16 & 255, !(16 & A)) {
            if (!(64 & A)) {
              C = E[(65535 & C) + (h & (1 << A) - 1)];
              continue n;
            }
            t11.msg = "invalid distance code", z.mode = $d;
            break t;
          }
          if (w = 65535 & C, A &= 15, p < A && (h += B[n++] << p, p += 8, p < A && (h += B[n++] << p, p += 8)), w += h & (1 << A) - 1, w > a) {
            t11.msg = "invalid distance too far back", z.mode = $d;
            break t;
          }
          if (h >>>= A, p -= A, A = r - o, w > A) {
            if (A = w - A, A > d && z.sane) {
              t11.msg = "invalid distance too far back", z.mode = $d;
              break t;
            }
            if (D = 0, k = u, l === 0) {
              if (D += c - A, A < b) {
                b -= A;
                do
                  V[r++] = u[D++];
                while (--A);
                D = r - w, k = V;
              }
            } else if (l < A) {
              if (D += c + l - A, A -= l, A < b) {
                b -= A;
                do
                  V[r++] = u[D++];
                while (--A);
                if (D = 0, l < b) {
                  A = l, b -= A;
                  do
                    V[r++] = u[D++];
                  while (--A);
                  D = r - w, k = V;
                }
              }
            } else if (D += l - A, A < b) {
              b -= A;
              do
                V[r++] = u[D++];
              while (--A);
              D = r - w, k = V;
            }
            for (; b > 2; ) V[r++] = k[D++], V[r++] = k[D++], V[r++] = k[D++], b -= 3;
            b && (V[r++] = k[D++], b > 1 && (V[r++] = k[D++]));
          } else {
            D = r - w;
            do
              V[r++] = V[D++], V[r++] = V[D++], V[r++] = V[D++], b -= 3;
            while (b > 2);
            b && (V[r++] = V[D++], b > 1 && (V[r++] = V[D++]));
          }
          break;
        }
      }
      break;
    }
  } while (n < i && r < s);
  b = p >> 3, n -= b, p -= b << 3, h &= (1 << p) - 1, t11.next_in = n, t11.next_out = r, t11.avail_in = n < i ? i - n + 5 : 5 - (n - i), t11.avail_out = r < s ? s - r + 257 : 257 - (r - s), z.hold = h, z.bits = p;
};
var tl = 15;
var I3 = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]);
var v3 = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]);
var y3 = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]);
var A3 = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
var Ec = (t11, e, n, i, r, o, s, a) => {
  let c = a.bits, d, l, u, h, p, g, E = 0, f = 0, S = 0, C = 0, A = 0, b = 0, w = 0, D = 0, k = 0, B = 0, V = null, z = new Uint16Array(16), lt = new Uint16Array(16), vt, Dt, ce, Wt = null;
  for (E = 0; E <= tl; E++) z[E] = 0;
  for (f = 0; f < i; f++) z[e[n + f]]++;
  for (A = c, C = tl; C >= 1 && z[C] === 0; C--) ;
  if (A > C && (A = C), C === 0) return r[o++] = 20971520, r[o++] = 20971520, a.bits = 1, 0;
  for (S = 1; S < C && z[S] === 0; S++) ;
  for (A < S && (A = S), D = 1, E = 1; E <= tl; E++) if (D <<= 1, D -= z[E], D < 0) return -1;
  if (D > 0 && (t11 === 0 || C !== 1)) return -1;
  for (lt[1] = 0, E = 1; E < tl; E++) lt[E + 1] = lt[E] + z[E];
  for (f = 0; f < i; f++) e[n + f] !== 0 && (s[lt[e[n + f]]++] = f);
  if (t11 === 0 ? (V = Wt = s, g = 20) : t11 === 1 ? (V = I3, Wt = v3, g = 257) : (V = y3, Wt = A3, g = 0), B = 0, f = 0, E = S, p = o, b = A, w = 0, u = -1, k = 1 << A, h = k - 1, t11 === 1 && k > 852 || t11 === 2 && k > 592) return 1;
  for (; ; ) {
    vt = E - w, s[f] + 1 < g ? (Dt = 0, ce = s[f]) : s[f] >= g ? (Dt = Wt[s[f] - g], ce = V[s[f] - g]) : (Dt = 96, ce = 0), d = 1 << E - w, l = 1 << b, S = l;
    do
      l -= d, r[p + (B >> w) + l] = vt << 24 | Dt << 16 | ce | 0;
    while (l !== 0);
    for (d = 1 << E - 1; B & d; ) d >>= 1;
    if (d !== 0 ? (B &= d - 1, B += d) : B = 0, f++, --z[E] == 0) {
      if (E === C) break;
      E = e[n + s[f]];
    }
    if (E > A && (B & h) !== u) {
      for (w === 0 && (w = A), p += S, b = E - w, D = 1 << b; b + w < C && (D -= z[b + w], !(D <= 0)); ) b++, D <<= 1;
      if (k += 1 << b, t11 === 1 && k > 852 || t11 === 2 && k > 592) return 1;
      u = B & h, r[u] = A << 24 | b << 16 | p - o | 0;
    }
  }
  return B !== 0 && (r[p + B] = E - w << 24 | 64 << 16 | 0), a.bits = A, 0;
};
var { Z_FINISH: lA, Z_BLOCK: b3, Z_TREES: el, Z_OK: Yo, Z_STREAM_END: w3, Z_NEED_DICT: O3, Z_STREAM_ERROR: Ci, Z_DATA_ERROR: J0, Z_MEM_ERROR: X0, Z_BUF_ERROR: N3, Z_DEFLATED: uA } = Ra;
var nh = 16180;
var Iu = 16190;
var Cr = 16191;
var D_ = 16192;
var P_ = 16194;
var nl = 16199;
var il = 16200;
var k_ = 16206;
var be = 16209;
var hA = (t11) => (t11 >>> 24 & 255) + (t11 >>> 8 & 65280) + ((65280 & t11) << 8) + ((255 & t11) << 24);
function D3() {
  this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
var qo = (t11) => {
  if (!t11) return 1;
  let e = t11.state;
  return !e || e.strm !== t11 || e.mode < nh || e.mode > 16211 ? 1 : 0;
};
var Q0 = (t11) => {
  if (qo(t11)) return Ci;
  let e = t11.state;
  return t11.total_in = t11.total_out = e.total = 0, t11.msg = "", e.wrap && (t11.adler = 1 & e.wrap), e.mode = nh, e.last = 0, e.havedict = 0, e.flags = -1, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(852), e.distcode = e.distdyn = new Int32Array(592), e.sane = 1, e.back = -1, Yo;
};
var Z0 = (t11) => {
  if (qo(t11)) return Ci;
  let e = t11.state;
  return e.wsize = 0, e.whave = 0, e.wnext = 0, Q0(t11);
};
var $0 = (t11, e) => {
  let n;
  if (qo(t11)) return Ci;
  let i = t11.state;
  return e < 0 ? (n = 0, e = -e) : (n = 5 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? Ci : (i.window !== null && i.wbits !== e && (i.window = null), i.wrap = n, i.wbits = e, Z0(t11));
};
var pA = (t11, e) => {
  if (!t11) return Ci;
  let n = new D3();
  t11.state = n, n.strm = t11, n.window = null, n.mode = nh;
  let i = $0(t11, e);
  return i !== Yo && (t11.state = null), i;
};
var L_;
var M_;
var _A = true;
var P3 = (t11) => {
  if (_A) {
    L_ = new Int32Array(512), M_ = new Int32Array(32);
    let e = 0;
    for (; e < 144; ) t11.lens[e++] = 8;
    for (; e < 256; ) t11.lens[e++] = 9;
    for (; e < 280; ) t11.lens[e++] = 7;
    for (; e < 288; ) t11.lens[e++] = 8;
    for (Ec(1, t11.lens, 0, 288, L_, 0, t11.work, { bits: 9 }), e = 0; e < 32; ) t11.lens[e++] = 5;
    Ec(2, t11.lens, 0, 32, M_, 0, t11.work, { bits: 5 }), _A = false;
  }
  t11.lencode = L_, t11.lenbits = 9, t11.distcode = M_, t11.distbits = 5;
};
var tN = (t11, e, n, i) => {
  let r, o = t11.state;
  return o.window === null && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new Uint8Array(o.wsize)), i >= o.wsize ? (o.window.set(e.subarray(n - o.wsize, n), 0), o.wnext = 0, o.whave = o.wsize) : (r = o.wsize - o.wnext, r > i && (r = i), o.window.set(e.subarray(n - i, n - i + r), o.wnext), (i -= r) ? (o.window.set(e.subarray(n - i, n), 0), o.wnext = i, o.whave = o.wsize) : (o.wnext += r, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += r))), 0;
};
var k3 = (t11, e) => {
  let n, i, r, o, s, a, c, d, l, u, h, p, g, E, f, S, C, A, b, w, D, k, B = 0, V = new Uint8Array(4), z, lt, vt = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (qo(t11) || !t11.output || !t11.input && t11.avail_in !== 0) return Ci;
  n = t11.state, n.mode === Cr && (n.mode = D_), s = t11.next_out, r = t11.output, c = t11.avail_out, o = t11.next_in, i = t11.input, a = t11.avail_in, d = n.hold, l = n.bits, u = a, h = c, k = Yo;
  t: for (; ; ) switch (n.mode) {
    case nh:
      if (n.wrap === 0) {
        n.mode = D_;
        break;
      }
      for (; l < 16; ) {
        if (a === 0) break t;
        a--, d += i[o++] << l, l += 8;
      }
      if (2 & n.wrap && d === 35615) {
        n.wbits === 0 && (n.wbits = 15), n.check = 0, V[0] = 255 & d, V[1] = d >>> 8 & 255, n.check = an(n.check, V, 2, 0), d = 0, l = 0, n.mode = 16181;
        break;
      }
      if (n.head && (n.head.done = false), !(1 & n.wrap) || (((255 & d) << 8) + (d >> 8)) % 31) {
        t11.msg = "incorrect header check", n.mode = be;
        break;
      }
      if ((15 & d) !== uA) {
        t11.msg = "unknown compression method", n.mode = be;
        break;
      }
      if (d >>>= 4, l -= 4, D = 8 + (15 & d), n.wbits === 0 && (n.wbits = D), D > 15 || D > n.wbits) {
        t11.msg = "invalid window size", n.mode = be;
        break;
      }
      n.dmax = 1 << n.wbits, n.flags = 0, t11.adler = n.check = 1, n.mode = 512 & d ? 16189 : Cr, d = 0, l = 0;
      break;
    case 16181:
      for (; l < 16; ) {
        if (a === 0) break t;
        a--, d += i[o++] << l, l += 8;
      }
      if (n.flags = d, (255 & en(n)) !== uA) {
        t11.msg = "unknown compression method", n.mode = be;
        break;
      }
      if (57344 & en(n)) {
        t11.msg = "unknown header flags set", n.mode = be;
        break;
      }
      n.head && (n.head.text = d >> 8 & 1), 512 & en(n) && 4 & n.wrap && (V[0] = 255 & d, V[1] = d >>> 8 & 255, n.check = an(n.check, V, 2, 0)), d = 0, l = 0, n.mode = 16182;
    case 16182:
      for (; l < 32; ) {
        if (a === 0) break t;
        a--, d += i[o++] << l, l += 8;
      }
      n.head && (n.head.time = d), 512 & en(n) && 4 & n.wrap && (V[0] = 255 & d, V[1] = d >>> 8 & 255, V[2] = d >>> 16 & 255, V[3] = d >>> 24 & 255, n.check = an(n.check, V, 4, 0)), d = 0, l = 0, n.mode = 16183;
    case 16183:
      for (; l < 16; ) {
        if (a === 0) break t;
        a--, d += i[o++] << l, l += 8;
      }
      n.head && (n.head.xflags = 255 & d, n.head.os = d >> 8), 512 & en(n) && 4 & n.wrap && (V[0] = 255 & d, V[1] = d >>> 8 & 255, n.check = an(n.check, V, 2, 0)), d = 0, l = 0, n.mode = 16184;
    case 16184:
      if (1024 & en(n)) {
        for (; l < 16; ) {
          if (a === 0) break t;
          a--, d += i[o++] << l, l += 8;
        }
        n.length = d, n.head && (n.head.extra_len = d), 512 & en(n) && 4 & n.wrap && (V[0] = 255 & d, V[1] = d >>> 8 & 255, n.check = an(n.check, V, 2, 0)), d = 0, l = 0;
      } else n.head && (n.head.extra = null);
      n.mode = 16185;
    case 16185:
      if (1024 & en(n) && (p = n.length, p > a && (p = a), p && (n.head && (D = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)), n.head.extra.set(i.subarray(o, o + p), D)), 512 & en(n) && 4 & n.wrap && (n.check = an(n.check, i, p, o)), a -= p, o += p, n.length -= p), n.length)) break t;
      n.length = 0, n.mode = 16186;
    case 16186:
      if (2048 & en(n)) {
        if (a === 0) break t;
        p = 0;
        do
          D = i[o + p++], n.head && D && n.length < 65536 && (n.head.name += String.fromCharCode(D));
        while (D && p < a);
        if (512 & en(n) && 4 & n.wrap && (n.check = an(n.check, i, p, o)), a -= p, o += p, D) break t;
      } else n.head && (n.head.name = null);
      n.length = 0, n.mode = 16187;
    case 16187:
      if (4096 & en(n)) {
        if (a === 0) break t;
        p = 0;
        do
          D = i[o + p++], n.head && D && n.length < 65536 && (n.head.comment += String.fromCharCode(D));
        while (D && p < a);
        if (512 & en(n) && 4 & n.wrap && (n.check = an(n.check, i, p, o)), a -= p, o += p, D) break t;
      } else n.head && (n.head.comment = null);
      n.mode = 16188;
    case 16188:
      if (512 & en(n)) {
        for (; l < 16; ) {
          if (a === 0) break t;
          a--, d += i[o++] << l, l += 8;
        }
        if (4 & n.wrap && d !== (65535 & n.check)) {
          t11.msg = "header crc mismatch", n.mode = be;
          break;
        }
        d = 0, l = 0;
      }
      n.head && (n.head.hcrc = en(n) >> 9 & 1, n.head.done = true), t11.adler = n.check = 0, n.mode = Cr;
      break;
    case 16189:
      for (; l < 32; ) {
        if (a === 0) break t;
        a--, d += i[o++] << l, l += 8;
      }
      t11.adler = n.check = hA(d), d = 0, l = 0, n.mode = Iu;
    case Iu:
      if (n.havedict === 0) return t11.next_out = s, t11.avail_out = c, t11.next_in = o, t11.avail_in = a, n.hold = d, n.bits = l, O3;
      t11.adler = n.check = 1, n.mode = Cr;
    case Cr:
      if (e === b3 || e === el) break t;
    case D_:
      if (n.last) {
        d >>>= 7 & l, l -= 7 & l, n.mode = k_;
        break;
      }
      for (; l < 3; ) {
        if (a === 0) break t;
        a--, d += i[o++] << l, l += 8;
      }
      switch (n.last = 1 & d, d >>>= 1, l -= 1, 3 & d) {
        case 0:
          n.mode = 16193;
          break;
        case 1:
          if (P3(n), n.mode = nl, e === el) {
            d >>>= 2, l -= 2;
            break t;
          }
          break;
        case 2:
          n.mode = 16196;
          break;
        case 3:
          t11.msg = "invalid block type", n.mode = be;
      }
      d >>>= 2, l -= 2;
      break;
    case 16193:
      for (d >>>= 7 & l, l -= 7 & l; l < 32; ) {
        if (a === 0) break t;
        a--, d += i[o++] << l, l += 8;
      }
      if ((65535 & d) != (d >>> 16 ^ 65535)) {
        t11.msg = "invalid stored block lengths", n.mode = be;
        break;
      }
      if (n.length = 65535 & d, d = 0, l = 0, n.mode = P_, e === el) break t;
    case P_:
      n.mode = 16195;
    case 16195:
      if (p = n.length, p) {
        if (p > a && (p = a), p > c && (p = c), p === 0) break t;
        r.set(i.subarray(o, o + p), s), a -= p, o += p, c -= p, s += p, n.length -= p;
        break;
      }
      n.mode = Cr;
      break;
    case 16196:
      for (; l < 14; ) {
        if (a === 0) break t;
        a--, d += i[o++] << l, l += 8;
      }
      if (n.nlen = 257 + (31 & d), d >>>= 5, l -= 5, n.ndist = 1 + (31 & d), d >>>= 5, l -= 5, n.ncode = 4 + (15 & d), d >>>= 4, l -= 4, n.nlen > 286 || n.ndist > 30) {
        t11.msg = "too many length or distance symbols", n.mode = be;
        break;
      }
      n.have = 0, n.mode = 16197;
    case 16197:
      for (; n.have < n.ncode; ) {
        for (; l < 3; ) {
          if (a === 0) break t;
          a--, d += i[o++] << l, l += 8;
        }
        n.lens[vt[n.have++]] = 7 & d, d >>>= 3, l -= 3;
      }
      for (; n.have < 19; ) n.lens[vt[n.have++]] = 0;
      if (n.lencode = n.lendyn, n.lenbits = 7, z = { bits: n.lenbits }, k = Ec(0, n.lens, 0, 19, n.lencode, 0, n.work, z), n.lenbits = z.bits, k) {
        t11.msg = "invalid code lengths set", n.mode = be;
        break;
      }
      n.have = 0, n.mode = 16198;
    case 16198:
      for (; n.have < n.nlen + n.ndist; ) {
        for (; B = n.lencode[d & (1 << n.lenbits) - 1], f = B >>> 24, S = B >>> 16 & 255, C = 65535 & B, !(f <= l); ) {
          if (a === 0) break t;
          a--, d += i[o++] << l, l += 8;
        }
        if (C < 16) d >>>= f, l -= f, n.lens[n.have++] = C;
        else {
          if (C === 16) {
            for (lt = f + 2; l < lt; ) {
              if (a === 0) break t;
              a--, d += i[o++] << l, l += 8;
            }
            if (d >>>= f, l -= f, n.have === 0) {
              t11.msg = "invalid bit length repeat", n.mode = be;
              break;
            }
            D = n.lens[n.have - 1], p = 3 + (3 & d), d >>>= 2, l -= 2;
          } else if (C === 17) {
            for (lt = f + 3; l < lt; ) {
              if (a === 0) break t;
              a--, d += i[o++] << l, l += 8;
            }
            d >>>= f, l -= f, D = 0, p = 3 + (7 & d), d >>>= 3, l -= 3;
          } else {
            for (lt = f + 7; l < lt; ) {
              if (a === 0) break t;
              a--, d += i[o++] << l, l += 8;
            }
            d >>>= f, l -= f, D = 0, p = 11 + (127 & d), d >>>= 7, l -= 7;
          }
          if (n.have + p > n.nlen + n.ndist) {
            t11.msg = "invalid bit length repeat", n.mode = be;
            break;
          }
          for (; p--; ) n.lens[n.have++] = D;
        }
      }
      if (n.mode === be) break;
      if (n.lens[256] === 0) {
        t11.msg = "invalid code -- missing end-of-block", n.mode = be;
        break;
      }
      if (n.lenbits = 9, z = { bits: n.lenbits }, k = Ec(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, z), n.lenbits = z.bits, k) {
        t11.msg = "invalid literal/lengths set", n.mode = be;
        break;
      }
      if (n.distbits = 6, n.distcode = n.distdyn, z = { bits: n.distbits }, k = Ec(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, z), n.distbits = z.bits, k) {
        t11.msg = "invalid distances set", n.mode = be;
        break;
      }
      if (n.mode = nl, e === el) break t;
    case nl:
      n.mode = il;
    case il:
      if (a >= 6 && c >= 258) {
        t11.next_out = s, t11.avail_out = c, t11.next_in = o, t11.avail_in = a, n.hold = d, n.bits = l, C3(t11, h), s = t11.next_out, r = t11.output, c = t11.avail_out, o = t11.next_in, i = t11.input, a = t11.avail_in, d = n.hold, l = n.bits, n.mode === Cr && (n.back = -1);
        break;
      }
      for (n.back = 0; B = n.lencode[d & (1 << n.lenbits) - 1], f = B >>> 24, S = B >>> 16 & 255, C = 65535 & B, !(f <= l); ) {
        if (a === 0) break t;
        a--, d += i[o++] << l, l += 8;
      }
      if (S && !(240 & S)) {
        for (A = f, b = S, w = C; B = n.lencode[w + ((d & (1 << A + b) - 1) >> A)], f = B >>> 24, S = B >>> 16 & 255, C = 65535 & B, !(A + f <= l); ) {
          if (a === 0) break t;
          a--, d += i[o++] << l, l += 8;
        }
        d >>>= A, l -= A, n.back += A;
      }
      if (d >>>= f, l -= f, n.back += f, n.length = C, S === 0) {
        n.mode = 16205;
        break;
      }
      if (32 & S) {
        n.back = -1, n.mode = Cr;
        break;
      }
      if (64 & S) {
        t11.msg = "invalid literal/length code", n.mode = be;
        break;
      }
      n.extra = 15 & S, n.mode = 16201;
    case 16201:
      if (n.extra) {
        for (lt = n.extra; l < lt; ) {
          if (a === 0) break t;
          a--, d += i[o++] << l, l += 8;
        }
        n.length += d & (1 << n.extra) - 1, d >>>= n.extra, l -= n.extra, n.back += n.extra;
      }
      n.was = n.length, n.mode = 16202;
    case 16202:
      for (; B = n.distcode[d & (1 << n.distbits) - 1], f = B >>> 24, S = B >>> 16 & 255, C = 65535 & B, !(f <= l); ) {
        if (a === 0) break t;
        a--, d += i[o++] << l, l += 8;
      }
      if (!(240 & S)) {
        for (A = f, b = S, w = C; B = n.distcode[w + ((d & (1 << A + b) - 1) >> A)], f = B >>> 24, S = B >>> 16 & 255, C = 65535 & B, !(A + f <= l); ) {
          if (a === 0) break t;
          a--, d += i[o++] << l, l += 8;
        }
        d >>>= A, l -= A, n.back += A;
      }
      if (d >>>= f, l -= f, n.back += f, 64 & S) {
        t11.msg = "invalid distance code", n.mode = be;
        break;
      }
      n.offset = C, n.extra = 15 & S, n.mode = 16203;
    case 16203:
      if (n.extra) {
        for (lt = n.extra; l < lt; ) {
          if (a === 0) break t;
          a--, d += i[o++] << l, l += 8;
        }
        n.offset += d & (1 << n.extra) - 1, d >>>= n.extra, l -= n.extra, n.back += n.extra;
      }
      if (n.offset > n.dmax) {
        t11.msg = "invalid distance too far back", n.mode = be;
        break;
      }
      n.mode = 16204;
    case 16204:
      if (c === 0) break t;
      if (p = h - c, n.offset > p) {
        if (p = n.offset - p, p > n.whave && n.sane) {
          t11.msg = "invalid distance too far back", n.mode = be;
          break;
        }
        p > n.wnext ? (p -= n.wnext, g = n.wsize - p) : g = n.wnext - p, p > n.length && (p = n.length), E = n.window;
      } else E = r, g = s - n.offset, p = n.length;
      p > c && (p = c), c -= p, n.length -= p;
      do
        r[s++] = E[g++];
      while (--p);
      n.length === 0 && (n.mode = il);
      break;
    case 16205:
      if (c === 0) break t;
      r[s++] = n.length, c--, n.mode = il;
      break;
    case k_:
      if (n.wrap) {
        for (; l < 32; ) {
          if (a === 0) break t;
          a--, d |= i[o++] << l, l += 8;
        }
        if (h -= c, t11.total_out += h, n.total += h, 4 & n.wrap && h && (t11.adler = n.check = en(n) ? an(n.check, r, h, s - h) : Gc(n.check, r, h, s - h)), h = c, 4 & n.wrap && (en(n) ? d : hA(d)) !== n.check) {
          t11.msg = "incorrect data check", n.mode = be;
          break;
        }
        d = 0, l = 0;
      }
      n.mode = 16207;
    case 16207:
      if (n.wrap && en(n)) {
        for (; l < 32; ) {
          if (a === 0) break t;
          a--, d += i[o++] << l, l += 8;
        }
        if (4 & n.wrap && d !== (4294967295 & n.total)) {
          t11.msg = "incorrect length check", n.mode = be;
          break;
        }
        d = 0, l = 0;
      }
      n.mode = 16208;
    case 16208:
      k = w3;
      break t;
    case be:
      k = J0;
      break t;
    case 16210:
      return X0;
    default:
      return Ci;
  }
  return t11.next_out = s, t11.avail_out = c, t11.next_in = o, t11.avail_in = a, n.hold = d, n.bits = l, (n.wsize || h !== t11.avail_out && n.mode < be && (n.mode < k_ || e !== lA)) && tN(t11, t11.output, t11.next_out, h - t11.avail_out), u -= t11.avail_in, h -= t11.avail_out, t11.total_in += u, t11.total_out += h, n.total += h, 4 & n.wrap && h && (t11.adler = n.check = en(n) ? an(n.check, r, h, t11.next_out - h) : Gc(n.check, r, h, t11.next_out - h)), t11.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === Cr ? 128 : 0) + (n.mode === nl || n.mode === P_ ? 256 : 0), (u === 0 && h === 0 || e === lA) && k === Yo && (k = N3), k;
};
var Or = { inflateReset: Z0, inflateReset2: $0, inflateResetKeep: Q0, inflateInit: (t11) => pA(t11, 15), inflateInit2: pA, inflate: k3, inflateEnd: (t11) => {
  if (qo(t11)) return Ci;
  let e = t11.state;
  return e.window && (e.window = null), t11.state = null, Yo;
}, inflateGetHeader: (t11, e) => {
  if (qo(t11)) return Ci;
  let n = t11.state;
  return 2 & n.wrap ? (n.head = e, e.done = false, Yo) : Ci;
}, inflateSetDictionary: (t11, e) => {
  let n = e.length, i, r, o;
  return qo(t11) ? Ci : (i = t11.state, i.wrap !== 0 && i.mode !== Iu ? Ci : i.mode === Iu && (r = 1, r = Gc(r, e, n, 0), r !== i.check) ? J0 : (o = tN(t11, e, n, n), o ? (i.mode = 16210, X0) : (i.havedict = 1, Yo)));
}, inflateInfo: "pako inflate (from Nodeca project)" };
var L3 = function() {
  this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
};
var eN = Object.prototype.toString;
var { Z_NO_FLUSH: M3, Z_FINISH: U3, Z_OK: mc, Z_STREAM_END: U_, Z_NEED_DICT: x_, Z_STREAM_ERROR: x3, Z_DATA_ERROR: EA, Z_MEM_ERROR: V3 } = Ra;
function fc(t11) {
  this.options = eh.assign({ chunkSize: 65536, windowBits: 15, to: "" }, t11 || {});
  let e = this.options;
  e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, e.windowBits === 0 && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t11 && t11.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && !(15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new q0(), this.strm.avail_out = 0;
  let n = Or.inflateInit2(this.strm, e.windowBits);
  if (n !== mc) throw new Error(Zo[n]);
  if (this.header = new L3(), Or.inflateGetHeader(this.strm, this.header), e.dictionary && (typeof e.dictionary == "string" ? e.dictionary = Kc.string2buf(e.dictionary) : eN.call(e.dictionary) === "[object ArrayBuffer]" && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (n = Or.inflateSetDictionary(this.strm, e.dictionary), n !== mc))) throw new Error(Zo[n]);
}
function V_(t11, e) {
  let n = new fc(e);
  if (n.push(t11), n.err) throw n.msg || Zo[n.err];
  return n.result;
}
fc.prototype.push = function(t11, e) {
  let n = this.strm, i = this.options.chunkSize, r = this.options.dictionary, o, s, a;
  if (this.ended) return false;
  for (s = e === ~~e ? e : e === true ? U3 : M3, eN.call(t11) === "[object ArrayBuffer]" ? n.input = new Uint8Array(t11) : n.input = t11, n.next_in = 0, n.avail_in = n.input.length; ; ) {
    for (n.avail_out === 0 && (n.output = new Uint8Array(i), n.next_out = 0, n.avail_out = i), o = Or.inflate(n, s), o === x_ && r && (o = Or.inflateSetDictionary(n, r), o === mc ? o = Or.inflate(n, s) : o === EA && (o = x_)); n.avail_in > 0 && o === U_ && n.state.wrap > 0 && t11[n.next_in] !== 0; ) Or.inflateReset(n), o = Or.inflate(n, s);
    switch (o) {
      case x3:
      case EA:
      case x_:
      case V3:
        return this.onEnd(o), this.ended = true, false;
    }
    if (a = n.avail_out, n.next_out && (n.avail_out === 0 || o === U_)) if (this.options.to === "string") {
      let c = Kc.utf8border(n.output, n.next_out), d = n.next_out - c, l = Kc.buf2string(n.output, c);
      n.next_out = d, n.avail_out = i - d, d && n.output.set(n.output.subarray(c, c + d), 0), this.onData(l);
    } else this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
    if (o !== mc || a !== 0) {
      if (o === U_) return o = Or.inflateEnd(this.strm), this.onEnd(o), this.ended = true, true;
      if (n.avail_in === 0) break;
    }
  }
  return true;
}, fc.prototype.onData = function(t11) {
  this.chunks.push(t11);
}, fc.prototype.onEnd = function(t11) {
  t11 === mc && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = eh.flattenChunks(this.chunks)), this.chunks = [], this.err = t11, this.msg = this.strm.msg;
};
var F3 = { Inflate: fc, inflate: V_, inflateRaw: function(t11, e) {
  return (e = e || {}).raw = true, V_(t11, e);
}, ungzip: V_, constants: Ra };
var { Deflate: $H, deflate: B3, deflateRaw: t52, gzip: e5 } = R3;
var { Inflate: n5, inflate: j3, inflateRaw: i5, ungzip: r5 } = F3;
var G3 = B3;
var W3 = j3;
var nN = function(t11) {
  return t11[t11.ONE_BYTE = 0] = "ONE_BYTE", t11[t11.TWO_BYTE = 1] = "TWO_BYTE", t11;
}(nN || {});
var gm = class {
  constructor() {
    T(this, "_sequence", 0), T(this, "_startTime", Date.now()), T(this, "isUseOneByte", true);
  }
  get startTime() {
    let e = Date.now() - this._startTime;
    return e < Math.pow(2, 16) ? e : (this._startTime += Math.pow(2, 16), this.startTime);
  }
  get sequence() {
    return this._sequence < Math.pow(2, 32) ? this._sequence++ : (this._sequence -= Math.pow(2, 32), this.sequence);
  }
  serialize(e) {
    let n = { commonPacketHeader: { length: 0, reserved: 0, extension: 0, sequence: this.sequence }, commonStreamHeader: this.startTime, extension: void 0, payload: e };
    if (e.byteLength > 128) {
      let a = new Uint8Array(4);
      a.set([1, 0, 0, 0]);
      let c = { id: 0, length: 4, data: a.buffer }, d = { profile: this.isUseOneByte ? 0 : 1, length: this.isUseOneByte ? 5 : 6, datas: [c] };
      n.commonPacketHeader.extension = 1, n.extension = d, n.payload = this.compress(e), n.commonPacketHeader.length = 8 + (n.extension.length + 2) + n.payload.byteLength;
    } else n.commonPacketHeader.length = 8 + n.payload.byteLength;
    v("SHOW_DATASTREAM2_LOG") && _.debug("send data header: ".concat(JSON.stringify(n.commonPacketHeader)));
    let i = new ArrayBuffer(n.commonPacketHeader.length), r = new Uint8Array(i), o = new DataView(i), s = 0;
    if (o.setUint16(s, n.commonPacketHeader.extension << 15 | n.commonPacketHeader.reserved << 14 | n.commonPacketHeader.length, true), s += 2, o.setUint32(s, n.commonPacketHeader.sequence, true), s += 4, o.setUint16(s, n.commonStreamHeader, true), s += 2, n.extension) {
      let a = this.serializeExtension(n.extension);
      r.set(new Uint8Array(a), s), s += a.byteLength;
    }
    if (r.set(new Uint8Array(n.payload), s), s += n.payload.byteLength, s !== n.commonPacketHeader.length) throw Error("serialize error!");
    return i;
  }
  deserialize(e) {
    if (e.byteLength < 4) return new ArrayBuffer(0);
    let n = new DataView(e), i = 0, r = n.getUint16(i, true);
    i += 2;
    let o = { length: 16383 & r, reserved: (16384 & r) >> 14, extension: (32768 & r) >> 15, sequence: n.getUint16(i + 2, true) << 16 | n.getUint16(i, true) }, s, a;
    if (i += 4, v("SHOW_DATASTREAM2_LOG") && _.debug("receive data header: ".concat(JSON.stringify(o))), n.getUint16(i, true), i += 2, o.extension) {
      a = this.deserializeExtension(e.slice(i)), i += 2 + a.length, s = e.slice(i);
      let c = false;
      if (a.datas.length > 0) {
        let d = a.datas.find((l) => l.id === 0);
        d && (c = (1 & new DataView(d.data).getUint32(0, true)) == 1);
      }
      s = c ? this.decompress(s) : s;
    } else s = e.slice(8);
    return s;
  }
  serializeExtension(e) {
    let { profile: n, length: i, datas: r } = e, o = new ArrayBuffer(i + 2), s = new Uint8Array(o), a = new DataView(o), c = 0;
    if (a.setUint8(c++, n), a.setUint8(c++, i), r.forEach((d) => {
      n ? (a.setUint8(c++, d.id), a.setUint8(c++, d.length), s.set(new Uint8Array(d.data), c), c += d.data.byteLength) : (a.setUint8(c++, d.id | d.length << 4), s.set(new Uint8Array(d.data), c), c += d.data.byteLength);
    }), c !== i + 2) throw Error("serialize extension error, is ".concat(c, "!==").concat(i + 2));
    return o;
  }
  deserializeExtension(e) {
    let n = new DataView(e), i = 0, r = n.getUint8(i);
    i++;
    let o = n.getUint8(i);
    i++;
    let s = r === nN.TWO_BYTE, a = [], c = new DataView(e, 2), d = 0;
    for (; d < o; ) {
      let l = 0, u = 0, h = new ArrayBuffer(0);
      s ? (l = c.getUint8(d), d++, u = c.getUint8(d), d++) : (l = 15 & c.getUint8(d), u = c.getUint8(d) >> 4, d++), u > 0 && (h = c.buffer.slice(d + 2, d + 2 + u), d += h.byteLength), a.push({ id: l, length: u, data: h });
    }
    if (d !== o) throw Error("parse error");
    return { profile: r, length: o, datas: a };
  }
  decompress(e) {
    return W3(new Uint8Array(e));
  }
  compress(e) {
    return G3(new Uint8Array(e));
  }
};
var H3 = { name: "DataStream", create: (t11, e) => {
  let n = e ? new QE(t11) : new ZE(t11);
  return n.useDataStream(new gm()), n;
} };
var Tm = class extends Xt {
  constructor(e, n, i) {
    super(), T(this, "ws", void 0), T(this, "requestId", 1), T(this, "heartBeatTimer", void 0), T(this, "joinInfo", void 0), T(this, "clientId", void 0), T(this, "onOpen", () => {
      this.emit("open"), this.startHeartBeatCheck();
    }), T(this, "onClose", (r) => {
      this.emit("close"), this.dispose();
    }), T(this, "onMessage", (r) => {
      let o = JSON.parse(r.data);
      if (!o || o.command !== "serverResponse" || !o.requestId) return o && o.command === "serverStatus" && o.serverStatus && o.serverStatus.command ? (this.emit("status", o.serverStatus), void this.emit(o.serverStatus.command, o.serverStatus)) : void 0;
      this.emit("req_".concat(o.requestId), o);
    }), this.joinInfo = e, this.clientId = n, this.ws = new Qo("cross-channel-".concat(this.clientId), i), this.ws.on(it.RECONNECTING, () => {
      this.ws.reconnectMode = "retry", this.emit("reconnecting");
    }), this.ws.on(it.CONNECTED, this.onOpen), this.ws.on(it.ON_MESSAGE, this.onMessage), this.ws.on(it.CLOSED, this.onClose);
  }
  isConnect() {
    return this.ws.state === "connected";
  }
  sendMessage(e) {
    let n = this.requestId++;
    return e.requestId = n, e.seq = n, this.ws.sendMessage(e), n;
  }
  waitStatus(e) {
    return new j((n, i) => {
      let r = window.setTimeout(() => {
        i(new O(R.TIMEOUT, "wait status timeout, status: ".concat(e)));
      }, 5e3);
      this.once(e, (o) => {
        window.clearTimeout(r), o.state && o.state !== 0 ? i(new O(R.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e))) : n(void 0);
      }), this.once("dispose", () => {
        window.clearTimeout(r), i(new O(R.WS_ABORT));
      });
    });
  }
  async request(e) {
    if (this.ws.state === "closed") throw new O(R.WS_DISCONNECT);
    let n = () => new j((s, a) => {
      this.ws.once(it.CLOSED, () => a(new O(R.WS_ABORT))), this.ws.once(it.CONNECTED, s);
    });
    this.ws.state !== "connected" && await n();
    let i = this.sendMessage(e), r = new j((s, a) => {
      let c = () => {
        a(new O(R.WS_ABORT));
      };
      this.ws.once(it.RECONNECTING, c), this.ws.once(it.CLOSED, c), this.once("req_".concat(i), s), Me(3e3).then(() => {
        this.removeAllListeners("req_".concat(i)), this.ws.off(it.RECONNECTING, c), this.ws.off(it.CLOSED, c), a(new O(R.TIMEOUT, "cross channel ws request timeout"));
      });
    }), o = await r;
    if (!o || o.code !== 200) throw new O(R.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(o)));
    return o;
  }
  async connect(e) {
    this.ws.removeAllListeners(it.REQUEST_NEW_URLS), this.ws.on(it.REQUEST_NEW_URLS, (n) => {
      n(e);
    }), await this.ws.init(e);
  }
  dispose() {
    this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close();
  }
  sendPing(e) {
    let n = this.requestId++;
    return e.requestId = n, this.ws.sendMessage(e), n;
  }
  startHeartBeatCheck() {
    this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval(() => {
      this.sendPing({ command: "ping", appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sid: this.joinInfo.sid, ts: +/* @__PURE__ */ new Date(), requestId: 0 });
    }, 3e3);
  }
  clearHeartBeatCheck() {
    window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;
  }
};
var Sm = class extends Xt {
  set state(e) {
    e !== this._state && (e !== Sn.RELAY_STATE_FAILURE && (this.errorCode = ys.RELAY_OK), this.emit("state", e, this.errorCode), this._state = e);
  }
  get state() {
    return this._state;
  }
  constructor(e, n, i, r, o) {
    super(), T(this, "joinInfo", void 0), T(this, "sid", void 0), T(this, "clientId", void 0), T(this, "cancelToken", mn.CancelToken.source()), T(this, "workerToken", void 0), T(this, "requestId", 0), T(this, "signal", void 0), T(this, "prevChannelMediaConfig", void 0), T(this, "httpRetryConfig", void 0), T(this, "_resolution", void 0), T(this, "_state", Sn.RELAY_STATE_IDLE), T(this, "errorCode", ys.RELAY_OK), T(this, "onStatus", (s) => {
      _.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(s))), s && s.command && (s.command === "onAudioPacketReceived" && this.emit("event", Ir.PACKET_RECEIVED_AUDIO_FROM_SRC), s.command === "onVideoPacketReceived" && this.emit("event", Ir.PACKET_RECEIVED_VIDEO_FROM_SRC), s.command === "onSrcTokenPrivilegeDidExpire" && (this.errorCode = ys.SRC_TOKEN_EXPIRED, this.state = Sn.RELAY_STATE_FAILURE), s.command === "onDestTokenPrivilegeDidExpire" && (this.errorCode = ys.DEST_TOKEN_EXPIRED, this.state = Sn.RELAY_STATE_FAILURE));
    }), T(this, "onReconnect", async () => {
      _.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", Ir.NETWORK_DISCONNECTED), this.state = Sn.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch((s) => {
        this.state !== Sn.RELAY_STATE_IDLE && (_.error("auto restart channel media relay failed", s.toString()), this.errorCode = ys.SERVER_CONNECTION_LOST, this.state = Sn.RELAY_STATE_FAILURE);
      });
    }), this.joinInfo = e, this.clientId = n, this.sid = Ms(), this.signal = new Tm(this.joinInfo, this.clientId, i), this.httpRetryConfig = r, this._resolution = o;
  }
  async startChannelMediaRelay(e) {
    if (this.state !== Sn.RELAY_STATE_IDLE) throw new O(R.INVALID_OPERATION);
    this.state = Sn.RELAY_STATE_CONNECTING, await this.connect(), _.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success"));
    try {
      await this.sendStartRelayMessage(e);
    } catch (n) {
      throw n.data && n.data.serverResponse && n.data.serverResponse.command === "SetSourceChannel" ? new O(R.CROSS_CHANNEL_FAILED_JOIN_SRC) : n.data && n.data.serverResponse && n.serverResponse.command === "SetDestChannelStatus" ? new O(R.CROSS_CHANNEL_FAILED_JOIN_DEST) : n.data && n.data.serverResponse && n.serverResponse.command === "StartPacketTransfer" ? new O(R.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST) : n;
    }
    this.prevChannelMediaConfig = e;
  }
  async updateChannelMediaRelay(e) {
    if (this.state !== Sn.RELAY_STATE_RUNNING) throw new O(R.INVALID_OPERATION);
    await this.sendUpdateMessage(e), this.prevChannelMediaConfig = e;
  }
  async setVideoProfile(e) {
    if (this._resolution = e, this.state !== Sn.RELAY_STATE_RUNNING) throw new O(R.INVALID_OPERATION);
    let n = this.genMessage(sn.SetVideoProfile);
    await this.signal.request(n), _.debug("[".concat(this.clientId, "] startChannelMediaRelay: setVideoProfile success"));
  }
  async stopChannelMediaRelay() {
    await this.sendStopRelayMessage(), _.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = Sn.RELAY_STATE_IDLE, this.dispose();
  }
  dispose() {
    _.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = mn.CancelToken.source(), this.state = Sn.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;
  }
  async connect() {
    let e = await zG(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);
    this.workerToken = e.workerToken, await this.signal.connect(e.addressList), this.emit("event", Ir.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect);
  }
  async sendStartRelayMessage(e) {
    let n = this.genMessage(sn.StopPacketTransfer);
    await this.signal.request(n), await this.signal.waitStatus("Normal Quit"), _.debug("[".concat(this.clientId, "] startChannelMediaRelay: StopPacketTransfer success"));
    let i = this.genMessage(sn.SetSdkProfile, e);
    await this.signal.request(i), _.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success"));
    let r = this.genMessage(sn.SetSourceChannel, e);
    await this.signal.request(r), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", Ir.PACKET_JOINED_SRC_CHANNEL), _.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success"));
    let o = this.genMessage(sn.SetSourceUserId, e);
    await this.signal.request(o), _.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success"));
    let s = this.genMessage(sn.SetDestChannel, e);
    await this.signal.request(s), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", Ir.PACKET_JOINED_DEST_CHANNEL), _.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success"));
    let a = this.genMessage(sn.StartPacketTransfer, e);
    await this.signal.request(a), this.emit("event", Ir.PACKET_SENT_TO_DEST_CHANNEL), this.state = Sn.RELAY_STATE_RUNNING, _.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success")), this.setVideoProfile(this._resolution);
  }
  async sendUpdateMessage(e) {
    let n = this.genMessage(sn.UpdateDestChannel, e);
    await this.signal.request(n), this.emit("event", Ir.PACKET_UPDATE_DEST_CHANNEL), _.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success"));
  }
  async sendStopRelayMessage() {
    let e = this.genMessage(sn.StopPacketTransfer);
    await this.signal.request(e), _.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success"));
  }
  genMessage(e, n) {
    let i = [], r = [], o = [];
    this.requestId += 1;
    let s = { appId: this.joinInfo.appId, cname: this.joinInfo.cname, uid: this.joinInfo.uid.toString(), sdkVersion: ii, sid: this.sid, ts: Date.now(), requestId: this.requestId, seq: this.requestId, allocate: true, clientRequest: {} };
    s.sdkVersion === "4.22.0" && (s.sdkVersion = "0.0.1");
    let a = null, c = null;
    switch (e) {
      case sn.SetSdkProfile:
        return s.clientRequest = { command: "SetSdkProfile", type: "multi_channel" }, s;
      case sn.SetSourceChannel:
        if (c = n && n.getSrcChannelMediaInfo(), !c) throw new O(R.UNEXPECTED_ERROR, "can not find source config");
        return s.clientRequest = { command: "SetSourceChannel", uid: "0", channelName: c.channelName, token: c.token || this.joinInfo.appId }, s;
      case sn.SetSourceUserId:
        if (c = n && n.getSrcChannelMediaInfo(), !c) throw new O(R.UNEXPECTED_ERROR, "can not find source config");
        return s.clientRequest = { command: "SetSourceUserId", uid: c.uid + "" }, s;
      case sn.SetDestChannel:
        if (a = n && n.getDestChannelMediaInfo(), !a) throw new O(R.UNEXPECTED_ERROR, "can not find dest config");
        return a.forEach((d) => {
          i.push(d.channelName), r.push(d.uid + ""), o.push(d.token || this.joinInfo.appId);
        }), s.clientRequest = { command: "SetDestChannel", channelName: i, uid: r, token: o }, s;
      case sn.StartPacketTransfer:
        return s.clientRequest = { command: "StartPacketTransfer" }, s;
      case sn.Reconnect:
        return s.clientRequest = { command: "Reconnect" }, s;
      case sn.StopPacketTransfer:
        return s.clientRequest = { command: "StopPacketTransfer" }, s;
      case sn.UpdateDestChannel:
        if (a = n && n.getDestChannelMediaInfo(), !a) throw new O(R.UNEXPECTED_ERROR, "can not find dest config");
        return a.forEach((d) => {
          i.push(d.channelName), r.push(d.uid + ""), o.push(d.token || this.joinInfo.appId);
        }), s.clientRequest = { command: "UpdateDestChannel", channelName: i, uid: r, token: o }, s;
      case sn.SetVideoProfile:
        s.clientRequest = { command: "SetVideoProfile", width: this._resolution.width, height: this._resolution.height };
    }
    return s;
  }
};
var K3 = { name: "ChannelMediaRelay", create: function(t11) {
  return new Sm(t11.joinInfo, t11.clientId, t11.websocketRetryConfig || Ee, t11.httpRetryConfig || Ee, t11.resolution);
} };
function mA(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Ga(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? mA(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : mA(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var Rm = class extends Xt {
  constructor(e, n, i, r) {
    super(), T(this, "spec", void 0), T(this, "token", void 0), T(this, "websocket", void 0), T(this, "pingpongTimer", void 0), T(this, "reconnectMode", "retry"), T(this, "serviceMode", void 0), T(this, "reqId", 0), T(this, "commandReqId", 0), T(this, "handleWebSocketOpen", () => {
      this.reconnectMode = "retry", this.startPingPong();
    }), T(this, "handleWebSocketMessage", (o) => {
      if (!o.data) return;
      let s = JSON.parse(o.data);
      s.requestId ? this.emit("@".concat(s.requestId, "-").concat(s.sid), s) : (X.workerEvent(this.spec.sid, { actionType: "status", serverCode: s.code, workerType: this.serviceMode === er.TRANSCODE ? 1 : 2 }), this.emit(Xr.PUBLISH_STREAM_STATUS, s));
    }), this.spec = n, this.token = e, this.serviceMode = r, this.websocket = new Qo("live-streaming", i), this.websocket.on(it.CONNECTED, this.handleWebSocketOpen), this.websocket.on(it.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(it.REQUEST_NEW_URLS, (o, s) => {
      Ge(this, Xr.REQUEST_NEW_ADDRESS).then(o).catch(s);
    }), this.websocket.on(it.RECONNECTING, () => {
      this.websocket.reconnectMode = this.reconnectMode;
    });
  }
  init(e) {
    return this.websocket.init(e);
  }
  async request(e, n, i, r) {
    this.reqId += 1, e === "request" && (this.commandReqId += 1);
    let o = this.commandReqId, s = this.reqId;
    if (!s || !this.websocket) throw new O(R.UNEXPECTED_ERROR);
    let a = Ga({ command: e, sdkVersion: ii === "4.22.0" ? "0.0.1" : ii, seq: s, requestId: s, allocate: i, cname: this.spec.cname, appId: this.spec.appId, sid: this.spec.sid, uid: this.spec.uid.toString(), ts: Math.floor(Date.now() / 1e3) }, n);
    if (this.websocket.state === "closed") throw new O(R.WS_DISCONNECT);
    let c = () => new j((h, p) => {
      this.websocket.once(it.CLOSED, () => p(new O(R.WS_ABORT))), this.websocket.once(it.CONNECTED, h);
    });
    this.websocket.state !== "connected" && await c(), a.clientRequest && (a.clientRequest.workerToken = this.token);
    let d = new j((h, p) => {
      let g = () => {
        p(new O(R.WS_ABORT));
      };
      this.websocket.once(it.RECONNECTING, g), this.websocket.once(it.CLOSED, g), this.once("@".concat(s, "-").concat(this.spec.sid), (E) => {
        h(E);
      });
    });
    r && X.workerEvent(this.spec.sid, Ga(Ga({}, r), {}, { requestId: o, actionType: "request", payload: JSON.stringify(n.clientRequest), serverCode: 0, code: 0 }));
    let l = Date.now();
    this.websocket.sendMessage(a);
    let u = null;
    try {
      u = await d;
    } catch (h) {
      if (this.websocket.state === "closed") throw h;
      return await c(), await this.request(e, n, i);
    }
    return r && X.workerEvent(this.spec.sid, Ga(Ga({}, r), {}, { requestId: o, actionType: "response", payload: JSON.stringify(u.serverResponse), serverCode: u.code, success: u.code === 200, responseTime: Date.now() - l })), u.code !== 200 && this.handleResponseError(u), u;
  }
  tryNextAddress() {
    this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext");
  }
  close() {
    let e = ii === "4.22.0" ? "0.0.1" : ii;
    this.reqId += 1, this.websocket.state === "connected" ? (this.websocket.sendMessage({ command: "request", appId: this.spec.appId, cname: this.spec.cname, uid: this.spec.uid.toString(), sdkVersion: e, sid: this.spec.sid, seq: this.reqId, ts: Math.floor(Date.now() / 1e3), requestId: this.reqId, clientRequest: { command: "DestroyWorker" } }), this.websocket.close(false, true)) : this.websocket.close(false), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);
  }
  handleResponseError(e) {
    switch (e.code) {
      case fe.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
        return void _.warning("live stream response already exists stream");
      case fe.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
      case fe.LIVE_STREAM_RESPONSE_BAD_STREAM:
      case fe.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
        return new O(R.LIVE_STREAMING_INVALID_ARGUMENT, "", { code: e.code }).throw();
      case fe.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
        if (e.serverResponse.command === "UnpublishStream") return;
        throw new O(R.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
      case fe.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
        return new O(R.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", { code: e.code }).throw();
      case fe.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
        let n = new O(R.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
        return this.emit(Xr.WARNING, n, e.serverResponse.url);
      }
      case fe.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: {
        let n = new O(R.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
        return this.emit(Xr.WARNING, n, e.serverResponse.url);
      }
      case fe.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
        throw new O(R.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", { retry: true });
      case fe.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
        return new O(R.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", { code: e.code }).throw();
      case fe.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: {
        let n = new O(R.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
        return this.emit(Xr.WARNING, n, e.serverResponse.url);
      }
      case fe.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
        return new O(R.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e.code }).throw();
      case fe.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
        throw new O(R.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", { retry: true, changeAddress: true });
      case fe.LIVE_STREAM_RESPONSE_WORKER_LOST:
      case fe.LIVE_STREAM_RESPONSE_WORKER_QUIT:
        if (e.serverResponse.command === "UnpublishStream") return;
        throw new O(R.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
      case fe.ERROR_FAIL_SEND_MESSAGE:
        if (e.serverResponse.command === "UnpublishStream") return;
        if (e.serverResponse.command === "UpdateTranscoding" || e.serverResponse.command === "ControlStream") return new O(R.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { code: e.code }).throw();
        throw new O(R.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", { retry: true, changeAddress: true });
      case fe.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
      case fe.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
      case fe.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
      case fe.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
        return new O(R.LIVE_STREAMING_CDN_ERROR, "", { code: e.code }).throw();
    }
  }
  startPingPong() {
    this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {
      this.websocket.state === "connected" && this.request("ping", {}).catch(zu);
    }, 6e3);
  }
};
function fA(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Tn(t11) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? fA(Object(n), true).forEach(function(i) {
      T(t11, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t11, Object.getOwnPropertyDescriptors(n)) : fA(Object(n)).forEach(function(i) {
      Object.defineProperty(t11, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t11;
}
var Cm = class extends Xt {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ee, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ee;
    super(), T(this, "onLiveStreamWarning", void 0), T(this, "onLiveStreamError", void 0), T(this, "spec", void 0), T(this, "retryTimeout", 1e4), T(this, "connection", void 0), T(this, "httpRetryConfig", void 0), T(this, "wsRetryConfig", void 0), T(this, "streamingTasks", /* @__PURE__ */ new Map()), T(this, "isStartingStreamingTask", false), T(this, "taskMutex", new ze("live-streaming")), T(this, "cancelToken", mn.CancelToken.source()), T(this, "transcodingConfig", void 0), T(this, "uapResponse", void 0), T(this, "lastTaskId", 1), T(this, "statusError", /* @__PURE__ */ new Map()), this.spec = e, this.httpRetryConfig = i, this.wsRetryConfig = n;
  }
  async setTranscodingConfig(e) {
    let n = Tn(Tn({}, aj), e);
    n.videoCodecProfile !== 66 && n.videoCodecProfile !== 77 && n.videoCodecProfile !== 100 && (_.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(n.videoCodecProfile, " -> 100")), n.videoCodecProfile = 100), n.transcodingUsers || (n.transcodingUsers = n.userConfigs), n.transcodingUsers && (n.transcodingUsers = n.transcodingUsers.map((s) => Tn(Tn(Tn({}, sj), s), {}, { zOrder: s.zOrder ? s.zOrder + 1 : 1 }))), function(s) {
      zt(s.width) || Nt(s.width, "config.width", 0, 1e4), zt(s.height) || Nt(s.height, "config.height", 0, 1e4), zt(s.videoBitrate) || Nt(s.videoBitrate, "config.videoBitrate", 1, 1e6), zt(s.videoFrameRate) || Nt(s.videoFrameRate, "config.videoFrameRate"), zt(s.lowLatency) || Nr(s.lowLatency, "config.lowLatency"), zt(s.audioSampleRate) || Ce(s.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), zt(s.audioBitrate) || Nt(s.audioBitrate, "config.audioBitrate", 1, 128), zt(s.audioChannels) || Ce(s.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), zt(s.videoGop) || Nt(s.videoGop, "config.videoGop"), zt(s.videoCodecProfile) || Ce(s.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), zt(s.userCount) || Nt(s.userCount, "config.userCount", 0, 17), zt(s.backgroundColor) || Nt(s.backgroundColor, "config.backgroundColor", 0, 16777215), zt(s.userConfigExtraInfo) || Pe(s.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, false), s.transcodingUsers && !zt(s.transcodingUsers) && (br(s.transcodingUsers, "config.transcodingUsers"), s.transcodingUsers.forEach((a, c) => {
        Qu(a.uid), zt(a.x) || Nt(a.x, "transcodingUser[".concat(c, "].x"), 0, 1e4), zt(a.y) || Nt(a.y, "transcodingUser[".concat(c, "].y"), 0, 1e4), zt(a.width) || Nt(a.width, "transcodingUser[".concat(c, "].width"), 0, 1e4), zt(a.height) || Nt(a.height, "transcodingUser[".concat(c, "].height"), 0, 1e4), zt(a.zOrder) || Nt(a.zOrder - 1, "transcodingUser[".concat(c, "].zOrder"), 0, 100), zt(a.alpha) || Nt(a.alpha, "transcodingUser[".concat(c, "].alpha"), 0, 1, false);
      })), zt(s.watermark) || xp(s.watermark, "watermark"), zt(s.backgroundImage) || xp(s.backgroundImage, "backgroundImage"), s.images && !zt(s.images) && (br(s.images, "config.images"), s.images.forEach((a, c) => {
        xp(a, "images[".concat(c, "]"));
      }));
    }(n);
    let i = [];
    n.images && i.push(...n.images.map((s) => Tn(Tn(Tn({}, Up), s), {}, { zOrder: 255 }))), n.backgroundImage && (i.push(Tn(Tn(Tn({}, Up), n.backgroundImage), {}, { zOrder: 0 })), delete n.backgroundImage), n.watermark && (i.push(Tn(Tn(Tn({}, Up), n.watermark), {}, { zOrder: 255 })), delete n.watermark), n.images = i, n.transcodingUsers && (n.userConfigs = n.transcodingUsers.map((s) => Tn({}, s)), n.userCount = n.transcodingUsers.length, delete n.transcodingUsers);
    let r = (n.userConfigs || []).map((s) => typeof s.uid == "number" ? j.resolve(s.uid) : h0(s.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));
    if ((await j.all(r)).forEach((s, a) => {
      n.userConfigs && n.userConfigs[a] && (n.userConfigs[a].uid = s);
    }), this.transcodingConfig = n, this.connection) try {
      var o;
      let s = await this.connection.request("request", { clientRequest: { command: "UpdateTranscoding", transcodingConfig: this.transcodingConfig } }, false, { command: "UpdateTranscoding", workerType: 1, requestByUser: true, tid: Array.from(Pr(o = this.streamingTasks).call(o)).map((a) => a.taskId).join("#") });
      _.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(s.code, ", config:"), JSON.stringify(this.transcodingConfig));
    } catch (s) {
      if (!s.data || !s.data.retry) throw s;
      s.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach((a) => {
        _.warning("[".concat(this.spec.clientId, "] live streaming receive error"), s.toString(), "try to republish", a.url), this.startLiveStreamingTask(a.url, a.mode, s).then(() => {
          _.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(a.url, " success"));
        }).catch((c) => {
          _.error("[".concat(this.spec.clientId, "] live streaming republish failed"), a.url, c.toString()), this.onLiveStreamError && this.onLiveStreamError(a.url, c);
        });
      });
    }
  }
  async startLiveStreamingTask(e, n, i) {
    if (!this.transcodingConfig && n === er.TRANSCODE) throw new O(R.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
    let r = { command: "PublishStream", ts: Date.now(), url: e, uid: this.spec.uid.toString(), autoDestroyTime: 100, acceptImageTimeout: true };
    _.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e, ", mode: ").concat(n));
    let o = await this.taskMutex.lock();
    if (!this.connection && i) return void o();
    if (this.streamingTasks.get(e) && !i) return o(), new O(R.LIVE_STREAMING_TASK_CONFLICT).throw();
    try {
      this.connection || (this.connection = await this.connect(n));
    } catch (a) {
      throw o(), a;
    }
    switch (n) {
      case er.TRANSCODE:
        r.transcodingConfig = Tn({}, this.transcodingConfig);
    }
    this.uapResponse && this.uapResponse.vid && (r.vid = this.uapResponse.vid), this.isStartingStreamingTask = true;
    let s = this.lastTaskId++;
    try {
      let a = new j((d, l) => {
        Me(this.retryTimeout).then(() => {
          if (i) return l(i);
          let u = this.statusError.get(e);
          return u ? (this.statusError.delete(e), l(u)) : void 0;
        });
      }), c = await j.race([this.connection.request("request", { clientRequest: r }, true, { url: e, command: "PublishStream", workerType: n === er.TRANSCODE ? 1 : 2, requestByUser: !i, tid: s.toString() }), a]);
      this.isStartingStreamingTask = false, _.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(c.code)), this.streamingTasks.set(e, { clientRequest: r, mode: n, url: e, taskId: s }), o();
    } catch (a) {
      if (o(), this.isStartingStreamingTask = false, !a.data || !a.data.retry || i) throw a;
      return a.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e, n, a)) : await this.startLiveStreamingTask(e, n, a);
    }
  }
  stopLiveStreamingTask(e) {
    return new j((n, i) => {
      let r = this.streamingTasks.get(e);
      if (!r || !this.connection) return new O(R.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
      let o = r.mode;
      r.abortTask = () => {
        _.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e), n();
      }, this.connection.request("request", { clientRequest: { command: "UnpublishStream", url: r.url } }, false, { url: e, command: "UnPublishStream", workerType: o === er.TRANSCODE ? 1 : 2, requestByUser: true, tid: (this.lastTaskId++).toString() }).then((s) => {
        _.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(s.code)), this.streamingTasks.delete(e), this.streamingTasks.size === 0 && (this.connection && this.connection.close(), this.connection = void 0), n();
      }).catch(i);
    });
  }
  resetAllTask() {
    var e;
    let n = Array.from(Pr(e = this.streamingTasks).call(e));
    this.terminate();
    for (let i of n) this.startLiveStreamingTask(i.url, i.mode).catch((r) => {
      this.onLiveStreamError && this.onLiveStreamError(i.url, r);
    });
  }
  terminate() {
    this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = /* @__PURE__ */ new Map(), this.isStartingStreamingTask = false, this.statusError = /* @__PURE__ */ new Map(), this.cancelToken = mn.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;
  }
  async connect(e) {
    if (this.connection) throw new O(R.UNEXPECTED_ERROR, "live streaming connection has already connected");
    let n = await Ge(this, VE.REQUEST_WORKER_MANAGER_LIST, e);
    return this.uapResponse = n, this.connection = new Rm(n.workerToken, this.spec, this.wsRetryConfig, e), this.connection.on(Xr.WARNING, (i, r) => this.onLiveStreamWarning && this.onLiveStreamWarning(r, i)), this.connection.on(Xr.PUBLISH_STREAM_STATUS, (i) => this.handlePublishStreamServer(i)), this.connection.on(Xr.REQUEST_NEW_ADDRESS, (i, r) => {
      if (!this.connection) return r(new O(R.UNEXPECTED_ERROR, "can not get new live streaming address list"));
      Ge(this, VE.REQUEST_WORKER_MANAGER_LIST, e).then((o) => {
        this.uapResponse = o, i(o.addressList);
      }).catch(r);
    }), await this.connection.init(n.addressList), this.connection;
  }
  handlePublishStreamServer(e) {
    let n = e.serverStatus && e.serverStatus.url || "empty_url", i = this.streamingTasks.get(n), r = e.reason;
    switch (e.code) {
      case fe.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
      case fe.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
      case fe.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
      case fe.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: {
        let s = new O(R.LIVE_STREAMING_CDN_ERROR, "", { code: e.code });
        if (i) return _.error(s.toString()), this.onLiveStreamError && this.onLiveStreamError(n, s);
        if (!this.isStartingStreamingTask) return;
        this.statusError.set(n, s);
      }
      case fe.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
        let s = new O(R.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, r);
        return this.onLiveStreamWarning && this.onLiveStreamWarning(n, s);
      }
      case fe.LIVE_STREAM_RESPONSE_WORKER_LOST:
      case fe.LIVE_STREAM_RESPONSE_WORKER_QUIT: {
        var o;
        if (!this.connection) return;
        this.connection.tryNextAddress();
        let s = Array.from(Pr(o = this.streamingTasks).call(o));
        for (let a of s) a.abortTask ? a.abortTask() : (_.warning("[".concat(this.spec.clientId, "] publish stream status code"), e.code, "try to republish", a.url), this.startLiveStreamingTask(a.url, a.mode, new O(R.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", { code: e.code })).then(() => {
          _.debug("[".concat(this.spec.clientId, "] republish live stream success"), a.url);
        }).catch((c) => {
          _.error(c.toString()), this.onLiveStreamError && this.onLiveStreamError(a.url, c);
        }));
        return;
      }
    }
  }
  hasUrl(e) {
    return this.streamingTasks.has(e);
  }
};
var Y3 = { name: "LiveStreaming", create: function(t11) {
  return new Cm(t11.joinInfo, t11.websocketRetryConfig || Ee, t11.httpRetryConfig || Ee);
} };
function q3(t11) {
  let e = gA();
  return function(n, i) {
    let r = n.appId;
    r !== void 0 && (yt(i, 10), tr(i, r));
    let o = n.cid;
    o !== void 0 && (yt(i, 16), yt(i, o));
    let s = n.cname;
    s !== void 0 && (yt(i, 26), tr(i, s));
    let a = n.deviceId;
    a !== void 0 && (yt(i, 34), tr(i, a));
    let c = n.elapse;
    c !== void 0 && (yt(i, 40), Yr(i, c));
    let d = n.fileSize;
    d !== void 0 && (yt(i, 48), Yr(i, Cs(d)));
    let l = n.height;
    l !== void 0 && (yt(i, 56), Yr(i, Cs(l)));
    let u = n.jpg;
    u !== void 0 && (yt(i, 66), yt(i, u.length), function(si, L) {
      let F = Ca(si, L.length);
      si.bytes.set(L, F);
    }(i, u));
    let h = n.networkType;
    h !== void 0 && (yt(i, 72), Yr(i, Cs(h)));
    let p = n.osType;
    p !== void 0 && (yt(i, 80), Yr(i, Cs(p)));
    let g = n.requestId;
    g !== void 0 && (yt(i, 90), tr(i, g));
    let E = n.sdkVersion;
    E !== void 0 && (yt(i, 98), tr(i, E));
    let f = n.sequence;
    f !== void 0 && (yt(i, 104), Yr(i, Cs(f)));
    let S = n.sid;
    S !== void 0 && (yt(i, 114), tr(i, S));
    let C = n.timestamp;
    C !== void 0 && (yt(i, 120), Yr(i, C));
    let A = n.uid;
    A !== void 0 && (yt(i, 128), yt(i, A));
    let b = n.vid;
    b !== void 0 && (yt(i, 136), yt(i, b));
    let w = n.width;
    w !== void 0 && (yt(i, 144), Yr(i, Cs(w)));
    let D = n.service;
    D !== void 0 && (yt(i, 152), yt(i, D));
    let k = n.callbackData;
    k !== void 0 && (yt(i, 162), tr(i, k));
    let B = n.jpgEncryption;
    B !== void 0 && (yt(i, 168), yt(i, B));
    let V = n.requestType;
    V !== void 0 && (yt(i, 176), yt(i, V));
    let z = n.scorePorn;
    z !== void 0 && (yt(i, 185), j_(i, z));
    let lt = n.scoreSexy;
    lt !== void 0 && (yt(i, 193), j_(i, lt));
    let vt = n.scoreNeutral;
    vt !== void 0 && (yt(i, 201), j_(i, vt));
    let Dt = n.scene;
    Dt !== void 0 && (yt(i, 208), yt(i, Dt));
    let ce = n.ossFilePrefix;
    ce !== void 0 && (yt(i, 218), tr(i, ce));
    let Wt = n.serviceVendor;
    if (Wt !== void 0) for (let si of Wt) {
      yt(i, 226);
      let L = gA();
      X3(si, L), yt(i, L.limit), tH(i, L), $3(L);
    }
  }(t11, e), function(n) {
    let i = n.bytes, r = n.limit;
    return i.length === r ? i : i.subarray(0, r);
  }(e);
}
function z3(t11) {
  return function(n) {
    let i = {};
    t: for (; !oN(n); ) {
      let r = or(n);
      switch (r >>> 3) {
        case 0:
          break t;
        case 1:
          i.code = or(n);
          break;
        case 2:
          i.msg = sN(n, or(n));
          break;
        case 3: {
          let o = Q3(n);
          i.data = J3(n), n.limit = o;
          break;
        }
        default:
          iN(n, 7 & r);
      }
    }
    return i;
  }({ bytes: e = t11, offset: 0, limit: e.length });
  var e;
}
function J3(t11) {
  let e = {};
  t: for (; !oN(t11); ) {
    let n = or(t11);
    switch (n >>> 3) {
      case 0:
        break t;
      case 1:
        e.requestId = sN(t11, or(t11));
        break;
      case 2:
        e.requestType = or(t11) >>> 0;
        break;
      case 3:
        e.scorePorn = B_(t11);
        break;
      case 4:
        e.scoreSexy = B_(t11);
        break;
      case 5:
        e.scoreNeutral = B_(t11);
        break;
      case 6:
        e.requestScene = or(t11) >>> 0;
        break;
      case 7:
        e.scene = or(t11) >>> 0;
        break;
      default:
        iN(t11, 7 & n);
    }
  }
  return e;
}
function X3(t11, e) {
  let n = t11.service;
  n !== void 0 && (yt(e, 8), yt(e, n));
  let i = t11.vendor;
  i !== void 0 && (yt(e, 16), yt(e, i));
  let r = t11.token;
  r !== void 0 && (yt(e, 26), tr(e, r));
  let o = t11.callbackUrl;
  o !== void 0 && (yt(e, 34), tr(e, o));
}
function Q3(t11) {
  let e = or(t11), n = t11.limit;
  return t11.limit = t11.offset + e, n;
}
function iN(t11, e) {
  switch (e) {
    case 0:
      for (; 128 & aN(t11); ) ;
      break;
    case 2:
      F_(t11, or(t11));
      break;
    case 5:
      F_(t11, 4);
      break;
    case 1:
      F_(t11, 8);
      break;
    default:
      throw new Error("Unimplemented type: " + e);
  }
}
var Z3 = new Float32Array(1);
new Uint8Array(Z3.buffer);
var Lf = new Float64Array(1);
var Rn = new Uint8Array(Lf.buffer);
function Cs(t11) {
  return { low: t11 |= 0, high: t11 >> 31, unsigned: t11 >= 0 };
}
var rN = [];
function gA() {
  let t11 = rN.pop();
  return t11 ? (t11.offset = t11.limit = 0, t11) : { bytes: new Uint8Array(64), offset: 0, limit: 0 };
}
function $3(t11) {
  rN.push(t11);
}
function F_(t11, e) {
  if (t11.offset + e > t11.limit) throw new Error("Skip past limit");
  t11.offset += e;
}
function oN(t11) {
  return t11.offset >= t11.limit;
}
function Ca(t11, e) {
  let n = t11.bytes, i = t11.offset, r = t11.limit, o = i + e;
  if (o > n.length) {
    let s = new Uint8Array(2 * o);
    s.set(n), t11.bytes = s;
  }
  return t11.offset = o, o > r && (t11.limit = o), i;
}
function Mf(t11, e) {
  let n = t11.offset;
  if (n + e > t11.limit) throw new Error("Read past limit");
  return t11.offset += e, n;
}
function sN(t11, e) {
  let n = Mf(t11, e), i = String.fromCharCode, r = t11.bytes, o = "ï¿½", s = "";
  for (let a = 0; a < e; a++) {
    let c, d, l, u, h = r[a + n];
    128 & h ? (224 & h) == 192 ? a + 1 >= e ? s += o : (c = r[a + n + 1], (192 & c) != 128 ? s += o : (u = (31 & h) << 6 | 63 & c, u < 128 ? s += o : (s += i(u), a++))) : (240 & h) == 224 ? a + 2 >= e ? s += o : (c = r[a + n + 1], d = r[a + n + 2], (49344 & (c | d << 8)) != 32896 ? s += o : (u = (15 & h) << 12 | (63 & c) << 6 | 63 & d, u < 2048 || u >= 55296 && u <= 57343 ? s += o : (s += i(u), a += 2))) : (248 & h) == 240 ? a + 3 >= e ? s += o : (c = r[a + n + 1], d = r[a + n + 2], l = r[a + n + 3], (12632256 & (c | d << 8 | l << 16)) != 8421504 ? s += o : (u = (7 & h) << 18 | (63 & c) << 12 | (63 & d) << 6 | 63 & l, u < 65536 || u > 1114111 ? s += o : (u -= 65536, s += i(55296 + (u >> 10), 56320 + (1023 & u)), a += 3))) : s += o : s += i(h);
  }
  return s;
}
function tr(t11, e) {
  let n = e.length, i = 0;
  for (let s = 0; s < n; s++) {
    let a = e.charCodeAt(s);
    a >= 55296 && a <= 56319 && s + 1 < n && (a = (a << 10) + e.charCodeAt(++s) - 56613888), i += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4;
  }
  yt(t11, i);
  let r = Ca(t11, i), o = t11.bytes;
  for (let s = 0; s < n; s++) {
    let a = e.charCodeAt(s);
    a >= 55296 && a <= 56319 && s + 1 < n && (a = (a << 10) + e.charCodeAt(++s) - 56613888), a < 128 ? o[r++] = a : (a < 2048 ? o[r++] = a >> 6 & 31 | 192 : (a < 65536 ? o[r++] = a >> 12 & 15 | 224 : (o[r++] = a >> 18 & 7 | 240, o[r++] = a >> 12 & 63 | 128), o[r++] = a >> 6 & 63 | 128), o[r++] = 63 & a | 128);
  }
}
function tH(t11, e) {
  let n = Ca(t11, e.limit), i = t11.bytes, r = e.bytes;
  for (let o = 0, s = e.limit; o < s; o++) i[o + n] = r[o];
}
function aN(t11) {
  return t11.bytes[Mf(t11, 1)];
}
function TA(t11, e) {
  let n = Ca(t11, 1);
  t11.bytes[n] = e;
}
function B_(t11) {
  let e = Mf(t11, 8), n = t11.bytes;
  return Rn[0] = n[e++], Rn[1] = n[e++], Rn[2] = n[e++], Rn[3] = n[e++], Rn[4] = n[e++], Rn[5] = n[e++], Rn[6] = n[e++], Rn[7] = n[e++], Lf[0];
}
function j_(t11, e) {
  let n = Ca(t11, 8), i = t11.bytes;
  Lf[0] = e, i[n++] = Rn[0], i[n++] = Rn[1], i[n++] = Rn[2], i[n++] = Rn[3], i[n++] = Rn[4], i[n++] = Rn[5], i[n++] = Rn[6], i[n++] = Rn[7];
}
function or(t11) {
  let e, n = 0, i = 0;
  do
    e = aN(t11), n < 32 && (i |= (127 & e) << n), n += 7;
  while (128 & e);
  return i;
}
function yt(t11, e) {
  for (e >>>= 0; e >= 128; ) TA(t11, 127 & e | 128), e >>>= 7;
  TA(t11, e);
}
function Yr(t11, e) {
  let n = e.low >>> 0, i = (e.low >>> 28 | e.high << 4) >>> 0, r = e.high >>> 24, o = r === 0 ? i === 0 ? n < 16384 ? n < 128 ? 1 : 2 : n < 1 << 21 ? 3 : 4 : i < 16384 ? i < 128 ? 5 : 6 : i < 1 << 21 ? 7 : 8 : r < 128 ? 9 : 10, s = Ca(t11, o), a = t11.bytes;
  switch (o) {
    case 10:
      a[s + 9] = r >>> 7 & 1;
    case 9:
      a[s + 8] = o !== 9 ? 128 | r : 127 & r;
    case 8:
      a[s + 7] = o !== 8 ? i >>> 21 | 128 : i >>> 21 & 127;
    case 7:
      a[s + 6] = o !== 7 ? i >>> 14 | 128 : i >>> 14 & 127;
    case 6:
      a[s + 5] = o !== 6 ? i >>> 7 | 128 : i >>> 7 & 127;
    case 5:
      a[s + 4] = o !== 5 ? 128 | i : 127 & i;
    case 4:
      a[s + 3] = o !== 4 ? n >>> 21 | 128 : n >>> 21 & 127;
    case 3:
      a[s + 2] = o !== 3 ? n >>> 14 | 128 : n >>> 14 & 127;
    case 2:
      a[s + 1] = o !== 2 ? n >>> 7 | 128 : n >>> 7 & 127;
    case 1:
      a[s] = o !== 1 ? 128 | n : 127 & n;
  }
}
function SA(t11, e) {
  var n = Object.keys(t11);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t11);
    e && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(t11, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
var eH = /* @__PURE__ */ new Map([["moderation", 1], ["supervise", 2]]);
function RA(t11) {
  return { low: t11 |= 0, high: t11 >> 31, unsigned: t11 >= 0 };
}
var Im = class extends Xt {
  get connectionState() {
    return this._connectionState;
  }
  set connectionState(e) {
    if (this._connectionState === e) return;
    let n = this._connectionState;
    this._connectionState = e, this.emit(we.CONNECTION_STATE_CHANGE, n, e);
  }
  get inspectType() {
    return this._inspectType;
  }
  set inspectType(e) {
    var n;
    this._inspectMode = ji(n = e.map((i) => eH.get(i) || 0)).call(n, (i, r) => i + r), this._inspectType = e;
  }
  get quality() {
    return this._quality;
  }
  set quality(e) {
    this._quality = e > 1 ? 1 : e < 0.1 ? 0.1 : e, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout(() => {
      this.quality = this._quality / this.qualityRatio;
    }, 6e4));
  }
  constructor(e) {
    super(), T(this, "name", "AgoraRTCVideoContentInspect"), T(this, "_connectionState", Ei.CONNECTING), T(this, "_innerConnectionState", void 0), T(this, "sequence", 0), T(this, "inspectStartTime", void 0), T(this, "workerManagerConnection", void 0), T(this, "workerConnection", void 0), T(this, "workerMessageLengthLimit", void 0), T(this, "inspectIntervalMinimum", void 0), T(this, "qualityRatio", void 0), T(this, "_connectInfo", void 0), T(this, "_cancelTokenSource", mn.CancelToken.source()), T(this, "_retryConfig", void 0), T(this, "wmSequence", 0), T(this, "inspectInterval", void 0), T(this, "inspectTimer", null), T(this, "ossFilePrefix", void 0), T(this, "extraInfo", void 0), T(this, "_inspectType", void 0), T(this, "_inspectMode", void 0), T(this, "_quality", 1), T(this, "qualityTimer", null), T(this, "_inspectId", void 0), T(this, "_needWorkUrlOnly", false), T(this, "inspectImage", () => {
      if (this.connectionState !== Ei.CONNECTED) throw new O(R.OPERATION_ABORTED, "content inspect service connection status is ".concat(this.connectionState));
      this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval(() => {
        this.connectionState === Ei.CONNECTED ? this.requestToInspectImage() : _.debug("[".concat(this._inspectId, "] Inspect State is not connected , "), this.connectionState);
      }, this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage();
    }), this._inspectId = Ut(5, "inspect-"), this.workerMessageLengthLimit = v("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"), this.inspectIntervalMinimum = v("VIDEO_INSPECT_INTERVAL_MINIMUM"), this.qualityRatio = v("VIDEO_INSPECT_QUALITY_RATIO"), this.inspectInterval = e.interval, this.ossFilePrefix = e.ossFilePrefix, this.extraInfo = e.extraInfo, this.inspectType = e.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new Qo("worker-manager-" + this._inspectId, Ee), this.on(we.STATE_CHANGE, (n, i) => {
      this._innerConnectionState = n, _.debug("[".concat(this._inspectId, "] Inspect operation :").concat(di[n], " ").concat(i || ""));
    }), this.handleWorkerManagerEvents(), this.workerConnection = new Qo("worker-" + this._inspectId, Ee), this.handleWorkerEvents();
  }
  async init(e, n) {
    this.emit(we.STATE_CHANGE, di.CONNECT_AP), this._connectInfo = e;
    let i = this._cancelTokenSource.token;
    return this._retryConfig = n, new j((r, o) => {
      this.on(we.CONNECTION_STATE_CHANGE, (s, a) => {
        a === Ei.CONNECTED && r();
      }), this.requestAP(e, i, n).then((s) => {
        this.connectWorkerManager(s);
      }).catch((s) => {
        o(s);
      });
    });
  }
  async requestAP(e, n, i) {
    let r = v("WEBCS_DOMAIN").map((a) => "https://".concat(a, "/api/v1")), o = await function(a, c, d, l) {
      let { appId: u, areaCode: h, cname: p, sid: g, token: E, uid: f } = c;
      Ys++;
      let S = "image_moderation_api", C = { service_name: S, json_body: JSON.stringify({ appId: u, areaCode: h, cname: p, command: "allocateEdge", requestId: Ys, seq: Ys, sid: g, token: E, ts: Date.now(), uid: f + "" }) }, A, b, w = a[0];
      return Wi(async () => {
        A = Date.now();
        let D = await Hi(w, { data: C, cancelToken: d, headers: { "X-Packet-Service-Type": "0", "X-Packet-URI": "61" }, params: { action: "wrtc_gateway" } });
        if (b = Date.now() - A, D.code !== 0) {
          let z = new O(R.UNEXPECTED_RESPONSE, "image inspect ap error, code" + D.code, { retry: true, responseTime: b });
          throw _.error(z.toString()), z;
        }
        let k = JSON.parse(D.json_body);
        if (k.code !== 200) {
          let z = new O(R.UNEXPECTED_RESPONSE, "image inspect ap error, code: ".concat(k.code, ", reason: ").concat(k.reason), { code: k.code, responseTime: b });
          throw _.error(z.toString()), z;
        }
        if (!k.servers || !Array.isArray(k.servers) || k.servers.length === 0) {
          let z = new O(R.UNEXPECTED_RESPONSE, "image inspect ap empty server", { code: k.code, responseTime: b });
          throw _.error(z.toString()), z;
        }
        let B = v("VIDEO_INSPECT_WORKER_MANAGER_HOST"), V = v("VIDEO_INSPECT_WORKER_MANAGER_PORT");
        return { addressList: k.servers.map((z) => {
          let { address: lt, wss: vt } = z;
          if (lt && vt) return "wss://".concat(lt.replace(/\./g, "-"), ".").concat(B, ":").concat(V || vt);
        }).filter((z) => !!z), workerToken: k.workerToken, vid: k.vid, responseTime: b };
      }, (D, k) => (X.apworkerEvent(g, { success: true, sc: 200, serviceName: S, responseDetail: JSON.stringify(D.addressList), firstSuccess: k === 0, responseTime: b, serverIp: a[k % a.length] }), false), (D, k) => (X.apworkerEvent(g, { success: false, sc: D.data && D.data.code || 200, serviceName: S, responseTime: b, serverIp: a[k % a.length] }), !!(D.code !== R.OPERATION_ABORTED && D.code !== R.UNEXPECTED_RESPONSE || D.data && D.data.retry) && (w = a[(k + 1) % a.length], true)), l);
    }(r, e, n, i);
    this.emit(we.STATE_CHANGE, di.AP_CONNECTED);
    let { addressList: s } = o;
    return this.wmSequence++, s;
  }
  async connectWorkerManager(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    this._needWorkUrlOnly = n, this.emit(we.STATE_CHANGE, di.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e, 1e4);
  }
  async connectWorker(e) {
    await this.workerConnection.init([e]);
  }
  handleWorkerManagerEvents() {
    this.workerManagerConnection.on(it.CONNECTED, async () => {
      this.emit(we.STATE_CHANGE, di.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({ appId: this._connectInfo.appId, cname: this._connectInfo.cname, uid: this._connectInfo.uid + "", sdkVersion: "4.22.0", sid: this._connectInfo.sid, seq: this.wmSequence, ts: Number(Date.now()), requestId: Math.floor(1e12 * Math.random()), allocate: true, clientRequest: { command: "join" } }, true);
    }), this.workerManagerConnection.on(it.CLOSED, () => {
      this._innerConnectionState < di.GET_WORKER_MANAGER_RESPONSE && _.debug("[".concat(this._inspectId, "] Inspect worker manager is closed before connecting worker"));
    }), this.workerManagerConnection.on(it.FAILED, () => {
      this._innerConnectionState < di.GET_WORKER_MANAGER_RESPONSE && _.debug("[".concat(this._inspectId, "] Connecting inspect worker manager is failed before connecting worker"));
    }), this.workerManagerConnection.on(it.RECONNECTING, () => {
      this._innerConnectionState < di.GET_WORKER_MANAGER_RESPONSE && _.debug("[".concat(this._inspectId, "] Inspect worker manager is reconnecting before connecting worker"));
    }), this.workerManagerConnection.on(it.ON_MESSAGE, async (e) => {
      this.emit(we.STATE_CHANGE, di.GET_WORKER_MANAGER_RESPONSE);
      let n = this.workerManagerConnection.url;
      this.workerManagerConnection.close();
      let i = JSON.parse(e.data);
      if (i.code !== 200) throw _.error("[".concat(this._inspectId, "] Unexpected code ").concat(i.code, " from worker manager")), new O(R.UNEXPECTED_RESPONSE, "response code of worker is unexpected", i);
      if (!(i.serverResponse && i.serverResponse.portWss && n)) throw _.error("[".concat(this._inspectId, "] Unexpected content from worker manager : ").concat(JSON.stringify(i))), new O(R.UNEXPECTED_RESPONSE, "response content of worker is unexpected", i);
      {
        let r = v("VIDEO_INSPECT_WORKER_PORT") || i.serverResponse.portWss, o = n.replace(/:\d+\/?$/, ":".concat(r));
        this.emit(we.STATE_CHANGE, di.CONNECT_WORKER, o), this._needWorkUrlOnly ? this.emit(we.REQUEST_NEW_WORKER_URL, o) : await this.connectWorker(o);
      }
    }), this.workerManagerConnection.on(it.WILL_RECONNECT, (e, n, i) => {
      i(e);
    }), this.workerManagerConnection.on(it.REQUEST_NEW_URLS, (e, n) => {
      this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e).catch(n);
    });
  }
  handleWorkerEvents() {
    this.workerConnection.on(it.CONNECTED, async () => {
      this.emit(we.STATE_CHANGE, di.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = Ei.CONNECTED;
    }), this.workerConnection.on(it.ON_MESSAGE, async (e) => {
      if (e.data instanceof ArrayBuffer) {
        let i = z3(new Uint8Array(e.data));
        if (v("SHOW_VIDEO_INSPECT_WORKER_MESSAGE") && _.debug("[".concat(this._inspectId, "] Response message for worker of inspect content "), JSON.stringify(i)), i.code === 200) {
          if (Array.isArray(this.inspectType) && this.inspectType.length === 1 && this.inspectType[0] === "supervise") return void this.emit(we.INSPECT_RESULT, void 0, void 0);
          if (i.data && i.data.scorePorn && i.data.scoreSexy && i.data.scoreNeutral) {
            var n;
            let r = { porn: i.data.scorePorn, sexy: i.data.scoreSexy, neutral: i.data.scoreNeutral }, o = ji(n = Object.keys(r)).call(n, (a, c) => r[a] > r[c] ? a : c, "porn"), s = Object.keys(r).find((a) => a === o);
            this.emit(we.INSPECT_RESULT, s);
          } else this.emit(we.INSPECT_RESULT, void 0, new O(R.UNEXPECTED_RESPONSE, i.code + "", "There is an unexpected data on message"));
        } else this.emit(we.INSPECT_RESULT, void 0, new O(R.UNEXPECTED_RESPONSE, i.code + "", i.msg));
      } else _.error("[".concat(this._inspectId, "] Unexpected message type from worker")), this.emit(we.INSPECT_RESULT, void 0, new O(R.UNEXPECTED_RESPONSE, "invalid worker message type"));
    }), this.workerConnection.on(it.CLOSED, () => {
      this.connectionState = Ei.CLOSED;
    }), this.workerConnection.on(it.FAILED, () => {
      this.connectionState = Ei.CLOSED;
    }), this.workerConnection.on(it.RECONNECTING, () => {
      this.connectionState = this.connectionState === Ei.CONNECTED ? Ei.RECONNECTING : Ei.CONNECTING;
    }), this.workerConnection.on(it.WILL_RECONNECT, (e, n, i) => {
      e === "recover" && i(e), i("tryNext");
    }), this.workerConnection.on(it.REQUEST_NEW_URLS, (e, n) => {
      this.workerManagerConnection.close(), this.once(we.REQUEST_NEW_WORKER_URL, (i) => {
        e([i]);
      }), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then((i) => {
        this.connectWorkerManager(i, true);
      }).catch((i) => {
        n(i);
      });
    });
  }
  async requestToInspectImage() {
    this.sequence++;
    let e = ni(this, we.CLIENT_LOCAL_VIDEO_TRACK), n = { appId: this._connectInfo.appId, cname: this._connectInfo.cname, cid: this._connectInfo.cid, sid: this._connectInfo.sid, uid: this._connectInfo.uid, vid: this._connectInfo.vid };
    if (e) {
      if (!e.isPlaying) return void this.emit(we.INSPECT_RESULT, void 0, new O(R.INVALID_OPERATION, "Only the track being played can be inspected"));
      let i = await this.generateRequestData(e, n);
      this.workerConnection.sendMessage(i, true, true);
    } else this.emit(we.INSPECT_RESULT, void 0, new O(R.INVALID_OPERATION, "Only the track being published can be inspected"));
  }
  async generateRequestData(e, n) {
    let { appId: i, cname: r, cid: o, vid: s, sid: a, uid: c } = n, d = Date.now(), l = await e.getCurrentFrameImage("image/jpeg", this.quality), u = await QO(l, i, r), h = this.sequence + "-" + o + "-" + c + "-" + d + "-" + Ut(12, ""), p = { appId: i, cid: o, cname: r, deviceId: "", elapse: RA(Number(d - this.inspectStartTime)), fileSize: u.byteLength, jpgEncryption: 2, height: l.height, width: l.width, jpg: u, networkType: 6, osType: 7, requestId: h, sdkVersion: "4.22.0", sequence: this.sequence, sid: a, timestamp: RA(d), uid: c, vid: s, service: this._inspectMode, callbackData: this.extraInfo, ossFilePrefix: this.ossFilePrefix };
    this.extraInfo === void 0 && delete p.callbackData, this.ossFilePrefix === void 0 && delete p.ossFilePrefix;
    let g = q3(p);
    if (g.byteLength < this.workerMessageLengthLimit) {
      if (v("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")) {
        let E = function(f) {
          for (var S = 1; S < arguments.length; S++) {
            var C = arguments[S] != null ? arguments[S] : {};
            S % 2 ? SA(Object(C), true).forEach(function(A) {
              T(f, A, C[A]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(f, Object.getOwnPropertyDescriptors(C)) : SA(Object(C)).forEach(function(A) {
              Object.defineProperty(f, A, Object.getOwnPropertyDescriptor(C, A));
            });
          }
          return f;
        }({}, p);
        delete E.jpg, _.debug("[".concat(this._inspectId, "] Request message for worker of inspect content "), JSON.stringify(E));
      }
      return g;
    }
    {
      let E = this.quality * this.qualityRatio;
      return this.quality = E, await this.generateRequestData(e, { appId: i, cname: r, cid: o, vid: s, sid: a, uid: c });
    }
  }
  close() {
    this._cancelTokenSource.cancel(), this._cancelTokenSource = mn.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = Ei.CLOSED, this.emit(we.STATE_CHANGE, di.CLOSED);
  }
};
var nH = { name: "ContentInspect", create: function(t11) {
  let { config: e } = t11;
  return function(n) {
    if (!n) throw new O(R.INVALID_PARAMS, "inspectConfig is necessary.");
    if (!n.inspectType || !Array.isArray(n.inspectType)) throw new O(R.INVALID_PARAMS, "inspectConfig.inspectType is necessary and is an instance of Array.");
    {
      let i = [...new Set(n.inspectType)];
      i.forEach((r) => {
        var o;
        if (!W(o = ["supervise", "moderation"]).call(o, r)) throw new O(R.INVALID_PARAMS, "".concat(r, " is not a valid inspect type."));
      }), n.inspectType = i;
    }
    if (n && n.extraInfo && n.extraInfo.length > 1024) throw new O(R.INVALID_PARAMS, "inspectConfig.extraInfo length cannot exceed 1024 bytes");
  }(e), new Im(e);
} };
Ot("PROCESS_ID", "process-".concat(Ut(8, ""), "-").concat(Ut(4, ""), "-").concat(Ut(4, ""), "-").concat(Ut(4, ""), "-").concat(Ut(12, ""))), function() {
  let t11;
  try {
    t11 = window.localStorage.getItem("websdk_ng_global_parameter");
  } catch (e) {
    return void _.error("Error loading sdk config", e.message);
  }
  if (t11) try {
    let e = JSON.parse(window.atob(t11)), n = Date.now();
    _.debug("Loading global parameters from cache", e), Object.keys(e).forEach((i) => {
      if (Object.prototype.hasOwnProperty.call(oe, i)) {
        let { value: r, expires: o } = e[i];
        if (o && o <= n) return;
        $r[i] = r, oe[i] = r;
      }
    });
  } catch (e) {
    _.error("Error loading mutableParamsCache: ".concat(t11), e.message);
  }
}(), Array.isArray($r.AREAS) && $r.AREAS.length > 0 && Af($r.AREAS, true);
var CA = (t11, e, n) => {
  _.debug("setParameter key:".concat(t11, ", value:").concat(JSON.stringify(e))), Ot(t11, e, n);
};
Ba(K3, false), Ba(Y3, false), Ba(PW, false), Ba(nH, false), Ba(H3, false);
var Mt = function(t11) {
  let e = new Xt(), n = t11, i = { getListeners: e.getListeners.bind(e), on: (r, o) => (function(s, a) {
    s === nr.SECURITY_POLICY_VIOLATION && L0(a, true);
  }(r, o), e.on.bind(e)(r, o)), addListener: e.addListener.bind(e), once: e.once.bind(e), off: e.off.bind(e), removeAllListeners: e.removeAllListeners.bind(e), emit: e.emit.bind(e), safeEmit: e.safeEmit.bind(e) };
  return Jy(Jy({}, n), i);
}({ __TRACK_LIST__: As, VERSION: ii, BUILD: Ef, ESM_BUNDLER: false, ESM: true, UMD: false, DEV: false, setParameter: CA, getParameter: v, getSupportedCodec: async function() {
  let t11 = { audio: [], video: [] };
  try {
    let e = new RTCPeerConnection(), n = await async function(i) {
      let r;
      return ft().supportUnifiedPlan ? (i.addTransceiver("video", { direction: "recvonly" }), i.addTransceiver("audio", { direction: "recvonly" }), r = (await i.createOffer()).sdp) : r = (await i.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true })).sdp, r;
    }(e);
    if (!n) return t11;
    e.close(), e = null, t11 = function(i) {
      let r = { video: [], audio: [] };
      return i.match(/ VP8/i) && r.video.push("VP8"), i.match(/ VP9/i) && r.video.push("VP9"), i.match(/ AV1/i) && r.video.push("AV1"), i.match(/ H264/i) && r.video.push("H264"), i.match(/ H265/i) && r.video.push("H265"), i.match(/ opus/i) && r.audio.push("OPUS"), i.match(/ PCMU/i) && r.audio.push("PCMU"), i.match(/ PCMA/i) && r.audio.push("PCMA"), i.match(/ G722/i) && r.audio.push("G722"), r;
    }(n);
  } catch (e) {
    throw new O(R.CREATE_OFFER_FAILED, e.toString && e.toString()).print();
  }
  return t11;
}, checkSystemRequirements: function() {
  let t11 = X.reportApiInvoke(null, { name: Te.CHECK_SYSTEM_REQUIREMENTS, options: [], tag: Zt.TRACER }), e = false;
  try {
    let o = window.RTCPeerConnection, s = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, a = window.WebSocket;
    e = !!(o && s && a), e && lf() && EO(75) && new o().close();
  } catch (o) {
    return _.error("check system requirement failed: ", o), false;
  }
  let n = false, i = mt();
  i.name === It.CHROME && Number(i.version) >= 58 && (Vi.engine.name !== "WebKit" || function() {
    let o = mt();
    if (Gl()) {
      if (o.os === ye.MAC_OS) return true;
      if (o.os === ye.IOS) {
        let s = Vi.os.version && Vi.os.version.split(".");
        if (s && Number(s[0]) === 14 && s[1] && Number(s[1]) >= 3 || s && Number(s[0]) > 14) return true;
      }
    }
    return false;
  }()) && (n = true), (i.name === It.FIREFOX && Number(i.version) >= 56 || i.name === It.OPERA && Number(i.version) >= 45 || i.name === It.SAFARI && Number(i.version) >= 11 || i.name === "WebKit" && (ln() || vi()) && i.osVersion && Number(i.osVersion.split(".")[0]) >= 11 || TO() || mt().name === It.QQ) && (n = true), _.debug("checkSystemRequirements, api:", e, "browser", n);
  let r = e && n;
  return t11.onSuccess(r), r;
}, getDevices: function(t11) {
  return Gn.enumerateDevices(true, true, t11);
}, getMicrophones: function(t11) {
  return Gn.getRecordingDevices(t11);
}, getCameras: function(t11) {
  return Gn.getCamerasDevices(t11);
}, getElectronScreenSources: KO, getPlaybackDevices: function(t11) {
  return Gn.getSpeakers(t11);
}, createClient: function() {
  var t11;
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { codec: "vp8", audioCodec: "opus", mode: "rtc" }, n = X.reportApiInvoke(null, { name: Te.CREATE_CLIENT, options: [e], tag: Zt.TRACER });
  try {
    (function(i) {
      Ce(i.codec, "config.codec", ["vp8", "vp9", "av1", "h264", "h265"]), Ce(i.mode, "config.mode", ["rtc", "live", "p2p"]), i.audioCodec !== void 0 && Ce(i.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), i.proxyServer !== void 0 && Pe(i.proxyServer, "config.proxyServer", 1, 1e4), i.turnServer !== void 0 && vO(i.turnServer), i.httpRetryConfig !== void 0 && mR(i.httpRetryConfig), i.websocketRetryConfig !== void 0 && mR(i.websocketRetryConfig);
    })(e);
  } catch (i) {
    throw n.onError(i), i;
  }
  return (fO(16, 0) || gO(16, 0)) && (e.codec === "vp9" && (e.codec = "vp8", _.debug("browser not support vp9, force use vp8")), Ot("UNSUPPORTED_VIDEO_CODEC", ["vp9"])), e.audioCodec === void 0 && (e.audioCodec = "opus"), n.onSuccess(), new kW(xi(xi({ forceWaitGatewayResponse: true }, e), {}, { role: W(t11 = ["rtc", "p2p"]).call(t11, e.mode) ? "host" : e.role || "audience" }));
}, createCameraVideoTrack: async function() {
  let t11 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = v("CAMERA_CAPTURE_CONFIG"), n = X.reportApiInvoke(null, { tag: Zt.TRACER, name: Te.CREATE_CAM_VIDEO_TRACK, options: [Kt({}, t11), e] });
  e && (t11.encoderConfig = e);
  let i = ru(t11), r = Ut(8, "track-cam-"), o = null;
  _.info("start create camera video track with config", JSON.stringify(t11), "trackId", r);
  try {
    o = (await Fn({ video: i }, r)).getVideoTracks()[0] || null;
  } catch (a) {
    throw n.onError(a), a;
  }
  if (!o) {
    let a = new N(R.UNEXPECTED_ERROR, "can not find track in media stream");
    return n.onError(a), a.throw(_);
  }
  t11.optimizationMode && c_(r, o, t11, cr(t11.encoderConfig));
  let s = new XE(o, t11, i, t11.scalabiltyMode ? Fd(t11.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t11.optimizationMode, r);
  return n.onSuccess(s.getTrackId()), _.info("create camera video success, trackId:", r), s;
}, createCustomVideoTrack: function(t11) {
  let e = X.reportApiInvoke(null, { tag: Zt.TRACER, name: Te.CREATE_CUSTOM_VIDEO_TRACK, options: [t11] }), n = new Ft(t11.mediaStreamTrack, { width: t11.width, height: t11.height, frameRate: t11.frameRate, bitrateMax: t11.bitrateMax, bitrateMin: t11.bitrateMin }, t11.scalabiltyMode ? Fd(t11.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t11.optimizationMode, Ut(8, "track-cus-"), [Gt.CUSTOM_TRACK]);
  return e.onSuccess(n.getTrackId()), _.info("create custom video track success with config", t11, "trackId", n.getTrackId()), n;
}, createScreenVideoTrack: async function() {
  let t11 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "disable", n = X.reportApiInvoke(null, { tag: Zt.TRACER, name: Te.CREATE_SCREEN_VIDEO_TRACK, options: [Kt({}, t11), e] });
  t11.encoderConfig ? typeof t11.encoderConfig == "string" || t11.encoderConfig.width && t11.encoderConfig.height || (t11.encoderConfig.width = { max: 1920 }, t11.encoderConfig.height = { max: 1080 }) : t11.encoderConfig = "1080p_2";
  let i = function(l) {
    let u = {};
    l.screenSourceType && (u.mediaSource = l.screenSourceType), l.extensionId && oo() && (u.extensionId = l.extensionId);
    let { displaySurface: h, selfBrowserSurface: p, surfaceSwitching: g, systemAudio: E } = l;
    (OE(107) || lR(107) || uR(93)) && (h && (Ce(h, "displaySurface", ["browser", "window", "monitor"]), u.displaySurface = h), p ? (Ce(p, "selfBrowserSurface", ["exclude", "include"]), u.selfBrowserSurface = p) : u.selfBrowserSurface = "include", g && (Ce(g, "surfaceSwitching", ["exclude", "include"]), u.surfaceSwitching = g)), (OE(105) || lR(105) || uR(91)) && E && (Ce(E, "systemAudio", ["exclude", "include"]), u.systemAudio = E), l.electronScreenSourceId && (u.sourceId = l.electronScreenSourceId);
    let f = l.encoderConfig ? r_(l.encoderConfig) : null;
    return u.mandatory = { chromeMediaSource: "desktop", maxWidth: f ? f.width : void 0, maxHeight: f ? f.height : void 0 }, f && (f.frameRate && (typeof f.frameRate == "number" ? (u.mandatory.maxFrameRate = f.frameRate, u.mandatory.minFrameRate = f.frameRate) : (u.mandatory.maxFrameRate = f.frameRate.max || f.frameRate.ideal || f.frameRate.exact || void 0, u.mandatory.minFrameRate = f.frameRate.min || f.frameRate.ideal || f.frameRate.exact || void 0), u.frameRate = f.frameRate), f.width && (u.width = f.width), f.height && (u.height = f.height)), u;
  }(t11), r = Ut(8, "track-scr-v-"), o = null, s = null, a = ft();
  if (!a.supportShareAudio && e === "enable") {
    let l = new N(R.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
    return n.onError(l), l.throw(_);
  }
  _.info("start create screen video track with config", t11, "withAudio", e, "trackId", r);
  try {
    let l = await Fn({ screen: i, screenAudio: e === "auto" ? a.supportShareAudio : e === "enable" }, r);
    o = l.getVideoTracks()[0] || null, s = l.getAudioTracks()[0] || null;
  } catch (l) {
    throw n.onError(l), l;
  }
  if (!o) {
    let l = new N(R.UNEXPECTED_ERROR, "can not find track in media stream");
    return n.onError(l), l.throw(_);
  }
  if (!s && e === "enable") {
    o && o.stop();
    let l = new N(R.SHARE_AUDIO_NOT_ALLOWED);
    return n.onError(l), l.throw(_);
  }
  t11.optimizationMode || (t11.optimizationMode = "detail"), t11.optimizationMode && (c_(r, o, t11, t11.encoderConfig && r_(t11.encoderConfig) || void 0), t11.encoderConfig && typeof t11.encoderConfig != "string" && (t11.encoderConfig.bitrateMin = t11.encoderConfig.bitrateMax));
  let c = new Ft(o, t11.encoderConfig ? r_(t11.encoderConfig) : {}, t11.scalabiltyMode ? Fd(t11.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, t11.optimizationMode, r, [Gt.SCREEN_TRACK]);
  if (!s) return n.onSuccess(c.getTrackId()), _.info("create screen video track success", "video:", c.getTrackId()), c;
  let d = new Qt(s, void 0, Ut(8, "track-scr-a-"), false);
  return n.onSuccess([c.getTrackId(), d.getTrackId()]), _.info("create screen video track success", "video:", c.getTrackId(), "audio:", d.getTrackId()), [c, d];
}, createMicrophoneAndCameraTracks: async function() {
  let t11 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = v("CAMERA_CAPTURE_CONFIG"), i = X.reportApiInvoke(null, { tag: Zt.TRACER, name: Te.CREATE_MIC_AND_CAM_TRACKS, options: [t11, e, n] });
  n && (e.encoderConfig = n);
  let r = ru(e), o = fC(t11), s = Ut(8, "track-mic-"), a = Ut(8, "track-cam-"), c = null, d = null;
  _.info("start create camera video track(".concat(a, ") and microphone audio track(").concat(s, ") with config, audio: ").concat(JSON.stringify(t11), ", video: ").concat(JSON.stringify(e)));
  try {
    let h = await Fn({ audio: o, video: r }, "".concat(s, "-").concat(a));
    c = h.getAudioTracks()[0], d = h.getVideoTracks()[0];
  } catch (h) {
    throw i.onError(h), h;
  }
  if (!c || !d) {
    let h = new N(R.UNEXPECTED_ERROR, "can not find tracks in media stream");
    return i.onError(h), h.throw(_);
  }
  e.optimizationMode && c_(a, d, e, cr(e.encoderConfig));
  let l = new ou(c, t11, o, s), u = new XE(d, e, r, e.scalabiltyMode ? Fd(e.scalabiltyMode) : { numSpatialLayers: 1, numTemporalLayers: 1 }, e.optimizationMode, a);
  return i.onSuccess([l.getTrackId(), u.getTrackId()]), _.info("create camera video track(".concat(a, ") and microphone audio track(").concat(s, ") success")), [l, u];
}, createMicrophoneAudioTrack: async function() {
  let t11 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = X.reportApiInvoke(null, { tag: Zt.TRACER, name: Te.CREATE_MIC_AUDIO_TRACK, options: [t11] }), n = fC(t11), i = Ut(8, "track-mic-"), r = null;
  _.info("start create microphone audio track with config", JSON.stringify(t11), "trackId", i);
  try {
    r = (await Fn({ audio: n }, i)).getAudioTracks()[0] || null;
  } catch (s) {
    throw e.onError(s), s;
  }
  if (!r) {
    let s = new N(R.UNEXPECTED_ERROR, "can not find track in media stream");
    return e.onError(s), s.throw(_);
  }
  let o = new ou(r, t11, n, i);
  return e.onSuccess(o.getTrackId()), _.info("create microphone audio track success, trackId:", i), o;
}, createCustomAudioTrack: function(t11) {
  let e = X.reportApiInvoke(null, { tag: Zt.TRACER, name: Te.CREATE_CUSTOM_AUDIO_TRACK, options: [t11] }), n = new Qt(t11.mediaStreamTrack, t11.encoderConfig ? Jl(t11.encoderConfig) : {}, Ut(8, "track-cus-"), false);
  return _.info("create custom audio track success with config", t11, "trackId", n.getTrackId()), e.onSuccess(n.getTrackId()), n;
}, createBufferSourceAudioTrack: async function(t11) {
  var e;
  let { cacheOnlineFile: n, encoderConfig: i } = t11, { source: r } = t11, o = { source: r instanceof AudioBuffer ? "AudioBuffer" : r instanceof File ? (e = File.name) !== null && e !== void 0 ? e : "File" : r, cacheOnlineFile: n, encoderConfig: i }, s = X.reportApiInvoke(null, { tag: Zt.TRACER, name: Te.CREATE_BUFFER_AUDIO_TRACK, options: [o] });
  if (v("DISABLE_WEBAUDIO")) throw new N(R.NOT_SUPPORTED, "can not create BufferSourceAudioTrack when WebAudio disabled");
  let a = Ut(8, "track-buf-");
  _.info("start create buffer source audio track with config", JSON.stringify(o), "trackId", a);
  let c = r;
  if (!(r instanceof AudioBuffer)) try {
    r = await async function(u, h) {
      let p = null;
      if (typeof u == "string") {
        let E = eI.get(u);
        if (E) return _.debug("use cached audio resource: ", u), E;
        try {
          p = (await Wi(() => mn.get(u, { responseType: "arraybuffer" }), void 0, void 0, { maxRetryCount: 3 })).data;
        } catch (f) {
          throw new N(R.FETCH_AUDIO_FILE_FAILED, f.toString());
        }
      } else p = await new j((f, S) => {
        let C = new FileReader();
        C.onload = (A) => {
          A.target ? f(A.target.result) : S(new N(R.READ_LOCAL_AUDIO_FILE_ERROR));
        }, C.onerror = () => {
          S(new N(R.READ_LOCAL_AUDIO_FILE_ERROR));
        }, C.readAsArrayBuffer(u);
      });
      let g = await function(E) {
        let f = ga();
        return new j((S, C) => {
          f.decodeAudioData(E, (A) => {
            S(A);
          }, (A) => {
            C(new N(R.DECODE_AUDIO_FILE_FAILED, A.toString()));
          });
        });
      }(p);
      return typeof u == "string" && h && eI.set(u, g), g;
    }(r, n);
  } catch (u) {
    return s.onError(u), u.throw(_);
  }
  let d = new JE(r), l = new VG(c, d, i ? Jl(i) : {}, a);
  return _.info("create buffer source audio track success, trackId:", a), s.onSuccess(l.getTrackId()), l;
}, setAppType: function(t11) {
  if (_.debug("setAppType: ".concat(t11)), !(Number.isInteger(t11) && t11 >= 0)) throw _.debug("Invalid appType"), new O(R.INVALID_PARAMS, "invalid app type", t11);
  Ot("APP_TYPE", Math.floor(t11));
}, setLogLevel: function(t11) {
  _.setLogLevel(t11);
}, enableLogUpload: function() {
  v("USE_NEW_LOG") ? Ot("UPLOAD_LOG", true) : _.enableLogUpload();
}, disableLogUpload: function() {
  v("USE_NEW_LOG") ? Ot("UPLOAD_LOG", false) : _.disableLogUpload();
}, createChannelMediaRelayConfiguration: function() {
  return new Eu();
}, checkAudioTrackIsActive: async function(t11) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5e3, n = X.reportApiInvoke(null, { tag: Zt.TRACER, name: Te.CHECK_AUDIO_TRACK_IS_ACTIVE, options: [e] });
  if (!(t11 instanceof Qt || t11 instanceof Ks)) {
    let c = new O(R.INVALID_TRACK, "the parameter is not a audio track");
    return n.onError(c), c.throw();
  }
  e && e < 1e3 && (e = 1e3);
  let i = t11 instanceof Qt ? t11.getTrackLabel() : "remote_track", r = t11.getVolumeLevel(), o = r, s = r, a = Date.now();
  return new j((c) => {
    let d = setInterval(() => {
      let l = t11.getVolumeLevel();
      o = l > o ? l : o, s = l < s ? l : s;
      let u = o - s > 1e-4, h = Date.now() - a;
      if (u || h > e) {
        clearInterval(d);
        let p = u, g = { duration: h, deviceLabel: i, maxVolumeLevel: o, result: p };
        _.info("[track-".concat(t11.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(g))), n.onSuccess(g), c(p);
      }
    }, 200);
  });
}, checkVideoTrackIsActive: async function(t11) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5e3, n = X.reportApiInvoke(null, { tag: Zt.TRACER, name: Te.CHECK_VIDEO_TRACK_IS_ACTIVE, options: [e] });
  if (!(t11 instanceof Ft || t11 instanceof Hs)) {
    let u = new O(R.INVALID_TRACK, "the parameter is not a video track");
    return n.onError(u), u.throw();
  }
  e && e < 1e3 && (e = 1e3);
  let i = t11 instanceof Ft ? t11.getTrackLabel() : "remote_track", r = t11.getMediaStreamTrack(true), o = document.createElement("video");
  o.style.width = "1px", o.style.height = "1px", o.setAttribute("muted", ""), o.muted = true, o.setAttribute("playsinline", ""), o.controls = false, (je() || Gl()) && (o.style.opacity = "0.01", o.style.position = "fixed", o.style.left = "0", o.style.top = "0", document.body.appendChild(o)), o.srcObject = new MediaStream([r]), o.play();
  let s = document.createElement("canvas");
  s.width = 160, s.height = 120;
  let a = 0, c = 0;
  try {
    let u = Date.now();
    a = await function(h, p, g, E) {
      let f, S = 0, C = null;
      return new j((A, b) => {
        function w() {
          S > E && f && (f(), A(S));
          let D = g.getContext("2d");
          if (!D) {
            let V = new O(R.UNEXPECTED_ERROR, "can not get canvas 2d context.");
            return _.error(V.toString()), void b(V);
          }
          D.drawImage(h, 0, 0, 160, 120);
          let k = D.getImageData(0, 0, g.width, g.height), B = Math.floor(k.data.length / 3);
          if (C) {
            for (let V = 0; V < B; V += 3) if (k.data[V] !== C[V]) return S += 1, void (C = k.data);
            C = k.data;
          } else C = k.data;
        }
        setTimeout(() => {
          f && (f(), A(S));
        }, p), f = Rf(() => {
          w();
        }, 30);
      });
    }(o, e, s, 4), c = Date.now() - u;
  } catch (u) {
    throw n.onError(u), u;
  }
  gW === It.SAFARI && (o.pause(), o.remove()), o.srcObject = null;
  let d = a > 4, l = { duration: c, changedPicNum: a, deviceLabel: i, result: d };
  return _.info("[track-".concat(t11.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(l))), n.onSuccess(l), d;
}, setArea: Af, audioElementPlayCenter: En, resumeAudioContext: function() {
  En.autoResumeAfterInterruption(true);
}, processExternalMediaAEC: function(t11) {
  MW.processExternalMediaAEC(t11);
}, registerExtensions: function(t11) {
  let e = v("PLUGIN_INFO") || [];
  t11.forEach((n) => {
    "name" in n && !W(e).call(e, n.name) && e.push(n.name);
    let i = n;
    i.__registered__ = true, i.logger.hookLog = _.extLog, i.reporter.hookApiInvoke = X.extApiInvoke, i.parameters && Object.keys(i.parameters).forEach((r) => {
      i.parameters[r] = v(r);
    });
  }), CA("PLUGIN_INFO", e);
}, ChannelMediaRelayError: ys, ChannelMediaRelayEvent: Ir, ChannelMediaRelayState: Sn, RemoteStreamFallbackType: PG, RemoteStreamType: DG, ConnectionDisconnectedReason: At, AudienceLatencyLevelType: EB, AREAS: St, preload: async function(t11, e, n, i) {
  return y0(t11, e, n, i);
} });
Object.defineProperties(Mt, { onAudioAutoplayFailed: { get: () => Un.onAudioAutoplayFailed, set: (t11) => {
  Un.onAudioAutoplayFailed = t11;
} }, onAutoplayFailed: { get: () => Un.onAutoplayFailed, set: (t11) => {
  Un.onAutoplayFailed = t11;
} }, _onSecurityPolicyViolation: { value: void 0, writable: true }, _cspEventHandlerPointer: { value: void 0, writable: true }, onSecurityPolicyViolation: { get: () => Mt._onSecurityPolicyViolation, set(t11) {
  Mt._onSecurityPolicyViolation = t11, L0(t11);
} }, __CLIENT_LIST__: { get: () => v("SHOW_GLOBAL_CLIENT_LIST") ? Jr : [] } }), Gn.on(Bo.CAMERA_DEVICE_CHANGED, (t11) => {
  _.info("camera device changed", JSON.stringify(t11)), Mt.onCameraChanged && Mt.onCameraChanged(t11), Mt.safeEmit(nr.CAMERA_CHANGED, t11);
}), Gn.on(Bo.RECORDING_DEVICE_CHANGED, (t11) => {
  _.info("microphone device changed", JSON.stringify(t11)), Mt.onMicrophoneChanged && Mt.onMicrophoneChanged(t11), Mt.safeEmit(nr.MICROPHONE_CHANGED, t11);
}), Gn.on(Bo.PLAYOUT_DEVICE_CHANGED, (t11) => {
  _.debug("playout device changed", JSON.stringify(t11)), Mt.onPlaybackDeviceChanged && Mt.onPlaybackDeviceChanged(t11), Mt.safeEmit(nr.PLAYBACK_DEVICE_CHANGED, t11);
}), En.onAutoplayFailed = () => {
  _.info("detect audio element autoplay failed"), Un.onAudioAutoplayFailed && Un.onAudioAutoplayFailed();
}, wt.on("autoplay-failed", () => {
  _.info("detect webaudio autoplay failed"), Un.onAudioAutoplayFailed && Un.onAudioAutoplayFailed(), Mt.safeEmit(nr.AUTOPLAY_FAILED);
}), wt.on(ke.STATE_CHANGE, (t11, e) => {
  _.info("audio context state changed: ".concat(e, " => ").concat(t11)), Mt.onAudioContextStateChanged && Mt.onAudioContextStateChanged(t11, e), Mt.safeEmit(nr.AUDIO_CONTEXT_STATE_CHANGED, t11, e);
}), he.on(ks.NETWORK_STATE_CHANGE, (t11, e) => {
  _.info("[network-indicator] network state changed, ".concat(e, " => ").concat(t11));
}), window && (window.__ARTC__ = Mt);
function Ae(t11, e, n) {
  return t11.on(e, n), () => t11.off(e, n);
}
function iH(t11) {
  try {
    return t11();
  } catch (e) {
    console.error(e);
  }
}
function Kn(t11) {
  return () => t11.forEach(iH);
}
function cN(t11, e) {
  let n = setInterval(t11, e);
  return () => clearInterval(n);
}
function So(t11, e) {
  let n = setTimeout(t11, e);
  return () => clearTimeout(n);
}
function Ia() {
  let t11, e, n;
  function i() {
    if (e) {
      let d = e;
      e = void 0, d();
    }
  }
  async function r() {
    if (n) {
      let d = n;
      n = void 0;
      try {
        await d();
      } catch (l) {
        console.error(l);
      }
    }
  }
  async function o(d) {
    t11 = true, await r();
    try {
      n = await d();
    } catch (l) {
      console.error(l);
    }
    t11 = false, i();
  }
  async function s() {
    t11 = true, await r(), t11 = false, i();
  }
  function a(d) {
    t11 ? e = () => o(d) : o(d);
  }
  function c() {
    t11 ? e = s : s();
  }
  return { run: a, dispose: c };
}
var va = typeof document < "u" ? import_react.useLayoutEffect : import_react.useEffect;
function aH(t11) {
  return t11 != null && typeof t11.then == "function";
}
function Pn() {
  let t11 = (0, import_react.useRef)(false);
  return (0, import_react.useEffect)(() => (t11.current = false, () => {
    t11.current = true;
  }), []), t11;
}
function cH() {
  let t11 = Pn();
  function e(n, i) {
    return new Promise(async (r, o) => {
      try {
        let s = await n;
        t11.current || r(s);
      } catch (s) {
        t11.current ? i ? i(s) : console.error("An error occurs from a promise after a component is unmounted", s) : o(s);
      }
    });
  }
  return (0, import_react.useCallback)(e, [t11]);
}
function ih(t11) {
  let e = cH(), [n, i] = (0, import_react.useState)();
  return va(() => {
    aH(t11) ? e(t11).then(i) : i(t11);
  }, [t11, e]), n;
}
function Yn(t11, e) {
  let n = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    let { run: i, dispose: r } = n.current || (n.current = Ia());
    return i(t11), r;
  }, e);
}
function lN(t11, e) {
  let n = t11.split("."), i = e.split("."), r = Math.max(n.length, i.length);
  for (let o = 0; o < r; o++) {
    let s = parseInt(n[o] || "0"), a = parseInt(i[o] || "0");
    if (s > a) return 1;
    if (s < a) return -1;
  }
  return 0;
}
function j5(t11, e, n) {
  let i = (0, import_react.useRef)(n);
  va(() => {
    i.current = n;
  }, [n]), (0, import_react.useEffect)(() => {
    if (t11) return Ae(t11, e, (...r) => {
      i.current && i.current(...r);
    });
  }, [e, t11]);
}
function G5(t11, e, n) {
  let i = (0, import_react.useRef)(n);
  va(() => {
    i.current = n;
  }, [n]), (0, import_react.useEffect)(() => {
    if (t11) return Ae(t11, e, (...r) => {
      i.current && i.current(...r);
    });
  }, [e, t11]);
}
var pN = (0, import_react.createContext)(null);
function K5({ client: t11, children: e }) {
  return (0, import_jsx_runtime.jsx)(pN.Provider, { value: t11, children: e });
}
function uH(t11) {
  let e = (0, import_react.useContext)(pN);
  return t11 || e;
}
function Ze(t11) {
  let e = uH(t11);
  if (!e) throw new Error("Agora RTC client not found. Should be wrapped in <AgoraRTCProvider value={client} />");
  return e;
}
var _N = (0, import_react.createContext)(null);
function J5({ client: t11, children: e }) {
  return (0, import_jsx_runtime.jsx)(_N.Provider, { value: t11, children: e });
}
function X5(t11) {
  let e = (0, import_react.useContext)(_N);
  return t11 || e;
}
function i4(t11) {
  let e = Ze(t11), [n, i] = (0, import_react.useState)(e ? e.connectionState : "DISCONNECTED");
  return (0, import_react.useEffect)(() => {
    if (e) {
      i(e.connectionState);
      let r;
      return Kn([Ae(e, "connection-state-change", (o) => {
        r == null ? void 0 : r(), o === "CONNECTED" ? r = So(() => i(o), 0) : i(o);
      }), () => r == null ? void 0 : r()]);
    } else i("DISCONNECTED");
  }, [e]), n;
}
function In(t11) {
  let e = Ze(t11), [n, i] = (0, import_react.useState)(e ? e.connectionState === "CONNECTED" : false);
  return (0, import_react.useEffect)(() => {
    if (e) {
      i(e.connectionState === "CONNECTED");
      let r;
      return Kn([Ae(e, "connection-state-change", (o) => {
        r == null ? void 0 : r(), r = So(() => i(o === "CONNECTED"), 0);
      }), () => r == null ? void 0 : r()]);
    } else i(false);
  }, [e]), n;
}
function _4(t11) {
  let e = Ze(t11), [n, i] = (0, import_react.useState)(e == null ? void 0 : e.uid);
  return (0, import_react.useEffect)(() => {
    if (e) return Ae(e, "connection-state-change", (r) => {
      if (r === "CONNECTED") return So(() => i(e.uid), 0);
      r === "DISCONNECTED" && i(void 0);
    });
  }, [e]), n;
}
var Oe = class extends Error {
  constructor(e, n) {
    var __super = (...args) => {
      super(...args);
      __publicField(this, "rtcMethod");
      __publicField(this, "rtcError");
      __publicField(this, "name", "AgoraRTCReactException");
      return this;
    };
    typeof n == "string" ? __super(n) : __super(n.message), this.rtcMethod = e, this.rtcError = n;
  }
  log(e) {
    console[e](this);
  }
};
function I4(t11, e = true, n) {
  let i = Ze(n), r = In(n), o = (0, import_react.useRef)(), [s, a] = (0, import_react.useState)(false), [c, d] = (0, import_react.useState)(0), [l, u] = (0, import_react.useState)(null), h = Pn();
  return Yn(async () => {
    if (h.current || (u(null), d(0), a(false)), e && i) {
      try {
        h.current || a(true);
        let { appid: g, channel: E, token: f, uid: S } = typeof t11 == "function" ? await t11() : t11, C = await i.join(g, E, f, S);
        h.current || d(C);
      } catch (g) {
        console.error(g), h.current || u(new Oe("IAgoraRTCClient.join", g));
      }
      h.current || a(false);
      let p = o.current || (o.current = Ia());
      return Kn([() => {
        p.dispose();
      }, () => {
        p.run(() => i.unpublish(i.localTracks));
      }, () => {
        for (let g of i.localTracks) g.isPlaying && g.stop(), g.close();
        p.run(() => i.leave());
      }]);
    }
  }, [e, n]), { data: c, isLoading: s, isConnected: r, error: l };
}
var EN = () => ({ uplinkNetworkQuality: 0, downlinkNetworkQuality: 0, delay: 0 });
function w4(t11) {
  let e = Ze(t11), [n, i] = (0, import_react.useState)(EN);
  return (0, import_react.useEffect)(() => {
    if (e) return Ae(e, "network-quality", (r) => i({ uplinkNetworkQuality: r.uplinkNetworkQuality, downlinkNetworkQuality: r.downlinkNetworkQuality, delay: e.getRTCStats().RTT ?? 0 }));
    i(EN());
  }, [e]), n;
}
function U4(t11, e = true, n) {
  let i = Ze(n), r = In(n), o = (0, import_react.useRef)([]), [s, a] = (0, import_react.useState)(false), [c, d] = (0, import_react.useState)(null), l = Pn();
  return Yn(async () => {
    if (l.current || (a(false), d(null)), !i || !r || !e) return;
    let u = t11.filter(Boolean), h = (E) => {
      let f = lN(Mt.VERSION, "4.18.2") >= 0;
      return f || new Oe("usePublish", "please check your agora-rtc-sdk-ng version in package.json, it's recommend upgrade to >= 4.18.2").log("warn"), f ? i.mode !== "live" || i.role !== "audience" : true;
    }, p = (E) => o.current.some((f) => f && f.getTrackId() === E.getTrackId()), g = (E) => h() && E.enabled && e && !p(E);
    for (let E = 0; E < u.length; E++) {
      let f = u[E];
      if (f && g(f)) {
        await i.unpublish(o.current.filter((S) => (S == null ? void 0 : S.trackMediaType) === f.trackMediaType));
        try {
          l.current || a(true), await i.publish(f);
        } catch (S) {
          console.error(S), l.current || d(new Oe("IAgoraRTCClient.publish", S));
        }
        l.current || a(false);
      }
    }
    o.current = u;
  }, [r, e, i, t11]), { isLoading: s, error: c };
}
function B4(t11) {
  let [e, n] = (0, import_react.useState)(0);
  return (0, import_react.useEffect)(() => {
    if (t11) return cN(() => {
      n(t11.getVolumeLevel());
    }, 1e3);
  }, [t11]), e;
}
function q4(t11 = true, e = { ANS: true, AEC: true }, n) {
  let i = In(n), [r, o] = (0, import_react.useState)(null), [s, a] = (0, import_react.useState)(false), [c, d] = (0, import_react.useState)(null), l = Pn();
  return Yn(async () => {
    if (l.current || (a(false), d(null)), i && t11 && !r) {
      try {
        l.current || a(true);
        let u = await Mt.createMicrophoneAudioTrack(e);
        l.current || o(u);
      } catch (u) {
        console.error(u), l.current || d(new Oe("IAgoraRTC.createMicrophoneAudioTrack", u));
      }
      l.current || a(false);
    }
    !i && !l.current && o(null);
  }, [i, t11]), { localMicrophoneTrack: r, isLoading: s, error: c };
}
function tK(t11 = true, e, n) {
  let i = In(n), [r, o] = (0, import_react.useState)(null), [s, a] = (0, import_react.useState)(false), [c, d] = (0, import_react.useState)(null), l = Pn();
  return Yn(async () => {
    if (l.current || (a(false), d(null)), i && t11 && !r) {
      try {
        l.current || a(true);
        let u = await Mt.createCameraVideoTrack(e);
        l.current || o(u);
      } catch (u) {
        console.error(u), l.current || d(new Oe("IAgoraRTC.createCameraVideoTrack", u));
      }
      l.current || a(false);
    }
    !i && !l.current && o(null);
  }, [i, t11]), { localCameraTrack: r, isLoading: s, error: c };
}
function dK(t11, e) {
  let n = Ze(e), [i, r] = (0, import_react.useState)([]), o = In(), s = (0, import_react.useRef)([]), [a, c] = (0, import_react.useState)(false), [d, l] = (0, import_react.useState)(null), u = Pn();
  return Yn(async () => {
    if (u.current || l(null), !Array.isArray(t11) || !o) return;
    let h = async (E) => {
      if (!E.audioTrack && t11.some(({ uid: f }) => E.uid === f)) {
        try {
          u.current || c(true), await n.subscribe(E, "audio");
        } catch (f) {
          console.error(f), u.current || l(new Oe("IAgoraRTCClient.subscribe", f));
        }
        E.audioTrack && !s.current.some((f) => f.getUserId() === E.uid) && s.current.push(E.audioTrack), s.current = s.current.map((f) => E.audioTrack && f.getUserId() === E.uid && f.getTrackId() !== E.audioTrack.getTrackId() ? E.audioTrack : f), u.current || (r([...s.current]), c(false));
      }
    }, p = async (E) => {
      if (t11.some(({ uid: f }) => E.uid === f)) {
        u.current || (s.current = s.current.filter((f) => f.getUserId() !== E.uid), r([...s.current]));
        try {
          u.current || c(true), await n.unsubscribe(E, "audio");
        } catch (f) {
          console.error(f), u.current || l(new Oe("IAgoraRTCClient.unsubscribe", f));
        }
        u.current || c(false);
      }
    };
    t11.map((E) => {
      !E.audioTrack && E.hasAudio && h(E);
    });
    let g = [];
    for (let E = 0; E < s.current.length; E++) {
      let f = s.current[E];
      if (!t11.some((S) => S.uid === f.getUserId())) {
        let S = n.remoteUsers.find((C) => C.uid === f.getUserId());
        S && g.push({ user: S, mediaType: "audio" }), s.current.splice(E, 1), E--;
      }
    }
    if (g.length > 0) {
      try {
        u.current || c(true), await n.massUnsubscribe(g);
      } catch (E) {
        console.error(E), u.current || l(new Oe("IAgoraRTCClient.massUnsubscribe", E));
      }
      u.current || (r(s.current.slice()), c(false));
    }
    return Kn([Ae(n, "user-published", (E, f) => {
      t11.find((S) => S.uid === E.uid) && f === "audio" && h(E);
    }), Ae(n, "user-unpublished", (E, f) => {
      t11.find((S) => S.uid === E.uid) && f === "audio" && p(E);
    })]);
  }, [o, n, t11]), { audioTracks: i, isLoading: a, error: d };
}
function gK(t11, e) {
  let n = Ze(e), [i, r] = (0, import_react.useState)([]), o = In(), s = (0, import_react.useRef)([]), [a, c] = (0, import_react.useState)(false), [d, l] = (0, import_react.useState)(null), u = Pn();
  return Yn(async () => {
    if (u.current || l(null), !Array.isArray(t11) || !o) return;
    let h = async (E) => {
      if (!E.videoTrack && t11.some(({ uid: f }) => E.uid === f)) {
        try {
          u.current || c(true), await n.subscribe(E, "video");
        } catch (f) {
          console.error(f), u.current || l(new Oe("IAgoraRTCClient.subscribe", f));
        }
        E.videoTrack && !s.current.some((f) => f.getUserId() === E.uid) && s.current.push(E.videoTrack), s.current = s.current.map((f) => E.videoTrack && f.getUserId() === E.uid && f.getTrackId() !== E.videoTrack.getTrackId() ? E.videoTrack : f), u.current || (r([...s.current]), c(false));
      }
    }, p = async (E) => {
      if (t11.some(({ uid: f }) => E.uid === f)) {
        u.current || (s.current = s.current.filter((f) => f.getUserId() !== E.uid), r([...s.current]));
        try {
          u.current || c(true), await n.unsubscribe(E, "video");
        } catch (f) {
          console.error(f), u.current || l(new Oe("IAgoraRTCClient.unsubscribe", f));
        }
        u.current || c(false);
      }
    };
    t11.map((E) => {
      !E.videoTrack && E.hasVideo && h(E);
    });
    let g = [];
    for (let E = 0; E < s.current.length; E++) {
      let f = s.current[E];
      if (!t11.some((S) => S.uid === f.getUserId())) {
        let S = n.remoteUsers.find((C) => C.uid === f.getUserId());
        S && g.push({ user: S, mediaType: "video" }), s.current.splice(E, 1), E--;
      }
    }
    if (g.length > 0) {
      try {
        u.current || c(true), await n.massUnsubscribe(g);
      } catch (E) {
        console.error(E), u.current || l(new Oe("IAgoraRTCClient.massUnsubscribe", E));
      }
      u.current || (r(s.current.slice()), c(false));
    }
    return Kn([Ae(n, "user-published", (E, f) => {
      t11.find((S) => S.uid === E.uid) && f === "video" && h(E);
    }), Ae(n, "user-unpublished", (E, f) => {
      t11.find((S) => S.uid === E.uid) && f === "video" && p(E);
    })]);
  }, [o, n, t11]), { videoTracks: i, isLoading: a, error: d };
}
function Wf(t11, e, n) {
  let i = Ze(n), r = e === "audio" ? "audioTrack" : "videoTrack", [o, s] = (0, import_react.useState)(t11 && t11[r]), a = In(), c = (0, import_react.useRef)(), [d, l] = (0, import_react.useState)(false), [u, h] = (0, import_react.useState)(null);
  return (0, import_react.useEffect)(() => {
    if (!t11 || !a) return;
    let p = false;
    p || h(null);
    let g = e === "audio" ? "hasAudio" : "hasVideo", E = t11.uid, f = async (A, b) => {
      if (A[r] && i.remoteUsers.some(({ uid: w }) => A.uid === w)) try {
        p || l(true), await i.unsubscribe(A, b);
      } catch (w) {
        p || h(new Oe("IAgoraRTCClient.unsubscribe", w)), console.error(w);
      }
      p || (s(void 0), l(false));
    }, S = async (A, b) => {
      try {
        !A[r] && i.remoteUsers.some(({ uid: w }) => A.uid === w) && (p || l(true), await i.subscribe(A, b)), p || s(A[r]);
      } catch (w) {
        p || h(new Oe("IAgoraRTCClient.subscribe", w)), console.error(w);
      }
      p || l(false);
    }, C = c.current || (c.current = Ia());
    return !t11[r] && t11[g] ? C.run(() => S(t11, e)) : s(t11[r]), Kn([() => {
      p = true, C.dispose();
    }, Ae(i, "user-published", (A, b) => {
      A.uid === E && b === e && C.run(() => S(A, e));
    }), Ae(i, "user-unpublished", (A, b) => {
      A.uid === E && b === e && C.run(() => f(A, e));
    })]);
  }, [a, i, t11, e, r]), { track: o, isLoading: d, error: u };
}
function DK(t11) {
  let e = Ze(t11), [n, i] = (0, import_react.useState)(e ? e.remoteUsers : []);
  return (0, import_react.useEffect)(() => {
    if (e) {
      let r = () => i(e.remoteUsers.slice());
      return Kn([Ae(e, "user-joined", r), Ae(e, "user-left", r), Ae(e, "user-published", r), Ae(e, "user-unpublished", r)]);
    }
  }, [e]), n;
}
function VK(t11 = true, e, n, i) {
  let r = In(i), [o, s] = (0, import_react.useState)(null), [a, c] = (0, import_react.useState)(false), [d, l] = (0, import_react.useState)(null), u = Pn();
  return Yn(async () => {
    if (u.current || (c(false), l(null)), r && t11 && !o) {
      try {
        u.current || c(true);
        let h = await Mt.createScreenVideoTrack(e, n);
        u.current || s(h);
      } catch (h) {
        console.error(h), u.current || l(new Oe("IAgoraRTC.createScreenVideoTrack", h));
      }
      u.current || c(false);
    }
    (!r || !t11) && !u.current && s(null);
  }, [r, t11]), { screenTrack: o, isLoading: a, error: d };
}
function UH() {
  let t11 = /* @__PURE__ */ new Map(), e = 1500;
  return { onMount: (n) => {
    let i = t11.get(n);
    i && (i(), t11.delete(n));
  }, onUnmount: (n) => {
    let i = t11.get(n);
    i && i(), t11.set(n, So(() => {
      n.isPlaying && n.stop(), t11.delete(n);
    }, e));
  }, dispose: () => {
    for (let [n, i] of t11) n.isPlaying && n.stop(), i && i();
    t11.clear();
  } };
}
var Kf = (0, import_react.createContext)(void 0);
function WK({ children: t11 }) {
  let [e] = (0, import_react.useState)(UH);
  return (0, import_react.useEffect)(() => e.dispose, [e]), (0, import_jsx_runtime.jsx)(Kf.Provider, { value: e, children: t11 });
}
function rh(t11, e, n, i) {
  let r = (0, import_react.useContext)(Kf);
  (0, import_react.useEffect)(() => {
    if (t11) return i && e ? t11.play(i, n || void 0) : t11.stop(), r ? (r.onMount(t11), () => r.onUnmount(t11)) : () => {
      t11.isPlaying && t11.stop();
    };
  }, [t11, i, e, r, n]);
}
function oh(t11, e) {
  let n = (0, import_react.useContext)(Kf);
  va(() => {
    if (t11) return e ? t11.play() : t11.stop(), n ? (n.onMount(t11), () => n.onUnmount(t11)) : () => {
      t11.isPlaying && t11.stop();
    };
  }, [t11, e, n]);
}
function TN({ track: t11, play: e = false, volume: n, disabled: i, muted: r, children: o }) {
  let s = ih(t11);
  return oh(s, e), (0, import_react.useEffect)(() => {
    s && n != null && s.setVolume(n);
  }, [s, n]), (0, import_react.useEffect)(() => {
    s && i != null && s.setEnabled(!i).catch(console.warn);
  }, [i, s]), (0, import_react.useEffect)(() => {
    s && r != null && s.setMuted(r).catch(console.warn);
  }, [r, s]), o ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: o }) : null;
}
var sh = { position: "relative", width: "100%", height: "100%", overflow: "hidden", background: "#000" };
var ah = { width: "100%", height: "100%" };
var ya = { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", overflow: "hidden", zIndex: 2 };
var Ro = (t11, e) => (0, import_react.useMemo)(() => ({ ...t11, ...e }), [t11, e]);
function RN({ track: t11, play: e, disabled: n, muted: i, style: r, videoPlayerConfig: o, ...s }) {
  let a = Ro(ah, r), [c, d] = (0, import_react.useState)(null), l = ih(t11);
  return rh(l, e, o, c), (0, import_react.useEffect)(() => {
    l && n != null && l.setEnabled(!n).catch(console.warn);
  }, [n, l]), (0, import_react.useEffect)(() => {
    l && i != null && l.setMuted(i).catch(console.warn);
  }, [i, l]), (0, import_jsx_runtime.jsx)("div", { ...s, ref: d, style: a });
}
var WH = { width: "100%", height: "100%", background: "#1a1e21 center/cover no-repeat", filter: "blur(16px) brightness(0.4)" };
var HH = { position: "absolute", top: "50%", left: "50%", maxWidth: "50%", maxHeight: "50%", aspectRatio: "1", transform: "translate(-50%, -50%)", borderRadius: "50%", overflow: "hidden", objectFit: "cover" };
function ch({ cover: t11 }) {
  return (0, import_jsx_runtime.jsx)("div", { style: ya, children: typeof t11 == "string" ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", { style: { ...WH, backgroundImage: `url(${t11})` } }), (0, import_jsx_runtime.jsx)("img", { src: t11, style: HH })] }) : t11() });
}
function h6({ micOn: t11, cameraOn: e, audioTrack: n, videoTrack: i, playAudio: r, playVideo: o, volume: s, cover: a, children: c, style: d, ...l }) {
  let u = Ro(sh, d);
  return o = o ?? !!e, r = r ?? !!t11, (0, import_jsx_runtime.jsxs)("div", { ...l, style: u, children: [(0, import_jsx_runtime.jsx)(RN, { disabled: !e, play: o, track: i }), (0, import_jsx_runtime.jsx)(TN, { disabled: !t11, play: r, track: n, volume: s }), a && !e && (0, import_jsx_runtime.jsx)(ch, { cover: a }), (0, import_jsx_runtime.jsx)("div", { style: ya, children: c })] });
}
function IN({ track: t11, play: e = false, playbackDeviceId: n, volume: i, children: r }) {
  return oh(t11, e), (0, import_react.useEffect)(() => {
    t11 && n != null && t11.setPlaybackDevice(n).catch(console.warn);
  }, [t11, n]), (0, import_react.useEffect)(() => {
    t11 && i != null && t11.setVolume(i);
  }, [t11, i]), r ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: r }) : null;
}
function vN({ track: t11, play: e, style: n, videoPlayerConfig: i, ...r }) {
  let o = Ro(ah, n), [s, a] = (0, import_react.useState)(null);
  return rh(t11, e, i, s), (0, import_jsx_runtime.jsx)("div", { ...r, ref: a, style: o });
}
function O6({ user: t11, playVideo: e, playAudio: n, playbackDeviceId: i, volume: r, cover: o, style: s, children: a, videoPlayerConfig: c, ...d }) {
  let l = Ro(sh, s), { track: u } = Wf(t11, "video"), { track: h } = Wf(t11, "audio");
  return e = e ?? (t11 == null ? void 0 : t11.hasVideo), n = n ?? (t11 == null ? void 0 : t11.hasAudio), (0, import_jsx_runtime.jsxs)("div", { ...d, style: l, children: [(0, import_jsx_runtime.jsx)(vN, { play: e, track: u, videoPlayerConfig: c }), (0, import_jsx_runtime.jsx)(IN, { play: n, playbackDeviceId: i, track: h, volume: r }), o && !e && (0, import_jsx_runtime.jsx)(ch, { cover: o }), (0, import_jsx_runtime.jsx)("div", { style: ya, children: a })] });
}
var zf = class {
  constructor() {
    __publicField(this, "appType", 1001);
    Mt.setAppType(this.appType);
  }
};
new zf();
var k6 = "2.3.0";
var U6 = Mt;
export {
  K5 as AgoraRTCProvider,
  Oe as AgoraRTCReactError,
  J5 as AgoraRTCScreenShareProvider,
  TN as LocalAudioTrack,
  h6 as LocalUser,
  RN as LocalVideoTrack,
  IN as RemoteAudioTrack,
  O6 as RemoteUser,
  vN as RemoteVideoTrack,
  WK as TrackBoundary,
  k6 as VERSION,
  U6 as default,
  oh as useAutoPlayAudioTrack,
  rh as useAutoPlayVideoTrack,
  j5 as useClientEvent,
  i4 as useConnectionState,
  _4 as useCurrentUID,
  In as useIsConnected,
  I4 as useJoin,
  tK as useLocalCameraTrack,
  q4 as useLocalMicrophoneTrack,
  VK as useLocalScreenTrack,
  w4 as useNetworkQuality,
  U4 as usePublish,
  Ze as useRTCClient,
  X5 as useRTCScreenShareClient,
  dK as useRemoteAudioTracks,
  Wf as useRemoteUserTrack,
  DK as useRemoteUsers,
  gK as useRemoteVideoTracks,
  G5 as useTrackEvent,
  B4 as useVolumeLevel
};
/*! Bundled license information:

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

agora-rtc-react/dist/agora-rtc-react.mjs:
  (**
   * @license agora-rtc-react
   * @version 2.3.0
   *
   * Copyright (c) Agora, Inc.
   *
   * This source code is licensed under the MIT license.
   *)
  (*! Bundled license information:
  
  agora-rtc-sdk-ng/AgoraRTC_N-production.esm.mjs:
    (*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> *)
  *)
*/
//# sourceMappingURL=agora-rtc-react.js.map
